<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java集合总结+源码分析]]></title>
    <url>%2F2020%2F03%2F04%2FJava%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 1115. 交替打印FooBar（Medium）Java语言题解]]></title>
    <url>%2F2020%2F03%2F01%2FLeetCode-1115-%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0FooBar%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.题目相关①题目及示例 ②相关标签 多线程 ③题目地址 1115. 交替打印FooBar — 力扣网 2.解题方法①synchronized 关键字 + this 锁对象 原因：两个线程属于同一个实例，虽然两个线程访问的是一个类的不同的普通同步方法，但是两个普通同步方法默认都是以 this 对象作为同步方法的锁，所以它们会争抢同一把锁（对于同一个实例来讲，两个方法的 this 对象是同一个）。 结果：两个线程争抢同一把锁，同一时刻只能有一个线程执行该线程对应的同步方法，然后再使用 wait 方法和 notify 方法，使得两个线程交替运行。 ②lock + condition lock 代替 synchronized 关键字 condition 中的 await 方法和 release 方法代替 Object 对象的 wait 方法和 notify 方法 ③信号量 两个线程第一次执行时，因为 bar 信号量的计数器初始值为 0，所以需要等 foo 线程中释放了 bar 信号量，bar 线程才能开始执行。而 foo 信号量在获取了一个许可后，其计数器值也变为 0，所以 foo 线程在下一次循环开始时需要等 bar 线程中释放了 foo 信号量，foo 线程才能继续执行。 ④CountDownLatch + CyclicBarrier CyclicBarrier 用于保证任务按组循环执行 CounDownLatch 用于保证一个循环内线程执行的先后顺序 具体实现见代码 3.代码详解①synchronized 关键字 + this 锁对象1234567891011121314151617181920212223242526272829303132333435// 1.synchronized关键字+this锁对象(两个不同的线程将会共用一个FooBar实例)class FooBar &#123; private int n; public FooBar(int n) &#123; this.n = n; &#125; public void foo(Runnable printFoo) throws InterruptedException &#123; for (int i = 0; i &lt; n; i++) &#123; synchronized (this) &#123; printFoo.run(); // 唤醒另一个线程 this.notify(); // 自己陷入等待 this.wait(); &#125; &#125; &#125; public void bar(Runnable printBar) throws InterruptedException &#123; for (int i = 0; i &lt; n; i++) &#123; synchronized (this) &#123; printBar.run(); // 唤醒另一个线程 this.notify(); // 防止线程在最后一次打印Bar时睡眠，从而造成死锁。 if (i != n - 1) &#123; // 自己陷入等待 this.wait(); &#125; &#125; &#125; &#125;&#125; ②lock + condition12345678910111213141516171819202122232425262728293031323334353637// 2.lock+conditionclass FooBar &#123; private int n; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public FooBar(int n) &#123; this.n = n; &#125; public void foo(Runnable printFoo) throws InterruptedException &#123; for (int i = 0; i &lt; n; i++) &#123; lock.lock(); printFoo.run(); // 唤醒另一个线程 condition.signalAll(); // 自己陷入等待 condition.await(); lock.unlock(); &#125; &#125; public void bar(Runnable printBar) throws InterruptedException &#123; for (int i = 0; i &lt; n; i++) &#123; lock.lock(); printBar.run(); // 唤醒另一个线程 condition.signalAll(); // 防止线程在最后一次打印Bar时睡眠，从而造成死锁。 if (i != n - 1) &#123; // 自己陷入等待 condition.await(); &#125; lock.unlock(); &#125; &#125;&#125; ③信号量123456789101112131415161718192021222324252627282930// 3.信号量(Semaphore)class FooBar &#123; private int n; private Semaphore foo = new Semaphore(1); private Semaphore bar = new Semaphore(0); public FooBar(int n) &#123; this.n = n; &#125; public void foo(Runnable printFoo) throws InterruptedException &#123; for (int i = 0; i &lt; n; i++) &#123; // 获取foo信号量的一个许可 foo.acquire(); printFoo.run(); // 释放bar信号量的一个许可 bar.release(); &#125; &#125; public void bar(Runnable printBar) throws InterruptedException &#123; for (int i = 0; i &lt; n; i++) &#123; // 获取bar信号量的一个许可 bar.acquire(); printBar.run(); // 释放foo信号量的一个许可 foo.release(); &#125; &#125;&#125; ④CountDownLatch + CyclicBarrier12345678910111213141516171819202122232425262728293031323334353637// 4.CountDownLatch+CyclicBarrierclass FooBar &#123; private int n; // CyclicBarrier用于保证任务按组循环执行 private CyclicBarrier barrier = new CyclicBarrier(2); // CounDownLatch用于保证一个循环内线程执行的先后顺序 private CountDownLatch latch = new CountDownLatch(1); public FooBar(int n) &#123; this.n = n; &#125; public void foo(Runnable printFoo) throws InterruptedException &#123; for (int i = 0; i &lt; n; i++) &#123; try&#123; printFoo.run(); // 触发bar线程执行 latch.countDown(); // 等待bar线程执行完成 barrier.await(); &#125; catch(Exception e) &#123;&#125; &#125; &#125; public void bar(Runnable printBar) throws InterruptedException &#123; for (int i = 0; i &lt; n; i++) &#123; try &#123; // 等待被触发 latch.await(); printBar.run(); latch = new CountDownLatch(1); // 触发foo线程和bar线程继续执行(进行下一次循环) barrier.await(); &#125; catch (Exception e) &#123;&#125; &#125; &#125;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#106;&#x79;&#109;&#x65;&#x73;&#115;&#105;&#64;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#109; 关于 数据结构与算法 的更多代码 请查看我的 GitHub仓库]]></content>
      <categories>
        <category>Java</category>
        <category>LeetCode-多线程</category>
      </categories>
      <tags>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 1188. 设计有限阻塞队列（Medium）Java语言题解]]></title>
    <url>%2F2020%2F03%2F01%2FLeetCode-1188-%E8%AE%BE%E8%AE%A1%E6%9C%89%E9%99%90%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.题目相关①题目及示例 ②相关标签 多线程 ③题目地址 1188. 设计有限阻塞队列 — 力扣网 2.解题方法 使用 LinkedList 集合模拟阻塞队列 存储当前队列元素个数的变量是 AtomicInteger 类型（来保证原子性） ①synchronized 关键字 + this 锁对象 使用 synchronized 关键字对入队和出队操作加锁 使用 Object 对象的 wait 方法 和 notify 方法控制两个线程的相互等待和唤醒操作 ②lock + condition 使用 lock 对入队和出队操作加锁 使用 condition 控制两个线程的相互等待和唤醒操作 3.代码详解①synchronized 关键字 + this 锁对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 1.synchronized关键字+this锁对象class BoundedBlockingQueue &#123; // 用线程安全的集合实现一个阻塞队列 private LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); // 存储当前队列元素个数 AtomicInteger size = new AtomicInteger(0); // 存储队列长度上限 private volatile int capacity; public BoundedBlockingQueue(int capacity) &#123; this.capacity = capacity; &#125; public void enqueue(int element) throws InterruptedException &#123; synchronized (this) &#123; // 如果队列满，调用线程被阻塞直到队列非满。 while (size.get() &gt;= capacity) &#123; // 线程阻塞时会释放锁 this.wait(); &#125; // 在队首增加一个element list.addFirst(element); // 当前队列元素个数加一 size.incrementAndGet(); // 通知消费者线程可以继续消费了 this.notify(); &#125; &#125; public int dequeue() throws InterruptedException &#123; synchronized (this) &#123; // 如果队列空，调用线程被阻塞直到队列非空。 while (size.get() == 0) &#123; // 线程阻塞时会释放锁 this.wait(); &#125; // 返回队尾元素并从队列中将其删除 int value = list.getLast(); list.removeLast(); // 当前队列元素个数减一 size.decrementAndGet(); // 通知生产者线程可以继续生产了 this.notify(); return value; &#125; &#125; public int size() &#123; return size.get(); &#125;&#125; ②lock + condition12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 2.lock+conditionclass BoundedBlockingQueue &#123; // 用线程安全的集合实现一个阻塞队列 private LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); // 存储当前队列元素个数 AtomicInteger size = new AtomicInteger(0); // 存储队列长度上限 private volatile int capacity; // 可重入锁 private Lock lock = new ReentrantLock(); Condition procuder = lock.newCondition(); Condition consumer = lock.newCondition(); public BoundedBlockingQueue(int capacity) &#123; this.capacity = capacity; &#125; public void enqueue(int element) throws InterruptedException &#123; try &#123; lock.lock(); // 如果队列满，调用线程被阻塞直到队列非满。 while (size.get() &gt;= capacity) &#123; // 线程阻塞时会释放锁 procuder.await(); &#125; // 在队首增加一个element list.addFirst(element); // 当前队列元素个数加一 size.incrementAndGet(); // 通知消费者线程可以继续消费了 consumer.signal(); &#125; finally &#123; lock.unlock(); &#125; &#125; public int dequeue() throws InterruptedException &#123; try &#123; lock.lock(); // 如果队列空，调用线程被阻塞直到队列非空。 while (size.get() == 0) &#123; // 线程阻塞时会释放锁 consumer.await(); &#125; // 返回队尾元素并从队列中将其删除 int value = list.getLast(); list.removeLast(); // 当前队列元素个数减一 size.decrementAndGet(); // 通知生产者线程可以继续生产了 procuder.signal(); return value; &#125; finally &#123; lock.unlock(); &#125; &#125; public int size() &#123; return size.get(); &#125;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#121;&#x6d;&#x65;&#115;&#115;&#x69;&#64;&#49;&#54;&#51;&#46;&#99;&#x6f;&#x6d; 关于 数据结构与算法 的更多代码 请查看我的 GitHub仓库]]></content>
      <categories>
        <category>Java</category>
        <category>LeetCode-多线程</category>
      </categories>
      <tags>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 1195. 交替打印字符串（Medium）Java语言题解]]></title>
    <url>%2F2020%2F03%2F01%2FLeetCode-1195-%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.题目相关①题目及示例 ②相关标签 多线程 ③题目地址 1195. 交替打印字符串 — 力扣网 2.解题方法①synchronized 关键字 + this 锁对象 原因：四个线程属于同一个实例，虽然四个线程访问的是一个类的不同的普通同步方法，但是四个普通同步方法默认都是以 this 对象作为同步方法的锁，所以它们会争抢同一把锁（对于同一个实例来讲，四个方法的 this 对象是同一个）。 结果：四个线程争抢同一把锁，同一时刻只能有一个线程执行该线程对应的同步方法，然后再使用 wait 方法和 notify 方法，使得四个线程交替运行。 ②lock + condition lock 代替 synchronized 关键字 condition 中的 await 方法和 release 方法代替 Object 对象的 wait 方法和 notify 方法 ③信号量 四个线程第一次执行时，因为只有 number 信号量的计数器初始值为 1，其余都为 0，所以 number 线程先执行，让它不断判断接下来该哪个线程执行，并释放对应线程的信号量，对应线程执行一次循环后，释放 number 信号量，以便 number 线程继续判断。 ④原子变量 使用一个原子变量控制，把并发调用变成按顺序调用。 ⑤volatile 关键字 使用 volatile 关键字保证变量的可见性，把并发调用变成按顺序调用。 3.代码详解①synchronized 关键字 + this 锁对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 1.synchronized关键字+this锁对象(四个不同的线程将会共用一个FizzBuzz实例)class FizzBuzz &#123; private int n; private int num = 1; public FizzBuzz(int n) &#123; this.n = n; &#125; public void fizz(Runnable printFizz) throws InterruptedException &#123; while (num &lt;= n) &#123; synchronized (this) &#123; // 是3的倍数且不是5的倍数 if (num % 3 == 0 &amp;&amp; num % 5 != 0) &#123; printFizz.run(); num++; &#125; // 唤醒所有线程 this.notifyAll(); // 防止线程在最后一次打印时睡眠，从而造成死锁。 if (num &lt;= n) &#123; // 自己陷入等待 this.wait(); &#125; &#125; &#125; &#125; public void buzz(Runnable printBuzz) throws InterruptedException &#123; while (num &lt;= n) &#123; synchronized (this) &#123; // 是5的倍数且不是3的倍数 if (num % 5 == 0 &amp;&amp; num % 3 != 0) &#123; printBuzz.run(); num++; &#125; // 唤醒所有线程 this.notifyAll(); // 防止线程在最后一次打印时睡眠，从而造成死锁。 if (num &lt;= n) &#123; // 自己陷入等待 this.wait(); &#125; &#125; &#125; &#125; public void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException &#123; while (num &lt;= n) &#123; synchronized (this) &#123; // 是3的倍数且是5的倍数 if (num % 3 == 0 &amp;&amp; num % 5 == 0) &#123; printFizzBuzz.run(); num++; &#125; // 唤醒所有线程 this.notifyAll(); // 防止线程在最后一次打印时睡眠，从而造成死锁。 if (num &lt;= n) &#123; // 自己陷入等待 this.wait(); &#125; &#125; &#125; &#125; public void number(IntConsumer printNumber) throws InterruptedException &#123; while (num &lt;= n) &#123; synchronized (this) &#123; // 不是3的倍数且不是5的倍数 if (num % 3 != 0 &amp;&amp; num % 5 != 0) &#123; printNumber.accept(num); num++; &#125; // 唤醒所有线程 this.notifyAll(); // 防止线程在最后一次打印时睡眠，从而造成死锁。 if (num &lt;= n) &#123; // 自己陷入等待 this.wait(); &#125; &#125; &#125; &#125;&#125; ②lock + condition123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// 2.lock+conditionclass FizzBuzz &#123; private int n; private int num = 1; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public FizzBuzz(int n) &#123; this.n = n; &#125; public void fizz(Runnable printFizz) throws InterruptedException &#123; while (num &lt;= n) &#123; lock.lock(); // 是3的倍数且不是5的倍数 if (num % 3 == 0 &amp;&amp; num % 5 != 0) &#123; printFizz.run(); num++; &#125; // 唤醒所有线程 condition.signalAll(); // 防止线程在最后一次打印时睡眠，从而造成死锁。 if (num &lt;= n) &#123; // 自己陷入等待 condition.await(); &#125; lock.unlock(); &#125; &#125; public void buzz(Runnable printBuzz) throws InterruptedException &#123; while (num &lt;= n) &#123; lock.lock(); // 是5的倍数且不是3的倍数 if (num % 5 == 0 &amp;&amp; num % 3 != 0) &#123; printBuzz.run(); num++; &#125; // 唤醒所有线程 condition.signalAll(); // 防止线程在最后一次打印时睡眠，从而造成死锁。 if (num &lt;= n) &#123; // 自己陷入等待 condition.await(); &#125; lock.unlock(); &#125; &#125; public void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException &#123; while (num &lt;= n) &#123; lock.lock(); // 是3的倍数且是5的倍数 if (num % 3 == 0 &amp;&amp; num % 5 == 0) &#123; printFizzBuzz.run(); num++; &#125; // 唤醒所有线程 condition.signalAll(); // 防止线程在最后一次打印时睡眠，从而造成死锁。 if (num &lt;= n) &#123; // 自己陷入等待 condition.await(); &#125; lock.unlock(); &#125; &#125; public void number(IntConsumer printNumber) throws InterruptedException &#123; while (num &lt;= n) &#123; lock.lock(); // 不是3的倍数且不是5的倍数 if (num % 3 != 0 &amp;&amp; num % 5 != 0) &#123; printNumber.accept(num); num++; &#125; // 唤醒所有线程 condition.signalAll(); // 防止线程在最后一次打印时睡眠，从而造成死锁。 if (num &lt;= n) &#123; // 自己陷入等待 condition.await(); &#125; lock.unlock(); &#125; &#125;&#125; ③信号量12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 3.信号量(Semaphore)class FizzBuzz &#123; private int n; private Semaphore fizz = new Semaphore(0); private Semaphore buzz = new Semaphore(0); private Semaphore fizzbuzz = new Semaphore(0); private Semaphore number = new Semaphore(1); public FizzBuzz(int n) &#123; this.n = n; &#125; public void fizz(Runnable printFizz) throws InterruptedException &#123; for (int i = 3; i &lt;= n; i += 3) &#123; if (i % 5 != 0) &#123; // 获取fizz信号量的一个许可 fizz.acquire(); printFizz.run(); // 释放number信号量的一个许可 number.release(); &#125; &#125; &#125; public void buzz(Runnable printBuzz) throws InterruptedException &#123; for (int i = 5; i &lt;= n; i += 5) &#123; if (i % 3 != 0) &#123; // 获取buzz信号量的一个许可 buzz.acquire(); printBuzz.run(); // 释放number信号量的一个许可 number.release(); &#125; &#125; &#125; public void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException &#123; for (int i = 15; i &lt;= n; i += 15) &#123; // 获取fizzbuzz信号量的一个许可 fizzbuzz.acquire(); printFizzBuzz.run(); // 释放number信号量的一个许可 number.release(); &#125; &#125; public void number(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 1; i &lt;= n; i++) &#123; // 获取number信号量的一个许可 number.acquire(); if (i % 3 == 0 &amp;&amp; i % 5 == 0) &#123; // 释放fizzbuzz信号量的一个许可 fizzbuzz.release(); &#125; else if (i % 3 == 0) &#123; // 释放fizz信号量的一个许可 fizz.release(); &#125; else if (i % 5 == 0) &#123; // 释放buzz信号量的一个许可 buzz.release(); &#125; else &#123; printNumber.accept(i); // 释放number信号量的一个许可 number.release(); &#125; &#125; &#125;&#125; ④原子变量1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 4.原子变量class FizzBuzz &#123; private int n; private AtomicInteger num = new AtomicInteger(1); public FizzBuzz(int n) &#123; this.n = n; &#125; public void fizz(Runnable printFizz) throws InterruptedException &#123; while (num.get() &lt;= n) &#123; int temp = num.get(); // 是3的倍数且不是5的倍数 if (temp % 3 == 0 &amp;&amp; temp % 5 != 0) &#123; printFizz.run(); num.getAndIncrement(); &#125; &#125; &#125; public void buzz(Runnable printBuzz) throws InterruptedException &#123; while (num.get() &lt;= n) &#123; int temp = num.get(); // 不是3的倍数且是5的倍数 if (temp % 3 != 0 &amp;&amp; temp % 5 == 0) &#123; printBuzz.run(); num.getAndIncrement(); &#125; &#125; &#125; public void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException &#123; while (num.get() &lt;= n) &#123; int temp = num.get(); // 是3的倍数且是5的倍数 if (temp % 3 == 0 &amp;&amp; temp % 5 == 0) &#123; printFizzBuzz.run(); num.getAndIncrement(); &#125; &#125; &#125; public void number(IntConsumer printNumber) throws InterruptedException &#123; while (num.get() &lt;= n) &#123; int temp = num.get(); // 不是3的倍数且不是5的倍数 if (temp % 3 != 0 &amp;&amp; temp % 5 != 0) &#123; printNumber.accept(temp); num.getAndIncrement(); &#125; &#125; &#125;&#125; ⑤volatile 关键字123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 5.volatile关键字class FizzBuzz &#123; private int n; private volatile int flag = 0; public FizzBuzz(int n) &#123; this.n = n; &#125; public void fizz(Runnable printFizz) throws InterruptedException &#123; for (int i = 3; i &lt;= n; i += 3) &#123; // 是3的倍数且不是5的倍数 if (i % 5 != 0) &#123; while (flag != 1) &#123; Thread.sleep(1);&#125; printFizz.run(); // 将控制权交还给number()方法 flag = 0; &#125; &#125; &#125; public void buzz(Runnable printBuzz) throws InterruptedException &#123; for (int i = 5; i &lt;= n; i += 5) &#123; // 不是3的倍数且是5的倍数 if (i % 3 != 0) &#123; while (flag != 2) &#123; Thread.sleep(1);&#125; printBuzz.run(); // 控制权交还给number()方法 flag = 0; &#125; &#125; &#125; public void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException &#123; for (int i = 15; i &lt;= n; i += 15) &#123; // 是3的倍数且是5的倍数 while (flag != 3) &#123; Thread.sleep(1);&#125; printFizzBuzz.run(); // 控制权交还给number()方法 flag = 0; &#125; &#125; public void number(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 1; i &lt;= n; i++) &#123; while (flag != 0) &#123; Thread.sleep(1);&#125; if (i % 3 == 0 &amp;&amp; i % 5 == 0) &#123; flag = 3; &#125; else if (i % 5 == 0) &#123; flag = 2; &#125; else if (i % 3 == 0) &#123; flag = 1; &#125; // 不是3的倍数且不是5的倍数 else &#123; printNumber.accept(i); flag = 0; &#125; &#125; &#125;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#121;&#x6d;&#101;&#115;&#115;&#x69;&#x40;&#49;&#x36;&#51;&#x2e;&#x63;&#x6f;&#x6d; 关于 数据结构与算法 的更多代码 请查看我的 GitHub仓库]]></content>
      <categories>
        <category>Java</category>
        <category>LeetCode-多线程</category>
      </categories>
      <tags>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 1116. 打印零与奇偶数（Medium）Java语言题解]]></title>
    <url>%2F2020%2F03%2F01%2FLeetCode-1116-%E6%89%93%E5%8D%B0%E9%9B%B6%E4%B8%8E%E5%A5%87%E5%81%B6%E6%95%B0%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.题目相关①题目及示例 ②相关标签 多线程 ③题目地址 1116. 打印零与奇偶数 — 力扣网 2.解题方法①synchronized 关键字 + this 锁对象 原因：三个线程属于同一个实例，虽然三个线程访问的是一个类的不同的普通同步方法，但是三个普通同步方法默认都是以 this 对象作为同步方法的锁，所以它们会争抢同一把锁（对于同一个实例来讲，三个方法的 this 对象是同一个）。 结果：三个线程争抢同一把锁，同一时刻只能有一个线程执行该线程对应的同步方法，然后再使用 wait 方法和 notify 方法，使得三个线程按题意顺序运行。 ②lock + condition lock 代替 synchronized 关键字 condition 中的 await 方法和 release 方法代替 Object 对象的 wait 方法和 notify 方法 ③信号量 三个线程第一次执行时，因为只有 zero 信号量的计数器初始值为 1，其余都为 0，所以 zero 线程先执行，让它不断判断接下来该哪个线程执行，并释放对应线程的信号量，对应线程执行一次循环后，释放 zero 信号量，以便 zero 线程继续判断。 ④volatile 关键字 直接使用 volatile 关键字控制三个线程的执行顺序 具体实现见代码 3.代码详解①synchronized 关键字 + this 锁对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 1.synchronized关键字+this锁对象(三个不同的线程将会共用一个ZeroEvenOdd实例)class ZeroEvenOdd &#123; private int n; private volatile int flag = 0; public ZeroEvenOdd(int n) &#123; this.n = n; &#125; public void zero(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 1; i &lt;= n; i++) &#123; synchronized(this) &#123; while (flag != 0) &#123; // 自己陷入等待 this.wait(); &#125; printNumber.accept(0); if (i % 2 != 0) &#123; flag = 1; &#125; else &#123; flag = 2; &#125; // 唤醒所有线程 this.notifyAll(); &#125; &#125; &#125; public void even(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 2; i &lt;= n; i += 2) &#123; synchronized(this) &#123; while (flag != 2) &#123; // 自己陷入等待 this.wait(); &#125; printNumber.accept(i); flag = 0; // 唤醒所有线程 this.notifyAll(); &#125; &#125; &#125; public void odd(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 1; i &lt;= n; i += 2) &#123; synchronized(this) &#123; while (flag != 1) &#123; // 自己陷入等待 this.wait(); &#125; printNumber.accept(i); flag = 0; // 唤醒所有线程 this.notifyAll(); &#125; &#125; &#125;&#125; ②lock + condition12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 2.lock+conditionclass ZeroEvenOdd &#123; private int n; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); private volatile int flag = 0; public ZeroEvenOdd(int n) &#123; this.n = n; &#125; public void zero(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 1; i &lt;= n; i++) &#123; lock.lock(); while (flag != 0) &#123; // 自己陷入等待 condition.await(); &#125; printNumber.accept(0); if (i % 2 != 0) &#123; flag = 1; &#125; else &#123; flag = 2; &#125; // 唤醒所有线程 condition.signalAll(); lock.unlock(); &#125; &#125; public void even(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 2; i &lt;= n; i += 2) &#123; lock.lock(); while (flag != 2) &#123; // 自己陷入等待 condition.await(); &#125; printNumber.accept(i); flag = 0; // 唤醒所有线程 condition.signalAll(); lock.unlock(); &#125; &#125; public void odd(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 1; i &lt;= n; i += 2) &#123; lock.lock(); while (flag != 1) &#123; // 自己陷入等待 condition.await(); &#125; printNumber.accept(i); flag = 0; // 唤醒所有线程 condition.signalAll(); lock.unlock(); &#125; &#125;&#125; ③信号量1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 3.信号量(Semaphore)class ZeroEvenOdd &#123; private int n; private Semaphore zero = new Semaphore(1); private Semaphore even = new Semaphore(0); private Semaphore odd = new Semaphore(0); public ZeroEvenOdd(int n) &#123; this.n = n; &#125; public void zero(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 1; i &lt;= n; i++) &#123; // 获取zero信号量的一个许可 zero.acquire(); printNumber.accept(0); if (i % 2 != 0) &#123; // 释放odd信号量的一个许可 odd.release(); &#125; else &#123; // 释放even信号量的一个许可 even.release(); &#125; &#125; &#125; public void even(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 2; i &lt;= n; i += 2) &#123; // 获取even信号量的一个许可 even.acquire(); printNumber.accept(i); // 释放zero信号量的一个许可 zero.release(); &#125; &#125; public void odd(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 1; i &lt;= n; i += 2) &#123; // 获取odd信号量的一个许可 odd.acquire(); printNumber.accept(i); // 释放zero信号量的一个许可 zero.release(); &#125; &#125;&#125; ④volatile 关键字1234567891011121314151617181920212223242526272829303132333435363738394041424344// 4.volatileclass ZeroEvenOdd &#123; private int n; private volatile int flag = 0; public ZeroEvenOdd(int n) &#123; this.n = n; &#125; public void zero(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 1; i &lt;= n; i++) &#123; while (flag != 0) &#123; Thread.sleep(1); &#125; printNumber.accept(0); if (i % 2 != 0) &#123; flag = 1; &#125; else &#123; flag = 2; &#125; &#125; &#125; public void even(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 2; i &lt;= n; i += 2) &#123; while (flag != 2) &#123; Thread.sleep(1); &#125; printNumber.accept(i); flag = 0; &#125; &#125; public void odd(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 1; i &lt;= n; i += 2) &#123; while (flag != 1) &#123; Thread.sleep(1); &#125; printNumber.accept(i); flag = 0; &#125; &#125;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#106;&#x79;&#109;&#x65;&#115;&#115;&#105;&#x40;&#49;&#54;&#x33;&#46;&#x63;&#x6f;&#x6d; 关于 数据结构与算法 的更多代码 请查看我的 GitHub仓库]]></content>
      <categories>
        <category>Java</category>
        <category>LeetCode-多线程</category>
      </categories>
      <tags>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 1226. 哲学家进餐（Medium）Java语言题解]]></title>
    <url>%2F2020%2F03%2F01%2FLeetCode-1226-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.题目相关①题目及示例 ②相关标签 多线程 ③题目地址 1226. 哲学家进餐 — 力扣网 2.解题方法 哲学家进餐问题有死锁和资源耗尽的风险：每个哲学家同时拿着左边的筷子，永远都在等右边的筷子。 所以本题的重点在于如何避免死锁，我们采用两种常用的解决方法： 改变一个哲学家拿叉子的顺序 餐票策略 ①synchronized 关键字 + 改变一个哲学家拿叉子的顺序 改变一个哲学家拿叉子的顺序：要想发生死锁，必须所有人同时拿起左边的筷子，但是如果这时有一个哲学家先拿右边再拿左边，就不会发生死锁。即避免发生环路，属于避免策略。 使用 synchronized 关键字对拿起的筷子加锁 ②lock + 改变一个哲学家拿叉子的顺序 改变一个哲学家拿叉子的顺序：要想发生死锁，必须所有人同时拿起左边的筷子，但是如果这时有一个哲学家先拿右边再拿左边，就不会发生死锁。即避免发生环路，属于避免策略。 使用 lock 对拿起的筷子加锁 ③synchronized 关键字 + 信号量 + 餐票策略 餐票策略：要求必须拿到餐票才能吃饭，而我们为了避免死锁，总共只发三张餐票，这样可以避免五个人同时准备吃饭的情况，也属于避免策略。 使用 synchronized 关键字对拿起的筷子加锁 使用信号量模拟餐票 ④lock + 信号量 + 餐票策略 餐票策略：要求必须拿到餐票才能吃饭，而我们为了避免死锁，总共只发三张餐票，这样可以避免五个人同时准备吃饭的情况，也属于避免策略。 使用 lock 对拿起的筷子加锁 使用信号量模拟餐票 3.代码详解①synchronized 关键字 + 改变一个哲学家拿叉子的顺序123456789101112131415161718192021222324252627282930// 1.synchronized+改变一个哲学家拿叉子的顺序来避免死锁class DiningPhilosophers &#123; private Object[] locks = new Object[5]; public DiningPhilosophers() &#123; for (int i = 0; i &lt; 5; i++) &#123; locks[i] = new Object(); &#125; &#125; public void wantsToEat(int philosopher, Runnable pickLeftFork, Runnable pickRightFork, Runnable eat, Runnable putLeftFork, Runnable putRightFork) throws InterruptedException &#123; // 改变0号哲学家拿叉子的顺序 int leftForkNumber = philosopher == 0? (philosopher + 1) % 5: philosopher; int rightForkNumber = philosopher == 0? philosopher: (philosopher + 1) % 5; synchronized (locks[leftForkNumber]) &#123; synchronized (locks[rightForkNumber]) &#123; pickLeftFork.run(); pickRightFork.run(); eat.run(); putLeftFork.run(); putRightFork.run(); &#125; &#125; &#125;&#125; ②lock + 改变一个哲学家拿叉子的顺序123456789101112131415161718192021222324252627// 2.lock+改变一个哲学家拿叉子的顺序来避免死锁class DiningPhilosophers &#123; private Lock[] locks = &#123;new ReentrantLock(), new ReentrantLock(), new ReentrantLock(), new ReentrantLock(), new ReentrantLock()&#125;; public DiningPhilosophers() &#123; &#125; public void wantsToEat(int philosopher, Runnable pickLeftFork, Runnable pickRightFork, Runnable eat, Runnable putLeftFork, Runnable putRightFork) throws InterruptedException &#123; // 改变0号哲学家拿叉子的顺序 int leftForkNumber = philosopher == 0? (philosopher + 1) % 5: philosopher; int rightForkNumber = philosopher == 0? philosopher: (philosopher + 1) % 5; locks[leftForkNumber].lock(); locks[rightForkNumber].lock(); pickLeftFork.run(); pickRightFork.run(); eat.run(); putLeftFork.run(); putRightFork.run(); locks[rightForkNumber].unlock(); locks[leftForkNumber].unlock(); &#125;&#125; ③synchronized 关键字 + 信号量 + 餐票策略123456789101112131415161718192021222324252627282930313233// 3.synchronized+信号量+餐票策略来避免死锁class DiningPhilosophers &#123; private Object[] locks = new Object[5]; private Semaphore limit = new Semaphore(3); public DiningPhilosophers() &#123; for (int i = 0; i &lt; 5; i++) &#123; locks[i] = new Object(); &#125; &#125; public void wantsToEat(int philosopher, Runnable pickLeftFork, Runnable pickRightFork, Runnable eat, Runnable putLeftFork, Runnable putRightFork) throws InterruptedException &#123; int leftForkNumber = philosopher; int rightForkNumber = (philosopher + 1) % 5; // 规定最多有三个哲学家同时拿起叉子 limit.acquire(); synchronized (locks[leftForkNumber]) &#123; synchronized (locks[rightForkNumber]) &#123; pickLeftFork.run(); pickRightFork.run(); eat.run(); putLeftFork.run(); putRightFork.run(); &#125; &#125; limit.release(); &#125;&#125; ④lock + 信号量 + 餐票策略123456789101112131415161718192021222324252627282930// 4.lock+信号量+餐票策略来避免死锁class DiningPhilosophers &#123; private Lock[] locks = &#123;new ReentrantLock(), new ReentrantLock(), new ReentrantLock(), new ReentrantLock(), new ReentrantLock()&#125;; private Semaphore limit = new Semaphore(3); public DiningPhilosophers() &#123; &#125; public void wantsToEat(int philosopher, Runnable pickLeftFork, Runnable pickRightFork, Runnable eat, Runnable putLeftFork, Runnable putRightFork) throws InterruptedException &#123; int leftForkNumber = philosopher; int rightForkNumber = (philosopher + 1) % 5; // 规定最多有三个哲学家同时拿起叉子 limit.acquire(); locks[leftForkNumber].lock(); locks[rightForkNumber].lock(); pickLeftFork.run(); pickRightFork.run(); eat.run(); putLeftFork.run(); putRightFork.run(); locks[rightForkNumber].unlock(); locks[leftForkNumber].unlock(); limit.release(); &#125;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#121;&#x6d;&#101;&#115;&#x73;&#x69;&#64;&#49;&#54;&#x33;&#46;&#99;&#x6f;&#x6d; 关于 数据结构与算法 的更多代码 请查看我的 GitHub仓库]]></content>
      <categories>
        <category>Java</category>
        <category>LeetCode-多线程</category>
      </categories>
      <tags>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 1114. 按序打印（Easy）Java语言题解]]></title>
    <url>%2F2020%2F03%2F01%2FLeetCode-1114-%E6%8C%89%E5%BA%8F%E6%89%93%E5%8D%B0%EF%BC%88Easy%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.题目相关①题目及示例 ②相关标签 多线程 ③题目地址 1114. 按序打印 — 力扣网 2.解题方法①原子变量 使用一个原子变量控制，把并发调用变成按顺序调用。 ②volatile 关键字 使用 volatile 关键字保证变量的可见性，把并发调用变成按顺序调用。 ③信号量 三个线程第一次执行时，因为 flag1 信号量和 flag2 信号量的计数器初始值都为 0，所以需要等 first 线程中释放了 flag1 信号量，second 线程才能开始执行，需要等 second 线程中释放了 flag2 信号量，third 线程才能开始执行。 ④CountDownLatch 两个 CountDownLatch 实例可以控制三个线程执行的先后顺序 具体实现见代码 ⑤CyclicBarrier 两个 CyclicBarrier 实例可以控制三个线程执行的先后顺序 具体实现见代码 3.代码详解①原子变量123456789101112131415161718192021222324252627// 1.使用一个原子变量控制，把并发调用变成按顺序调用。class Foo &#123; private AtomicInteger n = new AtomicInteger(0); public Foo() &#123; &#125; public void first(Runnable printFirst) throws InterruptedException &#123; printFirst.run(); n.incrementAndGet(); &#125; public void second(Runnable printSecond) throws InterruptedException &#123; // 等待第一个线程执行完毕 while (n.get() != 1) &#123; &#125; printSecond.run(); n.incrementAndGet(); &#125; public void third(Runnable printThird) throws InterruptedException &#123; // 等待第二个线程执行完毕 while (n.get() != 2) &#123; &#125; printThird.run(); &#125;&#125; ②volatile 关键字12345678910111213141516171819202122232425// 2.volatile关键字class Foo &#123; private volatile int flag = 0; public Foo() &#123; &#125; public void first(Runnable printFirst) throws InterruptedException &#123; printFirst.run(); flag = 1; &#125; public void second(Runnable printSecond) throws InterruptedException &#123; // 等待第一个线程执行完毕 while (flag != 1) &#123;&#125; printSecond.run(); flag = 2; &#125; public void third(Runnable printThird) throws InterruptedException &#123; // 等待第二个线程执行完毕 while (flag != 2) &#123;&#125; printThird.run(); &#125;&#125; ③信号量12345678910111213141516171819202122232425262728// 3.信号量(Semaphore)class Foo &#123; private Semaphore flag1 = new Semaphore(0); private Semaphore flag2 = new Semaphore(0); public Foo() &#123; &#125; public void first(Runnable printFirst) throws InterruptedException &#123; printFirst.run(); // 释放flag1信号量的一个许可 flag1.release(); &#125; public void second(Runnable printSecond) throws InterruptedException &#123; // 获取flag1信号量的一个许可 flag1.acquire(); printSecond.run(); // 释放flag2信号量的一个许可 flag2.release(); &#125; public void third(Runnable printThird) throws InterruptedException &#123; // 获取flag2信号量的一个许可 flag2.acquire(); printThird.run(); &#125;&#125; ④CountDownLatch12345678910111213141516171819202122232425262728// 4.CountDownLatchclass Foo &#123; private CountDownLatch latch1 = new CountDownLatch(1); private CountDownLatch latch2 = new CountDownLatch(1); public Foo() &#123; &#125; public void first(Runnable printFirst) throws InterruptedException &#123; printFirst.run(); // 触发second线程执行 latch1.countDown(); &#125; public void second(Runnable printSecond) throws InterruptedException &#123; // 等待被触发 latch1.await(); printSecond.run(); // 触发third线程执行 latch2.countDown(); &#125; public void third(Runnable printThird) throws InterruptedException &#123; // 等待被触发 latch2.await(); printThird.run(); &#125;&#125; ⑤CyclicBarrier1234567891011121314151617181920212223242526272829303132// 5.CyclicBarrierclass Foo &#123; private CyclicBarrier barrier1 = new CyclicBarrier(2); private CyclicBarrier barrier2 = new CyclicBarrier(2); public Foo() &#123; &#125; public void first(Runnable printFirst) throws InterruptedException &#123; try &#123; printFirst.run(); barrier1.await(); &#125; catch (BrokenBarrierException e) &#123;&#125; &#125; public void second(Runnable printSecond) throws InterruptedException &#123; try &#123; // 等待fisrt线程执行完printFirst.run(); barrier1.await(); printSecond.run(); barrier2.await(); &#125; catch (BrokenBarrierException e) &#123;&#125; &#125; public void third(Runnable printThird) throws InterruptedException &#123; try &#123; // 等待second线程执行完printSecond.run(); barrier2.await(); printThird.run(); &#125; catch (BrokenBarrierException e) &#123;&#125; &#125;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#121;&#109;&#101;&#115;&#x73;&#105;&#x40;&#x31;&#54;&#x33;&#x2e;&#99;&#111;&#109; 关于 数据结构与算法 的更多代码 请查看我的 GitHub仓库]]></content>
      <categories>
        <category>Java</category>
        <category>LeetCode-多线程</category>
      </categories>
      <tags>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程之死锁]]></title>
    <url>%2F2020%2F02%2F28%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程之基础概念]]></title>
    <url>%2F2020%2F02%2F25%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[1.进程和线程①与操作系统的关系 一个操作系统可以拥有多个进程（process） 一个进程可以拥有多个线程（thread） 即操作系统是包含多个进程的容器，而每个进程又都是容纳多个线程的容器。 ②进程定义 Oracle 的官方定义： 进程：使用 fork 系统调用创建的 UNIX 环境（包括文件描述符、用户 ID 、CPU 使用时间、存储器、IO 设备、内存等），它被设置为运行程序。 线程：在进程上下文中执行的一系列指令 通俗理解进程： 进程指的是程序的一次执行。在用户下达运行程序的命令后，就会产生进程。没有运行的程序占用的空间大部分是磁盘空间，将程序运行起来时就变成了一个进程。 比喻：进程是对代码的实例化 在任务管理器中可以查看正在运行的进程： 总结进程：进程是程序的真正运行实例，是资源分配的基本单位。内存、CPU 等资源都是以进程为单位进行分配的。 ③线程定义123456789101112131415161718192021222324/** * @author: wjy * @date: 2020/2/18 * @description: 创建100个线程，用任务管理器可以看到Java线程数量的变化。 */public class Create100Threads &#123; public static void main(String[] args) &#123; // 新建100个线程 for (int i = 0; i &lt; 100; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; // 睡眠10s try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; &#125;&#125; 程序运行前： 程序运行过程： 程序运行结束： 通俗理解线程： 线程是 CPU 的基本调度单位，每个线程执行的都是进程代码的某个片段。 进程是线程的容器，让线程利用进程中的资源执行代码。进程的线程数量若是大于 1，则是多线程的情况，多个线程帮助同一进程执行代码。 ④两者的异同 起源不同 回顾操作系统的历史，先有进程后有线程。 由于处理器的速度往往比外设（键盘、硬盘等）快，所以为了提高 CPU 的利用率，才诞生了线程，目的是提高程序的执行效率。 概念不同 进程是具有独立功能的程序运行起来的一个活动，是一个实例，也是系统分配资源和调度的独立单位。 线程是 CPU 的基本调度单位 内存共享方式不同 对于进程而言，每个进程都会被操作系统分配到一定的内存，不同进程之间的内存通常是不共享的。例如：浏览器无法访问正在播放的 qq 音乐，它们之间想要通讯的话，需要使用进程间通讯 RPC。 线程与线程之间服务于同一个进程，需要合作，所以两个线程之间通讯很容易，可以共享由操作系统分配给其父进程的相同内存块。 拥有的资源不用 线程本身是进程的一部分，拥有的资源一定少于进程。 不同的线程之间共享的内容：①进程代码段（重点）、②进程的公有数据（利用这些共享的数据，线程很容易实现互相通讯）、③进程打开的文件描述符、④信号的处理器、⑤进程的当前目录、⑥进程用户 ID 与进程组 ID 不同的线程之间独有的内容：①线程 ID、②寄存器组的值、③线程的堆栈（重点）、④错误返回码、⑤线程的信号屏蔽码 进程和线程的数量不同 进程只有一个，线程可以有多个。 一个进程至少拥有一个线程，否则没有办法执行。 开销不同 因为进程和线程本身不是一个数量级的东西，所以线程始终比进程更轻量级。 线程的创建、终止时间比进程短。 同一进程内的线程切换时间比进程切换时间短 同一进程的各个线程间共享内存和文件资源，可以不通过内核进行通信。而进程间想要通信，需要借助内核帮忙。 相同点：从生命周期 / 状态上来看，进程和线程从创建到结束都有就绪、等待、运行等状态。 ⑤Java 语言和多线程的关系 Java 语言的显著优势：在设计之初就支持多线程（当时大部分编程语言不支持多线程）。 Java 语言可以将我们创建的线程一对一映射到操作系统的内核线程中。而有些语言的线程是虚拟线程，不会在操作系统中对应的建立线程。 JVM 自动启动线程：即使在代码中不显式的创建线程，在运行 main 函数时，JVM 也会自动地启动其他线程，这些线程都有特定的含义。 123456789101112/** * @author: wjy * @date: 2020/2/18 * @description: 即使在代码中不显式的创建线程，在运行main函数时，JVM也会自动地启动其他线程。 * 并且这些线程都有特定的含义和作用。 */public class JavaAndThreads &#123; public static void main(String[] args) &#123; System.out.println("Hello Threads!"); &#125;&#125; Signal Dispatcher：把操作系统发来的信号分发给适当的处理程序，用于连接操作系统和应用程序。 Finalizer：负责对象的 finalize() 方法。在每个对象结束的时候，可能会实现 finalize() 方法，主要是为了处理该方法。但是随着 Java 语言的发展，不再推荐使用该方法。 Reference Handler：和 GC、引用相关的线程。将每一个对象的引用记录在案，以便配合 GC 进行垃圾回收。 main：主线程，用户程序的主入口，编写的代码从这里开始执行。 以上线程都是 JVM 自动创建的，由此可以看出 Java 语言和多线程息息相关。 2.多线程①定义 多线程：在单个进程中运行多个线程 多线程程序：如果一个程序允许运行两个或两个以上的线程，那么它就是多线程程序。 现在绝大部分的程序都是多线程程序。例如：在浏览器中可以同时打开几个网页、同时下载几个文件，以及服务端可以同时处理多个请求。 每个线程拥有自己的独立资源（ID、堆栈等），进程的内存空间对每个线程敞开，每个线程都可以到进程的内存空间中获取想要的资源并且互相通信。 相互独立的任务：没必要使用多线程 数据和资源共享的任务：需要使用多线程，并且要考虑线程的同步，确保线程的安全。 ②多线程实例 多线程实例：抢火车票 最开始在火车站买火车票，是全国统一进行放票。假设全国使用同一个服务器（类比为一个进程）进行放票，而多个售票窗口就可以类比为多个线程。不同的线程之间互相配合或竞争。 不断迭代后： 增加放票时间段（分散压力），不同的车次有自己的放票时间。 增加候补功能 增加买票限制 以上都是为了减少服务器的并发压力 ③为什么需要多线程？ 提高 CPU 的利用率（最主要的目的） 目前大部分 CPU 都是两核或者两核以上，如果不发挥多线程的优势，始终使用单线程，就会浪费计算资源。多线程程序可以充分发挥多核 CPU 的优势，提高计算机的运行效率。 ①提高了处理速度（CPU 的运行效率远远超过内存、磁盘、外设等） ②避免了无效等待（在读取磁盘 IO 的时候，CPU 没有必要等待，而应该去做其他的事情。） ③提高了用户体验：避免卡顿、缩短等待时间（并行处理，提高性能，例如 Tomcat 服务器用多个线程去接收 HTTP 请求，可以同时服务于多个用户。） 便于编程建模（简化任务） 将大任务拆解为 A、B、C、D 并建立模型，类似的任务都可以使用模型处理。然后用多线程分别执行这 4 个任务，就简单很多。因为每个子任务的目的明确、功能单一。 计算机性能定律：摩尔定律失效，阿姆达尔定律登上舞台。 摩尔定律：当价格不变时，集成电路上可容纳的晶体管数目约每隔 18 个月便会增加一倍，意味着 CPU 的性能可以提高一倍。这个定律告诉我们长期以来 CPU 的性能都是以指数型快速增长的。但是，近年来陷入了瓶颈。 阿姆达尔定律：处理器（CPU）越多，程序的执行速度就越快。但是执行速度也有上限，取决于程序中串行部分的比例，并行的比例越高，多处理器的效果越明显。对于串行任务，无论有多少 CPU 资源，都没有办法提高速度。 并行比例与提升速度的关系： 在未来，CPU 的性能的提升速度放缓了，这就要求我们把程序中更多可并行的部分并行化，以提高程序的性能。 ④什么场景中会用到多线程？ 执行耗时任务（IO、磁盘读写、网络通信等）新开线程，不但不会影响主程序的运行，也不会因为耗时任务执行时间过慢而影响其他任务的运行。 为了同时做多件不同的事：①使用浏览器的同时听音乐、②后台定时任务等 提高工作效率、处理能力 ①Tomcat 可以同时并行处理多个线程进来的请求 ②下载文件时可以选择线程数，多线程并行下载（每个线程都去和服务器通信，都去做独立的下载任务，并且把下载的任务进行分割，最后再把下载到的文件拼接起来），以提高下载效率。 ③NIO：将 IO 操作升级为多线程操作，提高了 IO 的处理能力。 需要同时有很大并发量的时候（比如进行服务器承受压力的能力的测试时，需要多线程并行请求） ⑤多线程的局限 性能问题：上下文切换带来的消耗 线程之间切换时会有上下文切换，会保存一些 CPU 所需要的数据，如当前运行到哪一行代码等。 异构化任务很难高效并行 每个任务之间的结构都不一样，很难总结为多个任务的拆解。 带来线程安全问题：包括数据安全问题（例如 i++ 总数不一致）以及线程带来的活跃性问题（线程饥饿、死锁等） 线程饥饿：某个线程想要执行任务，但是被其他线程强先，这个线程始终没有事干。 死锁：两个线程相互拥有对方所需要的资源但都不肯放手，于是陷入无穷等待。 3.串行、并行、并发①串行、并行、并发 串行：大家排队一个个来 左图：线程 A -&gt; B -&gt; C 依次执行 右图：将数据一位一位发送 并行：大家一起来 左图：线程 A / B / C 同时执行 右图：将 8 个数据一次性发送出去 并发（Concurrency）：单核就能实现并发、属于逻辑上的同时运行（由于处理器的处理速度很快，所以线程之间的切换肉眼是感知不到的，感觉它是在同时执行多个程序，实际某一时间只有一个程序执行（单处理器））。 在物理层面并发就是串行，只不过是在多个程序上快速的来回切换而不是一个个依次执行，所以在用户看来相当于三个程序同时执行。 并行（Parallelism）：多核处理器，物理上的同时运行，多个处理器都在同时执行任务。 并行是真正的 “同时” 运行：在同一时刻，有多个任务同时执行。 单核处理器是无法实现并行的，因为单核处理器无法在同一时刻执行多个任务。 并发可以对应到两个不同的概念 ①形容多个任务的执行状态： 两个或多个任务可以在重叠的时间段（不是指真正重叠的同一时刻，而是一段时间内交替运行）内启动，运行和完成。 并行（两个线程同时执行）一定是并发，两者是包含关系。 并发 + 多核 + 同一时刻执行同一段代码 = 并行 并发：不同的线程交替给一个 CPU 执行（蓝色竖线：CPU 的时间片） 并行：多个线程同时被多个 CPU 执行 ②对 “并发性” 的简称： 如果一个程序具有并发性，指的是程序不同的部分可以无序或同时执行，且不影响最终的执行结果。 在不同核心数的计算机上的表现不同： 在多核 CPU 上，可以并行执行并发性程序。 在单核 CPU 上，可以并发执行并发性程序，串行执行非并发性程序。 此时，并行和并发的概念并不在同一维度上。并发指的是并发性，并行指的是多个程序在同一时刻同时执行。一个程序如果想要并发 / 并行执行，前提条件是它具有并发性。并发性是并发执行和并行执行的前提条件和必要条件。如果一个程序可以并行执行，就代表它一定具有并发性。 ②是什么让并发和并行成为可能？ CPU 升级 CPU 之前一直遵循摩尔定律，性能提升的很快，它的处理速度远远比其他部件快。但是每个 CPU 同一时刻只能执行一个指令，出于这个原因，操作系统开发出了新的技术，可以让用户同时运行多个进程或者多个线程。 操作系统的升级 升级之后将 CPU 完美的调度了起来，即便是单核 CPU，也能让不同的进程使用时间片的方式（抢占式的方式）不停地切换。 抢占式多任务处理：现代 CPU 最主要的一种处理方式，即操作系统有权利中断正在执行的任务。 诞生多核处理器后，操作系统可以自动检测 CPU 核心的数量，为每个核心分配不同的任务，以实现真正地同一时刻运行多个程序。 编程语言的升级 Java 语言诞生之前，很多编程语言不支持多线程。随着 Java 的诞生，多线程编程开始逐渐火热并且发展成熟。 4.高并发①定义 高并发：同时有很多个请求发送给服务器系统，服务器会并行处理。 高并发场景：天猫双十一、春晚微信摇一摇、12306 卖火车票 一般将系统的承受能力设计为目前系统访问量的十倍比较合适 ②高并发和多线程的异同？ 高并发：指大量的请求同时到达服务器所带来的结果（结果指服务器需要同时处理很多请求），它是一种状态。系统需要应对高并发这种状态所带来的后果，如果处理不当，会导致请求的响应速度慢、无响应甚至服务器死机。 多线程并不意味着高并发，多线程编程是一种编程方式，是一种解决方案，不仅可以解决高并发所带来的线程安全问题 / 性能问题，还可以提高硬件的利用率，以便获取到更多的资源，从而解决高并发带来的服务器死机、响应慢等问题。 多线程编程是我们应对高并发场景的一种重要的解决方案。 高并发并不一定要通过多线程的方式解决 例如：解决数据库的高并发问题可以利用 Redis 缓存层（可能带来缓存不一致的问题，但不会带来线程安全问题） 总结：高并发并不意味着多线程（例如：Redis 底层是用单线程处理的）。高并发是一种状态，作为服务器开发者，最好用多线程的方式解决，这样可以提高 CPU 等资源的利用率，加快用户的响应速度。但是在场景不同，资源不同的情况下，也可以选择其他的解决方案。 ③高并发有哪些指标？ QPS（Queries Per Second）：每秒钟的查询（请求）数 PV（Page View）：24 小时内的页面点击量（综合浏览量） UV（Unique Visitor）：24 小时内访问的用户数量（根据 Cookie）、UV &lt;= PV 并发连接数：某个时刻服务器所接受的请求的数目。 对于同一个用户而言，可以同时产生很多个会话 / 连接，所以数目 &gt; 同时在线的用户数量。 对服务器来说，这个连接有一个上限 服务器平均请求等待时间：服务器处理一个请求所花费的时间 5.同步与异步、阻塞与非阻塞①同步与异步 同步与异步：被调用方是否主动告诉调用方结果。 同步与异步是被调用方（即服务端）的行为，而不是调用方的行为。 同步：在没有得到结果之前，服务端不返回任何结果。 异步：调用在发出之后，服务端会立刻返回，告诉调用方 “我收到你的请求了，我会马上处理的”，等服务器处理完成以后，会再次告诉调用方 “我已经处理完了”。 ②阻塞与非阻塞 站在线程状态的角度：阻塞指当前线程不能继续执行，需要等待一段时间或者被唤醒。 站在线程发出请求的角度：我是调用方，我调用一个东西后，在返回结果前是否还能做其他事情。 阻塞与非阻塞是调用方的行为，而不是被调用方的行为。 阻塞：调用一个东西后，返回结果前什么也不做。 非阻塞：调用一个东西后，返回结果前做其他事情。 ③同步阻塞、同步非阻塞、异步阻塞、异步非阻塞 同步不一定是阻塞，阻塞也不一定是同步。 异步不一定是非阻塞，非阻塞也不一定是异步。 同步阻塞：（被调用方）执行完成后才返回结果、（调用方）在返回结果前什么也不做。 同步非阻塞：（被调用方）执行完成后才返回结果、（调用方）在返回结果前做其他事情，不时地检查一下被调用方是否返回结果。 异步阻塞：调用方在发出请求之后，被调用方会立刻告诉调用方已经收到请求，当被调用方处理完成以后，会再次告诉调用方已经处理完了、但是（调用方）在返回结果前什么也不做。 异步非阻塞：调用方在发出请求之后，被调用方会立刻告诉调用方已经收到请求，当被调用方处理完成以后，会再次告诉调用方已经处理完了、（调用方）在返回结果前做其他事情，等待被调用方主动返回结果。 6.常见面试问题①进程和线程的异同？ 不同：起源、概念、内存共享方式、拥有的资源、数量、开销 相同：生命周期（状态） 具体见 1.进程和线程——④两者的异同 ②并行和并发的异同？ 都在形容一个程序的运行状态时：并行一定是并发。 并发也可以形容一个程序的属性，即程序是否具有并发性。若是程序没有并发性，表示程序只能串行执行。 ③多线程就是高并发吗？有什么反例？ 高并发指服务器同时接受很多请求，受到极大压力。 多线程是针对高并发的一个解决方案，可以使用多线程将这个压力迅速化解。 反例：Redis 本身是单线程的，但是同样可以支持高并发的场景。 应对高并发时，不仅可以通过多线程的方式解决，也可以从整体架构、缓存层的设计、MQ 队列等地方着手解决。 ④多线程可以提高程序的执行效率，你知不知道有哪些弊端？ 性能问题（上下文切换、保存 CPU cache） 异构化任务或不能并行执行的任务用多线程反而不如用单线程合适 线程安全问题 ⑤什么是同步？什么是异步？什么是阻塞？什么是非阻塞？ 同步、异步指的是被调用方在调用结束后是否主动返回结果 阻塞、非阻塞指的是调用方在调用后是否可以去做其他事情 具体见 5.同步与异步、阻塞与非阻塞 ⑥在单核 CPU 上运行多线程程序有意义吗？ 有意义，虽然在单核 CPU 上执行真正的并行是不可能的，因为只有一个处理器，但是对于应用程序而言，我们不知道它未来会运行在单核 CPU 还是多核 CPU 上，所以在编写时肯定以多核 CPU 为准。其次，对于多线程程序，当其中一个线程执行缓慢或者被阻塞时，其他线程可以利用这些时间（如读取磁盘的时间）做其他事情，让程序保持高效运转。 如果 CPU 被挤满，并不是说在单核 CPU 上运行多线程程序没有意义，而是说线程的数量设置不合理，应该减少线程的数量。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#x79;&#x6d;&#x65;&#115;&#115;&#105;&#x40;&#49;&#54;&#x33;&#46;&#x63;&#111;&#109;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Synchronized关键字]]></title>
    <url>%2F2020%2F02%2F20%2FSynchronized%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[1.简介①作用 Oracle 的官方解释：synchronized 关键字的同步方法支持一种简单的策略来防止线程干扰和内存一致性错误。 如果一个对象对多个线程可见，则对该对象变量的所有读取或写入都是通过同步方法完成的。 一句话总结 synchronized 的作用：能够保证在同一时刻最多只有一个线程执行该段代码，以达到保证并发安全的效果。 被 synchronized 关键字修饰的代码会以原子的方式执行，即多个线程不会同时执行这段代码，同一时刻最多只有一个线程执行该段代码。 如何控制同一时刻只有一个线程执行该段代码？有一把锁，当第一个线程执行这段代码时拿到这把锁，直到方法执行结束或一定条件后才会释放这把锁。在这把锁释放前，其他线程想要执行这段代码，只能等待或者阻塞。直到锁释放后，其他线程才能执行这段代码。 ②地位 synchronized 是 Java 的关键字，被 Java 语言原生支持。 volatile 也是 Java 的关键字（它们都是 Java 并发编程中的重要关键字） 它是最基本的互斥同步手段 互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。 同步：指程序用于控制不同线程之间操作发生相对顺序的机制。 它是并发编程中的元老级角色，是并发编程的必学内容。 ③不使用并发（同步方法）的后果 代码实战：两个线程同时执行 a++，最后结果会被预计的少。 12345678910111213141516171819202122232425262728293031/** * @author: wjy * @date: 2020/2/19 * @description: 不使用并发手段，建立两个线程一起执行a++。 */public class NoUseConcurrency implements Runnable &#123; // 创建类的实例 static NoUseConcurrency instance = new NoUseConcurrency(); // 初始化a的值 static int a = 0; public static void main(String[] args) throws InterruptedException &#123; // 建立两个线程，利用同一个实例，共用实例中的方法。 Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); // 启动两个线程 t1.start(); t2.start(); // 让主线程等待两个子线程都执行完成 t1.join(); t2.join(); System.out.println(a); &#125; @Override public void run() &#123; for (int i = 0; i &lt; 100000; i++) &#123; a++; &#125; &#125;&#125; 连续运行三次程序，打印的结果各不相同。 原因：a++ 看上去只是一个操作，实际上包含了三个步骤： ①读取 a ②将 a 的值加 1 ③将 a 的值写入到内存中 而在多线程的情况下任何一步执行完成后都有可能被打断，都有可能轮到另一个线程去执行，即线程不安全。 ④使用并发（同步方法）12345678910111213141516171819202122232425262728293031/** * @author: wjy * @date: 2020/2/20 * @description: 使用并发手段，建立两个线程一起执行a++。 */public class UseConcurrency implements Runnable &#123; static UseConcurrency instance = new UseConcurrency(); static int a = 0; public static void main(String[] args) throws InterruptedException &#123; // 建立两个线程，利用同一个实例，共用实例中的方法。 Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); // 启动两个线程 t1.start(); t2.start(); // 让主线程等待两个子线程都执行完成 t1.join(); t2.join(); System.out.println(a); &#125; // 对象锁-方法锁 // 将关键字加在普通方法上 @Override public synchronized void run() &#123; for (int i = 0; i &lt; 100000; i++) &#123; a++; &#125; &#125;&#125; 重复运行多次程序，打印结果都是 a = 200000。 2.用法 synchronized 关键字也叫做同步修饰符音标：[ˈsɪŋkrənaɪzd] ①对象锁 对象锁的两种形式： 同步代码块锁 手动指定锁对象（this 或自定义对象） 方法锁 synchronized 修饰普通方法（不能修饰静态方法），锁对象默认为 this。 12345678910111213141516171819202122232425262728293031323334353637/** * @author: wjy * @date: 2020/2/19 * @description: 对象锁实例1之同步代码块形式 */public class SynchronizedObjectLock1 implements Runnable &#123; static SynchronizedObjectLock1 instance = new SynchronizedObjectLock1(); @Override public void run() &#123; // 默认用this(当前对象)作为锁对象 // 保护以下代码块串行执行 synchronized (this) &#123; System.out.println(Thread.currentThread().getName() + "开始执行"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "执行结束"); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; // 建立两个线程，利用同一个实例，共用实例中的方法。 Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); // 启动两个线程 t1.start(); t2.start(); // 让主线程等待两个子线程都执行完成 while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("finished"); &#125;&#125; 以上代码线程 0 先执行，执行完成后线程 1 再执行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @author: wjy * @date: 2020/2/19 * @description: 对象锁实例1之同步代码块形式 */public class SynchronizedObjectLock1 implements Runnable &#123; static SynchronizedObjectLock1 instance = new SynchronizedObjectLock1(); // 创建自定义锁对象，lock1和lock2保护的时机不相同。 Object lock1 = new Object(); Object lock2 = new Object(); @Override public void run() &#123; // 自定义锁对象 synchronized (lock1) &#123; System.out.println(Thread.currentThread().getName() + "开始执行(lock1)"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "执行结束(lock1)"); &#125; synchronized (lock2) &#123; System.out.println(Thread.currentThread().getName() + "开始执行(lock2)"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "执行结束(lock2)"); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; // 建立两个线程，利用同一个实例，共用实例中的方法。 Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); // 启动两个线程 t1.start(); t2.start(); // 让主线程等待两个子线程都执行完成 while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("finished"); &#125;&#125; 以上代码线程 0 拿到第 2 把锁的同时，线程 1 拿到第 1 把锁，并行执行（第一把锁和第二把锁不相同，互不影响）。 1234567891011121314151617181920212223242526272829303132333435363738/** * @author: wjy * @date: 2020/2/19 * @description: 对象锁示例2之方法锁形式 */public class SynchronizedObjectLock2 implements Runnable &#123; static SynchronizedObjectLock2 instance = new SynchronizedObjectLock2(); @Override public void run() &#123; method(); &#125; // 对普通方法加上synchronized修饰符，保护以下代码块串行执行。 public synchronized void method() &#123; System.out.println(Thread.currentThread().getName() + "对象锁的方法修饰符形式"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "执行结束"); &#125; public static void main(String[] args) throws InterruptedException &#123; // 建立两个线程，利用同一个实例，共用实例中的方法。 Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); // 启动两个线程 t1.start(); t2.start(); // 让主线程等待两个子线程都执行完成 while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("finished"); &#125;&#125; 以上代码线程 0 先执行，执行完成后线程 1 再执行。 ②类锁 Java 类可能有很多个对象，但是只有 1 个 Class 对象。 本质：所谓的类锁，就是 Class 对象的锁。 效果：类锁在同一时刻只能被一个对象拥有 类锁的两种形式： 静态锁 synchronized 加在 static 方法上 Class 对象 synchronized 代码块（锁对象默认为 Class 对象） 指定锁为 Class 对象 12345678910111213141516171819202122232425262728293031323334353637383940/** * @author: wjy * @date: 2020/2/19 * @description: 类锁示例1之静态锁 */public class SynchronizedClassLock1 implements Runnable &#123; static SynchronizedClassLock1 instance1 = new SynchronizedClassLock1(); static SynchronizedClassLock1 instance2 = new SynchronizedClassLock1(); @Override public void run() &#123; method(); &#125; // synchronized修饰符修饰静态方法 // 在全局情况下保护以下代码块串行执行(不是对象的层面) public static synchronized void method() &#123; System.out.println(Thread.currentThread().getName() + "开始运行"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "结束运行"); &#125; public static void main(String[] args) throws InterruptedException &#123; // 建立两个线程，两个线程分别引用同一个类的不同实例。 Thread t1 = new Thread(instance1); Thread t2 = new Thread(instance2); // 启动两个线程 t1.start(); t2.start(); // 让主线程等待两个子线程都执行完成 while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("finished"); &#125;&#125; 以上代码线程 0 先执行，执行完成后线程 1 再执行。 若是将 method() 方法变为非静态方法，此时就算加了 synchronized 关键字，线程 0 和线程 1 也会同时执行。 123456789101112131415161718192021222324252627282930313233343536373839/** * @author: wjy * @date: 2020/2/19 * @description: 类锁示例1之静态锁 */public class SynchronizedClassLock1 implements Runnable &#123; static SynchronizedClassLock1 instance1 = new SynchronizedClassLock1(); static SynchronizedClassLock1 instance2 = new SynchronizedClassLock1(); @Override public void run() &#123; method(); &#125; // synchronized修饰符修饰非静态方法 public synchronized void method() &#123; System.out.println(Thread.currentThread().getName() + "开始运行"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "结束运行"); &#125; public static void main(String[] args) throws InterruptedException &#123; // 建立两个线程，两个线程分别引用同一个类的不同实例 Thread t1 = new Thread(instance1); Thread t2 = new Thread(instance2); // 启动两个线程 t1.start(); t2.start(); // 让主线程等待两个子线程都执行完成 while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("finished"); &#125;&#125; 因为静态方法属于整个类，当多个线程（类的不同实例）访问这个类的静态方法时，实际访问的是同一个方法。所以给这个静态方法上锁之后，同一时刻只能由一个线程执行该方法。 而非静态方法属于调用它的实例对象，当两个线程分别调用其实例对象的非静态方法时，相当于各自执行自己的方法，这时加或不加锁都不影响各自方法的执行。 所以类锁适用于在全局情况下同步方法，而不仅仅在对象层面。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @author: wjy * @date: 2020/2/19 * @description: 类锁示例2之Class对象 */public class SynchronizedClassLock2 implements Runnable &#123; static SynchronizedClassLock2 instance1 = new SynchronizedClassLock2(); static SynchronizedClassLock2 instance2 = new SynchronizedClassLock2(); @Override public void run() &#123; method(); &#125; private void method() &#123; // 锁对象是SynchronizedClassLock2.class // 无论是类的哪个实例用的都是同一个锁对象(串行执行) synchronized (SynchronizedClassLock2.class) &#123; System.out.println(Thread.currentThread().getName() + "开始运行"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "结束运行"); &#125; &#125; public static void main(String[] args) &#123; // 建立两个线程，两个线程分别引用同一个类的不同实例 Thread t1 = new Thread(instance1); Thread t2 = new Thread(instance2); // 启动两个线程 t1.start(); t2.start(); // 让主线程等待两个子线程都执行完成 while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("finished"); &#125;&#125; 以上代码线程 0 先执行，执行完成后线程 1 再执行。 若是将 synchronized 代码块中的 SynchronizedClassLock2.class 改为 this，此时就算是加了 synchronized 关键字，线程 0 和线程 1 也会同时执行。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @author: wjy * @date: 2020/2/19 * @description: 类锁示例2之Class对象 */public class SynchronizedClassLock2 implements Runnable &#123; static SynchronizedClassLock2 instance1 = new SynchronizedClassLock2(); static SynchronizedClassLock2 instance2 = new SynchronizedClassLock2(); @Override public void run() &#123; method(); &#125; private void method() &#123; // 锁对象是this // 不同实例的锁对象不同，多个线程并行执行。 synchronized (this) &#123; System.out.println(Thread.currentThread().getName() + "开始运行"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "结束运行"); &#125; &#125; public static void main(String[] args) &#123; // 建立两个线程，两个线程分别引用同一个类的不同实例 Thread t1 = new Thread(instance1); Thread t2 = new Thread(instance2); // 启动两个线程 t1.start(); t2.start(); // 让主线程等待两个子线程都执行完成 while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("finished"); &#125;&#125; 原因：不同实例的锁对象不同，多个线程并行执行。 3.多线程访问同步方法的 7 种情况（面试常考） 同步方法：被 synchronized 关键字所修饰的方法非同步方法：没有被 synchronized 关键字所修饰的方法普通方法：指非静态方法 ①两个线程同时访问一个对象的同步方法 原因：两个线程属于同一个实例，所以两个线程访问的是同一个方法，而这个方法被 synchronized 关键字修饰后默认以 this 对象作为同步方法的锁，所以它们会争抢同一把锁。 结果：两个线程争抢同一把锁，同一时刻只能有一个线程执行该同步方法。 12345678910111213141516171819202122232425262728293031323334/** * @author: wjy * @date: 2020/2/20 * @description: 两个线程同时访问一个对象的同步方法 */public class Situation1 implements Runnable &#123; static Situation1 instance = new Situation1(); @Override public void run() &#123; method(); &#125; private synchronized void method() &#123; System.out.println(Thread.currentThread().getName() + "开始运行"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "结束运行"); &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); t1.start(); t2.start(); while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("Situation1.class finished"); &#125;&#125; ②两个线程访问的是两个对象的同步方法 原因：两个线程属于不同的实例，所以两个线程访问的是不同的方法，而每个方法被 synchronized 关键字修饰后默认以 this 对象作为同步方法的锁，所以它们的锁对象不是同一个。 结果：两个线程的锁对象不是同一个，并行执行，互不干扰。 1234567891011121314151617181920212223242526272829303132333435/** * @author: wjy * @date: 2020/2/20 * @description: 两个线程访问的是两个对象的同步方法 */public class Situation2 implements Runnable &#123; static Situation2 instance1 = new Situation2(); static Situation2 instance2 = new Situation2(); @Override public void run() &#123; method(); &#125; private synchronized void method() &#123; System.out.println(Thread.currentThread().getName() + "开始运行"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "结束运行"); &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(instance1); Thread t2 = new Thread(instance2); t1.start(); t2.start(); while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("Situation2.class finished"); &#125;&#125; ③两个线程访问的是 synchronized 的静态方法 原因：虽然两个线程属于类的不同实例，但是两个线程访问的方法是类的静态方法，即它们实际访问的是同一个方法。给这个静态方法上锁之后，同一时刻只能有一个线程执行该方法。 结果：两个线程争抢同一把锁，同一时刻只能有一个线程执行该同步方法。 1234567891011121314151617181920212223242526272829303132333435/** * @author: wjy * @date: 2020/2/20 * @description: 两个线程访问的是synchronized的静态方法 */public class Situation3 implements Runnable &#123; static Situation3 instance1 = new Situation3(); static Situation3 instance2 = new Situation3(); @Override public void run() &#123; method(); &#125; private static synchronized void method() &#123; System.out.println(Thread.currentThread().getName() + "开始运行"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "结束运行"); &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(instance1); Thread t2 = new Thread(instance2); t1.start(); t2.start(); while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("Situation3.class finished"); &#125;&#125; ④同时访问同步方法与非同步方法 原因：synchronized 关键字只作用于其指定的方法中，其他非同步方法不受到影响。 结果：当线程 0 访问同步方法，线程 1 访问非同步方法时，两个线程并行执行，互不干扰。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * @author: wjy * @date: 2020/2/20 * @description: 同时访问同步和非同步方法 */public class Situation4 implements Runnable &#123; static Situation4 instance = new Situation4(); @Override public void run() &#123; // 让线程0运行method1()方法，线程1运行method2()方法。 // 线程的默认名是从Thread-0(Thread-1、Thread-2、...)开始。 if (Thread.currentThread().getName().equals("Thread-0")) &#123; method1(); &#125; else &#123; method2(); &#125; &#125; public synchronized void method1() &#123; System.out.println(Thread.currentThread().getName() + "开始运行(加锁的方法)"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "结束运行(加锁的方法)"); &#125; public void method2() &#123; System.out.println(Thread.currentThread().getName() + "开始运行(没加锁的方法)"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "结束运行(没加锁的方法)"); &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); t1.start(); t2.start(); while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("Situation4.class finished"); &#125;&#125; ⑤同时访问一个类的不同的普通同步方法 原因：两个线程属于同一个实例，虽然两个线程访问的是一个类的不同的普通同步方法，但是被 synchronized 关键字修饰的普通方法默认都是以 this 对象作为同步方法的锁，所以它们会争抢同一把锁（对于同一个实例来讲，两个方法的 this 对象是同一个）。 结果：两个线程争抢同一把锁，同一时刻只能有一个线程执行该线程对应的同步方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @author: wjy * @date: 2020/2/20 * @description: 同时访问一个类的不同的普通同步方法 */public class Situation5 implements Runnable &#123; static Situation5 instance = new Situation5(); @Override public void run() &#123; if (Thread.currentThread().getName().equals("Thread-0")) &#123; method1(); &#125; else &#123; method2(); &#125; &#125; public synchronized void method1() &#123; System.out.println(Thread.currentThread().getName() + "开始运行(加锁的方法)"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "结束运行(加锁的方法)"); &#125; public synchronized void method2() &#123; System.out.println(Thread.currentThread().getName() + "开始运行(加锁的方法)"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "结束运行(加锁的方法)"); &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); t1.start(); t2.start(); while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("Situation5.class finished"); &#125;&#125; ⑥同时访问静态 synchronized 和非静态 synchronized 方法 原因： synchronized 关键字修饰静态方法：类锁，锁住的是 .class 对象。 synchronized 关键字修饰非静态方法：方法锁，锁住的是实例本身 this。 两个线程的锁对象不是同一个，所以两个线程可以同时运行。 结果：两个线程的锁对象不是同一个，并行执行，互不干扰。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @author: wjy * @date: 2020/2/20 * @description: 同时访问静态synchronized和非静态synchronized方法 */public class Situation6 implements Runnable &#123; static Situation6 instance = new Situation6(); @Override public void run() &#123; if (Thread.currentThread().getName().equals("Thread-0")) &#123; method1(); &#125; else &#123; method2(); &#125; &#125; public static synchronized void method1() &#123; System.out.println(Thread.currentThread().getName() + "开始运行(静态加锁的方法)"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "结束运行(静态加锁的方法)"); &#125; public synchronized void method2() &#123; System.out.println(Thread.currentThread().getName() + "开始运行(非静态加锁的方法)"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "结束运行(非静态加锁的方法)"); &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); t1.start(); t2.start(); while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("Situation6.class finished"); &#125;&#125; ⑦方法抛出异常后会释放锁 synchronized：方法抛出异常后会主动释放锁。 Lock 类：方法抛出异常后不会主动释放锁，必须显式地释放锁。 12345678910111213141516171819202122232425262728293031323334353637/** * @author: wjy * @date: 2020/2/20 * @description: 方法抛出异常后会释放锁 * 展示不抛出异常前和抛出异常后的对比: 一旦第一个线程抛出异常，第二个线程会立刻进入同步方法，意味着锁已经释放。 */public class Situation7 implements Runnable &#123; static Situation7 instance = new Situation7(); @Override public void run() &#123; method(); &#125; public synchronized void method() &#123; System.out.println(Thread.currentThread().getName() + "开始运行"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 方法抛出异常后，JVM帮我们释放了锁，不需要手动释放锁。 // 抛出运行时异常，不强制要求捕获。 throw new RuntimeException(); &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); t1.start(); t2.start(); while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("Situation7.class finished"); &#125;&#125; ⑧总结 一把锁只能同时被一个线程获取，没有拿到锁的线程必须等待（对应①、⑤）。 每个实例都对应有自己的一把锁，不同的实例之间对应不同的锁，所以不同的实例之间互不影响。 例外：锁对象是 .class 以及 synchronized 修饰的是 static 方法的时候，所有对象共用同一把类锁（对应②、③、④、⑥） 。 无论是方法正常执行完毕或者方法抛出异常，都会释放锁（对应⑦）。 在被 synchronized 修饰的方法中调用没有被 synchronized 修饰的方法时，不是线程安全的，因为没有被 synchronized 修饰的方法是可以被多个线程同时访问的。 4.性质①可重入性（递归锁） 这是它区别于其他锁的关键特点 可重入性：指的是同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁。 ReentrantLock 也是可重入锁 好处： 避免死锁（假设方法 1 和方法 2 都被 synchronized 关键字修饰，此时某线程执行方法 1 和方法 2 时都需要同一把锁。假如线程 A 执行了方法 1 并且获得了这把锁，此时方法 1 要想访问方法 2，假设 synchronized 关键字没有可重入性，相当于线程 A 没有方法 2 的锁，不能直接使用本身已经获得的锁。既想要拿到方法 2 的锁又不释放方法 1 的锁（方法 1 和方法 2 是同一把锁），就开始了永久等待，变成了死锁。） 提升封装性（避免一次次解锁、加锁，提高了封装性，简化了并发编程的难度。） 粒度：即范围，默认加锁的范围是线程而非调用。 情况1：访问同一个方法是可重入的 情况2：可重入不要求是同一个方法（即证明在一个同步方法中调用另一个同步方法是可行的） 情况3：可重入不要求是同一个类中的 以上三种情况证明了可重入的粒度不是调用范围的，而是线程范围的。所以在同一个线程中，如果已经拿到了一把锁，又想继续使用这把锁访问其他（类的）方法时，只要锁是同一把锁，就可以访问。 证明情况1：访问同一个方法是可重入的 12345678910111213141516171819202122/** * @author: wjy * @date: 2020/2/20 * @description: 可重入粒度测试1——递归调用本方法 */public class ReentrantGranularityTest1 &#123; int a = 0; private synchronized void method() &#123; System.out.println("a = " + a); if (a == 0) &#123; a++; // 调用方法本身 method(); &#125; &#125; public static void main(String[] args) &#123; ReentrantGranularityTest1 test1 = new ReentrantGranularityTest1(); test1.method(); &#125; &#125; 证明情况2：可重入不要求是同一个方法 1234567891011121314151617181920/** * @author: wjy * @date: 2020/2/20 * @description: 可重入粒度测试2——调用类内其他的方法 */public class ReentrantGranularityTest2 &#123; private synchronized void method1() &#123; System.out.println("我是方法一"); method2(); &#125; private synchronized void method2() &#123; System.out.println("我是方法二"); &#125; public static void main(String[] args) &#123; ReentrantGranularityTest2 test2 = new ReentrantGranularityTest2(); test2.method1(); &#125;&#125; 证明情况3：可重入不要求是同一个类中的 123456789101112131415161718192021222324252627282930313233343536373839/** * @author: wjy * @date: 2020/2/20 * @description: 可重入粒度测试3——父类 */public class ReentrantGranularityTest &#123; public synchronized void doSomething() &#123; System.out.println("我是父类方法"); &#125;&#125;/** * @author: wjy * @date: 2020/2/20 * @description: 可重入粒度测试3——调用父类的方法 */public class ReentrantGranularityTest3 extends ReentrantGranularityTest &#123; /** * 功能描述: 重写父类方法 * * @param: [] * @return: void * @auther: wjy * @date: 2020/2/20 22:30 */ @Override public synchronized void doSomething() &#123; System.out.println("我是子类方法"); // 调用父类方法 super.doSomething(); &#125; public static void main(String[] args) &#123; ReentrantGranularityTest3 test3 = new ReentrantGranularityTest3(); // 执行子类方法 test3.doSomething(); &#125;&#125; ②不可中断性 这个性质是 synchronized 关键字的劣势 不可中断性：一旦这个锁已经被别人获得了，如果我还想获取，我只能选择等待或者阻塞，直到别的线程释放这个锁。如果别人永远不释放锁，那么我只能永远等待下去。 而 Lock 类拥有可以中断的能力 如果我觉得我等待的时间太长了，有权中断现在已经获取到锁的那个线程的执行。 如果我觉得我等待的时间太长了不想再等了，也可以直接退出。 5.原理①加锁和释放锁的原理 每一个类的实例对应着一把锁，而每一个被 synchronized 关键字修饰的方法都必须首先获得调用该方法的类的实例的锁才能执行，否则线程就会阻塞。而方法一旦执行，就会独占这把锁，直到该方法返回或者抛出异常，才会将锁释放。释放之后，其他被阻塞的线程就能获得这把锁，重新进入到可执行的状态。 即当一个对象中有 synchronized 关键字修饰的方法或者代码块时，要想执行这段代码，就必须先获得对象锁。如果此对象的对象锁已经被其他调用者占用了，就必须等待它被释放。所有的 Java 对象都含有一个互斥锁，这个锁由 JVM 自动去获取和释放，我们只需要指定这个对象就可以了。 获取和释放锁的时机：内置锁 每个 Java 对象都可以用作一个实现同步的锁，这个锁被称为内置锁或监视器锁。线程在进入到同步代码块之前，会自动获得这个锁，并且在退出同步代码块的时候，会自动释放。 获得内置锁的唯一途径，就是进入到锁所保护的同步代码块或方法中。 下面用 Lock 模拟 synchronized 加锁和释放锁的时机： 1234567891011121314151617181920212223242526272829303132333435363738import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * @author: wjy * @date: 2020/2/23 * @description: 用lock模拟synchronized加锁和释放锁的时机 */public class LockAndUnlock &#123; Lock lock = new ReentrantLock(); public synchronized void method1() &#123; // 进入方法时隐形地获取一把锁 System.out.println("我是synchronized形式的锁"); // 退出方法时隐形地释放一把锁 &#125; public void method2() &#123; // 加锁 lock.lock(); try &#123; System.out.println("我是lock形式的锁"); &#125; finally &#123; // 释放锁 lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; // synchronized和lock在底层可以相互类比和配合 // method1方法和method2方法等价 // 将method1中synchronized锁住和解锁的时机用method2中拆分的形式表达 LockAndUnlock l = new LockAndUnlock(); l.method1(); l.method2(); &#125;&#125; ③反编译看 monitor 指令 synchronized 是如何工作的 synchronized 用的锁是 Java 对象头里的一个字段（每一个对象都有一个对象头，对象头可以存储很多信息，其中有一个部分就是用来存储 synchronize 关键字的锁的，表明是否被锁住。） 细节：当线程访问一个同步代码块时，必须要得到这把锁，退出整个代码块或者抛出异常的时候必须释放锁，而锁存储在 Java 对象头中。在 JVM 规范中对于 synchronized 的实现原理已经有了说明，它的进入锁和释放锁是基于 Moniter 对象来实现同步方法和同步代码块的。Monditor 对象主要有两个指令：Monditorenter（插入到同步代码块开始的位置）和 Monditorexit（插入到方法结束的时候和退出的时候）。JVM 规范保证每一个 enter 之后必须要有 exit 和它对应，但是可能有多个 exit 和同一个 enter 对应，因为退出的时机包括方法结束和抛出异常。每一个对象都有一个 Monditor 和它关联，并且一旦一个 Monditor 被持有后，就会处于锁定状态，当线程执行到 Monditorenter 指令时，会尝试获取这个对象对应的 Monditor 的所有权，也就是尝试获取这个对象锁。 编译：javac 类名.java 将 Java 类编译为 .class 文件 反编译：javap -verbose class文件名.class 将 .class 文件反编译为字节码文件 反编译结果： 详细解读 Monditorenter 和 Monditorexit 指令：Monditorenter 和 Monditorexit 指令在执行的时候会使对象的锁计数加 1 或者减 1。每一个对象都和一个 Monditor 相关联，一个 Moditor 的 lock 锁只能被一个线程在同一时间获得，一个线程在尝试获得与这个对象关联的 Monditor 的所有权的时候，只会发生以下三种情况之一（即 Monditorenter 指令的三种情况）： 成功获得锁：Monditor 计数器为 0，意味着目前还没有被获得，这个线程就会立刻获得，然后把计数器加 1，之后别人再想进来就会看到信号，知道它已经被其他线程所持有，所以加 1 意味着当前线程是这个 Moditor 的持有者。 已经拿到这把锁的所有权再次重入时：计数器随着重入次数的增加而增加（每次加 1）。 Monditor 已经被其他线程所持有了：当前线程再次获取就会得到现在无法获取的信号，就会进入阻塞状态，直到 Moditor 的计数器变为0，才会再次尝试获取这个锁。 Monditorexit：释放 Monditor 的所有权（可以将 Monditor 理解为锁） 前提是已经拥有了锁的所有权 释放的过程：将 Monditor 的计数器减 1，如果减完之后变成 0 就意味着当前线程不再拥有对 Monditor 的所有权，即解锁。如果减完之后不是 0，意味着刚才是可重入进来的，所以还是继续持有这把锁。最终计数器减到 0 之后，不仅意味着释放锁了，还意味着刚才被阻塞的线程会再次尝试获取对这把锁的所有权。 ③可重入原理 可重入性：一个线程拿到一把锁之后，如果还想再次进入由这把锁所控制的方法，可以直接进入。 可重入原理：利用加锁次数计数器 每个对象自动地含有一把锁，JVM 负责跟踪对象被加锁的次数。 线程第一次给对象加锁的时候，计数变为 1。每当这个相同的线程在此对象上再次获得锁时，计数递增。每当任务结束离开时，计数递减，当计数为 0 的时候，锁被完全释放。 ④可见性原理 保证可见性的原理：Java 内存模型 共享变量的副本：将主内存的变量复制一份，放在自己的本地内存。原因：加速程序的运行，因为线程所使用的内存速度比主存中的速度快。 两个线程要想互相通信-要怎么做：线程 A 将共享变量的副本写到主内存中，因为主内存是它们相互沟通的桥梁，然后线程 B 再去主内存中读取。 这个过程是 JMM（Java 内存模型的缩写）控制的，JMM 通过控制主内存与每个线程的本地内存的交互来提供内存可见性的保证。 synchronized 是如何做到可见性的实现的？ 一旦代码块或者方法被 synchronized 关键字所修饰，那么它在执行完毕之后，被锁住的对象所做的任何修改，都要在释放锁之前，从线程内存写回到主内存中（不会存在线程内存和主内存不一致的情况）。 同样，在进入代码块获得锁之后，被锁定对象的数据也是直接从主内存中读取出来的。 6.缺陷 效率低 锁的释放情况少：当一个线程获取到锁并在执行过程中，其他线程也想要获得该锁时，只能等待当前线程释放。而当前线程只有在两种情况下才会释放锁：①线程执行完该段代码、②执行过程中发生异常（JVM 将锁释放）。如果要等待 IO 这种耗时操作或者线程 sleep 时，不会主动释放锁，其他线程只能等待，非常影响程序执行的效率。这时需要一种机制，遏制这些情况。（Lock 类可以做到） 试图获得锁时不能设定超时时间，只能等待。（Lock 类可以做到） 不能中断一个正在试图获得锁的线程（Lock 类可以做到） 不够灵活（读写锁更灵活） 加锁和释放锁的时机单一，每个锁仅有单一的条件（某个对象）。锁住某个对象，某个对象就是这把锁。释放这个对象，才意味着解了这把锁。 无法知道是否成功获取到锁（Lock 类可以做到） 1234567891011121314151617181920212223242526272829import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * @author: wjy * @date: 2020/2/23 * @description: 展示Lock的方法 */public class LockExample &#123; public static void main(String[] args) &#123; Lock lock = new ReentrantLock(); // 通过这两个方法灵活得控制这把锁，且可以配置自定义的锁。 // 锁住 lock.lock(); // 释放锁 lock.unlock(); // 在规定的超时时间内等待获得锁。 try &#123; // 不设置超时时间的tryLock() lock.tryLock(); // 若是10s拿不到锁，会主动放弃。 lock.tryLock(10, TimeUnit.SECONDS); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 7.常见面试问题①synchronized 关键字有哪些使用注意点？ 锁对象不能为空 指定一个对象作为锁对象时，必须是一个实例对象被 new 过，或者使用其他方法创建好的，而不是空对象。这是因为锁的信息保存在对象头中的，如果对象都没有，就没有对象头，所以这个锁是不能工作的。 作用域不宜过大 将尽可能多的代码使用 synchronized 包裹，虽然会降低出并发问题的可能性（大部分线程都是串行工作），但是没有达到多线程编程的目的，影响程序执行的效率。 避免死锁 ②如何选择 Lock 和 synchronized 关键字？ 如果可以的话，两者都不要使用，应该使用 JUC 中的各种类（更方便，不容易出错）。 如果 synchronized 关键字在程序中适用，那么就优先使用（可以减少所需要编写的代码，也就减少了出错的几率）。 如果需要使用到 Lock 类独有的特性（如灵活的加解锁机制），再使用 Lock。 ③多线程访问同步方法的各种具体情况 具体见 3.多线程访问同步方法的 7 种情况 8.思考 多个线程等待同一个 synchronized 锁的时候，JVM 如何选择下一个获取锁的是哪个线程？ 有内部锁调度机制有关 持有锁的线程在运行完成或抛出异常后，就会释放这把锁。线程释放锁之后，竞争锁的对象有：等待中的线程、刚刚申请这把锁的线程。内部锁调度机制实现细节和 JVM 的版本、具体实现相关，不能依赖算法。 目前是处于随机的，不公平的状态。 synchronized 是非公平锁，ReentrantLock 可以设置是否是公平锁。 synchronized 使得同时只有一个线程可以执行，性能较差，有什么方法可以提升性能？ 优化使用范围（临界区在符合要求的情况下尽可能得小） 使用其他类型的锁（如读写锁） 自己实现 Lock 接口，自由设定锁持有时间 想灵活的控制锁的获取和释放怎么办（现在释放锁的时机都被规定死了）？ 自己实现一个锁 什么是锁的升级和降级？什么是 JVM 里的偏斜锁、轻量级锁、重量级锁？ 9.总结 一句话介绍 synchronized：JVM 会自动通过使用 monitor 来自动加锁和解锁，保证了同时只有一个线程可以执行指定代码，从而保证了线程安全，同时具有可重入和不可中断的性质。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#x79;&#x6d;&#x65;&#x73;&#x73;&#105;&#64;&#x31;&#54;&#51;&#x2e;&#99;&#111;&#x6d;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb相关软件安装包分享]]></title>
    <url>%2F2020%2F02%2F18%2FJavaWeb%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8C%85%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[1.Linux 版本（JavaWeb 程序） 链接：https://pan.baidu.com/s/1BHFbs0_sMzfBdQGIOCrQ-w 提取码：wvtt jdk-8u201-linux-x64.tar.gz apache-tomcat-8.5.39.tar.gz apache-maven-3.6.0-bin.tar.gz nginx-1.8.0.tar.gz redis-5.0.4.tar.gz 2.Windows 版本（JavaWeb 程序） 链接：https://pan.baidu.com/s/1H4o8uCxwYVn_x0wn7aNvpg 提取码：9h05 jdk-8u65-windows-x64.zip mysql-5.7.24-winx64.zip Redis-x64-3.0.504.msi gradle-5.2.1-all.zip elasticsearch-7.1.1-windows-x86_64.zip elasticsearch-head-master.zip 3.其他工具（Windows） 链接：https://pan.baidu.com/s/1LnO1znY4nlDuu8QvC957bQ 提取码：ihaf 谷歌访问助手_v2.3.0.crx（翻墙） Git-2.19.1-64-bit.exe GitHubDesktopSetup.exe redis-desktop-manager-0.8.8.384.exe Xftp.6.0.0105.v2.7z（Xftp.exe） Xshell.6.0.0111.v2.7z（Xshell.exe） notepad++.exe VMware-workstation-full-15.0.0-10134415.exe CentOS-7-x86_64-Minimal-1908.iso（CentOS 镜像 在 VMware 中使用） 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#x79;&#x6d;&#101;&#115;&#x73;&#105;&#64;&#49;&#x36;&#x33;&#46;&#99;&#x6f;&#x6d;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>资源分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八种排序算法的总结及性能分析]]></title>
    <url>%2F2020%2F02%2F12%2F%E5%85%AB%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%2F</url>
    <content type="text"></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat+Nginx配置HTTPS]]></title>
    <url>%2F2019%2F09%2F13%2FTomcat-Nginx%E9%85%8D%E7%BD%AEHTTPS%2F</url>
    <content type="text"><![CDATA[ps：每次修改配置后，需要重启 Nginx。命令：systemctl restart nginx。Nginx 的配置文件：/etc/nginx/nginx.conf。 1.相关博客 阿里云CentOS7安装Nginx Nginx之访问服务器静态资源 Nginx之rewrite配置域名跳转 2.准备SSL证书 在域名备案的前提下，我们需要购买 SSL 证书。一般情况下，购买免费版即可。 ①什么是SSL证书 ②准备过程 进入阿里云控制台 购买免费版 SSL 证书 然后在签发后下载 Nginx 服务器类型的证书并上传到服务器 3.具体配置①强制HTTPS（可选） 把 HTTP 的域名请求转成 HTTPS 123456server &#123; listen 80; server_name a.com; # 使用证书绑定的域名替换localhost return 301 https://$server_name$request_uri; # 返回301状态码进行跳转被Google认为是将网站地址由HTTP迁移到HTTPS的最佳方法&#125; ②开启HTTPS 12345678910111213141516171819202122server &#123; listen 443 ssl; # 监听433端口 server_name a.com; # 证书绑定的域名 ssl on; ssl_certificate /usr/local/javaweb/cert/2557101_a.com.pem; # 证书的文件名 ssl_certificate_key /usr/local/javaweb/cert/2557101_a.com.key; # 证书的密钥文件名 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; proxy_pass http://127.0.0.1:8080; # 对应tomcat的端口号 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Forwarded-Proto https; proxy_redirect off; proxy_connect_timeout 240; proxy_send_timeout 240; proxy_read_timeout 240; &#125;&#125; 配置成功 4.工作原理 浏览器发送的请求是发送到 Nginx 的，Nginx 作为代理服务器再转发到 Tomcat，浏览器和 Nginx 之间以 HTTPS 协议传输数据，而 Nginx 和 Tomcat 之间通过 proxy_pass 以 HTTP 协议传输数据。Nginx 是中间的代理服务器。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#106;&#121;&#109;&#x65;&#115;&#115;&#105;&#x40;&#49;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;]]></content>
      <categories>
        <category>Linux</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>Tomcat</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx之rewrite配置域名跳转]]></title>
    <url>%2F2019%2F09%2F12%2FNginx%E4%B9%8Brewrite%E9%85%8D%E7%BD%AE%E5%9F%9F%E5%90%8D%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[ps：每次修改配置后，需要重启 Nginx。命令：systemctl restart nginx。Nginx 的配置文件：/etc/nginx/nginx.conf。 1.相关博客 阿里云CentOS7安装Nginx Nginx之访问服务器静态资源 Tomcat+Nginx配置HTTPS 2.语法格式 rewrite 作用：将某个 URL 重写为特定的 URL 语法格式：rewrite（关键字） &lt;regex&gt;（正则表达式） &lt;replacement&gt;（替代内容） 根据 正则表达式 重定向到 replacement 3.对a域名的访问全部redirect到b域名 配置前 server 中不允许存在 location / { ... } 配置示例 123location / &#123; rewrite ^/(.*) http://1000.xidian.edu.cn/$1;&#125; 跳转前：http://a.com/index.php/Request/… 跳转后： 通过 location / 匹配所有以 / 开头的请求（即所有请求） rewrite 为固定关键字 regex 部分表示匹配完整的域名和之后的路径 replacement 部分中的 $1 取自 regex 部分 ( ) 中的内容 即 nginx 将 a.com/ 之后的路径拼接到了 http://1000.xidian.edu.cn/ 后 4.对a域名的不同访问redirect到不同域名①应用场景 同一个域名下的不同 URL 需要跳转到不同的域名下 ②示例一123location /xiaoyuan/ &#123; rewrite ^/xiaoyuan(.*) http://ehall.xidian.edu.cn$1;&#125; 跳转前：http://a.com/xiaoyuan/jwapp/sys/cjcx 跳转后： 通过 location /xiaoyuan/ 匹配所有以 /xiaoyuan/ 开头的请求 rewrite 为固定关键字 regex 部分表示匹配完整的域名和之后的路径 replacement 部分中的 $1 取自 regex 部分 ( ) 中的内容 即 nginx 将 a.com/xiaoyuan 之后的路径拼接到了 http://ehall.xidian.edu.cn 后 ③示例二123location /houqin/ &#123; rewrite ^/houqin(.*) http://1000.xidian.edu.cn$1;&#125; 跳转前：http://a.com/houqin/index.php/Request/... 跳转后： 通过 location /houqin/ 匹配所有以 /houqin/ 开头的请求 rewrite 为固定关键字 regex 部分表示匹配完整的域名和之后的路径 replacement 部分中的 $1 取自 regex 部分 ( ) 中的内容 即 nginx 将 a.com/houqin 之后的路径拼接到了 http://1000.xidian.edu.cn 后 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#121;&#109;&#x65;&#115;&#x73;&#x69;&#64;&#49;&#x36;&#x33;&#46;&#99;&#111;&#x6d;]]></content>
      <categories>
        <category>Linux</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx之访问服务器静态资源]]></title>
    <url>%2F2019%2F09%2F12%2FNginx%E4%B9%8B%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[ps：每次修改配置后，需要重启 Nginx。命令：systemctl restart nginx。Nginx 的配置文件：/etc/nginx/nginx.conf。 1.相关博客 阿里云CentOS7安装Nginx Tomcat+Nginx配置HTTPS Nginx之rewrite配置域名跳转 2.通过域名/文件名.文件类型的URL格式访问 应用场景：小程序业务域名的验证。 ①方法一 当 server 的配置中不存在 location / { ... } 时 配置示例 123456server &#123; listen 80 default_server; # 监听80端口 server_name localhost; # 可自定义域名 root /usr; # 注意：/usr为文件所在目录,可任意设置 # root /; # 当文件在根目录时如此配置&#125; ②方法二 当 server 的配置中存在 location / { ... } 时 配置示例 1234567在server中添加：location /文件名.文件类型 &#123; root /usr; # 注意：/usr为文件所在目录,可任意设置 # root /; # 当文件在根目录时如此配置 expires 30d; access_log off;&#125; 通过 /文件名.文件类型 匹配以 /文件名.文件类型 开头的请求 ③验证配置 3.通过域名/自定义/文件名.文件类型的URL格式访问 应用场景：搭建 Nginx 图片服务器。 配置示例 12345location /images/ &#123; root /usr/local/javaweb/xdxlb/; # 将/images/映射到/usr/local/javaweb/xdxlb/images/ autoindex on; # 打开浏览功能&#125; 通过 location /images/ 匹配所有以 /images/ 开头的请求 验证配置： 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#x79;&#x6d;&#101;&#115;&#x73;&#x69;&#64;&#49;&#54;&#x33;&#x2e;&#x63;&#x6f;&#x6d;]]></content>
      <categories>
        <category>Linux</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java发起HTTP请求的工具类]]></title>
    <url>%2F2019%2F08%2F15%2FJava%E5%8F%91%E8%B5%B7HTTP%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[ps：CloseableHttpClient 是 HttpClient 接口的实现类 1.发起GET请求①无参数的GET请求123456789101112/** * 功能描述: 无参数的GET请求 * * @param: [url] * @return: java.lang.String * @auther: wjy * @date: 2019/5/31 22:06 */public static String doGet(String url) &#123; return doGet(url, null);&#125; ②有参数的GET请求12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 功能描述: 有参数的GET请求 * * @param: [url, param] * @return: java.lang.String * @auther: wjy * @date: 2019/5/31 22:05 */ public static String doGet(String url, LinkedHashMap&lt;String, String&gt; param) &#123; // 创建HttpClient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); CloseableHttpResponse response = null; // GET请求的返回内容 String resultString = ""; try &#123; URIBuilder builder = new URIBuilder(url); // 设置请求参数 if (param != null) &#123; for (String key : param.keySet()) &#123; builder.addParameter(key, param.get(key)); &#125; &#125; // 构建一个URI对象 URI uri = builder.build(); // 创建GET请求 HttpGet httpGet = new HttpGet(uri); // 执行GET请求 response = httpClient.execute(httpGet); // 获取响应状态码 if (response.getStatusLine().getStatusCode() == 200) &#123; resultString = EntityUtils.toString(response.getEntity(), "UTF-8"); &#125; &#125; catch (URISyntaxException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; log.error("GET Method Catch Unexception Hanlder:&#123;&#125;, message:&#123;&#125;", e, e.getMessage()); throw new ServiceException(e.getMessage()); &#125; finally &#123; try &#123; if (response != null) &#123; response.close(); &#125; httpClient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return resultString; &#125; 2.发起POST请求①参数为Map对象的POST请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 功能描述: 有参数(Map对象)的POST请求 * * @param: [url, param] * @return: java.lang.String * @auther: wjy * @date: 2019/5/31 22:06 */ public static String doPost(String url, Map&lt;String, String&gt; param) &#123; // 创建HttpClient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); CloseableHttpResponse response = null; // POST请求的返回内容 String resultString = ""; try &#123; // 创建POST请求 HttpPost httpPost = new HttpPost(url); // 创建请求参数列表 if (param != null) &#123; List&lt;NameValuePair&gt; paramList = new ArrayList&lt;&gt;(); for (String key : param.keySet()) &#123; paramList.add(new BasicNameValuePair(key, param.get(key))); &#125; // 构造form表单式的实体 UrlEncodedFormEntity entity = new UrlEncodedFormEntity(paramList); httpPost.setEntity(entity); &#125; // 执行POST请求 response = httpClient.execute(httpPost); // 获取响应状态码 if (response.getStatusLine().getStatusCode() == 200) &#123; resultString = EntityUtils.toString(response.getEntity(), "UTF-8"); &#125; &#125; catch (IOException e) &#123; log.error("POST Method Catch Unexception Hanlder:&#123;&#125;, message:&#123;&#125;", e, e.getMessage()); throw new ServiceException(e.getMessage()); &#125; finally &#123; try &#123; if (response != null) &#123; response.close(); &#125; httpClient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return resultString; &#125; ②参数为JSON字符串的POST请求12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 功能描述: 有参数(Json字符串)的POST请求 * * @param: [url, jsonData] * @return: java.lang.String * @author: wjy * @date: 2019/6/25 17:39 */public static String doPost(String url, String jsonData) &#123; // 创建HttpClient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); CloseableHttpResponse response = null; // POST请求的返回内容 String resultString = ""; try &#123; // 创建POST请求 HttpPost httpPost = new HttpPost(url); // 解析Json数据并构造实体 StringEntity stringEntity = new StringEntity(jsonData, ContentType.APPLICATION_JSON); httpPost.setEntity(stringEntity); // 执行POST请求 response = httpClient.execute(httpPost); // 获取响应状态码 if (response.getStatusLine().getStatusCode() == 200) &#123; resultString = EntityUtils.toString(response.getEntity(), "UTF-8"); &#125; &#125; catch (IOException e) &#123; log.error("POST Method Catch Exception Handler:&#123;&#125;, message:&#123;&#125;", e, e.getMessage()); &#125; finally &#123; try &#123; if (response != null) &#123; response.close(); &#125; httpClient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return resultString;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#106;&#121;&#109;&#101;&#x73;&#115;&#x69;&#64;&#49;&#54;&#x33;&#x2e;&#x63;&#111;&#109;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb开发总结]]></title>
    <url>%2F2019%2F08%2F12%2FJavaWeb%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1.开发环境①开发必备 Java 版本：JDK8 Web 服务器：Tomcat9（运行后端）、Nginx（前端请求转发和搭建图片服务器） 工程框架：Spring Boot 2.0 操作数据库：Spring Boot Jpa（优先） / Mybatis 其他：Lombok 插件、JSON（fastjson / jackson） ②数据库 MySQL（主 db） Redis（处理缓存） MongoDB （特殊需求使用） ③编译器&amp;构建工具&amp;测试工具 IDEA maven（优先） / gradle Postman 2.框架分层①总览 common（公共包） enums（枚举类） exception（全局异常处理） interceptor（拦截器） jpa（jpa 配置） log（AOP 方式的日志埋点） utils（工具类） controller（控制层） model（DAO 层） dto（数据传输对象） entity（数据库实体类） repository / mapper（数据库操作层） service（服务层) base（基础服务） impl（业务服务实现类） resources（资源目录） application.yml（切换配置文件） application-dev.yml（本地配置文件） application-pro.yml （服务器配置文件） ②common层 ResultEnum 类：用于存放前端请求的响应 / 执行结果 注意枚举类定义格式 私有变量名不能定义为 name ③controller层 调用 service 层方法 提供对外暴露的接口 ④model层 ResultDTO 类：统一使用此类将数据封装好返回给前端 关于使用 DTO：从数据库中查出的是一个完整的对象，而大多数时候只会用到某些字段，这时候需要 DTO。 3.代码规范①注释 类注释（配置模板） 123456/** * @功能名称: HttpClient(举例) * @文件名称: HttpUtil.java(举例) * @Date: $date$ $time$ * @Author: 自定义 */ 方法注释（配置模板） 12345678/** * 功能描述: * * @param: $param$ * @return: $return$ * @auther: 自定义 * @date: $date$ $time$ */ 变量注释 123/** * 文字 */ 方法内注释 1// 文字 ②注解 自动装配用 @Autowired 注解 其 byType 注入 注解在字段上 @component：泛指组件 把普通 POJO 实例化到 spring 容器中 @Service：用于标注业务层组件 @RestController：用于标注控制层组件 @Repository：用于标注数据访问组件 即 DAO 组件 @RequestMapping(value = “/URI”)：标注控制层组件中的方法 @GetMapping(value = “/URI”)：标注控制层组件中的方法 @PostMapping(value = “/URI”)：标注控制层组件中的方法 @RequestParam：用于标注控制层组件的方法的参数 参数名与前端传来的必须吻合 若是不吻合 需要加 value = “…” 使参数名一一对应 ③配置文件 application.yml：总控制文件 可随时切换为本地 / 服务器的配置文件 便于开发 123spring: profiles: active: dev/pro application-dev.yml 12345678910111213141516171819202122232425262728293031323334353637383940server: port: 本地访问端口号spring: # MySQL数据库配置 datasource: driverClass: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/数据库名?characterEncoding=utf-8&amp;serverTimezone=GMT%2B8 username: root password: 自定义 # Redis配置 redis: database: 0 host: 127.0.0.1 port: 6379 password: 自定义 # MongoDB配置 data: mongodb: uri: mongodb://用户名:密码@localhost:27017/数据库名 # jpa配置 jpa: hibernate: # 在程序启动时更新实体类对应的表 ddl-auto: update # 在日志中打印出执行的SQL语句信息 show-sql: true naming: physical-strategy: org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy # mybatis配置 mybatis: type-aliases-package: 数据库实体类所在包 # 下划线自动转驼峰 configuration: map-underscore-to-camel-case: true use-generated-keys: true # jackson配置 jackson: serialization: indent-output: true application-pro.yml 123456789101112131415161718192021server: port: 服务器端口号spring: # MySQL数据库配置 datasource: driverClass: com.mysql.cj.jdbc.Driver url: jdbc:mysql://服务器公网ip:3306/数据库名?characterEncoding=utf-8&amp;serverTimezone=GMT%2B8&amp;useSSL=true username: root password: 自定义 # Redis配置 redis: database: 0 host: 服务器公网ip port: 6379 password: 自定义 # MongoDB配置 data: mongodb: uri: mongodb://用户名:密码@服务器ip:27017/数据库名 ...其他如上 ④pom.xml（maven）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MySQL --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- MongoDB --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- jpa --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- lombok插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- httpclient --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- maven插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- 解决项目启动bug --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; ⑤其他 将私有常量值单独定义在类的开头 公有常量值定义在公有枚举类中 工具类一般不需要被注入或构造 只包含普通的类方法 所有需要注入的类，都应该放到 Service 目录下 除 db 对象外 尽量使用全参构造对象 尽量消除魔法值 可使用枚举类封装 遵循《阿里巴巴Java代码开发规范》进行开发 4.安装插件 安装插件：Settings —&gt; Plugins —&gt; Marketplace —&gt; 查找所需插件 —&gt; Install 查看安装的所有插件： 安装后需要重启 IDEA ①Lombok 以简单的注解形式来简化 Java 代码，提高开发人员的开发效率。 @Getter：注解在类上 为类提供 get 方法 @Setter：注解在类上 为类提供 set 方法 @Data：注解在类上 为类提供读写属性 此外还提供了equals()、hashCode()、toString() 方法 @AllArgsConstructor：注解在类上 为类提供一个全参的构造方法 @NoArgsConstructor：注解在类上 为类提供一个无参的构造方法 @Slf4j：注解在类上 为类提供一个属性名为 log 的 log4j 日志对象 @Slf4j 相当于 private static final Logger log = LoggerFactory.getLogger(CategoryServiceImpl.class); ②Alibaba Java Coding Guidelines 阿里巴巴 Java 代码规约检测 使用插件： ③Grep Console 可以将不同级别的日志通过颜色区分，便于查看。 配置各级日志的颜色： 5.前后端交互①交互流程1.通过原型图确定产品功能（明确每个细节）2.后端撰写 API 文档及建表3.前后端按照 API 文档各自开发4.测试 ②API文档 ShowDoc 举例： ③RESTful API 后端撰写请求 URL 时 必须遵守 RESTful API 设计规范 举例： 6.关于团队协作（git） GitHub 客户端每次只能 commit 一个文件，不利于版本回滚和团队协作，所以尽量使用 git 命令行。 ①git同步流程 一般开发完成、但还没有测试的文件都会被提交到暂存区 将暂存区的文件（测试好的）提交到本地仓库 通过 git push 提交修改到远程仓库 ②git常用命令 git add 文件名：将本地某个文件添加到暂存区 git add *：将本地所有文件添加到暂存区 git commit -m “本次提交说明（自定义）”：将暂存区文件提交到本地仓库 git push -u origin master：使用本地 master 分支来更新远程 master 分支（远程仓库） git reset HEAD 文件名（将暂存区的内容还原为最后一次提交的内容） git checkout – 文件名（将工作区的内容还原为最后一次提交的内容） git tag -a name -m “comment”：新建标签并指定提交信息 git tag -d name：删除标签 git branch：查看当前所有分支 git branch name：创建分支 git checkout name：进入分支 通过两种方式克隆仓库： Clone with SSH：git clone git@github.com:messi1002/leetcode.git Clone with HTTPS：git clone https://github.com/messi1002/leetcode.git ③git高级操作 git stash save “注释”：将工作区和暂存区的新内容暂时保存在栈中 git stash list：显示缓存堆栈中的内容 git stash pop：将缓存堆栈中的第一个 stash 内容恢复到工作区后删除 git commit –amend：将缓存区的内容补充到上次 commit 并可以修改上次 commit 的描述（用来修复最近一次 commit） git rebase -i [startpoint] [endpoint]：每一个功能开发完成后 对多个 commit 进行合并处理（变基） 123[startpoint] 和 [endpoint] 指定了一个编辑区间，前开后闭。如果不指定 [endpoint]，则该区间的终点默认是当前分支 HEAD 所指向的 commit。进入编辑页面后，按照指令说明修改指令即可。 7.入门博客汇总 StringUtils用法+StringUtils详细介绍 Java 枚举类Enum的用法总结 Spring Boot 中 Redis 的使用 如何使用RedisTemplate访问Redis数据结构 Spring Boot中使用Redis数据库 Spring Boot中快速操作Mongodb Spring Boot 中 MongoDB 的使用 Spring Boot Jpa 的使用 如何优雅的使用 Mybatis MyBatis中Like语句使用方式 Java 开发工具–Lombok 介绍 Spring Boot中Jackson应用详解 JSON框架之阿里fastjson的介绍 RESTful API 设计规范 Git—版本控制工具 Git教程 上传图片到七牛云（前端和后端） 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#x6a;&#121;&#x6d;&#101;&#x73;&#x73;&#105;&#64;&#x31;&#x36;&#51;&#x2e;&#99;&#111;&#x6d;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Docker入门]]></title>
    <url>%2F2019%2F07%2F20%2FDocker%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云CentOS7安装Docker]]></title>
    <url>%2F2019%2F07%2F18%2F%E9%98%BF%E9%87%8C%E4%BA%91CentOS7%E5%AE%89%E8%A3%85Docker%2F</url>
    <content type="text"></content>
      <categories>
        <category>Linux</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用GoLand创建go工程]]></title>
    <url>%2F2019%2F07%2F12%2F%E4%BD%BF%E7%94%A8GoLand%E5%88%9B%E5%BB%BAgo%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1.准备工作 下载 JetBrains GoLand 配置 go 的开发环境 2.hello go 代码1234567package mainimport "fmt"func main() &#123; fmt.Println("你好")&#125; 3.创建 go 工程 新建工程、选择 GOROOT 路径 创建目录结构、创建 hello.go 文件 bin：包含生成的执行文件 pkg：包含编译的中间文件 src：包含程序的代码文件 配置全局路径和项目路径 配置并运行 hello.go 文件 4.命令行中运行 go 文件(windows) go run 文件名.go：编译一个或多个以 .go 结尾的源文件，链接库文件并运行最终生成的可执行文件 go build 文件名.go：生成一个可执行的二进制文件 文件名.exe：运行生成的文件 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#x79;&#109;&#101;&#x73;&#115;&#105;&#64;&#x31;&#54;&#51;&#46;&#x63;&#111;&#109;]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis入门]]></title>
    <url>%2F2019%2F06%2F06%2FRedis%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为春招面经2020届JavaWeb]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%8D%8E%E4%B8%BA%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F2020%E5%B1%8AJavaWeb%2F</url>
    <content type="text"><![CDATA[1.投递职位 华为 2020 届勇敢星实习—通用软件开发工程师 年龄：大二(非大三) 时间：2019 年 地点：华为西研所 华为校招官网 2.我的招聘流程3.29 投递简历 ——&gt; 4.2 性格测试 ——&gt; 4.3 线上笔试 ——&gt; 4.20 面试 ——&gt; 4.25 收到 offer ——&gt; 5.6 签约 3.性格测试 华为比较重视这个，最好认真做完。可以在网上查查技巧，反正我是挂了(⊙o⊙)…。 4.笔试①题目分析 华为的笔试题都是基础的编程题，比较简单。总共有三道题，分值分别为 100、200、300，难度递增。第一题重点考察输入与输出， 第二题重点考察对语言类库的运用，第三题重点考察数据结构与算法。注意：最好在笔试后仔细研究研究未 AC 的题，面试官可能会问。 ②练习网址 牛客网：https://www.nowcoder.com/ta/huawei ③我的笔试 当时我 AC 了第一题和第二题(300 分)，由于第三题涉及到的算法还没有学习过，故放弃。不过只要拿 100 分，就能得到面试机会。 5.一面(35min)①面试问题 自我介绍 对华为的了解 为什么来华为实习 笔试中未做出的题 三道算法题 做项目遇到的困难 对软件工程的了解 对”好代码”的理解 ②面试技巧 面试前最好了解一下企业文化及其业务方向。 面试官很看重应聘者解决问题的能力，即面对一个完全陌生的问题，应聘者能将之快速理解并想出求解方法。 在解决算法题的时候，最好先从最基础的求解方法开始分析，逐步优化并且分析每种解法的复杂度和优缺点(系统原理、安全漏洞等)。 如果实在想不出求解方法，也要尽可能地想出一个大概思路，最好别卡壳。如果面试时很紧张，会非常非常影响思路！所以一定要放松！！ 底层知识一定要重视！要将学过的知识点充分理解！ 注意：思考面试官问你的题目之间是否有关联，也许这是一个很好的解题突破点。 6.二面(20min)①面试问题 自我介绍 对 996 的看法 为什么跨专业学习 职业规划 关于读研 想在华为学到什么 项目介绍 英语能力及课内成绩 瞎聊… ②面试体验 一面结束后，排队等待二面，二面相对比较轻松。因为我是跨专业自学 CS，所以面试官一直逮着这点问，emmm。然后就会和你聊聊家庭情况、未来规划、学习情况等。 7.等待结果 面试完成后官网会更新 应聘进展 我的状态码： 状态码：6、1 性格测试貌似挂了 但没有被安排重测 面试考核 下无小字： but 5 天后就收到 offer 啦 纪念收到的第一个 offer！ 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#121;&#109;&#x65;&#115;&#x73;&#105;&#64;&#x31;&#54;&#x33;&#46;&#99;&#111;&#x6d;]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 172. 阶乘后的零（Easy）C语言题解]]></title>
    <url>%2F2019%2F05%2F05%2FLeetCode-172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6%EF%BC%88Easy%EF%BC%89C%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.题目相关①题目及示例 ②相关标签 数学 ③题目地址 172. 阶乘后的零 — 力扣网 2.解题方法①暴力解法（超时） 思路：已知 2 * 5 = 10，所以尾数中零的数量只与 2 和 5 有关 。由此可知，我们只需要关注 N! 中作为乘法因子的 2 的数量和 5 的数量，最后计算 count(2) &lt; count(5)? count(2): count(5) 即可。 深入分析 1：2 的数量一定比 5 的数量多，所以只需要考虑 5 的数量（即统计小于或等于 N 的 5 的倍数们能拆分成多少个 5）。 ②数学规律 深入分析 2：通过观察 5 的倍数（5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 105 110 115 120 125 ……），可以发现对于 N! 的乘积因子来说，每隔 5 个数出现一个 5，每隔 25 个数出现两个 5，每隔 125 个数出现三个 5，以此类推，每隔 5^i 个数出现 i 个 5，最终 5 的个数就是 N / 5 + N / 25 + N / 125 + ...。 时间复杂度：O(log n) 空间复杂度：O(1) 3.代码详解①暴力解法（超时）123456789101112int trailingZeroes(int n)&#123; int count = 0; // 计算i的乘法因子中有几个5 for (int i = 5; i &lt;= n; i += 5) &#123; int j = i; while (j % 5 == 0) &#123; j /= 5; count += 1; &#125; &#125; return count;&#125; ②数学规律12345678int trailingZeroes(int n)&#123; int count = 0; while (n &gt; 0) &#123; count += n / 5; n /= 5; &#125; return count;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#x79;&#x6d;&#101;&#x73;&#115;&#x69;&#x40;&#x31;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#x6d; 关于 数据结构与算法 的更多代码 请查看我的 GitHub仓库]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>LeetCode-C</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 172. 阶乘后的零（Easy）Java语言题解]]></title>
    <url>%2F2019%2F05%2F05%2FLeetCode-172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6%EF%BC%88Easy%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.题目相关①题目及示例 ②相关标签 数学 ③题目地址 172. 阶乘后的零 — 力扣网 2.解题方法①暴力解法（超时） 思路：已知 2 * 5 = 10，所以尾数中零的数量只与 2 和 5 有关 。由此可知，我们只需要关注 N! 中作为乘法因子的 2 的数量和 5 的数量，最后计算 Math.min(count(2), count(5)) 即可。 深入分析 1：2 的数量一定比 5 的数量多，所以只需要考虑 5 的数量（即统计小于或等于 N 的 5 的倍数们能拆分成多少个 5）。 ②数学规律 深入分析 2：通过观察 5 的倍数（5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 105 110 115 120 125 ……），可以发现对于 N! 的乘积因子来说，每隔 5 个数出现一个 5，每隔 25 个数出现两个 5，每隔 125 个数出现三个 5，以此类推，每隔 5^i 个数出现 i 个 5，最终 5 的个数就是 N / 5 + N / 25 + N / 125 + ...。 时间复杂度：O(log n) 空间复杂度：O(1) 3.代码详解①暴力解法（超时）123456789101112public int trailingZeroes(int n) &#123; int count = 0; // 计算i的乘法因子中有几个5 for (int i = 5; i &lt;= n; i += 5) &#123; int j = i; while (j % 5 == 0) &#123; j /= 5; count += 1; &#125; &#125; return count;&#125; ②数学规律12345678public int trailingZeroes(int n) &#123; int count = 0; while (n &gt; 0) &#123; count += n / 5; n /= 5; &#125; return count;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#121;&#109;&#101;&#x73;&#115;&#x69;&#x40;&#x31;&#x36;&#x33;&#x2e;&#99;&#x6f;&#x6d; 关于 数据结构与算法 的更多代码 请查看我的 GitHub仓库]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>LeetCode-Java</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云CentOS7安装Nginx]]></title>
    <url>%2F2019%2F05%2F01%2F%E9%98%BF%E9%87%8C%E4%BA%91CentOS7%E5%AE%89%E8%A3%85Nginx%2F</url>
    <content type="text"><![CDATA[1.准备工作①添加安全组规则 服务器的安全组默认未设置任何自定义放行规则，这将会导致无法访问实例端口，若需访问需要添加安全组规则放行对应的端口。 放行 80 端口 ②设置防火墙 防火墙是系统的第一道防线，其作用是防止非法用户的进入。服务器的防火墙默认未设置任何自定义放行规则，这将会导致无法访问实例端口，若需访问需要防火墙放行对应的端口。注意：CentOS7 默认使用 firewalld 作为防火墙。 firewalld 默认是关闭 http 服务的。 1234567891011firewall-cmd --state # 查看防火墙状态systemctl start firewalld.service # 开启防火墙systemctl stop firewalld.service # 关闭防火墙systemctl enable firewalld.service # 打开防火墙的开机自启systemctl disable firewalld.service # 关闭防火墙的开机自启firewall-cmd --permanent --zone=public --add-port=80/tcp # 让防火墙永久开放80端口firewall-cmd --reload # 加载配置 使得修改有效firewall-cmd --permanent --zone=public --list-ports # 查看开放的端口号firewall-cmd --permanent --zone=public --add-service=http # 让防火墙永久打开http服务firewall-cmd --reload # 加载配置 使得修改有效firewall-cmd --permanent --zone=public --list-service # 查看开放的服务 2.yum安装Nginx Nginx 是一个高性能的 HTTP 和反向代理服务器。 ①下载和安装123rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm # 将nginx添加到yum源的repo中yum repolist # 查看yum源的repoyum install nginx # yum源安装nginx ②启动1234systemctl enable nginx # 设置开机启动systemctl start nginx # 启动nginxsystemctl reload nginx # 重新加载nginxsystemctl status nginx # 查看nginx启动状态 ③验证配置 访问 公网ip:80 如果出现上图内容 说明配置成功 ④安装后的目录结构1234567查看刚安装的所有目录：rpm -ql nginx启动nginx：/usr/sbin/nginx主配置文件：/etc/nginx/nginx.conf 首页的html网页所在路径：/usr/share/nginx/html缓存目录：/var/cache/nginx/fastcgi_temp代理目录：/var/cache/nginx/proxy_temp... 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#x79;&#109;&#x65;&#x73;&#115;&#x69;&#x40;&#49;&#54;&#x33;&#46;&#x63;&#x6f;&#x6d;]]></content>
      <categories>
        <category>Linux</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云CentOS7安装 jdk8+tomcat8+maven+MySQL5.7+redis5]]></title>
    <url>%2F2019%2F04%2F27%2F%E9%98%BF%E9%87%8C%E4%BA%91CentOS7%E5%AE%89%E8%A3%85-jdk8-tomcat8-maven-MySQL5-7-redis5%2F</url>
    <content type="text"><![CDATA[1.我的服务器配置 2.准备工作①下载压缩包 下载 jdk8：https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 下载 tomcat8：https://tomcat.apache.org/download-80.cgi 下载 maven：http://maven.apache.org/download.cgi 下载 redis5：https://redis.io/download ②下载 Xftp6 Xftp6 是一款功能强大，主要用于 SFTP、FTP 文件传输的软件，能够帮助用户安全地在 UNIX/Linux 和 Windows PC 之间传输文件。我们需要使用此软件，将压缩包上传至阿里云服务器。 请自行搜索安装包 下载并安装 ③添加安全组规则 服务器的安全组默认未设置任何自定义放行规则，这将会导致无法访问实例端口，若需访问需要添加安全组规则放行对应的端口。 我们需要放行常用的端口号：8080、3306、22、6379 等 添加安全组规则： ④上传压缩包至服务器 打开 Xftp6 工具 点击 文件 – 新建 按下图填写信息并连接服务器 然后在 /usr/local/ 目录下新建 javaweb 文件夹 将压缩包上传到此文件夹中 ⑤设置防火墙 防火墙是系统的第一道防线，其作用是防止非法用户的进入。服务器的防火墙默认未设置任何自定义放行规则，这将会导致无法访问实例端口，若需访问需要防火墙放行对应的端口。注意：CentOS7 默认使用 firewalld 作为防火墙。 1234567891011firewall-cmd --state # 查看防火墙状态systemctl start firewalld.service # 开启防火墙systemctl stop firewalld.service # 关闭防火墙systemctl enable firewalld.service # 打开防火墙的开机自启systemctl disable firewalld.service # 关闭防火墙的开机自启firewall-cmd --permanent --zone=public --add-port=8080/tcp # 让防火墙永久开放8080端口firewall-cmd --permanent --zone=public --add-port=3306/tcp # 让防火墙永久开放3306端口firewall-cmd --permanent --zone=public --add-port=22/tcp # 让防火墙永久开放22端口firewall-cmd --permanent --zone=public --add-port=6379/tcp # 让防火墙永久开放6379端口firewall-cmd --reload # 加载配置 使得修改有效firewall-cmd --permanent --zone=public --list-ports # 查看开放的端口号 3.安装 jdk8 注意：若服务器版本是 CentOS7 系列，尽量不要安装系统自带的 openJDK (会有坑)！ ①解压安装包123cd /usr/local/javaweb # 进入该目录tar -zxvf jdk-8u201-linux-x64.tar.gz # 解压压缩包mv jdk1.8.0_201 jdk8 # 重命名文件夹 ②配置环境 使用 vim 命令打开文件 1vim /etc/profile # 配置环境变量 然后按 i 进入编辑模式 插入以下文字 123export JAVA_HOME=/usr/local/javaweb/jdk8 # jdk所在位置的绝对路径export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin 最后按 Esc 并输入 :wq 回车退出 1source /etc/profile # 使脚本文件生效 ③验证配置12javacjava -version 如果出现上图内容 说明配置成功 4.安装 tomcat8①解压安装包123cd /usr/local/javaweb # 进入该目录tar -zxvf apache-tomcat-8.5.39.tar.gz # 解压压缩包mv apache-tomcat-8.5.39 tomcat8 # 重命名文件夹 ②启动 tomcat812cd /usr/local/javaweb/tomcat8/bin # 进入该目录./startup.sh # 启动tomcat ③验证配置 访问 公网ip:8080 如果出现上图内容 说明配置成功 5.安装 maven①解压安装包123cd /usr/local/javaweb # 进入该目录tar -zxvf apache-maven-3.6.0-bin.tar.gz # 解压压缩包mv apache-maven-3.6.0 maven3 # 重命名文件夹 ②配置环境 使用 vim 命令打开文件 1vim /etc/profile.d/maven.sh # 配置环境变量 然后按 i 进入编辑模式 插入以下内容 123#!/bin/bashexport M2_HOME=/usr/local/javaweb/maven3 # maven所在位置的绝对路径export PATH=$PATH:$M2_HOME/bin 最后按 Esc 并输入 :wq 回车退出 1source /etc/profile.d/maven.sh # 使脚本文件生效 ③验证配置1mvn -v # 查看maven版本 如果出现上图内容 说明配置成功 6.安装 MySQL5.7①下载和安装12345rpm -ivh http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm # 下载安装包yum install -y mysql-server # 安装MySQLsystemctl enable mysqld.service # 设置开机自启动MySQLsystemctl start mysqld.service # 启动MySQLgrep &apos;temporary password&apos; /var/log/mysqld.log # 查看MySQL默认密码 ②登录 MySQL123mysql -uroot -p # 登录MySQL 然后输入默认密码(系统自动生成)SET PASSWORD = PASSWORD(&apos;Zxcvbnm10!_&apos;); # 修改默认密码 新密码必须包含大小写字母、数字、下划线和感叹号eixt # 退出MySQL 用新密码重新登录 ps：如果觉得新密码太复杂，可以修改以下两个字段来降低默认的密码安全级别。 12set global validate_password_policy=0; 设置密码安全级别为LOWset global validate_password_length=6; 设置密码最短长度为6 ③远程连接12GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;新密码&apos; WITH GRANT OPTION; # 开启root用户的远程访问权限flush privileges; # 使命令执行生效 使用 Navicat 远程访问数据库 连接后可以通过 Navicat 管理远程数据库 7.安装 redis5①解压安装包123cd /usr/local/javaweb # 进入该目录tar -zxvf redis-5.0.4.tar.gz # 解压压缩包mv redis-5.0.4 redis5 # 重命名文件夹 ②配置环境1234567cd /usr/local/javaweb/redis5 # 进入解压后的目录make # 编译mkdir -p /usr/local/javaweb/redis # 新创建目录存储rediscp /usr/local/javaweb/redis5/src/redis-server /usr/local/javaweb/redis/ # 复制redis-server到新目录cp /usr/local/javaweb/redis5/src/redis-cli /usr/local/javaweb/redis/ # 复制redis-cli到新目录cp /usr/local/javaweb/redis5/redis.conf /usr/local/javaweb/redis/ # 复制redis.conf到新目录cd /usr/local/javaweb/redis/ # 进入新目录 使用 vim 命令打开文件 1vim /usr/local/javaweb/redis/redis.conf # 编辑配置文件 然后按 i 进入编辑模式 编辑以下字段 1234bind 127.0.0.1 ——&gt; # bind 127.0.0.1 # 将此行注释掉protected-mode yes ——&gt; protected-mode nodaemonize no ——&gt; daemonize yes# requirepass foobared ——&gt; requirepass 123456 # 设置密码为123456 最后按 Esc 并输入 :wq 回车退出 使用 vim 命令打开文件 1vim /etc/init.d/redis #编辑redis开机启动脚本 然后按 i 进入编辑模式 插入以下文字 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/bin/sh # chkconfig: 2345 80 90 # description: Start and Stop redis #PATH=/usr/local/bin:/sbin:/usr/bin:/bin REDISPORT=6379 EXEC=/usr/local/javaweb/redis/redis-server REDIS_CLI=/usr/local/javaweb/redis/redis-cli PIDFILE=/var/run/redis_6379.pid CONF=&quot;/usr/local/javaweb/redis/redis.conf&quot; AUTH=&quot;123456&quot;case &quot;$1&quot; in start) if [ -f $PIDFILE ] then echo &quot;$PIDFILE exists, process is already running or crashed&quot; else echo &quot;Starting Redis server...&quot; $EXEC $CONF fi if [ &quot;$?&quot;=&quot;0&quot; ] then echo &quot;Redis is running...&quot; fi ;; stop) if [ ! -f $PIDFILE ] then echo &quot;$PIDFILE does not exist, process is not running&quot; else PID=$(cat $PIDFILE) echo &quot;Stopping ...&quot; $REDIS_CLI -p $REDISPORT SHUTDOWN while [ -x $&#123;PIDFILE&#125; ] do echo &quot;Waiting for Redis to shutdown ...&quot; sleep 1 done echo &quot;Redis stopped&quot; fi ;; restart|force-reload) $&#123;0&#125; stop $&#123;0&#125; start ;; *) echo &quot;Usage: /etc/init.d/redis &#123;start|stop|restart|force-reload&#125;&quot; &gt;&amp;2 exit 1esac 最后按 Esc 并输入 :wq 回车退出 使用 vim 命令打开文件 1vim /etc/rc.local # 添加开机启动服务 然后按 i 进入编辑模式 插入以下文字 1service redis start 最后按 Esc 并输入 :wq 回车退出 ③登录 redis12345678910chmod 755 /etc/init.d/redis # 设置权限chkconfig --add redis # 注册系统服务service redis start # 启动redis服务ps -ef|grep redis # 查看当前状态ln -s /usr/local/javaweb/redis/redis-cli /usr/bin/redis # 创建redis命令软连接cd /redis # 进入redisauth 123456 # 密码验证set name wiy # 增加用户get name ④验证配置 如果上图命令没有报错 说明配置成功 ⑤远程连接 使用 Redis Desktop Manager 远程访问数据库 连接后可以通过 Redis Desktop Manager 管理远程数据库 ⑥参考博客 https://blog.csdn.net/lc1010078424/article/details/78295482 8.部署 Springboot 项目①打包项目123本地命令行中: cd 项目根目录 # 进入该目录mvn package # 将项目打包 ②上传 jar 包 使用 Xftp6 工具上传 jar 包至服务器 ③运行 jar 包 方式一：在当前窗口运行 12cd /usr/local/javaweb/springboot # 进入该目录java -jar luckymoney-0.0.1-SNAPSHOT.jar # 运行此jar包 方式二：使 jar 包一直处于后台运行 123cd /usr/local/javaweb/springboot # 进入该目录nohup java -jar luckymoney-0.0.1-SNAPSHOT.jar &amp; # 运行此jar包cat nohup.out # 此文件存放控制台的实时输出内容 ④验证配置 如上图内容 我们成功地访问了这个 springboot 项目 间接说明了配置的正确性！ Ctrl + v：停止运行项目 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#106;&#x79;&#109;&#101;&#x73;&#115;&#105;&#x40;&#49;&#x36;&#x33;&#46;&#99;&#111;&#109;]]></content>
      <categories>
        <category>Linux</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在命令行中使用SSH免密登录服务器]]></title>
    <url>%2F2019%2F04%2F25%2F%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E4%BD%BF%E7%94%A8SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1.生成公钥和私钥 打开命令行 输入 ssh-keygen -t rsa 然后连续按三个回车(第一个回车表示不重命名文件 第二、三个回车表示不设置密码) 最后在 C 盘找到生成的公钥和私钥 2.将公钥写入服务器 ps：需要服务器的防火墙放行 22 端口。 在命令行使用密码登录服务器 将生成的公匙内容粘贴到 authorized_keys 文件中 退出服务器 重新连接时 不用输入密码即可登录！ 3.解决WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! 重置服务器之后再配置 SSH 连接时 会报这个错误：远程主机标识已更改！ 这时需要将电脑上的旧连接信息删除（根据服务器IP） 删除后重新连接即可 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#121;&#109;&#x65;&#x73;&#115;&#x69;&#64;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#109;]]></content>
      <categories>
        <category>Linux</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[域名解析到服务器]]></title>
    <url>%2F2019%2F04%2F14%2F%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1.域名与服务器 域名是网站的入口，是 IP 的别名，便于记忆而存在，域名最终会通过 DNS 解析成 IP 地址。所以将域名解析到服务器后，域名 == 服务器 IP(一样的作用)！ 2.域名解析到服务器①域名解析 登录阿里云 打开 控制台-域名 选择域名 点击 解析 点击 添加记录 解析类型为 A-将域名解析到服务器 ②验证解析 验证网址：17CE 选择 Dns 并输入域名 如果画圈处的 IP 地址正确 说明解析成功 ps：解析成功后，使用 www.域名/域名 均可代替服务器 IP。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#x79;&#x6d;&#x65;&#115;&#115;&#105;&#64;&#x31;&#54;&#51;&#x2e;&#99;&#111;&#x6d;]]></content>
      <categories>
        <category>Linux</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10 + Ubuntu 18.04 双系统安装]]></title>
    <url>%2F2019%2F04%2F06%2Fwin10-Ubuntu-18-04-%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[1.准备工作①下载 Ubuntu 18.04.2 LTS 官网地址：https://www.ubuntu.com/download/desktop ②下载 Rufus Rufus 是 Ubuntu 官网推荐的 USB 启动盘制作工具。 官网地址：https://rufus.ie/ 或者我的网盘分享：https://pan.baidu.com/s/1uWUmyNQuupPJIp2YDhKDgg，提取码：fwea。 ③制作 Ubuntu 18.04 U盘启动 打开下载好的 Rufus 并将空U盘插入电脑，点击 选择，添加 Ubuntu 18.04.2 LTS。 其他设置如图所示，点击 开始 后，一直选择 OK 即可。 按照上图设置后，软件会把 ubuntu-18.04.2-desktop-amd64.iso 文件写入U盘，制作系统启动盘。 写入完成，点击 关闭。 刻录完成后的U盘内部： ④关闭 win10 的快速启动 关闭快速启动：https://jingyan.baidu.com/article/ca00d56c7a40e6e99febcf4f.html#!/article/ca00d56c7a40e6e99febcf4f ⑤磁盘分区 使用快捷键 win + x + Ctrl + k 打开 win10 的 磁盘管理 选择剩余空间较大的可分配磁盘，点击 右键 并选择 压缩卷，压缩 50~80 G。 压缩成功： 2.安装过程①BIOS 设置 重启电脑，按 F12。 进入 BIOS 设置后，如下图操作。 然后插入U盘，保存设置并退出，电脑会自动重启。 继续按 F12，选择如何启动电脑。 ②进入 Ubuntu 每次选择空闲设备中内存最大的设备——用于设置分区(四个分区)。| /：存储系统文件。| swap：交换分区。| /boot：包含系统内核和系统启动文件。| /home：存放文件。 然后将剩余空间全部用于创建 home 分区| 类型：逻辑分区。| 用于：Ext4 日志文件系统。| 挂载点：/home。 分区效果图： 最后设置时区、注册账号、重启电脑，即可完成安装。 3.问题总结①系统时间不同步 修改 Linux 系统时间： 123456# 安装ntpdate。sudo apt-get install ntpdate# 校准时间。sudo ntpdate time.windows.com# 将时间更新到硬件上。sudo hwclock --localtime --systohc 修改 win 系统时间：https://jingyan.baidu.com/article/60ccbcebbb041b64cab19730.html ②WIFI 无法开启 如图：优先级较前的 ideapad_wlan 的 Hard blocked 默认为 yes，说明 Ubuntu 默认关闭了硬件 wifi 开关，我们需要将这个模块移除，以便使用序号 3 模块(wifi 开关是打开的)。 注意：每次重启 Ubuntu 系统都要重新将第一个模块移除。 ③Linux 无法关机/重启 进入 软件和更新，选择 附加驱动，安装 NVDIA 专用驱动即可。 ④分区详解 https://blog.csdn.net/cl_cjh/article/details/69396906 ⑤误删 win10 引导 用快启动 pe 修复 win10 系统引导：https://blog.csdn.net/jessical1020/article/details/72933056 4.参考博客 安装教程：https://blog.csdn.net/lipengfei0427/article/details/83116527http://tieba.baidu.com/p/5276785632 更改系统时间：https://blog.csdn.net/hansion3333/article/details/60469583 WIFI 无法开启：https://www.linuxidc.com/Linux/2015-04/116077.htm 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#x6a;&#121;&#x6d;&#x65;&#x73;&#115;&#x69;&#x40;&#49;&#54;&#51;&#x2e;&#99;&#x6f;&#x6d;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树的常用操作]]></title>
    <url>%2F2019%2F02%2F15%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1.相关博客二分查找法代码实现二叉树的定义及性质树的遍历（递归加迭代） 注意：示例代码中的 TreeNode 对象和结构体定义如下： 123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 12345struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right;&#125; 2.简介 二叉搜索树 不仅可以查找数据，还可以高效地插入、删除数据（即动态维护数据）。 堆的二叉树一定是完全二叉树，所以用数组表示很方便。而二叉搜索树不一定是完全二叉树，所以不好用数组表示，通常使用引用的方式表示二叉搜索树节点间的关系。 二叉搜索树中的问题：求最小值、最大值、查找一个节点的前驱节点和后继节点，实现 floor、ceil 和 rank 函数、以及支持插入重复节点值的二叉搜索树该如何实现。 二叉搜索树的局限性：可能退化成链表，此时二叉搜索树的高度为 n ，时间复杂度退化为 O(n)，还不如顺序查找表（原因：顺序查找表不用递归实现且不需要每次访问两个指针）。它不能像堆一样保证所有的操作一定是 O(logn) 级别的。 平衡二叉树：改进二叉树的实现，使之不能退化成链表。 平衡二叉树最著名的实现：红黑树 其他平衡二叉树的实现：SBT 树、AVL 树、Splay 树 平衡二叉树和堆的结合：Treap 树形问题：归并排序、快速排序、搜索树（八皇后） 3.查找最大值或最小值 返回以 root 为根节点的二叉搜索树中的最大（小）节点 Java 12345678910111213141516171819public TreeNode findMax(TreeNode root) &#123; if (root == null) &#123; return null; &#125; if (root.right == null) &#123; return root; &#125; return findMax(root.right);&#125;public TreeNode findMin(TreeNode root) &#123; if (root == null) &#123; return null; &#125; if (root.left == null) &#123; return root; &#125; return findMin(root.left);&#125; 返回以 root 为根节点的二叉搜索树中的最大 （小）节点的节点值 C 12345678910111213int findMax(struct TreeNode* root) &#123; if (!root-&gt;right) &#123; return root-&gt;val; &#125; return findMax(root-&gt;right);&#125;int findMin(struct TreeNode* root) &#123; if (!root-&gt;left) &#123; return root-&gt;val; &#125; return findMin(root-&gt;left);&#125; 4.删除最大值或最小值 删除以 root 为根节点的二叉搜索树中的最大（小）节点，返回删除最大（小）节点后新的二叉搜索树的根。 删除最大值：向右走到头，若它是叶子节点则直接删除，若它有左子树，则将左子树赋给其父亲节点（最大值所在的节点只可能有左孩子） 删除最小值：向左走到头，若它是叶子节点则直接删除，若它有右子树，则将右子树赋给其父亲节点（最小值所在的节点只可能有右孩子） Java 123456789101112131415public TreeNode removeMax(TreeNode root) &#123; if (root.right == null) &#123; return root.left; &#125; root.right = removeMax(root.right); return root;&#125;public TreeNode removeMin(TreeNode root) &#123; if (root.left == null) &#123; return root.right; &#125; root.left = removeMin(root.left); return root;&#125; C 123456789101112131415struct TreeNode* removeMax(struct TreeNode* root) &#123; if (!root-&gt;right) &#123; return root-&gt;left; &#125; root-&gt;right = removeMax(root-&gt;right); return root;&#125;struct TreeNode* removeMin(struct TreeNode* root) &#123; if (!root-&gt;left) &#123; return root-&gt;right; &#125; root-&gt;left = removeMin(root-&gt;left); return root;&#125; 5.二叉搜索树中的搜索 查找节点的过程： 和当前节点值相等，则直接返回 小于当前节点值，在左子树中查找 大于当前节点值，在右子树中查找 Java 12345678910111213141516171819202122232425262728293031// 1.尾递归public TreeNode searchBST(TreeNode root, int val) &#123; if (root == null) &#123; return null; &#125; if (val == root.val) &#123; return root; &#125; else if (val &lt; root.val) &#123; return searchBST(root.left, val); &#125; else &#123; return searchBST(root.right, val); &#125;&#125;// 2.迭代public TreeNode searchBST(TreeNode root, int val) &#123; while (root != null) &#123; if (val == root.val) &#123; return root; &#125; else if (val &lt; root.val) &#123; root = root.left; &#125; else &#123; root = root.right; &#125; &#125; return null;&#125; C 12345678910111213141516171819202122232425262728293031// 1.尾递归struct TreeNode* searchBST(struct TreeNode* root, int val) &#123; if (!root) &#123; return NULL; &#125; if (val == root-&gt;val) &#123; return root; &#125; else if (val &lt; root-&gt;val) &#123; return searchBST(root-&gt;left, val); &#125; else &#123; return searchBST(root-&gt;right, val); &#125;&#125;// 2.迭代struct TreeNode* searchBST(struct TreeNode* root, int val) &#123; while (root) &#123; if (val == root-&gt;val) &#123; return root; &#125; else if (val &lt; root-&gt;val) &#123; root = root-&gt;left; &#125; else &#123; root = root-&gt;right; &#125; &#125; return NULL;&#125; 6.二叉搜索树中的遍历操作 因为二叉搜索树也是一种二叉树，所以它的遍历操作与二叉树的遍历操作相同。 具体见：树的遍历（递归加迭代） 7.二叉搜索树中的插入操作 插入新节点的过程： 和当前节点值相等，则直接返回（假设这种情况不存在） 小于当前节点值，在左子树中插入 大于当前节点值，在右子树中插入 Java 1234567891011121314151617181920212223242526272829303132333435363738// 1.尾递归public TreeNode insertIntoBST(TreeNode root, int val) &#123; // 找到插入位置 if (root == null) &#123; return new TreeNode(val); &#125; if (val &lt; root.val) &#123; root.left = insertIntoBST(root.left, val); &#125; else &#123; root.right = insertIntoBST(root.right, val); &#125; return root;&#125;// 2.迭代public TreeNode insertIntoBST(TreeNode root, int val) &#123; TreeNode node = root; while (node != null) &#123; if (val &lt; node.val) &#123; // 找到插入位置 if (node.left == null) &#123; node.left = new TreeNode(val); break; &#125; node = node.left; &#125; else &#123; // 找到插入位置 if (node.right == null) &#123; node.right = new TreeNode(val); break; &#125; node = node.right; &#125; &#125; return root;&#125; C 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 1.尾递归struct TreeNode* insertIntoBST(struct TreeNode* root, int val) &#123; // 找到插入位置 if (!root) &#123; struct TreeNode* node = malloc(sizeof(struct TreeNode)); node-&gt;val = val; node-&gt;left = NULL; node-&gt;right = NULL; return node; &#125; if (val &lt; root-&gt;val) &#123; root-&gt;left = insertIntoBST(root-&gt;left, val); &#125; else &#123; root-&gt;right = insertIntoBST(root-&gt;right, val); &#125; return root;&#125;// 2.迭代struct TreeNode* insertIntoBST(struct TreeNode* root, int val) &#123; struct TreeNode* t = root; while (t) &#123; if (val &lt; t-&gt;val) &#123; // 找到插入位置 if (!t-&gt;left) &#123; struct TreeNode* node = malloc(sizeof(struct TreeNode)); node-&gt;val = val; node-&gt;left = NULL; node-&gt;right = NULL; t-&gt;left = node; break; &#125; t = t-&gt;left; &#125; else &#123; // 找到插入位置 if (!t-&gt;right) &#123; struct TreeNode* node = malloc(sizeof(struct TreeNode)); node-&gt;val = val; node-&gt;left = NULL; node-&gt;right = NULL; t-&gt;right = node; break; &#125; t = t-&gt;right; &#125; &#125; return root;&#125; 8.删除二叉搜索树中的节点 分析： 删除只有一个孩子的节点：直接将孩子赋给其父节点 删除有两个孩子的节点：找到其右子树中的最小值代替该节点（即该节点的后继节点）或找到其左子树中的最大值代替该节点（即该节点的前驱节点）。 具体做法：先创建一个新节点（值是其后继节点或前驱节点的节点值），再把被删除节点的后继节点或前驱节点在原位置删除，最后将被删除节点的左右子树分别赋值给该新节点。 删除二叉搜索树中任意一个节点的时间复杂度为 O(logn) Java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// 1.用被删除节点的前驱节点(是其左子树中的最大值所在的节点)替换被删除的节点// 返回以root为根节点的二分搜索树中的最大节点public TreeNode findMax(TreeNode root) &#123; if (root == null) &#123; return null; &#125; if (root.right == null) &#123; return root; &#125; return findMax(root.right);&#125;public TreeNode deleteNode(TreeNode root, int key) &#123; if (root == null) &#123; return null; &#125; if (key &lt; root.val) &#123; root.left = deleteNode(root.left, key); &#125; else if (key &gt; root.val) &#123; root.right = deleteNode(root.right, key); &#125; else &#123; if (root.left == null) &#123; return root.right; &#125; else if (root.right == null) &#123; return root.left; &#125; else &#123; // 此时root是被删除的节点 // maxNode(node)是被删除节点的前驱节点 TreeNode maxNode = findMax(root.left); // 将被删除节点的前驱节点放在被删除节点的位置 TreeNode node = new TreeNode(maxNode.val); // 删除原来的前驱节点 node.left = deleteNode(root.left, maxNode.val); node.right = root.right; return node; &#125; &#125; return root;&#125;// 2.用被删除节点的后继节点(是其右子树中的最小值所在的节点)替换被删除的节点// 返回以root为根节点的二分搜索树中的最小节点public TreeNode findMin(TreeNode root) &#123; if (root == null) &#123; return null; &#125; if (root.left == null) &#123; return root; &#125; return findMin(root.left);&#125;public TreeNode deleteNode(TreeNode root, int key) &#123; if (root == null) &#123; return null; &#125; if (key &lt; root.val) &#123; root.left = deleteNode(root.left, key); &#125; else if (key &gt; root.val) &#123; root.right = deleteNode(root.right, key); &#125; else &#123; if (root.left == null) &#123; return root.right; &#125; else if (root.right == null) &#123; return root.left; &#125; else &#123; // 此时root是被删除的节点 // minNode(node)是被删除节点的后继节点 TreeNode minNode = findMin(root.right); // 将被删除节点的后继节点放在被删除节点的位置 TreeNode node = new TreeNode(minNode.val); node.left = root.left; // 删除原来的后继节点 node.right = deleteNode(root.right, minNode.val); return node; &#125; &#125; return root;&#125; 具体做法：先将被删除节点的节点值改为其后继节点或前驱节点的节点值，再把被删除节点的后继节点或前驱节点在原位置删除。 C 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 1.用被删除节点的前驱节点(是其左子树中的最大值所在的节点)替换被删除的节点// 返回以root为根节点的二分搜索树中的最大节点int findMax(struct TreeNode* root) &#123; if (!root-&gt;right) &#123; return root-&gt;val; &#125; return findMax(root-&gt;right);&#125;struct TreeNode* deleteNode(struct TreeNode* root, int key) &#123; if (!root) &#123; return NULL; &#125; if (key &lt; root-&gt;val) &#123; root-&gt;left = deleteNode(root-&gt;left, key); &#125; else if (key &gt; root-&gt;val) &#123; root-&gt;right = deleteNode(root-&gt;right, key); &#125; else &#123; if (!root-&gt;left) &#123; return root-&gt;right; &#125; else if (!root-&gt;right) &#123; return root-&gt;left; &#125; else &#123; // 此时root是被删除的节点 // max是被删除节点的前驱节点的值 int max = findMax(root-&gt;left); // 将被删除节点的前驱节点放在被删除节点的位置 root-&gt;val = max; // 删除原来的前驱节点 root-&gt;left = deleteNode(root-&gt;left, max); root-&gt;right = root-&gt;right; &#125; &#125; return root;&#125;// 2.用被删除节点的后继节点(是其右子树中的最小值所在的节点)替换被删除的节点// 返回以root为根节点的二分搜索树中的最小节点int findMin(struct TreeNode* root) &#123; if (!root-&gt;left) &#123; return root-&gt;val; &#125; return findMin(root-&gt;left);&#125;struct TreeNode* deleteNode(struct TreeNode* root, int key) &#123; if (!root) &#123; return NULL; &#125; if (key &lt; root-&gt;val) &#123; root-&gt;left = deleteNode(root-&gt;left, key); &#125; else if (key &gt; root-&gt;val) &#123; root-&gt;right = deleteNode(root-&gt;right, key); &#125; else &#123; if (!root-&gt;left) &#123; return root-&gt;right; &#125; else if (!root-&gt;right) &#123; return root-&gt;left; &#125; else &#123; // 此时root是被删除的节点 // min是被删除节点的后继节点的值 int min = findMin(root-&gt;right); // 将被删除节点的后继节点放在被删除节点的位置 root-&gt;val = min; // 删除原来的后继节点 root-&gt;left = root-&gt;left; root-&gt;right = deleteNode(root-&gt;right, min); &#125; &#125; return root;&#125; 9.二叉搜索树的第 k 大节点 Java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 1.中序遍历二叉搜索树得到升序数列，再找到第k大节点的值。private List&lt;Integer&gt; list;private void inorderTraversal(TreeNode root) &#123; if (root == null) &#123; return; &#125; inorderTraversal(root.left); list.add(root.val); inorderTraversal(root.right);&#125;public int kthLargest(TreeNode root, int k) &#123; list = new ArrayList&lt;&gt;(); inorderTraversal(root); return list.get(list.size() - k);&#125;// 2.优化: 对于升序数组来说，第k小节点值易求，第k大节点值不易求。// 所以逆中序遍历二叉搜索树得到降序数列，当遍历到第k个值时，即得第k大节点值，结束递归。private int k;private int k_number;private void inorderTraversal(TreeNode root) &#123; if (root == null) &#123; return; &#125; inorderTraversal(root.right); if (--k == 0) &#123; k_number = root.val; return; &#125; inorderTraversal(root.left);&#125;public int kthLargest(TreeNode root, int k) &#123; this.k = k; inorderTraversal(root); return k_number;&#125;// 3.迭代(逆中序遍历)public int kthLargest(TreeNode root, int k) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); int count = 0; while (!stack.isEmpty() || root != null) &#123; // 遇到一个节点，就把它压入栈中，并去遍历它的右子树。 while (root != null) &#123; stack.push(root); root = root.right; &#125; // 当右子树遍历结束后，弹出栈顶元素并访问它。 if (!stack.isEmpty()) &#123; root = stack.pop(); if (++count == k) &#123; return root.val; &#125; // 再去中序遍历该节点的左子树 root = root.left; &#125; &#125; return -1;&#125; C 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// 1.中序遍历二叉搜索树得到升序数列，再找到第k大节点的值。void orderTraversal(struct TreeNode* root, int* returnSize, int* arr) &#123; if (!root) &#123; return; &#125; orderTraversal(root-&gt;left, returnSize, arr); arr[(*returnSize)++] = root-&gt;val; orderTraversal(root-&gt;right, returnSize, arr); &#125;// 统计结点数int makeSize(struct TreeNode* root) &#123; if (!root) &#123; return 0; &#125; return makeSize(root-&gt;left) + makeSize(root-&gt;right) + 1;&#125;int kthLargest(struct TreeNode* root, int k)&#123; int size = makeSize(root); int* arr = (int*)malloc(sizeof(int) * size); int* returnSize = (int*)malloc(sizeof(int)); *returnSize = 0; orderTraversal(root, returnSize, arr); return arr[size - k];&#125;// 2.优化: 对于升序数组来说，第k小节点值易求，第k大节点值不易求。// 所以逆中序遍历二叉搜索树得到降序数列，当遍历到第k个值时，即得第k大节点值，结束递归。void orderTraversal(struct TreeNode* root, int* returnSize, int* arr, int k, int* k_number) &#123; if (!root) &#123; return; &#125; orderTraversal(root-&gt;right, returnSize, arr, k, k_number); if (++(*returnSize) == k) &#123; *k_number = root-&gt;val; &#125; orderTraversal(root-&gt;left, returnSize, arr, k, k_number);&#125;// 统计结点数int makeSize(struct TreeNode* root) &#123; if (!root) &#123; return 0; &#125; return makeSize(root-&gt;left) + makeSize(root-&gt;right) + 1;&#125;int kthLargest(struct TreeNode* root, int k)&#123; int size = makeSize(root); int* arr = (int*)malloc(sizeof(int) * size); int* returnSize = (int*)malloc(sizeof(int)); int* k_number = (int*)malloc(sizeof(int)); *returnSize = 0; *k_number = 0; orderTraversal(root, returnSize, arr, k, k_number); return *k_number;&#125;// 3.迭代(逆中序遍历)// 统计结点数int makeSize(struct TreeNode* root) &#123; if (!root) return 0; return makeSize(root-&gt;left) + makeSize(root-&gt;right) + 1;&#125;typedef struct &#123; struct TreeNode** array; int top;&#125; Stack;int kthLargest(struct TreeNode* root, int k)&#123; int size = makeSize(root); int* arr = (int*)malloc(sizeof(int) * size); Stack* s = (Stack*)malloc(sizeof(Stack)); s-&gt;array = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * size); s-&gt;top = -1; int count = 0; while (s-&gt;top != -1 || root) &#123; // 遇到一个节点，就把它压入栈中，并去遍历它的右子树。 while (root) &#123; s-&gt;array[++s-&gt;top] = root; root = root-&gt;right; &#125; // 当右子树遍历结束后，弹出栈顶元素并访问它。 if (s-&gt;top != -1) &#123; root = s-&gt;array[s-&gt;top--]; if (++count == k) &#123; return root-&gt;val; &#125; // 再去中序遍历该节点的左子树 root = root-&gt;left; &#125; &#125; return -1;&#125; 10.二叉搜索树的范围和 Java 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 明确题意: 求出所有满足 节点值&gt;=L且节点值&lt;=R 的节点的值的和// 1.递归解法public int rangeSumBST(TreeNode root, int L, int R) &#123; if (root == null) &#123; return 0; &#125; if (root.val &lt; L) &#123; // root.val&lt;L，说明其左子树所有的值都小于L，排除这些节点。 return rangeSumBST(root.right, L, R); &#125; else if (root.val &gt; R) &#123; // root.val&gt;R，说明其右子树所有的值都大于R，排除这些节点。 return rangeSumBST(root.left, L, R); &#125; else &#123; return root.val + rangeSumBST(root.right, L, R) + rangeSumBST(root.left, L, R); &#125;&#125;// 2.迭代public int rangeSumBST(TreeNode root, int L, int R) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); int sum = 0; stack.push(root); while (!stack.isEmpty()) &#123; TreeNode node = stack.pop(); if (node != null) &#123; // root.val&lt;L，说明其左子树所有的值都小于L，排除这些节点。 if (node.val &lt; L) &#123; stack.push(node.right); &#125; // root.val&gt;R，说明其右子树所有的值都大于R，排除这些节点。 else if (node.val &gt; R) &#123; stack.push(node.left); &#125; else &#123; sum += node.val; stack.push(node.left); stack.push(node.right); &#125; &#125; &#125; return sum;&#125; C 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 明确题意: 求出所有满足 节点值&gt;=L且节点值&lt;=R 的节点的值的和// 1.递归解法int rangeSumBST(struct TreeNode* root, int L, int R) &#123; if (!root) &#123; return 0; &#125; if (root-&gt;val &lt; L) &#123; // root.val&lt;L，说明其左子树所有的值都小于L，排除这些节点。 return rangeSumBST(root-&gt;right, L, R); &#125; else if (root-&gt;val &gt; R) &#123; // root.val&gt;R，说明其右子树所有的值都大于R，排除这些节点。 return rangeSumBST(root-&gt;left, L, R); &#125; else &#123; return root-&gt;val + rangeSumBST(root-&gt;left, L, R) + rangeSumBST(root-&gt;right, L, R); &#125;&#125;// 2.迭代// 统计结点数int makeSize(struct TreeNode* root) &#123; if (!root) return 0; return makeSize(root-&gt;left) + makeSize(root-&gt;right) + 1;&#125;typedef struct &#123; struct TreeNode** array; int top;&#125; Stack;int rangeSumBST(struct TreeNode* root, int L, int R) &#123; int size = makeSize(root), sum = 0; Stack* s = (Stack*)malloc(sizeof(Stack)); s-&gt;array = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * size); s-&gt;top = -1; s-&gt;array[++s-&gt;top] = root; while (s-&gt;top != -1) &#123; struct TreeNode* node = s-&gt;array[s-&gt;top--]; if (node) &#123; // root.val&lt;L，说明其左子树所有的值都小于L，排除这些节点。 if (node-&gt;val &lt; L) &#123; s-&gt;array[++s-&gt;top] = node-&gt;right; &#125; // root.val&gt;R，说明其右子树所有的值都大于R，排除这些节点。 else if (node-&gt;val &gt; R) &#123; s-&gt;array[++s-&gt;top] = node-&gt;left; &#125; else &#123; sum += node-&gt;val; s-&gt;array[++s-&gt;top] = node-&gt;left; s-&gt;array[++s-&gt;top] = node-&gt;right; &#125; &#125; &#125; return sum;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#106;&#x79;&#x6d;&#x65;&#x73;&#x73;&#x69;&#x40;&#49;&#x36;&#x33;&#46;&#99;&#x6f;&#x6d; 关于 数据结构与算法 的更多代码 请查看我的 GitHub仓库]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的遍历(递归+迭代)]]></title>
    <url>%2F2019%2F02%2F11%2F%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E9%80%92%E5%BD%92-%E8%BF%AD%E4%BB%A3%2F</url>
    <content type="text"><![CDATA[1.相关博客因为二叉树这种数据结构本身天然的就具有递归的结构，所以面对二叉树问题，使用递归方法解决通常比较简单。 二叉树的定义及性质二叉搜索树的常用操作 注意：示例代码中的 TreeNode 对象、Node 对象和结构体定义如下： 123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415public class Node &#123; public int val; public List&lt;Node&gt; children; public Node() &#123;&#125; public Node(int _val) &#123; val = _val; &#125; public Node(int _val, List&lt;Node&gt; _children) &#123; val = _val; children = _children; &#125;&#125;; 12345struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right;&#125; 2.树的前序遍历 前序遍历也称为先序遍历 遍历过程为： ①访问根结点 ②先序遍历其左子树 ③先序遍历其右子树 举例： 下图的先序遍历结果为：1、2、3、4、5、6、7、8、9。 ①二叉树-递归 Java 12345678910111213141516171819202122class Solution &#123; // 递归函数定义: 前序遍历以root节点为根节点的二叉树 private void traversal(TreeNode root, List list) &#123; // 递归终止条件 if (root == null) &#123; return; &#125; // 递归过程 // 处理当前节点 list.add(root.val); // 前序遍历root节点的左子树 traversal(root.left, list); // 前序遍历root节点的右子树 traversal(root.right, list); &#125; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); traversal(root, list); return list; &#125;&#125; C 12345678910111213141516171819202122232425262728293031// 递归函数，returnSize、arr是指针，动态修改。// 递归函数定义: 前序遍历以root节点为根节点的二叉树void orderTraversal(struct TreeNode* root, int* returnSize, int* arr) &#123; // 递归终止条件 if (!root) &#123; return; &#125; // 递归过程 // 处理当前节点 arr[(*returnSize)++] = root-&gt;val; // 前序遍历root节点的左子树 orderTraversal(root-&gt;left, returnSize, arr); // 前序遍历root节点的右子树 orderTraversal(root-&gt;right, returnSize, arr); &#125;// 统计结点数int makeSize(struct TreeNode* root) &#123; if (!root) &#123; return 0; &#125; return makeSize(root-&gt;left) + makeSize(root-&gt;right) + 1;&#125;int* preorderTraversal(struct TreeNode* root, int* returnSize) &#123; int size = makeSize(root); int* arr = (int*)malloc(sizeof(int) * size); *returnSize = 0; orderTraversal(root, returnSize, arr); return arr;&#125; ②二叉树-迭代 遇到一个节点就访问它，然后把它压入栈中，并去遍历它的左子树。当左子树遍历结束后，弹出栈顶元素，再去先序遍历该节点的右子树。 Java 123456789101112131415161718192021class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (!stack.isEmpty() || root != null) &#123; // 遇到一个节点就访问它，然后把它压入栈中，并去遍历它的左子树。 while (root != null) &#123; list.add(root.val); stack.push(root); root = root.left; &#125; // 当左子树遍历结束后，弹出栈顶元素。 if (!stack.isEmpty()) &#123; root = stack.pop(); // 再去先序遍历该节点的右子树 root = root.right; &#125; &#125; return list; &#125;&#125; C 123456789101112131415161718192021222324252627282930313233343536// 统计结点数int makeSize(struct TreeNode* root) &#123; if (!root) return 0; return makeSize(root-&gt;left) + makeSize(root-&gt;right) + 1;&#125;typedef struct &#123; struct TreeNode** array; int top;&#125; Stack;int* preorderTraversal(struct TreeNode* root, int* returnSize) &#123; int size = makeSize(root); int* arr = (int*)malloc(sizeof(int) * size); *returnSize = 0; Stack* s = (Stack*)malloc(sizeof(Stack)); s-&gt;array = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * size); s-&gt;top = -1; while (s-&gt;top != -1 || root) &#123; // 遇到一个节点就访问它，然后把它压入栈中，并去遍历它的左子树。 while (root) &#123; arr[(*returnSize)++] = root-&gt;val; s-&gt;array[++s-&gt;top] = root; root = root-&gt;left; &#125; // 当左子树遍历结束后，弹出栈顶元素。 if (s-&gt;top != -1) &#123; root = s-&gt;array[s-&gt;top--]; // 再去先序遍历该节点的右子树 root = root-&gt;right; &#125; &#125; return arr;&#125; ③N叉树-递归 Java 123456789101112131415161718192021class Solution &#123; // 递归函数定义: 前序遍历以root节点为根节点的N叉树 private void traversal(Node root, List list) &#123; // 递归终止条件 if (root == null) &#123; return; &#125; // 递归过程 // 处理当前节点 list.add(root.val); // 前序遍历root节点的每个子树 for (Node node: root.children) &#123; traversal(node, list); &#125; &#125; public List&lt;Integer&gt; preorder(Node root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); traversal(root, list); return list; &#125;&#125; ④N叉树-迭代 Java 1234567891011121314151617181920class Solution &#123; public List&lt;Integer&gt; preorder(Node root) &#123; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (root == null) &#123; return list; &#125; stack.push(root); while (!stack.isEmpty()) &#123; root = stack.pop(); list.add(root.val); // 将N叉树的子树从右向左推入栈中，这样子树出栈的顺序是从左到右。 Collections.reverse(root.children); for (Node n: root.children) &#123; stack.push(n); &#125; &#125; return list; &#125;&#125; 3.树的中序遍历 遍历过程为： ①中序遍历其左子树 ②访问根结点 ③中序遍历其右子树 对于二分搜索树来说，中序遍历使得元素从小到大排序。 举例： 下图的中序遍历结果为：1、2、3、4、5、6、7、8、9。 ①二叉树-递归 Java 12345678910111213141516171819202122class Solution &#123; // 递归函数定义: 中序遍历以root节点为根节点的二叉树 private void traversal(TreeNode root, List list) &#123; // 递归终止条件 if (root == null) &#123; return; &#125; // 递归过程 // 中序遍历root节点的左子树 traversal(root.left, list); // 处理当前节点 list.add(root.val); // 中序遍历root节点的右子树 traversal(root.right, list); &#125; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); traversal(root, list); return list; &#125;&#125; C 12345678910111213141516171819202122232425262728293031// 递归函数，returnSize、arr是指针，动态修改。// 递归函数定义: 中序遍历以root节点为根节点的二叉树void orderTraversal(struct TreeNode* root, int* returnSize, int* arr) &#123; // 递归终止条件 if (!root) &#123; return; &#125; // 递归过程 // 中序遍历root节点的左子树 orderTraversal(root-&gt;left, returnSize, arr); // 处理当前节点 arr[(*returnSize)++] = root-&gt;val; // 中序遍历root节点的右子树 orderTraversal(root-&gt;right, returnSize, arr); &#125;// 统计结点数int makeSize(struct TreeNode* root) &#123; if (!root) &#123; return 0; &#125; return makeSize(root-&gt;left) + makeSize(root-&gt;right) + 1;&#125;int* inorderTraversal(struct TreeNode* root, int* returnSize) &#123; int size = makeSize(root); int* arr = (int*)malloc(sizeof(int) * size); *returnSize = 0; orderTraversal(root, returnSize, arr); return arr;&#125; ②二叉树-迭代 遇到一个节点，就把它压入栈中，并去遍历它的左子树。当左子树遍历结束后，弹出栈顶元素并访问它，再去中序遍历该节点的右子树。 Java 123456789101112131415161718192021class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (!stack.isEmpty() || root != null) &#123; // 遇到一个节点，就把它压入栈中，并去遍历它的左子树。 while (root != null) &#123; stack.push(root); root = root.left; &#125; // 当左子树遍历结束后，弹出栈顶元素并访问它。 if (!stack.isEmpty()) &#123; root = stack.pop(); list.add(root.val); // 再去中序遍历该节点的右子树 root = root.right; &#125; &#125; return list; &#125;&#125; C 123456789101112131415161718192021222324252627282930313233343536// 统计结点数int makeSize(struct TreeNode* root) &#123; if (!root) return 0; return makeSize(root-&gt;left) + makeSize(root-&gt;right) + 1;&#125;typedef struct &#123; struct TreeNode** array; int top;&#125; Stack;int* inorderTraversal(struct TreeNode* root, int* returnSize) &#123; int size = makeSize(root); int* arr = (int*)malloc(sizeof(int) * size); *returnSize = 0; Stack* s = (Stack*)malloc(sizeof(Stack)); s-&gt;array = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * size); s-&gt;top = -1; while (s-&gt;top != -1 || root) &#123; // 遇到一个节点，就把它压入栈中，并去遍历它的左子树。 while (root) &#123; s-&gt;array[++s-&gt;top] = root; root = root-&gt;left; &#125; // 当左子树遍历结束后，弹出栈顶元素并访问它。 if (s-&gt;top != -1) &#123; root = s-&gt;array[s-&gt;top--]; arr[(*returnSize)++] = root-&gt;val; // 再去中序遍历该节点的右子树 root = root-&gt;right; &#125; &#125; return arr;&#125; 4.树的后序遍历 遍历过程为： ①后序遍历其左子树 ②后序遍历其右子树 ③访问根结点 举例： 下图的后序遍历结果为：1、2、3、4、5、6、7、8、9。 ①二叉树-递归 Java 12345678910111213141516171819202122class Solution &#123; // 递归函数定义: 后序遍历以root节点为根节点的二叉树 private void traversal(TreeNode root, List list) &#123; // 递归终止条件 if (root == null) &#123; return; &#125; // 递归过程 // 后序遍历root节点的左子树 traversal(root.left, list); // 后序遍历root节点的右子树 traversal(root.right, list); // 处理当前节点 list.add(root.val); &#125; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); traversal(root, list); return list; &#125;&#125; C 12345678910111213141516171819202122232425262728293031// 递归函数，returnSize、arr是指针，动态修改。// 递归函数定义: 后序遍历以root节点为根节点的二叉树void orderTraversal(struct TreeNode* root, int* returnSize, int* arr) &#123; // 递归终止条件 if (!root) &#123; return; &#125; // 递归过程 // 后序遍历root节点的左子树 orderTraversal(root-&gt;left, returnSize, arr); // 后序遍历root节点的右子树 orderTraversal(root-&gt;right, returnSize, arr); // 处理当前节点 arr[(*returnSize)++] = root-&gt;val;&#125;// 统计结点数int makeSize(struct TreeNode* root) &#123; if (!root) &#123; return 0; &#125; return makeSize(root-&gt;left) + makeSize(root-&gt;right) + 1;&#125;int* postorderTraversal(struct TreeNode* root, int* returnSize) &#123; int size = makeSize(root); int* arr = (int*)malloc(sizeof(int) * size); *returnSize = 0; orderTraversal(root, returnSize, arr); return arr;&#125; ②二叉树-迭代 后序遍历的顺序是：左右中 先序遍历的顺序是：中左右 所以我们可以先将先序遍历修改为：中右左，再将其遍历结果翻转存放，即可得到后序遍历的结果。 Java 123456789101112131415161718192021222324class Solution &#123; // 先将先序遍历的中左右改为中右左，再将遍历结果翻转，即可得到后序遍历的左右中。 public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (!stack.isEmpty() || root != null) &#123; // 遇到一个节点就访问它，然后把它压入栈中，并去遍历它的右子树。 while (root != null) &#123; list.add(root.val); stack.push(root); root = root.right; &#125; // 当右子树遍历结束后，弹出栈顶元素。 if (!stack.isEmpty()) &#123; root = stack.pop(); // 再去"改写的先序"遍历该节点的左子树 root = root.left; &#125; &#125; // 将遍历结果翻转 Collections.reverse(list); return list; &#125;&#125; C 123456789101112131415161718192021222324252627282930313233343536373839// 先将先序遍历的中左右改为中右左，再将遍历结果翻转，即可得到后序遍历的左右中。// 统计结点数int makeSize(struct TreeNode* root) &#123; if (!root) return 0; return makeSize(root-&gt;left) + makeSize(root-&gt;right) + 1;&#125;typedef struct &#123; struct TreeNode** array; int top;&#125; Stack;int* postorderTraversal(struct TreeNode* root, int* returnSize) &#123; int size = makeSize(root); int* arr = (int*)malloc(sizeof(int) * size); Stack* s = (Stack*)malloc(sizeof(Stack)); s-&gt;array = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * size); s-&gt;top = -1; *returnSize = size; int row = *returnSize-1; while (root || s-&gt;top != -1) &#123; // 遇到一个节点就访问它，然后把它压入栈中，并去遍历它的右子树。 while (root) &#123; // 反向存储遍历结果 arr[row--] = root-&gt;val; s-&gt;array[++s-&gt;top] = root; root = root-&gt;right; &#125; // 当右子树遍历结束后，弹出栈顶元素。 if (s-&gt;top != -1) &#123; root = s-&gt;array[s-&gt;top--]; // 再去"改写的先序"遍历该节点的左子树 root = root-&gt;left; &#125; &#125; return arr;&#125; ③N叉树-递归 Java 123456789101112131415161718192021class Solution &#123; // 递归函数定义: 后序遍历以root节点为根节点的N叉树 private void traversal(Node root, List list) &#123; // 递归终止条件 if (root == null) &#123; return; &#125; // 递归过程 // 后序遍历root节点的每个子树 for (Node node: root.children) &#123; traversal(node, list); &#125; // 处理当前节点 list.add(root.val); &#125; public List&lt;Integer&gt; postorder(Node root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); traversal(root, list); return list; &#125;&#125; ④N叉树-迭代 Java 12345678910111213141516171819202122class Solution &#123; // 与二叉树的后序遍历——迭代法同理 public List&lt;Integer&gt; postorder(Node root) &#123; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (root == null) &#123; return list; &#125; stack.push(root); while (!stack.isEmpty()) &#123; root = stack.pop(); list.add(root.val); // 将N叉树的子树从左向右推入栈中，这样子树出栈的顺序是从右到左。 for (Node n: root.children) &#123; stack.push(n); &#125; &#125; // 将遍历结果翻转 Collections.reverse(list); return list; &#125;&#125; 5.树的层序遍历 从根节点开始，首先将根节点入队，然后开始执行循环：节点出队、访问该节点、其左右孩子入队。 举例： 下图的层序遍历结果为：5、2、8、1、4、6、9、3、7。 注意：层序遍历的示例代码输出格式为下图所示格式。 ①二叉树-迭代 Java 12345678910111213141516171819202122232425262728293031class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (root == null) &#123; return res; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); // 将根节点入队 queue.add(root); while (!queue.isEmpty()) &#123; // 使用count分层 int count = queue.size(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (count-- &gt; 0) &#123; // 节点出队 TreeNode node = queue.poll(); // 访问该节点 list.add(node.val); // 其左右孩子入队 if (node.left != null) &#123; queue.add(node.left); &#125; if (node.right != null) &#123; queue.add(node.right); &#125; &#125; res.add(list); &#125; return res; &#125;&#125; ②N叉树-迭代 Java 12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (root == null) &#123; return res; &#125; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); // 将根节点入队 queue.add(root); while (!queue.isEmpty()) &#123; // 使用count分层 int count = queue.size(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (count-- &gt; 0) &#123; // 节点出队 Node node = queue.poll(); // 访问该节点 list.add(node.val); // 其所有孩子从左到右依次入队 for (Node n: node.children) &#123; queue.add(n); &#125; &#125; res.add(list); &#125; return res; &#125;&#125; 6.总结 前、中、后序遍历都属于 深度优先遍历。 即首先尝试走到最深，走不通之后再返回用回溯的方式将整棵树遍历结束。 三种遍历实际访问节点的顺序相同，只是执行打印的位置不同。 实现深度优先遍历：需要堆栈。 层序遍历属于 广度优先遍历。 一层一层地遍历，关注广度，将每层的所有结点遍历完再去下一层。 实现广度优先遍历：需要队列。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#x6a;&#121;&#x6d;&#x65;&#x73;&#115;&#105;&#x40;&#x31;&#x36;&#51;&#46;&#99;&#111;&#109; 关于 数据结构与算法 的更多代码 请查看我的 GitHub仓库]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的定义及性质]]></title>
    <url>%2F2019%2F02%2F08%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%80%A7%E8%B4%A8%2F</url>
    <content type="text"></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找法代码实现]]></title>
    <url>%2F2019%2F01%2F05%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1.概念 对于有序数列，才能使用二分查找法。 二分查找又称折半查找。 优点：比较次数少、查找速度快、平均性能好 缺点：要求待查表为有序表、插入和删除困难 因此二分查找适用于不经常变动且查找频繁的有序列表 2.代码实现 二分查找法：在有序数组 arr 中查找 target。 如果找到 target，返回相应的索引 index。 如果没有找到 target，返回 -1。 时间复杂度：O(log n) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * @author: wjy * @date: 2020/2/21 * @description: 二分查找法: 在有序数组arr中查找target。 * 如果找到target，返回相应的索引index。如果没有找到target，返回-1。 * 时间复杂度: O(log n) */public class BinarySearch &#123; /** * 功能描述: 使用迭代的方法实现二分查找法。 * * @param: [arr, target] * @return: int * @auther: wjy * @date: 2020/2/21 21:10 */ public static int binarySearch(int[] arr, int target) &#123; // 在arr[l...r]之中查找target int l = 0, r = arr.length - 1; while (l &lt;= r) &#123; // int mid = (l + r) / 2; // 防止极端情况下的整形溢出，用以下方法求mid。 // int mid = l + (r - l) / 2; // 模仿jdk源码中的写法，无符号右移一位。 int mid = (l + r) &gt;&gt;&gt; 1; if (arr[mid] == target) &#123; return mid; &#125; else if (target &lt; arr[mid]) &#123; // 在arr[l...mid-1]之中查找target r = mid - 1; &#125; else &#123; // 在arr[mid+1...r]之中查找target l = mid + 1; &#125; &#125; return -1; &#125; /** * 功能描述: 使用递归的方法实现二分查找法(性能上略差，但差异是常数级的)。 * * @param: [arr, l, r, target] * @return: int * @auther: wjy * @date: 2020/2/21 20:58 */ public static int binarySearchByRecursion(int[] arr, int l, int r, int target) &#123; // 在arr[l...r]之中查找target if (l &gt; r) &#123; return -1; &#125; // int mid = (l + r) / 2; // 防止极端情况下的整形溢出，用以下方法求mid。 // int mid = l + (r - l) / 2, index = -1; // 模仿jdk源码中的写法，无符号右移一位。 int mid = (l + r) &gt;&gt;&gt; 1, index = -1; if (arr[mid] == target) &#123; index = mid; &#125; else if (target &lt; arr[mid]) &#123; // 在arr[l...mid-1]之中查找target index = binarySearchByRecursion(arr, l, mid - 1, target); &#125; else &#123; // 在arr[mid+1...r]之中查找target index = binarySearchByRecursion(arr, mid + 1, r, target); &#125; return index; &#125; /** * 功能描述: 测试迭代方法和递归方法的正确性 * * @param: [args] * @return: void * @auther: wjy * @date: 2020/2/21 20:39 */ public static void main(String[] args) &#123; // 生成一个有序数组 int n = 100; int[] arr = new int[n]; for (int i = 0; i &lt; n; i++) &#123; arr[i] = i; &#125; int random = (int) (Math.random() * n); System.out.println("随机数: " + random + " 迭代方法执行结果: " + binarySearch(arr, random)); System.out.println("随机数: " + random + " 递归方法执行结果: " + binarySearchByRecursion(arr, 0, n - 1, random)); &#125;&#125; 3.Leetcode 题解举例 [LeetCode] 35.搜索插入位置（Easy）Java语言题解 [LeetCode] 35.搜索插入位置（Easy）C语言题解 优秀题解分享：用“排除法”（减治思想）写二分查找问题 4.扩展问题 如果有序数列中存在多个 target 值，我们应该返回什么呢？ 使用上述代码，并不能确定我们找到的索引具体对应哪一个 target。 为了解决这个问题，我们额外定义两个函数： ①floor() 函数: 返回 target 在数组中第一次出现的位置，若是元素不存在，返回数组中小于 target 的最大元素。 ②ceil() 函数: 返回 target 在数组中最后一次出现的位置，若是元素不存在，返回数组中大于 target 的最小元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * @author: wjy * @date: 2020/2/21 * @description: 二分查找法的扩展问题: 当数组中存在多个target值时，应该返回什么？ */public class BinarySearchExtend &#123; public static int floor(int[] arr, int target) &#123; int l = 0, r = arr.length - 1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt;&gt; 1; if (arr[mid] &lt; target) &#123; l = mid + 1; &#125; else &#123; r = mid - 1; &#125; &#125; // 所有元素都小于target if (l == arr.length) &#123; return l - 1; &#125; return arr[l] == target? l: l - 1; &#125; public static int ceil(int[] arr, int target) &#123; int l = 0, r = arr.length - 1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt;&gt; 1; if (arr[mid] &gt; target) &#123; r = mid - 1; &#125; else &#123; l = mid + 1; &#125; &#125; // 所有元素都大于target if (r &lt; 0) &#123; return 0; &#125; // 所有元素都小于target if (l == arr.length) &#123; return l - 1; &#125; return arr[r] == target? r: r + 1; &#125; /** * 功能描述: 测试floor()函数和ceil()函数 * * @param: [args] * @return: void * @auther: wjy * @date: 2020/2/21 20:39 */ public static void main(String[] args) &#123; int[] arr = &#123;0, 1, 3, 4, 4, 4, 4, 5, 6, 6&#125;; int random = (int) (Math.random() * arr.length); System.out.println("floor(arr, " + random + ") = " + floor(arr, random)); System.out.println("ceil(arr, " + random + ") = " + ceil(arr, random)); &#125;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#x6a;&#121;&#x6d;&#101;&#115;&#115;&#x69;&#x40;&#49;&#54;&#x33;&#x2e;&#99;&#x6f;&#109; 关于 数据结构与算法 的更多代码 请查看我的 GitHub仓库]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二分查找法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 35.搜索插入位置（Easy）Java语言题解]]></title>
    <url>%2F2019%2F01%2F04%2FLeetCode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%EF%BC%88Easy%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.题目相关①题目及示例 ②相关标签 数组 二分查找 ③题目地址 35. 搜索插入位置 — 力扣网 2.解题方法①顺序查找 根据题意可以看出，数组中第一个大于或等于 target 的元素对应的下标就是 target 将要插入的位置，若是数组中的元素都比 target 小，则返回数组长度。 时间复杂度：O(n) 空间复杂度：O(1) ②二分查找 结论： 每次判断 nums[mid] 和 target 之间的大小： 若 nums[mid] = target，则直接返回下标。 若 nums[mid] &lt; target，则 left = mid + 1。 若 nums[mid] &gt; target，则 right = mid - 1。 查找结束后返回 left，该值为插入位置。 这道题的难点是如果数组中不包含值和 target 相等的元素，那么我们要返回什么呢？上文的结论是返回 left，那么我们是如何得到的呢？ 此时我们可以想象程序在最后一次循环中会做什么： 已知程序结束循环的条件是 left &gt; right，所以我们可以确定在最后一次循环中有：right == left -&gt; mid == (right + left) / 2 == right == left，此时存在两种情况： 12345if (nums[mid] &lt; target) &#123; // left &gt; right，之后退出循环。 left = mid + 1;&#125;// 退出循环后，nums[left] = nums[right + 1] &gt; target。 12345if (nums[mid] &gt; target) &#123; // right &lt; left，之后退出循环。 right = mid - 1;&#125;// 退出循环后，nums[left] = nums[mid] &gt; target。 根据上述证明可知，返回 left 是正确的。 时间复杂度：O(log n) 空间复杂度：O(1) 3.代码详解①暴力解法123456789public int searchInsert(int[] nums, int target) &#123; int len = nums.length; for (int i = 0; i &lt; len; i++) &#123; if (nums[i] &gt;= target) &#123; return i; &#125; &#125; return len;&#125; ②二分查找123456789101112131415161718public int searchInsert(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; // int mid = (left + right) / 2; // int mid = left + (right - left) / 2; int mid = (left + right) &gt;&gt;&gt; 1; if (nums[mid] == target) &#123; return mid; &#125; else if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; return left;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#106;&#x79;&#x6d;&#101;&#x73;&#115;&#x69;&#x40;&#49;&#x36;&#51;&#x2e;&#x63;&#x6f;&#109; 关于 数据结构与算法 的更多代码 请查看我的 GitHub仓库]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>LeetCode-Java</category>
      </categories>
      <tags>
        <tag>二分查找法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 35.搜索插入位置（Easy）C语言题解]]></title>
    <url>%2F2019%2F01%2F04%2FLeetCode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%EF%BC%88Easy%EF%BC%89C%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.题目相关①题目及示例 ②相关标签 数组 二分查找 ③题目地址 35. 搜索插入位置 — 力扣网 2.解题方法①顺序查找 根据题意可以看出，数组中第一个大于或等于 target 的元素对应的下标就是 target 将要插入的位置，若是数组中的元素都比 target 小，则返回数组长度。 时间复杂度：O(n) 空间复杂度：O(1) ②二分查找 结论： 每次判断 nums[mid] 和 target 之间的大小： 若 nums[mid] = target，则直接返回下标。 若 nums[mid] &lt; target，则 left = mid + 1。 若 nums[mid] &gt; target，则 right = mid - 1。 查找结束后返回 left，该值为插入位置。 这道题的难点是如果数组中不包含值和 target 相等的元素，那么我们要返回什么呢？上文的结论是返回 left，那么我们是如何得到的呢？ 此时我们可以想象程序在最后一次循环中会做什么： 已知程序结束循环的条件是 left &gt; right，所以我们可以确定在最后一次循环中有：right == left -&gt; mid == (right + left) / 2 == right == left，此时存在两种情况： 12345if (nums[mid] &lt; target) &#123; // left &gt; right，之后退出循环。 left = mid + 1;&#125;// 退出循环后，nums[left] = nums[right + 1] &gt; target。 12345if (nums[mid] &gt; target) &#123; // right &lt; left，之后退出循环。 right = mid - 1;&#125;// 退出循环后，nums[left] = nums[mid] &gt; target。 根据上述证明可知，返回 left 是正确的。 时间复杂度：O(log n) 空间复杂度：O(1) 3.代码详解①暴力解法12345678int searchInsert(int* nums, int numsSize, int target) &#123; for (int i = 0; i &lt; numsSize; i++) &#123; if (nums[i] &gt;= target) &#123; return i; &#125; &#125; return numsSize;&#125; ②二分查找123456789101112131415161718int searchInsert(int* nums, int numsSize, int target) &#123; int left = 0, right = numsSize - 1; while (left &lt;= right) &#123; // int mid = (left + right) / 2; // int mid = left + (right - left) / 2; int mid = (left + right) &gt;&gt;&gt; 1; if (nums[mid] == target) &#123; return mid; &#125; else if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; return left;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#121;&#109;&#x65;&#115;&#x73;&#105;&#64;&#49;&#54;&#x33;&#x2e;&#x63;&#111;&#x6d; 关于 数据结构与算法 的更多代码 请查看我的 GitHub仓库]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>LeetCode-C</category>
      </categories>
      <tags>
        <tag>二分查找法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言常用库函数整理]]></title>
    <url>%2F2018%2F12%2F20%2FC%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[PS：include 称为文件包含命令，即它把 &lt; &gt; 或 &quot; &quot; 内指定的文件包含到程序中。被包含的(头)文件通常是由系统提供的，其扩展名为 .h。如下介绍了 stdio.h、stdlib.h、string.h、math.h 等系统提供的文件。 1.stdio.h 标准 I/O 库。 int scanf(char *format, args, …)：按 format 指定的格式将输入数据存入到 args，… 指定的内存中(读取到空格就停止)。 int printf(char *format, args, …)：将 args，… 的值以 format 指定的格式输出。 char *gets(char *str)：从标准输入中读取一行，并把它存储在 str 所指向的字符串中(读取到换行符或者到达文件末尾时停止，读取到空格不停止)。 int getchar(void)：从标准输入中读取下一个字符。| 如果没有错误发生，返回相同的字符，如果碰到文件结尾或者有错误发生，则返回 EOF。 int putchar(int character)：将字符输出到标准输出中。| 如果没有错误发生，返回相同的字符，如果有错误发生，则返回 EOF。 int sprintf(char *str, const char *format, …)：格式化输出到 str 所指向的字符串。 12345int a = 123;char* s1 = "abc";char* s2;sprintf(s2, "%d %s", a, s1);printf("%s", s2); // 123 abc。 宏 EOF 是一个负整数，通常在有函数调用错误或者碰到文件结尾时返回。 1234// 判断是否到达输入流末尾。if (scanf("%d", %num) != EOF) &#123; ...&#125; 2.stdlib.h①分配空间 void *calloc(unsigned n, unsigned size)：分配所需的内存空间，并返回一个指向它的指针。 void *malloc(unsigned size)：分配所需的内存空间，并返回一个指向它的指针。 1234// 如: 向系统申请分配100个int型的连续内存空间。// 并返回所分配的内存空间的首地址。int* array = malloc(sizeof(int)*100); int* array = calloc(100, sizeof(int)); void *realloc(void *ptr, unsigned size)：重新调整之前调用 malloc 或 calloc 所分配的内存块的大小(其中 ptr 为指向内存块的指针)。 void free(void *ptr)：释放调用 calloc、malloc 或 realloc 所分配的内存空间(即释放 ptr 指针所指向的内存空间)。 ②算法相关 执行快速排序： 12345678910// 主函数外声明一个compare函数，决定升序/降序。int compare(const void* a, const void* b) &#123; // 升序。 return (*(待排元素类型*)a) -/&gt; (*(待排元素类型*)b); // 降序。 return (*(待排元素类型*)b) -/&gt; (*(待排元素类型*)a);&#125;// 主函数内调用快排函数，进行快速排序。qsort(待排数组首地址, 待排元素总个数, sizeof(待排元素类型), compare(函数，决定升序/降序)); 执行二分查找： 1234567891011// 主函数外声明一个compare函数，决定升序/降序。int compare(const void* a, const void* b) &#123; // 升序。 return (*(待排元素类型*)a) -/&gt; (*(待排元素类型*)b); // 降序。 return (*(待排元素类型*)b) -/&gt; (*(待排元素类型*)a);&#125;// 主函数内调用二分查找函数，查找某个元素。int* ptr;ptr = (int*)bsearch(指向要查找元素的指针, 待查数组首地址, 待查数组的元素总个数, sizeof(待排元素类型), compare(函数，决定升序/降序)); 如果查找成功，则返回一个指向数组中匹配元素的指针，否则返回空指针。 ③其他 int rand(void)：返回一个范围在 0 - RAND_MAX(32767) 之间的伪随机数。 123456// 返回[0-10)之间的随机数。printf("%d", rand()%10);// 返回[20-30)之间的随机数。printf("%d", rand()%10+20);// 返回[m,n)范围内的随机数num，可用：prinrf("%d", rand()%(n-m)+m); int abs(int x)：求整数 x 的绝对值。 long int labs(long int x)：返回长整型 x 的绝对值。 int atoi(const char *str)：把参数 str 所指向的字符串转换为一个 int 型整数。 123char* s = "521 abc";int a = atoi(s);printf("%d", a); // 521。 double atof(const char *str)：把参数 str 所指向的字符串转换为一个 double 型浮点数。 long int atol(const char *str)：把参数 str 所指向的字符串转换为一个 long int 型长整数。 void exit(int status)：使一个程序正常终止(status 为 0)，或非正常终止(status 为 1)。 void abort(void)：使一个异常程序终止。 ④库宏RAND_MAX： rand 函数返回的最大值。NULL：是一个空指针常量的值。 NULL——stdio.h、string.h 头文件中也有此宏。 3.string.h string.h 头文件定义了各种操作字符数组的函数。 int strcmp(const char *str1, const char *str2)：把 str1 所指向的字符串和 str2 所指向的字符串进行比较。 12345678910111213/* strcmp()函数会按照ASCII码顺序比较两个字符串，并由函数返回值返回比较结果。 字符串1 ＝ 字符串2，返回值 ＝ 0。 字符串2 &gt; 字符串2，返回值 &gt; 0。 字符串1 &lt; 字符串2，返回值 &lt; 0。 */char* s1 = "asd";char* s2 = "asd";// 两字符串相等，返回1，否则，返回0。if (strcmp(s1, s2) == 0) return 1; else return 0; size_t strlen(const char *str)：计算字符串 str 的长度。 char *strcpy(char *dest, const char *src)：把 src 所指向的字符串复制到 dest。 char *strcat(char *dest, const char *src)：把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。 12345678910// 注意: 以下代码会出现错误。char* s = malloc(sizeof(char)*10);char arr[5] = "abcde";strcat(s, arr);// ×，必须给s赋初值，再使用此函数。// 正确操作。char s[5] = "aaaaa";char arr[5] = "bbbbb";strcat(s, arr);printf("%s", s);// aaaaabbbbb。 void *memcpy(void *str1, const void *str2, size_t n)：从存储区 str2 复制 n 个字符到存储区 str1。| 返回一个指向目标存储区 str1 的指针。 char *strtok(char *str, const char *delim)：分解字符串 str，其中 delim 为分隔符。| str — 要被分解的字符串。| delim — 包含分隔符的 C 字符串。 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main() &#123; char s[15] = "I am so cold"; char** arr = (char**)malloc(sizeof(char*)*4); int i = 0; arr[i] = (char*)malloc(sizeof(char)*5); arr[i] = strtok(s, " "); /* 输出: I am so cold */ while (arr[i] != NULL) &#123; printf("%s\n", arr[i]); i++; arr[i] = (char*)malloc(sizeof(char)*5); arr[i] = strtok(NULL, " "); &#125; return 0;&#125; 4.math.h math.h 头文件定义了各种数学函数，此库中所有函数都带有一个 double 类型的参数，且都返回 double 类型的结果。 ①普通数字处理 double fabs(double x)：求浮点数 x 的绝对值。 double sqrt(double x)：计算 x 的平方根。 double pow(double x, double y)：计算 x 的 y 次幂。 double fmod (double x, double y)：返回 x / y 的余数。 double exp(double x)：求 e 的 x 次幂，e = 2.718281828。 double log(double x)：计算 x 的自然对数，即 e 为底数，x 的值应大于零。 double log10(double x)：计算 x 的常用对数，即 10 为底数，x 的值应大于零。 double floor(double x)：求不大于 x 的最大整数。| 返回 x 的下限，如 74.12 的下限为 74，-74.12 的下限为 -75，返回值为 double 类型。 double ceil(double x)：求不小于 x 的最小整数。| 返回 x 的上限，如 74.12 的上限为 75，-74.12 的上限为 -74，返回值为 double 类型。 ②三角函数 double cos(double x)：求 x (弧度表示)的余弦值。 double sin(double x)：求 x (弧度表示)的正弦值。 double tan(double x)：求 x (弧度表示)的正切值。 ③其他 double hypot(double x, double y)：x、y 为直角三角形的两个直角边，返回其斜边的长度。 double modf(double x, double *ip)：将 x 的整数部分通过指针回传，返回其小数部分，并将整数部分保存在 *ip 中。 5.ctype.h 如果参数 c 满足函数条件，则如下函数返回非零值(即 true)。如果不满足，则如下函数返回零(即 false)。 int isalnum(int c)：检查所传的字符是否是字母和数字。 int isalpha(int c)：该函数检查所传的字符是否是字母。 int islower(int c)：检查所传的字符是否是小写字母。 int isupper(int c)：检查所传的字符是否是大写字母。 int isdigit(int c)：检查所传的字符是否是十进制数字。 int isxdigit(int c)：检查所传的字符是否是十六进制数字。 int tolower(int c)：把大写字母转换为小写字母。 int toupper(int c)：把小写字母转换为大写字母。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#121;&#x6d;&#101;&#115;&#115;&#105;&#64;&#49;&#x36;&#x33;&#46;&#x63;&#x6f;&#109;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言库函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASC2码]]></title>
    <url>%2F2018%2F12%2F18%2FASC%E2%85%A1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[方便用时查看。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#121;&#109;&#x65;&#115;&#115;&#x69;&#x40;&#49;&#x36;&#51;&#46;&#x63;&#x6f;&#x6d;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JSON快速入门(JAVA版)]]></title>
    <url>%2F2018%2F12%2F11%2FJSON%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-JAVA%E7%89%88%2F</url>
    <content type="text"><![CDATA[org.json、gson 等 jar 包的下载：链接：https://pan.baidu.com/s/1sjMDVajQgR-ihFvAZ54ymg提取码：dt84 1.了解 JSON 它的全称为 JavaScript Object Notation。 ①优点 JSON 是一种与开发语言无关的、轻量级的数据交换格式。| 它采用完全独立于编程语言的文本格式来存储和表示数据。| 最初来自 JS，后来几乎每种常用语言都有处理 JSON 的 API，它支持多种服务器端语言，便于服务器端的解析。 JSON 是行业内使用最为广泛的数据传输格式。| 调用服务端 API 时会使用 JSON 作为返回格式。 JSON 是数据存储的一种格式，格式简单、易于读写、占用带宽小。| 它易于易于程序的解析和生成，并能有效的提升网络传输效率。 ②缺点 要求字符集必须是 Unicode，受约束性强。 ③实例 { }：标识一个 JSON 对象(即结构体)。| { } 中包含键值对结构，key 必须是 String 类型，value 为任何基本类型、对象或数组，多个键值对之间用逗号分隔。 []：数组 Array，用逗号分隔元素。| 在 Java 中，可用集合、string[] 等定义。 元素基本类型：String、number、true、false、null。| JSON 中的数字没有浮点数、整数 … 之分。但在 Java 中，JSONObject 的 put 方法会自动区分不同的数字格式。这是一种 JSON 原生数据格式到 Java 数据格式的映射关系。| 标准 JSON 中不支持任何形式的注释。| JSON 中没有日期 / 时间数据格式。 2.org.json 包的使用①使用 JSONObject 构建 JSON 对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package json;import org.json.JSONException;import org.json.JSONObject;/** * @Auther: wjy * @Date: 2019/4/10 16:34 * @Description: 使用JSONObject构建JSON对象。 */public class jsonTest &#123; public static void main(String[] args) &#123; JSONObject messi = new JSONObject(); Object null1 = null; try &#123; messi.put("name", "messi"); // put方法具有替代性，第二次赋值会代替第一次赋值。 messi.put("name", "梅西"); messi.put("age", 31.8); // JSON中用String类型代替日期类型。 messi.put("birthday", "1987-06-24"); messi.put("home", "Barcelona"); // 可用集合、string[]等定义JSON数组。 messi.put("major", new String[]&#123;"player", "star"&#125;); messi.put("car", true); messi.put("house", true); // 直接使用null会产生二义性。 messi.put("daughter", null1); messi.put("girlfriend", "安东内拉"); // 此键值作为JSON数据的注释。 messi.put("comment", "love him!!"); // 打印JSON格式的数据。 /* * 自动去除空格 —— 压缩数据。 * 与键值的插入顺序不同。 * &#123;"birthday":"1987-06-24","girlfriend":"安东内拉","major":["player","star"],"car":true,"name":"梅西","comment":"love him!!","house":true,"age":31.8,"home":"Barcelona"&#125; */ System.out.println(messi.toString()); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ②使用 Map 构建 JSON 对象1234567891011121314151617181920212223242526272829303132333435363738394041424344package json;import org.json.JSONObject;import java.util.HashMap;/** * @Auther: wjy * @Date: 2019/4/10 16:34 * @Description: 使用Map构建JSON对象。 */public class jsonTest &#123; public static void main(String[] args) &#123; HashMap&lt;String, Object&gt; messi = new HashMap&lt;String, Object&gt;(); Object null1 = null; messi.put("name", "messi"); // put方法具有替代性，第二次赋值会代替第一次赋值。 messi.put("name", "梅西"); messi.put("age", 31.8); // JSON中用String类型代替日期类型。 messi.put("birthday", "1987-06-24"); messi.put("home", "Barcelona"); // 可用集合、string[]等定义JSON数组。 messi.put("major", new String[]&#123;"player", "star"&#125;); messi.put("car", true); messi.put("house", true); // 直接使用null会产生二义性。 messi.put("daughter", null1); messi.put("girlfriend", "安东内拉"); // 此键值作为JSON数据的注释。 messi.put("comment", "love him!!"); // 打印JSON格式的数据。 /* * 通过JSONObject的构造函数传入Map对象,来构建一个JSON对象。 * 自动去除空格 —— 压缩数据。 * 与键值的插入顺序不同。 * &#123;"birthday":"1987-06-24","girlfriend":"安东内拉","major":["player","star"],"car":true,"name":"梅西","comment":"love him!!","house":true,"age":31.8,"home":"Barcelona"&#125; */ System.out.println(new JSONObject(messi).toString()); &#125;&#125; ③使用 Javabean 构建 JSON 对象(推荐使用)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package json;/** * @Auther: wjy * @Date: 2019/4/10 17:21 * @Description: 封装数据的Javabean。 */public class lover &#123; private String name; private double age; // 日期类型需要用字符串类型代替。 private String birthday; private String home; private String[] major; private Boolean car; private Boolean house; private String girlfriend; private Object daugter; private String comment; public lover() &#123;&#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getAge() &#123; return age; &#125; public void setAge(double age) &#123; this.age = age; &#125; public String getBirthday() &#123; return birthday; &#125; public void setBirthday(String birthday) &#123; this.birthday = birthday; &#125; public String getHome() &#123; return home; &#125; public void setHome(String school) &#123; this.home = home; &#125; public String[] getMajor() &#123; return major; &#125; public void setMajor(String[] major) &#123; this.major = major; &#125; public Boolean getCar() &#123; return car; &#125; public void setCar(boolean car) &#123; this.car = car; &#125; public Boolean getHouse() &#123; return house; &#125; public void setHouse(boolean house) &#123; this.house = house; &#125; public String getGirlfriend() &#123; return girlfriend; &#125; public void setGirlfriend(String girlfriend) &#123; this.girlfriend = girlfriend; &#125; public Object getDaughter() &#123; return daugter; &#125; public void setDaughter(Object daugter) &#123; this.daugter = daugter; &#125; public String getComment() &#123; return comment; &#125; public void setComment(String comment) &#123; this.comment = comment; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637package json;import org.json.JSONObject;/** * @Auther: wjy * @Date: 2019/4/10 16:34 * @Description: 使用Javabean构建JSON对象。 */public class jsonTest &#123; public static void main(String[] args) &#123; // 声明一个bean的实例。 lover messi = new lover(); Object null1 = null; // 给bean的属性赋值。 messi.setName("梅西"); messi.setAge(31.8); messi.setBirthday("1987-06-24"); messi.setHome("Barcelona"); messi.setMajor(new String[]&#123;"player", "star"&#125;); messi.setCar(true); messi.setHouse(true); messi.setDaughter(null1); messi.setGirlfriend("安东内拉"); messi.setComment("love him!!"); /* * 通过JSONObject的构造函数传入Javabean实例，来构建一个JSON对象。 * 并不是直接对JSONObject进行操作，没有将属性直接put到JSONObject中。而是先创建一个Javabean对象，给此对象的属性赋值，便于重用Javabean。 * &#123;"birthday":"1987-06-24","girlfriend":"安东内拉","major":["player","star"],"car":true,"name":"梅西","comment":"love him!!","daughter":null,"house":true,"age":31.8,"home":null&#125; */ System.out.println(new JSONObject(messi).toString()); &#125;&#125; ④从文件中读取 JSON 需要将此 JSON 文件放在工程根目录下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package json;import java.io.File;import java.io.IOException;import org.apache.commons.io.FileUtils;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;/** * @Auther: wjy * @Date: 2019/4/10 18:31 * @Description: 从文件中读取JSON数据。 * 注意: JSONObject不支持将JSON数据反解析为Javabean。 */public class readJsonTest &#123; public static void main(String[] args) throws IOException, JSONException &#123; // 获取文件。 File file = new File(readJsonTest.class.getResource("../messi.json").getFile()); // 读取文件内容。 String content = FileUtils.readFileToString(file); // 将文件内容转换为JSON对象。 JSONObject json = new JSONObject(content); // 增加程序的健壮性。 if (!json.isNull("name")) System.out.println("name: " + json.getString("name")); // 解析JSON格式的数据。 System.out.println("age: " + json.getDouble("age")); System.out.println("birthday: " + json.getString("birthday")); System.out.println("home: " + json.getString("home")); System.out.println("car? " + json.getBoolean("car")); System.out.println("house? " + json.getBoolean("house")); System.out.println("comment: " + json.getString("comment")); // JSONObject对象不能解析JSON格式中的数组，需要JSONArray对象解析。 // 获取JSON格式中的数组。 JSONArray array = json.getJSONArray("major"); // 遍历获取到的数组。 /* * 专业-1: player * 专业-2: star */ for (int i = 0; i &lt; array.length(); i++) System.out.println("专业-" + (i+1) + ": " + array.getString(i)); &#125;&#125; 3.GSON 的使用 Google 提出的开源项目(第三方工具)，相比于 JSONObject，功能更强大、性能更出色、使用方式更简单。 ①使用 Javabean 构建 JSON 对象(推荐使用)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package gson;/** * @Auther: wjy * @Date: 2019/4/11 17:21 * @Description: 封装数据的JavaBean。 */public class lover1 &#123; private String name; private double age; private String birthday; private String home; private String[] major; private Boolean car; private Boolean house; private String girlfriend; private Object daughter; private String comment; public lover1() &#123;&#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getAge() &#123; return age; &#125; public void setAge(double age) &#123; this.age = age; &#125; public String getBirthday() &#123; return birthday; &#125; public void setBirthday(String birthday) &#123; this.birthday = birthday; &#125; public String getHome() &#123; return home; &#125; public void setHome(String home) &#123; this.home = home; &#125; public String[] getMajor() &#123; return major; &#125; public void setMajor(String[] major) &#123; this.major = major; &#125; public Boolean getCar() &#123; return car; &#125; public void setCar(boolean car) &#123; this.car = car; &#125; public Boolean getHouse() &#123; return house; &#125; public void setHouse(boolean house) &#123; this.house = house; &#125; public String getGirlfriend() &#123; return girlfriend; &#125; public void setGirlfriend(String girlfriend) &#123; this.girlfriend = girlfriend; &#125; public Object getDaughter() &#123; return daughter; &#125; public void setDaughter(Object daugter) &#123; this.daughter = daugter; &#125; public String getComment() &#123; return comment; &#125; public void setComment(String comment) &#123; this.comment = comment; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435package gson;import com.google.gson.Gson;/** * @Auther: wjy * @Date: 2019/4/11 10:13 * @Description: 使用Javabean构建JSON对象。 */public class gsonTest &#123; public static void main(String[] args) &#123; lover1 messi = new lover1(); Object null1 = null; Gson gson = new Gson(); messi.setName("messi"); messi.setAge(31.8); messi.setBirthday("1987-06-24"); messi.setHome("Barcelona"); messi.setMajor(new String[]&#123;"player", "star"&#125;); messi.setCar(true); messi.setHouse(true); messi.setDaughter(null1); messi.setGirlfriend("安东内拉"); messi.setComment("love him!!"); // 生成JSON格式的数据。 /* * &#123;"name":"messi","age":31.8,"birthday":"1987-06-24","home":"Barcelona","major":["player","star"],"car":true,"house":true,"girlfriend":"安东内拉","comment":"love him!!"&#125; */ System.out.println(gson.toJson(messi)); &#125;&#125; ②个性化定制 JSON123456789101112131415161718192021222324252627282930313233343536373839404142package gson;import com.google.gson.annotations.SerializedName;/** * @Auther: wjy * @Date: 2019/4/11 17:21 * @Description: 封装数据的JavaBean。 * GSON有更强的灵活性。 */public class lover2 &#123; // 通过添加注解的方式，标识生成JSON对象的一个key。 // 将name转换为NAME，相当于解析的时候重新命名key值。 @SerializedName("NAME") private String name; private double age; // 隐藏某个属性。 private transient String ignore; public lover2() &#123;&#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getAge() &#123; return age; &#125; public void setAge(double age) &#123; this.age = age; &#125; public String getIgnore() &#123; return ignore; &#125; public void setIgnore(String ignore) &#123; this.ignore = ignore; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package gson;import com.google.gson.Gson;import com.google.gson.GsonBuilder;/** * @Auther: wjy * @Date: 2019/4/11 10:13 * @Description: 使用Javabean构建JSON对象。 * 个性化构建JSON格式。 */public class gsonTest &#123; public static void main(String[] args) &#123; lover2 messi = new lover2(); GsonBuilder gb = new GsonBuilder(); // 通过Javabean类中的注解将name变为NAME，即在构建过程中将key个性化，一直有效。 messi.setName("messi"); messi.setAge(31.8); // 通过传入回调参数将age变为AGE，即在构建过程中将key个性化，仅在这个gb对象中有效。 gb.setFieldNamingStrategy(field -&gt; &#123; if (field.getName().equals("age")) return "AGE"; else return field.getName(); &#125;); // 生成JSON格式的数据。 /* * &#123;"NAME":"messi","AGE":31.8&#125; */ System.out.println(gb.create().toJson(messi)); // 美化JSON格式。 gb.setPrettyPrinting(); // 生成JSON格式的数据。 /* * &#123; * "NAME": "messi", * "AGE": 31.8 * &#125; */ System.out.println(gb.create().toJson(messi)); Gson gson = new Gson(); // 在JavaBean中构建JSON对象时隐藏某个属性(private transient String 属性名)。 messi.setIgnore("I love you!"); // 生成JSON格式的数据。 /* * 隐藏了ignore属性。 * &#123;"NAME":"messi","age":31.8&#125; */ System.out.println(gson.toJson(messi)); &#125;&#125; ③从文件中读取 JSON + 将 JSON 数据反解析为 Javabean 对象 将 JSON 数据反解析为 Javabean 对象时，GSON 支持将 String 类型的日期转换为日期类型。GSON 会将 JSON 数据中的数组自动转换为 Javabean 对象中的集合类型。 1234567891011121314151617181920212223242526272829303132333435363738394041package gson;import java.util.Date;import java.util.List;/** * @Auther: wjy * @Date: 2019/4/11 17:21 * @Description: 封装数据的Javabean。 * 将JSON数据反解析为Javabean对象。 */public class lover3 &#123; private double age; // 日期类型。 private Date birthday; // 集合类型。 private List&lt;String&gt; major; public lover3() &#123;&#125; public double getAge() &#123; return age; &#125; public void setAge(double age) &#123; this.age = age; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public List&lt;String&gt; getMajor() &#123; return major; &#125; public void setMajor(List&lt;String&gt; major) &#123; this.major = major; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243package gson;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import org.apache.commons.io.FileUtils;import java.io.File;import java.io.IOException;/** * @Auther: wjy * @Date: 2019/4/11 20:00 * @Description: 从文件中读取JSON。 * 将JSON数据反解析为Javabean对象。 */public class readJsonTest &#123; public static void main(String[] args) throws IOException &#123; // 从文件中读取JSON。 File file = new File(readJsonTest.class.getResource("../messi.json").getFile()); String content = FileUtils.readFileToString(file); // 使用GsonBuilder的setDateFormat("日期模板")方法可以将JSON对象中String类型的日期转换成Date类型。 Gson gson = new GsonBuilder().setDateFormat("yyyy-MM-dd").create(); // JSON对象中的key与Javabean的属性一一对应。 // 将JSON数据反解析为Javabean对象。 lover3 messi = gson.fromJson(content, lover3.class); /* * Wed Jun 24 00:00:00 CDT 1987 * 31.8 * gson.lover3@1e4a7dd4 * GSON会将JSON数据中的数组自动转换为Javabean对象中的集合类型。 * [player, star] * class java.util.ArrayList */ System.out.println(messi.getBirthday()); System.out.println(messi.getAge()); System.out.println(messi.toString()); System.out.println(messi.getMajor()); System.out.println(messi.getMajor().getClass()); &#125;&#125; org.json 是 Android SDK 的官方库。GSON 应用于服务端开发，功能更强大。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#106;&#x79;&#109;&#x65;&#x73;&#115;&#x69;&#x40;&#49;&#54;&#51;&#46;&#99;&#111;&#109;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git-版本控制工具]]></title>
    <url>%2F2018%2F11%2F25%2FGit-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[版本控制工具的发展： git 是分布式版本控制系统，能记录所有文件的所有版本，并有效地追踪文件的变化，也容易回滚到文件之前的状态。 1.安装与配置①下载 git 下载地址：https://git-scm.com/downloads 然后按默认选项安装即可 ②验证安装 打开命令行 输入 git 如果出现上图内容 说明安装成功 ③配置用户信息 安装好 git 后，需要配置用户信息(绑定 GitHub 用户名 和邮箱)。 2.Git 仓库 仓库又名版本库，英文名是 repository，可以将之理解为一个目录，目录中的所有文件都可被 git 管理。每个文件的修改、删除等操作都可以被 git 追踪。 git 仓库的相关操作： 12345678910111213141516171819202122pwd: 查看目前位置。cd 文件夹名: 进入该目录。cd ..: 进入上级目录。git init: 初始化版本库。git add: 添加文件到暂存区。git commit: 将文件从暂存区提交到仓库。git status: 查看仓库状态信息。ll: 展示当前目录的详细信息，等价于ls -l。ls -a: 展示隐藏和非隐藏文件。 一般点开头的文件都是隐藏文件。 创建仓库详情: mkdir test // 创建test目录。 cd test // 进入test目录。 git init // 初始化版本库。 ll // 目录为空。 ls -a // 展示.git隐藏目录。 echo &quot;......&quot; &gt;&gt; test.txt // 将&apos;......&apos;追加到test.txt文件中。 cat test.txt // 展示当前文件内容。 git add test.txt // 添加文件到版本库(即本地暂存区)。 git commit -m &quot;repo first commit&quot; // 提交到仓库中，&quot;repo first commit&quot;为本次提交的描述信息。 git status // 查看仓库状态。 3.Git 工作流 原理分析：当工作区使用 git add 命令将修改后的文件提交到暂存区时，暂存区中的文件将会被提交到 object 文件目录中，index 的指针也会指向 object 文件目录中的新文件 id。执行 git commit 命令后，master 分支更新，其中的指针也会指向 object 文件目录中的新文件 id。 ①暂存区到工作区的回滚 一般开发完成但还没有测试的文件都会被提交到暂存区 如果不想要暂存区的最新版本 可以直接丢弃| git reset HEAD 文件名(将暂存区的内容还原为最后一次提交的内容)| git checkout – 文件名(将工作区的内容还原为最后一次提交的内容) ②已提交版本的回滚 要找到以前的提交版本 需要回滚 我们先创建一次提交： 现在查看 commit 号：git log 此时代码需要回到过去 即将 hard 指针(当前环境的版本指针)修改到某次 commit 上：git reset –hard commit号 回到过去后 使用 git reflog 可以查看”未来”的版本号 ③清空仓库 清空本地仓库： git rm –cache 文件名：删除添加到暂存区的文件 git rm 文件名：同时删除工作区和暂存区的文件 注意：以上所有操作只是提交给本地仓库，并不是 Github。 4.远程仓库 本地仓库：在电脑上的仓库 远程仓库：在公网服务器上的仓库 通过 git push 提交修改到远程仓库时，需要 ssh 连接(连接后每次提交都不需要重新输入密码)。ssh 连接的具体步骤：https://blog.csdn.net/qq_41979043/article/details/83046278 —— 3.安装git 关联远程仓库： 每次可以使用 git push 命令 将本地仓库的 master 分支同步到远程仓库的 master 分支 5.克隆仓库 将远程仓库克隆到本地： 1.Clone with SSH：git clone git@github.com:messi1002/test.git 2.Clone with HTTPS：git clone https://github.com/messi1002/test.git 将远程仓库的文件更新到本地仓库：git pull origin master 6.标签管理 当需要发布新的版本时，需要在版本库中打一个标签(确定该标签对应的版本时刻)。以后想要回滚到某个版本时，可以直接通过标签(版本号)回滚。 新建标签并指定提交信息：git tag -a name -m “comment” 删除标签：git tag -d name 7.分支管理 当我们需要修改正在更新的项目的 bug 时，可以新建一个分支，以已经发布的项目代码为基础，修改 bug 后重新发布代码，最后再将此分支合并到正在开发的分支上。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#121;&#109;&#101;&#115;&#x73;&#x69;&#x40;&#x31;&#54;&#x33;&#x2e;&#x63;&#111;&#109;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用NATAPP进行微信本地开发调试]]></title>
    <url>%2F2018%2F11%2F14%2F%E7%94%A8NATAPP%E8%BF%9B%E8%A1%8C%E5%BE%AE%E4%BF%A1%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[开发环境下，要想与微信后台对接，需要在公网上访问本机服务器 URL 地址(只能使用 80 端口 / 443 端口)。因此，需要用映射工具将本机地址映射到公网上。 1.使用NATAPP①购买隧道 地址：https://natapp.cn/ 注册之后 点击 登录 然后购买隧道| 注意：免费隧道在每次启动窗口时都会更换映射地址。 &emsp;&emsp; 填写 80 端口 / 443 端口(微信仅支持这两个端口号) &emsp;&emsp; 然后进入刚刚购买的隧道 记住你的 authtoken ②映射 下载客户端 &emsp;&emsp; 新建一个 config.ini 文件 内容如下| 将 authtoken 字段的值修改为刚刚购买的隧道的 authtoken。 12345678#将本文件放置于natapp同级目录,程序将读取[default]段。#在命令行参数模式如 natapp -authtoken=xxx 等相同参数将会覆盖掉此配置。[default]authtoken=你的authtoken #对应一条隧道的authtoken。clienttoken= #对应客户端的clienttoken,将会忽略authtoken,若无请留空。log=none #log 日志文件,可指定本地文件,none=不做记录,stdout=直接屏幕输出,默认为none。loglevel=ERROR #日志等级DEBUG,INFO,WARNING,ERROR默认为DEBUG。http_proxy= #代理设置 如 http://10.123.10.10:3128 非代理上网用户,请务必留空。 将客户端程序和 config.ini 文件放入同一个文件夹中 启动命令行 进入该文件夹 输入 natapp -authtoken=你的authtoken 即可得到如下结果 &emsp;&emsp; 再注意！！对于免费隧道来说，每次启动 natapp.exe 进行映射时，其外网映射地址都会改变。 ③映射测试 将工程的 Tomcat 端口号改为 80 端口或 443 端口(对应隧道的端口号)| 在 Spring Boot 工程中，按照以下方式修改： &emsp;&emsp; &emsp;&emsp; | 其他工程的修改方式： &emsp;&emsp; 若此时访问 127.0.0.1:80(或localhost:80) 和访问 映射外网:80 是同一个效果，说明映射成功！ 2.微信开发者模式接入①填写服务器配置 服务器地址 URL：所映射的外网地址 / 工程校验代码的访问地址。| 如： http://qc95we.natappfree.cc/weixinA。 Token：开发者随意填写 在接入认证时生成一个签名。| 需要在校验代码中定义一个字符串名为 Token，此字符串值对应所填写内容，具体看下文。 ②验证服务器地址的有效性 开发者提交信息后，微信服务器会发送 GET 请求到填写的服务器地址 URL 上，GET 请求携带以下四个参数。 &emsp;&emsp; signature 微信加密签名 &emsp;&emsp; timestamp 时间戳 &emsp;&emsp; nonce 随机数 &emsp;&emsp; echostr 随机字符串 需要开发者将 token、timestamp、nonce 这三个参数进行排序，再拼接成字符串并对其进行 sha1 加密，再将加密后的字符串与微信加密签名( signature )进行对比，两个字符串相同时(可标识该 GET 请求来自微信服务器)返回 echostr 参数内容，此时开发者接入成功。 ③具体代码 我在 Spring Boot 工程中配置了 Servlet 校验代码。如果你不想在 Spring Boot 工程中测试，可以在其他 web 应用的 web.xml 文件中自行配置 Servlet。只是配置文件不同，校验代码都相同。 工程目录结构如下： &emsp;&emsp; 附上我的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package com.example.springbootdemo.config;import com.example.springbootdemo.util.CheckUtil;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * @Auther: wjy * @Date: 2018/12/4 20:56 * @Description: 获得参数。 */public class WeixinServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; request.setCharacterEncoding("UTF-8"); response.setCharacterEncoding("UTF-8"); PrintWriter out = response.getWriter(); String echostr = request.getParameter("echostr"); String signature = request.getParameter("signature"); String timestamp = request.getParameter("timestamp"); String nonce = request.getParameter("nonce"); if (CheckUtil.check(timestamp, nonce, signature) == true) out.print(echostr); &#125;&#125;--------------------------------------------------------------------------------package com.example.springbootdemo.util;import java.security.MessageDigest;import java.util.Arrays;/** * @Auther: wjy * @Date: 2018/12/4 21:57 * @Description: 开发者校验。 */public class CheckUtil &#123; public static String token = "weixinAAAA"; /* * 按照微信公众号平台要求校验。 */ public static boolean check(String timestamp, String nonce, String signature) &#123; String[] string = new String[]&#123;timestamp, nonce, token&#125;; String s = new String(); String encrypt = null; Arrays.sort(string); for (int i = 0; i &lt; string.length; i++) s += string[i]; encrypt = getSha1(s); System.out.println(encrypt); if (encrypt.equals(signature)) return true; else return false; &#125; /* * 加密。 */ public static String getSha1(String decript) &#123; if(decript == null | decript .length() == 0) return null; char hexDigits[] = &#123;'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'&#125;; try &#123; MessageDigest mdTemp = MessageDigest.getInstance("SHA1"); mdTemp.update(decript.getBytes("UTF-8")); byte[] md = mdTemp.digest(); int j = md.length, k = 0; char buf[] = new char[j*2]; for (int i = 0; i &lt; j; i++) &#123; byte byte0 = md[i]; buf[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf]; buf[k++] = hexDigits[byte0 &amp; 0xf]; &#125; return new String(buf); &#125; catch (Exception e) &#123; return null; &#125; &#125;&#125;--------------------------------------------------------------------------------package com.example.springbootdemo.servlet;import com.example.springbootdemo.config.WeixinServlet;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;import org.springframework.context.annotation.Bean;/** * @Auther: wjy * @Date: 2018/12/4 21:33 * @Description: SpringBoot中的Servlet配置。 */@SpringBootApplicationpublic class ServletConfig extends SpringBootServletInitializer &#123; public static void main(String[] args) &#123; SpringApplication.run(ServletConfig.class, args); &#125; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(ServletConfig.class); &#125; // 注册Servlet。 @Bean public ServletRegistrationBean wexinA() &#123; return new ServletRegistrationBean(new WeixinServlet(), "/weixinA"); &#125;&#125; ④映射调试 此时可通过 映射地址/wenxinA 或 localhost:80/weixinA 访问这个 Servlet| 注意：因为访问此校验代码需要传入四个参数，所以如下直接访问时，控制台报出的空指针异常，不是配置的问题！！ &emsp;&emsp; &emsp;&emsp; 将可以访问 Servlet 的 URL 配置到微信公共平台的服务器 URL 一栏 最后再填写 Token 对应的值| 我的校验代码中，Token 字符串的值为 wenxinAAAA。 &emsp; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#121;&#109;&#101;&#x73;&#x73;&#105;&#64;&#x31;&#54;&#x33;&#x2e;&#x63;&#111;&#109;]]></content>
      <categories>
        <category>微信开发</category>
      </categories>
      <tags>
        <tag>外网映射——NATAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识微信公众号开发]]></title>
    <url>%2F2018%2F11%2F11%2F%E5%88%9D%E8%AF%86%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[1.了解微信公众号①明确概念 公众号与微信聊天的区别 公众号类型介绍| 企业号：消息出现在好友会话列表首层、每分钟最多群发 200 条消息、通讯录关注、支持保密消息。| 服务号：消息出现在好友会话列表首层、每周最多群发一条消息、查找关注。| 订阅号：支持个人申请、每天最多群发一条消息、查找关注、不支持高级接口权限。 以下内容，仅针对订阅号。 ②申请公众号 注册地址：微信公众平台 微信公众平台是腾讯为了让用户申请和管理微信公众账号而推出的一个 web 平台。 登记信息 填写账号名称和功能介绍 个性化公众号 ③功能模块 可群发文字、图片、语音、视频或图文消息(每天 1 条) 自动回复| 被添加自动回复| 固定自动回复(每小时提示一次)| 关键词自动回复(灵活) 自定义菜单| 最多三个 1 级菜单| 最多五个 2 级菜单 投票功能(文章中加入) … ④管理模块 消息管理(回复消息) 用户管理(管理已关注的用户) 素材管理(保存公众号的群发内容) ⑤编辑模式 微信公众号开发的模式之一——编辑模式。 所谓编辑模式 就是在官网网页上操作基本功能 添加被关注自动回复 &emsp; 根据服务功能设置关键字回复(关注中英文差异) &emsp; 素材管理| 单图文消息可显示摘要，多图文消息只显示标题。| 如下为多图文消息： &emsp; 自定义菜单| click 类型(发送消息)| view 类型(跳转到网页) &emsp; &emsp; 群发消息(每天 1 次) 2.开发前奏①开发准备 开发环境下，要想与微信后台对接，需要在公网上访问本机服务器 URL 地址(只能使用 80 端口 / 443 端口)。因此，需要用映射工具将本机地址映射到公网上。 一个微信公众号 外网映射工具(开发调试) ②映射工具 ngrok：服务器在国外、访问速度慢、每次映射地址不同(现在国内有很多使用它的方法)。 tunnel：部署在国内、支持 ngrok 的绝大数功能(现在不可用)。 正在使用 NATAPP.cn，教程见用NATAPP进行微信本地开发调试—1。 ③访问模式 映射成功后，使用以下格式进行公网访问。 本地访问：http://localhost:8080/Test/index.jsp 对应的公网访问：(映射公网)/Test/index.jsp 3.开发模式 微信公众号开发的模式之一——开发模式。注意：开发模式和编辑模式是互斥关系，两者的设置不共存。只能使用一种模式，选择之后公众号会应用该模式的所有设置。 ①数据交互原理 如下所示： &emsp; 其中，微信公众号服务器就是我们在开发模式下需要开发的内容。 ②开发模式接入 具体操作参见：用NATAPP进行微信本地开发调试—2 通过之前的操作 我们已经进入了开发模式 启用了开发模式 编辑模式的设置会自动失效| 此时编辑模式下的自动回复和菜单栏都跑了。 &emsp; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#x79;&#x6d;&#x65;&#x73;&#x73;&#105;&#64;&#x31;&#54;&#51;&#x2e;&#99;&#x6f;&#x6d;]]></content>
      <categories>
        <category>微信开发</category>
      </categories>
      <tags>
        <tag>微信公众号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目管理利器-maven]]></title>
    <url>%2F2018%2F11%2F01%2F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%88%A9%E5%99%A8-maven%2F</url>
    <content type="text"><![CDATA[maven 是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型(POM)的概念，它可以从一个中心资料片管理项目构建、报告和文件。它也是一套强大的自动化构建工具，覆盖了编译、测试、运行、清理、打包和部署等整个项目构建的周期。并且它提供了一个仓库的概念，可以统一地管理项目所依赖的第三方 jar 包。 1.安装 maven①下载 maven 下载地址：https://maven.apache.org/download.cgi 然后解压压缩包 ②安装目录介绍 ③配置环境变量12M2_HOME: D:\apache-maven-3.5.4(安装目录)path: %M2_HOME%\bin 注意：%环境变量% 相当于引用这个环境变量的路径。 配置完 path 环境变量后，需要重启命令行(重新加载环境变量)。 ④验证配置 mvn -v 命令：查看 maven 版本 如果出现上图文字 说明安装成功 2.第一个 maven 项目①目录结构 使用 maven 管理的 Java 项目都有着相同的项目结构(强制) ②编写代码 编写 “Hello Maven!” 类： 123456public class HelloMaven &#123; public String say() &#123; return "Hello Maven!"; &#125;&#125; 编写测试类： 123456789101112import org.junit.Assert.*;import org.junit.*;public class HelloMavenTest &#123; // 表明该方法为测试方法。 @Test public void test() &#123; // 检验new HelloMaven().say()的返回值是否为"Hello Maven!"。 Assert.assertEquals("Hello Maven!", new HelloMaven().say()); &#125;&#125; 目录结构如下： ③新建 pom.xml 文件 pom.xml：用于管理项目依赖和构建过程(维护当前项目的 jar 包)。 写完代码后 还需要 pom.xml 文件管理项目的依赖 新建 pom.xml 文件 并将之移至项目根目录 1234567891011121314151617181920212223242526272829&lt;!-- 以下文字:&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 组织名 --&gt; &lt;groupId&gt;wjy-maven1&lt;/groupId&gt; &lt;!-- 模块名 --&gt; &lt;artifactId&gt;maven1-model&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 导入junit依赖(测试框架) --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 增加jdk的设置 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt;&lt;/project&gt; !--&gt; ④编译运行(进入项目根目录) mvn compile：编译项目 mvn test：测试运行项目 编译运行后，项目根目录会自动生成一个 target 目录，里面存放着测试报告、编译生成的 class 文件等。 3.核心知识①常用构建命令 mvn -v：查看 maven 版本 mvn clean：清理上一次构建生成的所有文件 mvn compile：编译 mvn test：测试运行 mvn package：将项目打包 mvn install：安装 jar 包到本地仓库 若要在 a 包的类中导入 b 包类，一般需要把包含 b 包类的 jar 包加入到 classpath 路径中。而 maven 为我们提供了更方便的方法：在 b 包的根目录下，我们使用 mvn install 命令将包含其所有类的 jar 文件发布到本地仓库中，然后在 a 包的 pom.xml 文件中添加 b 包的坐标，之后 maven 会自动帮我们进行依赖管理操作。原理：在编译源代码时，若程序用到了其他的包，maven 会在 pom.xml 文件中查找程序是否引入了该包的坐标。若是已经引入，maven 会在本地仓库中查找其对应的 jar 包并添加到 classpath 路径中，若是没有找到 jar 包，maven 会上网在中央仓库中下载 jar 包并放入本地仓库。若是没有引入，则返回异常信息。 ②自动创建目录结构 archetype 插件：用于自动创建符合 maven 规定的目录结构| 目录结构详情见 2-① 创建目录结构的两种方式： 1.输入 mvn archetype:generate -DarchetypeCatalog=internal 后按照命令行提示进行创建： 2.一次性写入以下代码： 1234mvn archetype:generate -DarchetypeCatalog=internal -DgroupId=wjy-maven02 -DartifactId=maven02-model -Dversion=1.0-SNAPSHOT -Dpackage=maven02.model# groupId: 组织名，一般为公司网址的反写-项目名。# artifactId: 一般为项目名-模块名，它是maven项目在组织中的唯一标识。# package: 代码所存在的包名，应该和groupId名、artifactId名相吻合。 ③坐标 在 maven 中，任何一个依赖、插件、项目构件的输出都可被称为构件。所有构件都通过坐标作为其唯一标识。&lt;groupId&gt;、&lt;artifactId&gt;、&lt;version&gt; 组成了 maven 的基本坐标。 ④仓库 仓库：用来管理项目的依赖。 a.本地仓库 在本地仓库中找不到项目所需要的构件时 会自动到远程仓库中查找并下载 b.远程仓库 远程仓库：即全球中央仓库 地址为 https://repo.maven.apache.org/maven2 远程仓库中包含了绝大多数开源的 Java 项目 但访问速度较慢(访问量大、且在国外) c.镜像仓库 镜像仓库：与全球中央仓库的功能相同 可以将默认的远程仓库改为国内的镜像仓库(访问速度更快、更稳定) 修改方法(将下列内容添加到 settings.xml 文件中)： 12345678&lt;!--设置镜像仓库为阿里云--&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;!-- 为中央仓库配置镜像。 --&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;&lt;/mirror&gt; 修改后 访问远程仓库的操作会转为访问镜像仓库 d.更改仓库默认位置 maven 的本地仓库默认存放在 C 盘中(占用 C 盘内存！) 修改上文的 settings.xml 文件 可以更改本地仓库的位置 然后在 maven 项目下执行 mvn clean compile 命令 会更新本地仓库的位置 最后将 setting.xml 文件放入新仓库中 防止 maven 升级后需要重新配置此文件 4.项目构建过程①项目构建与插件 完整的项目构建过程包括：清理(clean)、编译(compile)、测试(test)、打包(package)、集成测试、验证、部署(deploy)等。maven 和插件是密不可分的，maven 抽象出一套项目构建的生命周期，而插件是对 maven 抽象的具体实现，即 maven 中的所有命令都是调用插件实现的。在 maven 官网中，提供了很多插件。插件地址：https://mvnrepository.com/open-source/maven-plugins ②生命周期 maven 定义了三套相互独立的生命周期(clean、default、site)，每套生命周期包含一些有顺序的阶段，后面的阶段依赖于前面的阶段。即执行某个阶段时，其之前同一周期的阶段会顺序执行，如执行 package 命令时，complie、test 命令会自动顺序执行。 在 IDEA 中 pom.xml 文件会自动导入与生命周期有关的插件 a.clean—清理项目 pre-clean：执行清理前的工作 clean：清理上一次构建生成的所有文件 post-clean：执行清理后的工作 b.default(最核心)—构建项目 compile：编译 test：测试 package：打包 install：安装 jar 包到本地仓库 c.site—生成项目站点 pre-site：在生成项目站点之前要完成的工作 site：生成项目的站点文档 post-site：在生成项目站点之后要完成的工作 site-deploy：将生成的站点发布到服务器上 5.pom.xml 详解①pom pom 是 maven 项目的核心管理文件，用于项目描述、组织管理、依赖管理和构建信息的管理。方便的第三方框架的管理和便捷的项目构建过程，大大提高了工作效率。 ②pom 常用元素1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!-- project是pom.xml文件的根元素，包含了一些约束信息。 --&gt;&lt;project&gt; &lt;!-- modelVersion为必须元素，指定了当前文件的版本。 --&gt; &lt;modelVersion&gt;&lt;/modelVersion&gt; &lt;!-- 坐标信息: --&gt; &lt;!-- maven项目与实际项目不同，maven项目体现了模块化的概念，一个实际项目往往被划分为多个模块。 --&gt; &lt;!-- groupId为主项目标识，一般为反写的公司网址+项目名。 --&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;!-- artifactId为实际项目中的一个模块，一般为项目名+模块名。 --&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;!-- version为当前项目的版本号。 第一个0是大版本号，第二个0是分支版本号，第三个0是小版本号，如0.0.1。 napshot: 快照版、alpha: 内测版、beta: 公测版、Release: 稳定版、GA: 正式版。 --&gt; &lt;version&gt;&lt;/version&gt; &lt;!-- package为maven项目的打包方式，默认打包为war，也可以是jar、zip、pom等。 --&gt; &lt;packaging&gt;&lt;/packaging&gt; &lt;!-- name为项目的描述名，产生项目文档时才会使用。 --&gt; &lt;name&gt;&lt;/name&gt; &lt;!-- url为项目地址。 --&gt; &lt;url&gt;&lt;/url&gt; &lt;!-- description为项目描述。 --&gt; &lt;description&gt;&lt;/description&gt; &lt;!-- developers为开发人员列表。 --&gt; &lt;developers&gt;&lt;/developers&gt; &lt;!-- licenses为许可证信息。 --&gt; &lt;licenses&gt;&lt;/licenses&gt; &lt;!-- organization为组织信息。 --&gt; &lt;organization&gt;&lt;/organization&gt; &lt;!-- dependencies为依赖列表，其下包含多个依赖项(dependency)，一个坐标唯一标识一个依赖项。 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;type&gt;&lt;/type&gt; &lt;!-- optional设置该依赖是否可选，默认为false。若为true，项目必须显式引入该依赖，若为false，项目默认继承该依赖。 --&gt; &lt;optional&gt;&lt;/optional&gt; &lt;!-- 依赖范围。 --&gt; &lt;scope&gt;&lt;/scope&gt; &lt;!-- exclusions是排除依赖传递的列表。 --&gt; &lt;exclusions&gt; &lt;exclusion&gt;&lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- dependencyManagement为依赖的管理，主要定义在父模块中，供子模块继承。 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!-- 对构建行为提供一个支持。 --&gt; &lt;build&gt; &lt;!-- 插件列表: --&gt; &lt;plugins&gt; &lt;!-- 一个坐标唯一标识一个插件。 --&gt; &lt;plugin&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!-- 用于子模块中，是对父模块的一个继承。 --&gt; &lt;parent&gt;&lt;/parent&gt; &lt;!-- 用来聚合多个maven项目，使多个maven模块可以一起编译并运行。 --&gt; &lt;modules&gt;&lt;/modules&gt;&lt;/project&gt; 6.依赖①依赖范围 关于 &lt;scope&gt;&lt;/scope&gt; 12345678910&lt;!-- 平时开发时，若使用某一框架，就要将该框架的jar包引入到项目的classpath路径中，这样项目就可以使用该框架为我们封装好的一些方法。而maven为我们提供了三种classpath，分别为编译、测试、运行(时有效)，依赖的范围就是用来控制依赖与三种classpath的关系的。 scope标签的值有六种，分别为: compile(测试、编译和运行时都有效，默认选项)、 provided(测试、编译时有效，适用于一些web容器中已经包含的jar(运行时不需要再引入)，如servlet)、 runtime(测试、运行时有效，适用于JDBC驱动，项目主代码的编译只需要jdk提供的JDBC的API，只有测试或运行时才需要具体驱动的API)、 test(测试时有效，如junit测试框架)、 system(测试、编译时有效，但具有不可移植性，需要与本地系统相关联)、 import(导入，它只使用在dependencyManagement标签中，表示从其它的pom中继承过来的依赖)。 --&gt; 将 A 中的依赖导入到 B 中 12345678910111213141516171819&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;WJY-Test&lt;/groupId&gt; &lt;artifactId&gt;Test-B&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;name&gt;B&lt;/name&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;WJY-Test&lt;/groupId&gt; &lt;artifactId&gt;Test-A&lt;/artifactId&gt; &lt;type&gt;pom&lt;/type&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; ②排除依赖传递123456789101112131415161718192021&lt;!-- exclusions是排除依赖传递的列表。 若模块C依赖模块B的jar，模块B依赖模块A的jar，模块A对模块C来说就是传递依赖，默认模块C也会依赖模块A的jar。 若模块C不想依赖模块A的jar，可以使用这个标签，在模块C的pom.xml文件中添加以下内容便可排除模块A的依赖。 --&gt; &lt;!-- 此时模块C只依赖模块B的jar。 --&gt; &lt;dependency&gt; &lt;groupId&gt;WJY-Maven&lt;/groupId&gt; &lt;artifactId&gt;Mavan-B&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 排除依赖。 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;WJY-Maven&lt;/groupId&gt; &lt;artifactId&gt;Maven-A&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- 注意: 先要将模块A的jar发布到本地仓库中，模块B才能通过坐标在本地仓库中找到模块A的jar，再将模块B的jar发布到本地仓库中，模块C才能通过坐标在本地仓库中找到模块B的jar。 --&gt; ③依赖冲突 如果 A 和 B 分别有不同版本的相同构件，而 C 同时依赖于 A 和 B，此时会发生依赖冲突。 解决依赖冲突的两个原则： 1.短路优先—优先解析路径短(依赖级数少)的版本 2.如果路径相同 则看依赖的先后(先声明依赖哪个 就选择哪个依赖的版本) ④聚合 聚合：在 maven 中，将多个项目(模块)放在一起运行。聚合时，需要新建一个 maven 项目(父模块)，新建项目的 pom 将作为其他 pom 的容器。 1234567891011121314151617&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 作为其他pom的容器。 --&gt; &lt;groupId&gt;WJY-Maven&lt;/groupId&gt; &lt;artifactId&gt;Maven-0&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;!-- 此pom项目里不执行任何代码，只是为了聚合或传递依赖。--&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;!-- 用来聚合多个maven项目，使多个maven模块可以一起编译并运行。 --&gt; &lt;!-- 聚合后，还需要引入这些maven项目的依赖！ --&gt; &lt;modules&gt; &lt;module&gt;../Maven-1&lt;/module&gt; &lt;module&gt;../Maven-2&lt;/module&gt; &lt;module&gt;../Maven-3&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; ⑤继承123456&lt;!-- dependencyManagement为依赖的管理，可以声明依赖列表，但不会被引入到实际依赖中。主要定义在父模块中，供子模块继承(继承版本号等信息)。 即若多个模块都包括同一个依赖，可以抽象出来一个父模块，在父模块中对其进行一个定义，其他子模块只需要继承即可。 注意: 子模块还是需要显式地声明依赖。 优点: 如果有多个子模块都需要引用同样的依赖，则此标签可以避免在每个子模块中重复声明版本号等信息，便于整体修改。如果某个子模块需要其他版本，只需要单独声明version。 --&gt; 父 pom.xml 中： 12345678910111213141516171819202122&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;WJY-Maven&lt;/groupId&gt; &lt;artifactId&gt;Maven-1&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;junit.version&gt;4.11&lt;/junit.version&gt; &lt;/peoperties&gt; &lt;!-- 要被继承的依赖: --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 子 pom.xml 中： 123456&lt;parent&gt; &lt;!-- 父坐标: --&gt; &lt;groupId&gt;WJY-Maven&lt;/groupId&gt; &lt;artifactId&gt;Maven-1&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; 7.IDEA 中使用 maven 构建 web 项目①新建工程 注意：模板 maven-archetype-quickstart 的目录结构如下图所示，应该根据需要选择合适的模板。 ②创建目录结构 在 src/main 目录下新建 java 目录 将 java 目录作为 Sources Root 在 src/main 目录下新建 resources 目录 将 resources 目录作为 Resources Root 在 src/test 目录下新建 java 目录 将 java 目录作为 Test Sources Root 在 src/test 目录下新建 resources 目录 将 resources 目录作为 Test Resources Root 目录结构如下： ③配置 tomcat 新建 tomcat： tomcat 热部署： ④运行 tomcat 如果出现上图内容 说明配置成功 ⑤IDEA 中管理 maven 的生命周期 修改以下部分 并新增工程入口类 使用 package 命令 可以将工程打包 ⑥运行 jar 包 用 360压缩 打开 jar 包 编辑 MANIFEST.MF 文件 添加划线部分 保存并退出 在命令行运行 jar 包 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#x79;&#x6d;&#x65;&#115;&#x73;&#x69;&#x40;&#x31;&#x36;&#x33;&#46;&#x63;&#x6f;&#109;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录GitHub+Hexo搭建博客过程]]></title>
    <url>%2F2018%2F10%2F04%2F%E8%AE%B0%E5%BD%95GitHub-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1.next 主题使用文档 官方文档 2.使用基础①常用技巧 hexo 命令 出错时 可使用 hexo –debug 查看错误 安装插件命令是 install 卸载插件命令是 uninstall hexo clean：清除缓存文件和已生成的静态文件(public) 每次更新修改：| hexo g：重新生成缓存和静态文件。| hexo d/deploy：重新部署到服务器。 在博客文章中插入图片：点击查看| 注意：对于 next 主题，引入图片时使用 ![图片代替名](图片名.jpg) 的格式。 ②修改根目录下的 _config.yml 文件123456title: # 你的标题subtitle: # 副标题description: # 网站描述，便于搜索引擎用关键词检索。author: wjy # 作者language: # 语言timezone: Asia/Shanghai ③添加 about 等页面 使用此命令：hexo new page about| 会看到在 source 文件夹中生成了一个 about 文件夹，里面包含一个 index.md 文件。| 在这个 markdown 文件内，我们可以编写一些 about 页面的信息。 然后修改主题目录下的 _config.yml 文件 在 menu 中添加 about 页面的链接 添加其他页面同理，下列文字是为 next 主题配置页面链接。 12345678910menu: home: / || home archives: /archives/ || archive tags: /tags/ || tags categories: /categories/ || th 最爱: /love/ || soccer-ball-o 电影: /movies/ || film 书籍: /books/ || book 旅行: /photos/ || camera-retro about: /about/ || user 配置后会在页面菜单中生成一个关于 about 页面的链接 点击 about 就可跳转到 about 页面 ④写文章时添加分类、标签格式123456categories:- 分类1 - 分类2tags:- 标签1- 标签2 3.我的博客配置 我的博客：http://messi1002.top 语言：zh-Hans(中文) √ ①侧边栏 侧边栏排版(签名)及头像 √ 侧边栏作者头像旋转 √ 配置侧边栏中的社交账号及其图标 √ 侧边栏推荐阅读 √ DaoVoice 在线联系功能 √ 添加 RSS 订阅 √ ②网站主页 菜单栏优化及签名 √ 添加顶部加载条 √ 修改网页 icon √ 首页不显示全文 √ 添加 fork me on github √ 增加动态线段背景 √ 爆炸效果图 √ 增加宠物 √ 隐藏网页底部的 … By Hexo √ 文章添加阴影效果(好看) √ 修改网页底部的星星 √ 网站底部访问量统计 √ 网站底部字数统计 √ 博文置顶 √ 修改内容宽度 √ 添加博客背景 √ 设置站点图标 √ ③网站功能 添加本地搜索 √ 添加评论功能(来必力) √ 添加打赏功能 √ 添加 README.md 文件 √ 引入豆瓣电影和读书 √ 引入相册功能(两个) √| 最爱页—使用 GitHub 存放图片(简单)| 旅行页—使用阿里云存放图片(速度) ④文章细节 文章内容统计功能 √ 在文章底部增加版权信息 √ 修改文章内链接文本样式 √ 修改文章底部的带 # 号的标签 √ 添加热度 √ 代码高亮 √ 文章加密访问 √ 配置教程参考：Next主题配置博客 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#121;&#x6d;&#x65;&#115;&#x73;&#x69;&#64;&#x31;&#54;&#x33;&#46;&#x63;&#111;&#x6d;]]></content>
      <categories>
        <category>博客相关</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb入门之Servlet]]></title>
    <url>%2F2018%2F09%2F27%2FJavaWeb%E5%85%A5%E9%97%A8%E4%B9%8BServlet%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb入门之JSP]]></title>
    <url>%2F2018%2F09%2F25%2FJavaWeb%E5%85%A5%E9%97%A8%E4%B9%8BJSP%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java进制转换及位运算]]></title>
    <url>%2F2018%2F09%2F20%2FJava%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%8F%8A%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[1.进制①进制相关 在线进制转换工具：https://tool.lu/hexconvert/ 进位制是一种记数方式，亦称进位计数法或位值计数法。它是人们为计数和运算方便而约定的计数系统。 把一个数表示成 a 与 10 的 n 次幂相乘的形式（1 ≤ |a| &lt; 10，n 为整数），这种记数的方法叫做科学记数法。 使用的数字符号的数目称为这种进位制的基数或底数。 位权：一个数码在不同的位置上所代表的值不同、且不同的进位制，处于同一数位上的权也是不同的。 例如：十进制第 2 位的位权为 10，第 3 位的位权为 100、而二进制第 2 位的位权为 2，第 3 位的位权为 4。 ②进制转换 进位制 基本数字 进位规则 应用 标志的开头 二进制 0 ~ 1 二进一 计算机内部采用二进制，其运算简单，简化了计算机结构 0b / 0B 八进制 0 ~ 7 八进一 适用于12位和36位计算机系统 0 十进制 0 ~ 9 十进一 日常生活中使用 无 十六进制 0 ~ 9和A、B、C、D、E、F(15) 十六进一 长度短 0x / 0X 进制表： ​​​​ 十进制转换为 二 / 八 / 十六 进制 对于整数：采用重复相除权再倒看余数的方法 对于小数：采用重复相乘权再正看 “余数” 的方法 二 / 八 / 十六进制采用科学计数法按对应权展开可得十进制数： ③JDK 内置的进制转换 1234567891011121314151617181920212223242526272829303132333435363738394041424344package object.base;/** * @author: wjy * @date: 2018/10/08 * @description: JDK内置的进制转换 */public class javaSystem &#123; public static void main(String[] args) &#123; // 10进制转换为其他进制 // 10进制转换为2进制：1100 System.out.println(Integer.toBinaryString(12)); // 10进制转换为8进制：14 System.out.println(Integer.toOctalString(12)); // 10进制转换为16进制：14 System.out.println(Integer.toHexString(20)); // 其他进制转换为10进制 // 2进制转换为10进制：1*2^2+1*2^0=5 System.out.println(Integer.parseInt("0101",2)); System.out.println(Integer.valueOf("0101",2).toString()); // 8进制转换为10进制：1*8^2+2*8^1+3*8^0=83 System.out.println(Integer.parseInt("0123",8)); System.out.println(Integer.valueOf("0123",8).toString()); // 16进制转换为10进制：15*16^3+15*16^2+15*16^1+15*16^0=65535 System.out.println(Integer.parseInt("FFFF",16)); System.out.println(Integer.valueOf("FFFF",16).toString()); // 打印为十进制数字123 System.out.println(123); // 打印为十进制数字5(其中0101是2进制数字，0b标识0101为2进制) System.out.println(0b0101); // 打印为十进制数字5(其中0101是2进制数字，0B标识0101为2进制) System.out.println(0B0101); // 打印为十进制数字83(其中123是8进制数字，0标识123为8进制) System.out.println(0123); // 打印为十进制数字291(其中123是16进制数字，0x标识123为16进制) System.out.println(0x123); // 打印为十进制数字291(其中123是16进制数字，0X标识123为16进制) System.out.println(0X123); &#125;&#125; 2.二进制数据的表示方法 ps：Java 中整型（int型）是 32 位的。 ①原码 原码表示法：最高位为符号位，其余位表示数值的大小。 使用 0 表示正数、1 表示负数 [+1]原 = 0000 0001 [-1]原 = 1000 0001 优点：表达简单明了、易于理解 缺点： 有歧义（0 既可以用 00 表示，也可以用 10 表示） 当两个操作数的符号不同时，运算十分复杂 ②反码 正数的反码是其本身 [+1] = [00000001]原 = [00000001]反 负数的反码等于原码除符号位外按位取反 [-1] = [10000001]原 = [11111110]反 ③补码 正数的补码是其本身 [+1] = [00000001]原 = [00000001]反 = [00000001]补 负数的补码等于反码加 1 [-1] = [10000001]原 = [11111110]反 = [11111111]补 ④原码、补码和反码之间的关系 因为原码表示法对于零的表示有歧义且其减法运算复杂，所以引入了补码表示法。虽然补码表示法在一定程度上解决了这两个问题，但是其在计算补码的过程中引进了减法操作。 解决方法：引进反码表示法。先由原码计算出反码，再由反码计算出补码，即可消除直接通过原码求补码时引入的减法操作。 在计算机中，数据都是以补码的形式存储的。 0 的反码和补码都为零 3.位运算 ps：程序中所有的数在内存中都是以二进制的形式存储的，位运算是直接对二进制位进行的位操作。二进制位运算的优点：计算方便，速度快，被支持面广。 ①运算符 运算 功能 举例 应用/规律 按位与(&amp;) 两位全为1，结果才为1 6(00000110) &amp; 3(00000011) = 2(00000010) a.清零(若要将一个单元清零，只要与一个各位都为0的数值相与即可) b.取一个数中的指定位(找一个数，对应x要取的位，该数的对应位为1，其余位为0，此数与x进行与运算即可得到x中的指定位) 按位或(|) 只要有一个为1，结果就为1 6(00000110) | 3(00000011) = 7(00000111) 用来对一个数据的某些位置1(找一个数，对应x要置1的位，该数的对应位为1，其余位为0，此数与x进行或运算即可使x中的某些位置1) 异或运算(^) 两个相应位为”异”，则该位结果为1，否则为0 6(00000110) ^ 3(00000011) = 5(00000101) a.与0相异或，可保留原值 b.使特定位翻转(找一个数，对应x要翻转的位，该数的对应位为1，其余位为0，此数与x对应位异或即可) 取反运算(~) 对一个二进制数按位取反，0变1，1变0 ~6(00000110) = -7(11111001) 补码(11111001)-1 -&gt; 得到反码(11111000)，除符号位外各位取反 -&gt; 得到原码-7(10000111) 左移运算(&lt;&lt;) 将一个数的各二进制位全部左移指定的位数，右边补0 3(00000011) &lt;&lt; 2 = 12(00001100) 若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2 右移运算(&gt;&gt;) 将一个数的各二进制位全部右移指定的位数，正数左补0，负数左补1 3(00000011) &gt;&gt; 1 = 1(00000001) 若操作数为正数，则每右移一位，相当于该数除以2 无符号右移运算(&gt;&gt;&gt;) 将一个数的各二进制位全部右移指定的位数，左边补0 3(00000011) &gt;&gt;&gt; 1 = 1(00000001) 若操作数为正数，则每右移一位，相当于该数除以2 ②两个变量交换值的方法 借助第三个变量来实现 C = A、A = B、B = C 利用加减法实现两个变量的交换 A = A + B、B = A - B、A = A - B 用位异或运算来实现（效率最高） 原理：利用一个数异或本身等于 0 和异或运算符合交换律 举例：A = A ^ B、B = A ^ B、A = A ^ B 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#x79;&#109;&#101;&#x73;&#x73;&#x69;&#64;&#49;&#x36;&#51;&#46;&#99;&#x6f;&#x6d;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Markdown]]></title>
    <url>%2F2018%2F09%2F17%2F%E5%85%B3%E4%BA%8EMarkdown%2F</url>
    <content type="text"><![CDATA[1.认识Markdown Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的 HTML 页面。 —— 维基百科 Markdown 的目标是实现易读易写。其语法全由一些符号组成，并且符号的作用一目了然。语法目标：成为一种适用于网络的书写语言。它的语法种类很少，只对应于 HTML 标记的一小部分。理念是能使文档更易读、写和随意更改。 一般 Markdown 编译器的左边是编辑区，右边显示的样式是转换为 HTML 后加上 CSS 样式显示的。 同理在 Hexo 博客中，Markdown 文章需要解析成 HTML 格式，再输出到网页中。 2.Markdown和HTML HTML 是一种发布的格式。 Markdown 是一种书写的格式，其格式语法只涵盖纯文本可以涵盖的范围。 不在 Markdown 涵盖范围之内的标签，都可以直接在文档里用 HTML 撰写。 3.特殊字符自动转换①HTML中 在 HTML 文件内，有些字符需要特殊处理(相当于”转义”)，才能使用。如 &lt; 符号用于起始标签，&amp; 符号用于标记 HTML实体 。要想单纯的显示这两个字符原型，必须要使用实体的形式，即避免它们被当成标签的一部分。 字符实体有三部分：一个 &amp;符号、一个 实体名称 或&emsp; # 和 实体编号 、一个 ; 。如： &lt; == &amp;lt; == &amp;#60; || &amp; == &amp;amp; == &amp;#38; 。链接内、网址名中的 &amp; 也是要转换成实体后，再放到 &lt;a&gt; 标签的 herf 属性中去。 ②Markdown中 而 Markdown 可以让我们自然地书写字符。你只需正常的写，Markdown 编译器会进行判断，然后在生成 HTML 代码时自动转换，无须编写者关注。 即如果使用的 &amp; 是 HTML 字符实体的一部分(即是标识实体的特殊字符时)，它会保留原状，*否则自动转换成 &amp;amp; *。 或如果把使用的 &lt; 作为 HTML 标签的定界符使用，它会保留原状，否则自动转换为其实体名。 4.区块元素①段落与换行 一个 Markdown 段落的前后要有一个以上的空行(即无文本行)。若一行只包含空格和制表符，则该行会被视为空行。 与 HTML 的空格和换行设定一样，不管换(空)多少行(格)，只一个符号有效。可以用 HTML 标签实现多个换行与空格功能。 ②标题 Markdown 支持两种标题的语法，类Setext 和 类atx 形式。 类setext 形式：用底线的形式，=表示一级标题，–表示二级标题。 类Atx 形式：在行首插入1-6个 # ，对应1到6级标题。 作为美观,可以在行尾使用 # 闭合 类atx 样式的标题。 ③区块引用 Markdown 文件中建立一个区块引用，每行的最前面加上 &gt; 。 区块引用可以嵌套(例如：引用内的引用)，只要根据层次加上不同数量的 &gt; 。引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等。 ④列表 Markdown 支持有序列表和无序列表。 无序列表使用 * 、+ 或 - 接一个 空格 作为列表标记。 有序列表则使用 数字 接 . 再接一个 空格 作为列表标记。 如果要在列表项目内放进引用,那就需要缩进：空格 + 两个 Tab 为宜。 1 2 3 1 2 3 ⑤分隔线 在一行中用三个以上的 * 、 - 、 _ 可建立一个分隔线，行内不能有其他东东。也可以在 * 或是 - 中间插入空格。 ps：使用 --- 必须上下行都是空行，防止它作用在文字底部加粗文字。 ⑥表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 5.区段元素①文字链接 123 ②强调 Markdown使用 * 和下划线 _ 作为标记强调文字的符号。 斜体：被一个 * 或 _ 包围的文字，会被转成用 &lt;em&gt; 标签包围。 加粗：用两个 * 或 _ 包围的文字，会被转成用 &lt;strong&gt; 标签包围。 加粗斜体：被三个 * / _ 包围。 删除线：被~~ 包围 / &lt;del&gt; 标签。 强调也可以直接插在文字中间。 但是如果你的 * 和 _ 两边都有空白的话，它们就会被当成普通的符号。 如果要在文字前后直接插入普通的星号或底线，你可以用反斜线。 ③代码 如果要标记一小段行内代码，你可以用 反引号 把它包起来。 如果要标记多行代码： 1**123** 在代码区段内，&amp; 和 &lt; 都会被自动地转成 HTML 实体，这使得插入 HTML 原始代码变得很容易。代码区段中的Markdown 语法不会被转换，它们只是有高亮的普通文本。 ④图片![图片的代替文字](URL) Markdown 没有办法指定图片的宽高。如果需要，可以使用普通的 &lt;img&gt; 标签。 ⑤网址/邮箱链接 用尖括号包起来，Markdown 就会自动把它转成链接。 &lt;http:messi1002.top&gt; ⑥反斜杠 Markdown 支持以下符号前面加上反斜杠来帮助插入普通的符号：即反斜杠可以转义 Markdown 中的特殊字符！ 123456789101112\：反斜线。`：反引号。*：星号。_：底线。。&#123;&#125;：花括号。[]：方括号。()：括弧。#：井字号。+：加号。-：减号。.：英文句点。!：惊叹号。 如果想在行首出现 数字.空格 ，而不生成列表样式，可以在句点前面加上反斜杠。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#x6a;&#121;&#109;&#x65;&#x73;&#x73;&#x69;&#x40;&#49;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#109;]]></content>
      <categories>
        <category>博客相关</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java.math.BigDecimal类的使用]]></title>
    <url>%2F2018%2F09%2F12%2Fjava-math-BigDecimal%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.浮点数的运算 double、float 类型的浮点数在进行运算时会发生精度丢失。 12345678910111213141516171819/** * @Auther: wjy * @Date: 2018/4/15 20:16 * @Description: 浮点数的运算。 */public class BigDecimalTest1 &#123; public static void main(String[] args) &#123; /* * 0.05 + 0.01 = 0.060000000000000005 * 1.0 - 0.42 = 0.5800000000000001 * 4.015 * 100 = 401.49999999999994 * 123.3 / 100 = 1.2329999999999999 */ System.out.println("0.05 + 0.01 = " + (0.05 + 0.01)); System.out.println("1.0 - 0.42 = " + (1.0 - 0.42)); System.out.println("4.015 * 100 = " + (4.015 * 100)); System.out.println("123.3 / 100 = " + (123.3 / 100)); &#125;&#125; 2.BigDecimal[‘desɪm(ə)l] 对象 为了能精确表示和计算浮点数，Java 提供了 BigDecimal 类，该类提供了大量的构造器，可以将不同的基本数值型变量、数字字符串、数字字符数组等转换成一个 BigDecimal 对象。注意：对于浮点数，建议使用基于 String 的构造器 (new BigDecimal(“num”);) 或 BigDecimal.valueOf(double value) 静态方法，以便在不丢失精度的前提下转换成一个 BigDecimal 对象。 new BigDecimal(double value) 构造器也会发生精度丢失 1234567891011121314151617181920212223import java.math.BigDecimal;/** * @Auther: wjy * @Date: 2018/4/15 20:49 * @Description: new BigDecimal(double value)构造器的精度丢失。 */public class BigDecicalTest2 &#123; public static void main(String[] args) &#123; BigDecimal b1 = new BigDecimal("0.01"); // 直接使用new BigDecimal(double value)同样会发生精度丢失。 BigDecimal b2 = new BigDecimal(0.01); BigDecimal b3 = BigDecimal.valueOf(0.01); /* * 0.01 * 0.01000000000000000020816681711721685132943093776702880859375 * 0.01 */ System.out.println(b1); System.out.println(b2); System.out.println(b3); &#125;&#125; BigDecimal 类中的方法： 1234567891011121314151617181920212223242526272829303132333435import java.math.BigDecimal;/** * @Auther: wjy * @Date: 2018/4/15 21:05 * @Description: BigDecimal类中的方法。 */public class BigDecimalTest3 &#123; public static void main(String[] args) &#123; BigDecimal b1 = new BigDecimal("123.4"); BigDecimal b2 = BigDecimal.valueOf(0.4); /* * b1 + b2 = 123.8 * b1 - b2 = 123.0 * b1 * b2 = 49.36 * b1 / b2 = 308.5 * b1 &gt; b2? 1 * b2 &gt; b1? -1 * b1的平方 = 15227.56 * b1的绝对值 = 123.4 * b1和b2中的较小值 = 0.4 * b1和b2中的较大值 = 123.4 */ System.out.println("b1 + b2 = " + b1.add(b2)); System.out.println("b1 - b2 = " + b1.subtract(b2)); System.out.println("b1 * b2 = " + b1.multiply(b2)); System.out.println("b1 / b2 = " + b1.divide(b2)); System.out.println("b1 &gt; b2? " + b1.compareTo(b2)); System.out.println("b2 &gt; b1? " + b2.compareTo(b1)); System.out.println("b1的平方 = " + b1.pow(2)); System.out.println("b1的绝对值 = " + b1.abs()); System.out.println("b1和b2中的较小值 = " + b1.min(b2)); System.out.println("b1和b2中的较大值 = " + b1.max(b2)); &#125;&#125; 3.自定义 Arith 工具类 当程序进行浮点数的运算时，需要先将 double 类型数值包装成 BigDecimal 对象，再调用 BigDecimal 对象的方法执行运算，最后将结果转换为 double 变量。如果代码中需要频繁地进行浮点数的运算，可以将上述步骤封装起来，写成一个 Arith 工具类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.math.BigDecimal;import java.math.RoundingMode;/** * @Auther: wjy * @Date: 2018/4/15 21:37 * @Description: 浮点数运算工具类。 */class BigDecimalArith &#123; // 设置除法运算精度，防止除不尽。 public static final int DEF_DIV_SCALE = 10; // 构造器私有，防止类的实例化。 private BigDecimalArith() &#123;&#125; // 加法。 public static double add(double d1, double d2) &#123; BigDecimal b1 = BigDecimal.valueOf(d1); BigDecimal b2 = BigDecimal.valueOf(d2); return b1.add(b2).doubleValue(); &#125; // 减法。 public static double sub(double d1, double d2) &#123; BigDecimal b1 = BigDecimal.valueOf(d1); BigDecimal b2 = BigDecimal.valueOf(d2); return b1.subtract(b2).doubleValue(); &#125; // 乘法。 public static double mul(double d1, double d2) &#123; BigDecimal b1 = BigDecimal.valueOf(d1); BigDecimal b2 = BigDecimal.valueOf(d2); return b1.multiply(b2).doubleValue(); &#125; // 除法。 public static double div(double d1, double d2) &#123; BigDecimal b1 = BigDecimal.valueOf(d1); BigDecimal b2 = BigDecimal.valueOf(d2); return b1.divide(b2, DEF_DIV_SCALE, RoundingMode.HALF_UP).doubleValue(); &#125;&#125;public class BigDecimalArithTest &#123; public static void main(String[]args)&#123; /* * 1.2 + 2.3 = 3.5 * 1.2 - 2.3 = -1.1 * 1.2 * 2.3 = 2.76 * 1.2 / 2.3 = 0.5217391304 */ System.out.println("1.2 + 2.3 = " + BigDecimalArith.add(1.2, 2.3)); System.out.println("1.2 - 2.3 = " + BigDecimalArith.sub(1.2, 2.3)); System.out.println("1.2 * 2.3 = " + BigDecimalArith.mul(1.2, 2.3)); System.out.println("1.2 / 2.3 = " + BigDecimalArith.div(1.2, 2.3)); &#125;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#x6a;&#x79;&#109;&#101;&#x73;&#x73;&#105;&#64;&#49;&#x36;&#51;&#x2e;&#x63;&#111;&#109;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写给阿根廷]]></title>
    <url>%2F2018%2F09%2F07%2F%E5%86%99%E7%BB%99%E9%98%BF%E6%A0%B9%E5%BB%B7%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 东南 再东南&emsp;&emsp; 穿过太平洋&emsp;&emsp; 五月的太阳&emsp;&emsp; 晴空的蓝 浮云的白 &emsp;&emsp; 耶稣山上的圣象&emsp;&emsp; 张开双臂俯视世间万物&emsp;&emsp; …&emsp;&emsp; … &emsp;&emsp; 雄鹰蓦地折断翅膀&emsp;&emsp; 蓝白色海洋陷入死寂&emsp;&emsp; 眼中闪着点点泪光&emsp;&emsp; 蓝白色是不变的信仰 &emsp;&emsp; 战车上的残翼&emsp;&emsp; 无法挫伤你的锐气&emsp;&emsp; 潘帕斯雄鹰&emsp;&emsp; 依旧是绿茵场上的传奇&emsp;&emsp;&emsp;&emsp; ——记2014年巴西世界杯 围巾一 &emsp;&emsp; 重新想起以前写的这首诗，有些片段忘记了，慢慢回忆吧。ps：不管有没有世界杯冠军，你都是当之无愧的球王！ 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#x79;&#109;&#x65;&#x73;&#x73;&#105;&#x40;&#49;&#x36;&#x33;&#46;&#x63;&#111;&#109;]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
</search>
