<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaWeb相关软件安装包分享]]></title>
    <url>%2F2020%2F02%2F18%2FJavaWeb%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8C%85%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[1.Linux 版本（JavaWeb 程序） 链接：https://pan.baidu.com/s/1BHFbs0_sMzfBdQGIOCrQ-w 提取码：wvtt jdk-8u201-linux-x64.tar.gz apache-tomcat-8.5.39.tar.gz apache-maven-3.6.0-bin.tar.gz nginx-1.8.0.tar.gz redis-5.0.4.tar.gz 2.Windows 版本（JavaWeb 程序） 链接：https://pan.baidu.com/s/1H4o8uCxwYVn_x0wn7aNvpg 提取码：9h05 jdk-8u65-windows-x64.zip Redis-x64-3.0.504.msi gradle-5.2.1-all.zip elasticsearch-7.1.1-windows-x86_64.zip elasticsearch-head-master.zip 3.其他工具（Windows） 链接：https://pan.baidu.com/s/1LnO1znY4nlDuu8QvC957bQ 提取码：ihaf 谷歌访问助手_v2.3.0.crx（翻墙） GitHubDesktopSetup.exe redis-desktop-manager-0.8.8.384.exe Xftp.6.0.0105.v2.7z（Xftp.exe） Xshell.6.0.0111.v2.7z（Xshell.exe） notepad++.exe VMware-workstation-full-15.0.0-10134415.exe CentOS-7-x86_64-Minimal-1908.iso（CentOS 镜像 在 VMware 中使用） 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 wjymessi@163.com]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>资源分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式之工厂方法模式]]></title>
    <url>%2F2020%2F01%2F21%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式之简单工程]]></title>
    <url>%2F2020%2F01%2F21%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式之建造者模式]]></title>
    <url>%2F2020%2F01%2F21%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式之抽象工厂模式]]></title>
    <url>%2F2020%2F01%2F21%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式之单例模式]]></title>
    <url>%2F2020%2F01%2F21%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[操作系统基础之设备管理]]></title>
    <url>%2F2020%2F01%2F21%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[操作系统基础之文件管理]]></title>
    <url>%2F2020%2F01%2F21%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[操作系统基础之存储管理]]></title>
    <url>%2F2020%2F01%2F21%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[操作系统基础之作业管理]]></title>
    <url>%2F2020%2F01%2F21%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[操作系统基础之进程管理]]></title>
    <url>%2F2020%2F01%2F21%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL入门之性能优化]]></title>
    <url>%2F2020%2F01%2F09%2FMySQL%E5%85%A5%E9%97%A8%E4%B9%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL入门之数据库设计]]></title>
    <url>%2F2020%2F01%2F09%2FMySQL%E5%85%A5%E9%97%A8%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL入门之进阶知识]]></title>
    <url>%2F2020%2F01%2F09%2FMySQL%E5%85%A5%E9%97%A8%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL入门之基础知识]]></title>
    <url>%2F2020%2F01%2F09%2FMySQL%E5%85%A5%E9%97%A8%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题解总结之MySQL（简单难度）]]></title>
    <url>%2F2020%2F01%2F08%2FLeetCode%E9%A2%98%E8%A7%A3%E6%80%BB%E7%BB%93%E4%B9%8BMySQL%EF%BC%88%E7%AE%80%E5%8D%95%E9%9A%BE%E5%BA%A6%EF%BC%89%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题解之数据过滤、排序和分组（MySQL）]]></title>
    <url>%2F2020%2F01%2F08%2FLeetCode%E9%A2%98%E8%A7%A3%E4%B9%8B%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E5%88%86%E7%BB%84%EF%BC%88MySQL%EF%BC%89%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题解之子查询和联结（MySQL）]]></title>
    <url>%2F2020%2F01%2F08%2FLeetCode%E9%A2%98%E8%A7%A3%E4%B9%8B%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%92%8C%E8%81%94%E7%BB%93%EF%BC%88MySQL%EF%BC%89%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题解之更新和删除数据（MySQL）]]></title>
    <url>%2F2020%2F01%2F08%2FLeetCode%E9%A2%98%E8%A7%A3%E4%B9%8B%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%EF%BC%88MySQL%EF%BC%89%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[《MySQL必知必会》之操纵表及数据]]></title>
    <url>%2F2020%2F01%2F08%2F%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B%E4%B9%8B%E6%93%8D%E7%BA%B5%E8%A1%A8%E5%8F%8A%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[《MySQL必知必会》之子查询和联结]]></title>
    <url>%2F2020%2F01%2F08%2F%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B%E4%B9%8B%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%92%8C%E8%81%94%E7%BB%93%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[《MySQL必知必会》之数据过滤、排序和分组]]></title>
    <url>%2F2020%2F01%2F08%2F%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B%E4%B9%8B%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E5%88%86%E7%BB%84%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[计算机网络之图解HTTP]]></title>
    <url>%2F2020%2F01%2F08%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E5%9B%BE%E8%A7%A3HTTP%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[计算机网络之HTTP协议原理+实践]]></title>
    <url>%2F2020%2F01%2F08%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86-%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Linux入门之网络管理]]></title>
    <url>%2F2020%2F01%2F08%2FLinux%E5%85%A5%E9%97%A8%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Linux入门之Shell编程]]></title>
    <url>%2F2020%2F01%2F08%2FLinux%E5%85%A5%E9%97%A8%E4%B9%8BShell%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Linux入门之权限管理]]></title>
    <url>%2F2020%2F01%2F08%2FLinux%E5%85%A5%E9%97%A8%E4%B9%8B%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Linux入门之常用命令]]></title>
    <url>%2F2020%2F01%2F08%2FLinux%E5%85%A5%E9%97%A8%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Linux入门之基础概念]]></title>
    <url>%2F2020%2F01%2F08%2FLinux%E5%85%A5%E9%97%A8%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb入门之Servlet]]></title>
    <url>%2F2019%2F12%2F22%2FJavaWeb%E5%85%A5%E9%97%A8%E4%B9%8BServlet%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb入门之JSP]]></title>
    <url>%2F2019%2F12%2F22%2FJavaWeb%E5%85%A5%E9%97%A8%E4%B9%8BJSP%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Spring入门之AOP]]></title>
    <url>%2F2019%2F12%2F22%2FSpring%E5%85%A5%E9%97%A8%E4%B9%8BAOP%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Spring入门之IOC]]></title>
    <url>%2F2019%2F12%2F22%2FSpring%E5%85%A5%E9%97%A8%E4%B9%8BIOC%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java进制转换及位运算]]></title>
    <url>%2F2019%2F12%2F20%2FJava%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%8F%8A%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[1.进制①进制相关 在线进制转换工具：https://tool.lu/hexconvert/ 进位制是一种记数方式，亦称进位计数法或位值计数法。它是人们为计数和运算方便而约定的计数系统。 把一个数表示成 a 与 10 的 n 次幂相乘的形式（1 ≤ |a| &lt; 10，n 为整数），这种记数的方法叫做科学记数法。 使用的数字符号的数目称为这种进位制的基数或底数。 位权：一个数码在不同的位置上所代表的值不同、且不同的进位制，处于同一数位上的权也是不同的。 例如：十进制第 2 位的位权为 10，第 3 位的位权为 100、而二进制第 2 位的位权为 2，第 3 位的位权为 4。 ②进制转换 进位制 基本数字 进位规则 应用 标志的开头 二进制 0 ~ 1 二进一 计算机内部采用二进制，其运算简单，简化了计算机结构 0b / 0B 八进制 0 ~ 7 八进一 适用于12位和36位计算机系统 0 十进制 0 ~ 9 十进一 日常生活中使用 无 十六进制 0 ~ 9和A、B、C、D、E、F(15) 十六进一 长度短 0x / 0X 进制表： ​​​​ 十进制转换为 二 / 八 / 十六 进制 对于整数：采用重复相除权再倒看余数的方法 对于小数：采用重复相乘权再正看 “余数” 的方法 二 / 八 / 十六进制采用科学计数法按对应权展开可得十进制数： ③JDK 内置的进制转换 1234567891011121314151617181920212223242526272829303132333435363738394041424344package object.base;/** * @author: wjy * @date: 2018/10/08 * @description: JDK内置的进制转换 */public class javaSystem &#123; public static void main(String[] args) &#123; // 10进制转换为其他进制 // 10进制转换为2进制：1100 System.out.println(Integer.toBinaryString(12)); // 10进制转换为8进制：14 System.out.println(Integer.toOctalString(12)); // 10进制转换为16进制：14 System.out.println(Integer.toHexString(20)); // 其他进制转换为10进制 // 2进制转换为10进制：1*2^2+1*2^0=5 System.out.println(Integer.parseInt("0101",2)); System.out.println(Integer.valueOf("0101",2).toString()); // 8进制转换为10进制：1*8^2+2*8^1+3*8^0=83 System.out.println(Integer.parseInt("0123",8)); System.out.println(Integer.valueOf("0123",8).toString()); // 16进制转换为10进制：15*16^3+15*16^2+15*16^1+15*16^0=65535 System.out.println(Integer.parseInt("FFFF",16)); System.out.println(Integer.valueOf("FFFF",16).toString()); // 打印为十进制数字123 System.out.println(123); // 打印为十进制数字5(其中0101是2进制数字，0b标识0101为2进制) System.out.println(0b0101); // 打印为十进制数字5(其中0101是2进制数字，0B标识0101为2进制) System.out.println(0B0101); // 打印为十进制数字83(其中123是8进制数字，0标识123为8进制) System.out.println(0123); // 打印为十进制数字291(其中123是16进制数字，0x标识123为16进制) System.out.println(0x123); // 打印为十进制数字291(其中123是16进制数字，0X标识123为16进制) System.out.println(0X123); &#125;&#125; 2.二进制数据的表示方法 ps：Java 中整型（int型）是 32 位的。 ①原码 原码表示法：最高位为符号位，其余位表示数值的大小。 使用 0 表示正数、1 表示负数 [+1]原 = 0000 0001 [-1]原 = 1000 0001 优点：表达简单明了、易于理解 缺点： 有歧义（0 既可以用 00 表示，也可以用 10 表示） 当两个操作数的符号不同时，运算十分复杂 ②反码 正数的反码是其本身 [+1] = [00000001]原 = [00000001]反 负数的反码等于原码除符号位外按位取反 [-1] = [10000001]原 = [11111110]反 ③补码 正数的补码是其本身 [+1] = [00000001]原 = [00000001]反 = [00000001]补 负数的补码等于反码加 1 [-1] = [10000001]原 = [11111110]反 = [11111111]补 ④原码、补码和反码之间的关系 因为原码表示法对于零的表示有歧义且其减法运算复杂，所以引入了补码表示法。虽然补码表示法在一定程度上解决了这两个问题，但是其在计算补码的过程中引进了减法操作。 解决方法：引进反码表示法。先由原码计算出反码，再由反码计算出补码，即可消除直接通过原码求补码时引入的减法操作。 在计算机中，数据都是以补码的形式存储的。 0 的反码和补码都为零 3.位运算 ps：程序中所有的数在内存中都是以二进制的形式存储的，位运算是直接对二进制位进行的位操作。二进制位运算的优点：计算方便，速度快，被支持面广。 ①运算符 运算 功能 举例 应用/规律 按位与(&amp;) 两位全为1，结果才为1 6(00000110) &amp; 3(00000011) = 2(00000010) a.清零(若要将一个单元清零，只要与一个各位都为0的数值相与即可) b.取一个数中的指定位(找一个数，对应x要取的位，该数的对应位为1，其余位为0，此数与x进行与运算即可得到x中的指定位) 按位或(|) 只要有一个为1，结果就为1 6(00000110) | 3(00000011) = 7(00000111) 用来对一个数据的某些位置1(找一个数，对应x要置1的位，该数的对应位为1，其余位为0，此数与x进行或运算即可使x中的某些位置1) 异或运算(^) 两个相应位为”异”，则该位结果为1，否则为0 6(00000110) ^ 3(00000011) = 5(00000101) a.与0相异或，可保留原值 b.使特定位翻转(找一个数，对应x要翻转的位，该数的对应位为1，其余位为0，此数与x对应位异或即可) 取反运算(~) 对一个二进制数按位取反，0变1，1变0 ~6(00000110) = -7(11111001) 补码(11111001)-1 -&gt; 得到反码(11111000)，除符号位外各位取反 -&gt; 得到原码-7(10000111) 左移运算(&lt;&lt;) 将一个数的各二进制位全部左移指定的位数，右边补0 3(00000011) &lt;&lt; 2 = 12(00001100) 若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2 右移运算(&gt;&gt;) 将一个数的各二进制位全部右移指定的位数，正数左补0，负数左补1 3(00000011) &gt;&gt; 1 = 1(00000001) 若操作数为正数，则每右移一位，相当于该数除以2 无符号右移运算(&gt;&gt;&gt;) 将一个数的各二进制位全部右移指定的位数，左边补0 3(00000011) &gt;&gt;&gt; 1 = 1(00000001) 若操作数为正数，则每右移一位，相当于该数除以2 ②两个变量交换值的方法 借助第三个变量来实现 C = A、A = B、B = C 利用加减法实现两个变量的交换 A = A + B、B = A - B、A = A - B 用位异或运算来实现（效率最高） 原理：利用一个数异或本身等于 0 和异或运算符合交换律 举例：A = A ^ B、B = A ^ B、A = A ^ B 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#106;&#x79;&#x6d;&#x65;&#x73;&#x73;&#x69;&#64;&#x31;&#x36;&#51;&#x2e;&#x63;&#111;&#109;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis入门]]></title>
    <url>%2F2019%2F12%2F12%2FRedis%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[2020届春招面经之数据库]]></title>
    <url>%2F2019%2F12%2F12%2F2020%E5%B1%8A%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[2020届春招面经之后端框架]]></title>
    <url>%2F2019%2F12%2F12%2F2020%E5%B1%8A%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%E4%B9%8B%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[2020届春招面经之设计模式]]></title>
    <url>%2F2019%2F12%2F12%2F2020%E5%B1%8A%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[2020届春招面经之jvm]]></title>
    <url>%2F2019%2F12%2F12%2F2020%E5%B1%8A%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%E4%B9%8Bjvm%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[2020届春招面经之数据结构与算法]]></title>
    <url>%2F2019%2F12%2F12%2F2020%E5%B1%8A%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[2020届春招面经之Java基础]]></title>
    <url>%2F2019%2F12%2F12%2F2020%E5%B1%8A%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%E4%B9%8BJava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[2020届春招面经之操作系统]]></title>
    <url>%2F2019%2F12%2F12%2F2020%E5%B1%8A%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[2020届春招面经之计算机网络]]></title>
    <url>%2F2019%2F12%2F12%2F2020%E5%B1%8A%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[2020届春招面经汇总]]></title>
    <url>%2F2019%2F12%2F12%2F2020%E5%B1%8A%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[使用GoLand创建go工程]]></title>
    <url>%2F2019%2F12%2F12%2F%E4%BD%BF%E7%94%A8GoLand%E5%88%9B%E5%BB%BAgo%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1.准备工作 下载 JetBrains GoLand 配置 go 的开发环境 2.hello go 代码1234567package mainimport "fmt"func main() &#123; fmt.Println("你好")&#125; 3.创建 go 工程 新建工程、选择 GOROOT 路径 创建目录结构、创建 hello.go 文件 bin：包含生成的执行文件 pkg：包含编译的中间文件 src：包含程序的代码文件 配置全局路径和项目路径 配置并运行 hello.go 文件 4.命令行中运行 go 文件(windows) go run 文件名.go：编译一个或多个以 .go 结尾的源文件，链接库文件并运行最终生成的可执行文件 go build 文件名.go：生成一个可执行的二进制文件 文件名.exe：运行生成的文件 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#x79;&#109;&#101;&#115;&#115;&#x69;&#x40;&#x31;&#x36;&#51;&#x2e;&#99;&#x6f;&#109;]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为春招面经2020届JavaWeb]]></title>
    <url>%2F2019%2F10%2F13%2F%E5%8D%8E%E4%B8%BA%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F2020%E5%B1%8AJavaWeb%2F</url>
    <content type="text"><![CDATA[1.投递职位 华为 2020 届勇敢星实习—通用软件开发工程师 年龄：大二(非大三) 时间：2019 年 地点：华为西研所 华为校招官网 2.我的招聘流程3.29 投递简历 ——&gt; 4.2 性格测试 ——&gt; 4.3 线上笔试 ——&gt; 4.20 面试 ——&gt; 4.25 收到 offer ——&gt; 5.6 签约 3.性格测试 华为比较重视这个，最好认真做完。可以在网上查查技巧，反正我是挂了(⊙o⊙)…。 4.笔试①题目分析 华为的笔试题都是基础的编程题，比较简单。总共有三道题，分值分别为 100、200、300，难度递增。第一题重点考察输入与输出， 第二题重点考察对语言类库的运用，第三题重点考察数据结构与算法。注意：最好在笔试后仔细研究研究未 AC 的题，面试官可能会问。 ②练习网址 牛客网：https://www.nowcoder.com/ta/huawei ③我的笔试 当时我 AC 了第一题和第二题(300 分)，由于第三题涉及到的算法还没有学习过，故放弃。不过只要拿 100 分，就能得到面试机会。 5.一面(35min)①面试问题 自我介绍 对华为的了解 为什么来华为实习 笔试中未做出的题 三道算法题 做项目遇到的困难 对软件工程的了解 对”好代码”的理解 ②面试技巧 面试前最好了解一下企业文化及其业务方向。 面试官很看重应聘者解决问题的能力，即面对一个完全陌生的问题，应聘者能将之快速理解并想出求解方法。 在解决算法题的时候，最好先从最基础的求解方法开始分析，逐步优化并且分析每种解法的复杂度和优缺点(系统原理、安全漏洞等)。 如果实在想不出求解方法，也要尽可能地想出一个大概思路，最好别卡壳。如果面试时很紧张，会非常非常影响思路！所以一定要放松！！ 底层知识一定要重视！要将学过的知识点充分理解！ 注意：思考面试官问你的题目之间是否有关联，也许这是一个很好的解题突破点。 6.二面(20min)①面试问题 自我介绍 对 996 的看法 为什么跨专业学习 职业规划 关于读研 想在华为学到什么 项目介绍 英语能力及课内成绩 瞎聊… ②面试体验 一面结束后，排队等待二面，二面相对比较轻松。因为我是跨专业自学 CS，所以面试官一直逮着这点问，emmm。然后就会和你聊聊家庭情况、未来规划、学习情况等。 7.等待结果 面试完成后官网会更新 应聘进展 我的状态码： 状态码：6、1 性格测试貌似挂了 但没有被安排重测 面试考核 下无小字： but 5 天后就收到 offer 啦 ps：谢谢男票陪我去面试，肝就对了！纪念收到的第一个 offer！ 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#121;&#109;&#x65;&#115;&#x73;&#x69;&#x40;&#x31;&#54;&#x33;&#x2e;&#x63;&#x6f;&#x6d;]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat+Nginx配置HTTPS]]></title>
    <url>%2F2019%2F09%2F13%2FTomcat-Nginx%E9%85%8D%E7%BD%AEHTTPS%2F</url>
    <content type="text"><![CDATA[ps：每次修改配置后，需要重启 Nginx。命令：systemctl restart nginx。Nginx 的配置文件：/etc/nginx/nginx.conf。 1.相关博客 阿里云CentOS7安装Nginx Nginx之访问服务器静态资源 Nginx之rewrite配置域名跳转 2.准备SSL证书 在域名备案的前提下，我们需要购买 SSL 证书。一般情况下，购买免费版即可。 ①什么是SSL证书 ②准备过程 进入阿里云控制台 购买免费版 SSL 证书 然后在签发后下载 Nginx 服务器类型的证书并上传到服务器 3.具体配置①强制HTTPS（可选） 把 HTTP 的域名请求转成 HTTPS 123456server &#123; listen 80; server_name a.com; # 使用证书绑定的域名替换localhost return 301 https://$server_name$request_uri; # 返回301状态码进行跳转被Google认为是将网站地址由HTTP迁移到HTTPS的最佳方法&#125; ②开启HTTPS 12345678910111213141516171819202122server &#123; listen 443 ssl; # 监听433端口 server_name a.com; # 证书绑定的域名 ssl on; ssl_certificate /usr/local/javaweb/cert/2557101_a.com.pem; # 证书的文件名 ssl_certificate_key /usr/local/javaweb/cert/2557101_a.com.key; # 证书的密钥文件名 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; proxy_pass http://127.0.0.1:8080; # 对应tomcat的端口号 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Forwarded-Proto https; proxy_redirect off; proxy_connect_timeout 240; proxy_send_timeout 240; proxy_read_timeout 240; &#125;&#125; 配置成功 4.工作原理 浏览器发送的请求是发送到 Nginx 的，Nginx 作为代理服务器再转发到 Tomcat，浏览器和 Nginx 之间以 HTTPS 协议传输数据，而 Nginx 和 Tomcat 之间通过 proxy_pass 以 HTTP 协议传输数据。Nginx 是中间的代理服务器。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#x6a;&#121;&#109;&#101;&#x73;&#x73;&#x69;&#64;&#49;&#x36;&#51;&#46;&#99;&#111;&#109;]]></content>
      <categories>
        <category>Linux</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>Tomcat</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb开发总结]]></title>
    <url>%2F2019%2F09%2F12%2FJavaWeb%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1.开发环境①开发必备 Java 版本：JDK8 Web 服务器：Tomcat9（运行后端）、Nginx（前端请求转发和搭建图片服务器） 工程框架：Spring Boot 2.0 操作数据库：Spring Boot Jpa（优先） / Mybatis 其他：Lombok 插件、JSON（fastjson / jackson） ②数据库 MySQL（主 db） Redis（处理缓存） MongoDB （特殊需求使用） ③编译器&amp;构建工具&amp;测试工具 IDEA maven（优先） / gradle Postman 2.框架分层①总览 common（公共包） enums（枚举类） exception（全局异常处理） interceptor（拦截器） jpa（jpa 配置） log（AOP 方式的日志埋点） utils（工具类） controller（控制层） model（DAO 层） dto（数据传输对象） entity（数据库实体类） repository / mapper（数据库操作层） service（服务层) base（基础服务） impl（业务服务实现类） resources（资源目录） application.yml（切换配置文件） application-dev.yml（本地配置文件） application-pro.yml （服务器配置文件） ②common层 ResultEnum 类：用于存放前端请求的响应 / 执行结果 注意枚举类定义格式 私有变量名不能定义为 name ③controller层 调用 service 层方法 提供对外暴露的接口 ④model层 ResultDTO 类：统一使用此类将数据封装好返回给前端 关于使用 DTO：从数据库中查出的是一个完整的对象，而大多数时候只会用到某些字段，这时候需要 DTO。 3.代码规范①注释 类注释（配置模板） 123456/** * @功能名称: HttpClient(举例) * @文件名称: HttpUtil.java(举例) * @Date: $date$ $time$ * @Author: 自定义 */ 方法注释（配置模板） 12345678/** * 功能描述: * * @param: $param$ * @return: $return$ * @auther: 自定义 * @date: $date$ $time$ */ 变量注释 123/** * 文字 */ 方法内注释 1// 文字 ②注解 自动装配用 @Autowired 注解 其 byType 注入 注解在字段上 @component：泛指组件 把普通 POJO 实例化到 spring 容器中 @Service：用于标注业务层组件 @RestController：用于标注控制层组件 @Repository：用于标注数据访问组件 即 DAO 组件 @RequestMapping(value = “/URI”)：标注控制层组件中的方法 @GetMapping(value = “/URI”)：标注控制层组件中的方法 @PostMapping(value = “/URI”)：标注控制层组件中的方法 @RequestParam：用于标注控制层组件的方法的参数 参数名与前端传来的必须吻合 若是不吻合 需要加 value = “…” 使参数名一一对应 ③配置文件 application.yml：总控制文件 可随时切换为本地 / 服务器的配置文件 便于开发 123spring: profiles: active: dev/pro application-dev.yml 12345678910111213141516171819202122232425262728293031323334353637383940server: port: 本地访问端口号spring: # MySQL数据库配置 datasource: driverClass: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/数据库名?characterEncoding=utf-8&amp;serverTimezone=GMT%2B8 username: root password: 自定义 # Redis配置 redis: database: 0 host: 127.0.0.1 port: 6379 password: 自定义 # MongoDB配置 data: mongodb: uri: mongodb://用户名:密码@localhost:27017/数据库名 # jpa配置 jpa: hibernate: # 在程序启动时更新实体类对应的表 ddl-auto: update # 在日志中打印出执行的SQL语句信息 show-sql: true naming: physical-strategy: org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy # mybatis配置 mybatis: type-aliases-package: 数据库实体类所在包 # 下划线自动转驼峰 configuration: map-underscore-to-camel-case: true use-generated-keys: true # jackson配置 jackson: serialization: indent-output: true application-pro.yml 123456789101112131415161718192021server: port: 服务器端口号spring: # MySQL数据库配置 datasource: driverClass: com.mysql.cj.jdbc.Driver url: jdbc:mysql://服务器公网ip:3306/数据库名?characterEncoding=utf-8&amp;serverTimezone=GMT%2B8&amp;useSSL=true username: root password: 自定义 # Redis配置 redis: database: 0 host: 服务器公网ip port: 6379 password: 自定义 # MongoDB配置 data: mongodb: uri: mongodb://用户名:密码@服务器ip:27017/数据库名 ...其他如上 ④pom.xml（maven）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MySQL --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- MongoDB --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- jpa --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- lombok插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- httpclient --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- maven插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- 解决项目启动bug --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; ⑤其他 将私有常量值单独定义在类的开头 公有常量值定义在公有枚举类中 工具类一般不需要被注入或构造 只包含普通的类方法 所有需要注入的类，都应该放到 Service 目录下 除 db 对象外 尽量使用全参构造对象 尽量消除魔法值 可使用枚举类封装 遵循《阿里巴巴Java代码开发规范》进行开发 4.安装插件 安装插件：Settings —&gt; Plugins —&gt; Marketplace —&gt; 查找所需插件 —&gt; Install 查看安装的所有插件： 安装后需要重启 IDEA ①Lombok 以简单的注解形式来简化 Java 代码，提高开发人员的开发效率。 @Getter：注解在类上 为类提供 get 方法 @Setter：注解在类上 为类提供 set 方法 @Data：注解在类上 为类提供读写属性 此外还提供了equals()、hashCode()、toString() 方法 @AllArgsConstructor：注解在类上 为类提供一个全参的构造方法 @NoArgsConstructor：注解在类上 为类提供一个无参的构造方法 @Slf4j：注解在类上 为类提供一个属性名为 log 的 log4j 日志对象 @Slf4j 相当于 private static final Logger log = LoggerFactory.getLogger(CategoryServiceImpl.class); ②Alibaba Java Coding Guidelines 阿里巴巴 Java 代码规约检测 使用插件： ③Grep Console 可以将不同级别的日志通过颜色区分，便于查看。 配置各级日志的颜色： 5.前后端交互①交互流程1.通过原型图确定产品功能（明确每个细节）2.后端撰写 API 文档及建表3.前后端按照 API 文档各自开发4.测试 ②API文档 ShowDoc 举例： ③RESTful API 后端撰写请求 URL 时 必须遵守 RESTful API 设计规范 举例： 6.关于团队协作（git） GitHub 客户端每次只能 commit 一个文件，不利于版本回滚和团队协作，所以尽量使用 git 命令行。 ①git同步流程 一般开发完成、但还没有测试的文件都会被提交到暂存区 将暂存区的文件（测试好的）提交到本地仓库 通过 git push 提交修改到远程仓库 ②git常用命令 git add 文件名：将本地某个文件添加到暂存区 git add *：将本地所有文件添加到暂存区 git commit -m “本次提交说明（自定义）”：将暂存区文件提交到本地仓库 git push -u origin master：使用本地 master 分支来更新远程 master 分支（远程仓库） git reset HEAD 文件名（将暂存区的内容还原为最后一次提交的内容） git checkout – 文件名（将工作区的内容还原为最后一次提交的内容） git tag -a name -m “comment”：新建标签并指定提交信息 git tag -d name：删除标签 git branch：查看当前所有分支 git branch name：创建分支 git checkout name：进入分支 通过两种方式克隆仓库： Clone with SSH：git clone git@github.com:messi1002/leetcode.git Clone with HTTPS：git clone https://github.com/messi1002/leetcode.git ③git高级操作 git stash save “注释”：将工作区和暂存区的新内容暂时保存在栈中 git stash list：显示缓存堆栈中的内容 git stash pop：将缓存堆栈中的第一个 stash 内容恢复到工作区后删除 git commit –amend：将缓存区的内容补充到上次 commit 并可以修改上次 commit 的描述（用来修复最近一次 commit） git rebase -i [startpoint] [endpoint]：每一个功能开发完成后 对多个 commit 进行合并处理（变基） 123[startpoint] 和 [endpoint] 指定了一个编辑区间，前开后闭。如果不指定 [endpoint]，则该区间的终点默认是当前分支 HEAD 所指向的 commit。进入编辑页面后，按照指令说明修改指令即可。 7.入门博客汇总 StringUtils用法+StringUtils详细介绍 Java 枚举类Enum的用法总结 Spring Boot 中 Redis 的使用 如何使用RedisTemplate访问Redis数据结构 Spring Boot中使用Redis数据库 Spring Boot中快速操作Mongodb Spring Boot 中 MongoDB 的使用 Spring Boot Jpa 的使用 如何优雅的使用 Mybatis MyBatis中Like语句使用方式 Java 开发工具–Lombok 介绍 Spring Boot中Jackson应用详解 JSON框架之阿里fastjson的介绍 RESTful API 设计规范 Git—版本控制工具 Git教程 上传图片到七牛云（前端和后端） 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#x6a;&#x79;&#x6d;&#x65;&#115;&#x73;&#x69;&#64;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#109;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Nginx之rewrite配置域名跳转]]></title>
    <url>%2F2019%2F09%2F12%2FNginx%E4%B9%8Brewrite%E9%85%8D%E7%BD%AE%E5%9F%9F%E5%90%8D%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[ps：每次修改配置后，需要重启 Nginx。命令：systemctl restart nginx。Nginx 的配置文件：/etc/nginx/nginx.conf。 1.相关博客 阿里云CentOS7安装Nginx Nginx之访问服务器静态资源 Tomcat+Nginx配置HTTPS 2.语法格式 rewrite 作用：将某个 URL 重写为特定的 URL 语法格式：rewrite（关键字） &lt;regex&gt;（正则表达式） &lt;replacement&gt;（替代内容） 根据 正则表达式 重定向到 replacement 3.对a域名的访问全部redirect到b域名 配置前 server 中不允许存在 location / { ... } 配置示例 123location / &#123; rewrite ^/(.*) http://1000.xidian.edu.cn/$1;&#125; 跳转前：http://a.com/index.php/Request/… 跳转后： 通过 location / 匹配所有以 / 开头的请求（即所有请求） rewrite 为固定关键字 regex 部分表示匹配完整的域名和之后的路径 replacement 部分中的 $1 取自 regex 部分 ( ) 中的内容 即 nginx 将 a.com/ 之后的路径拼接到了 http://1000.xidian.edu.cn/ 后 4.对a域名的不同访问redirect到不同域名①应用场景 同一个域名下的不同 URL 需要跳转到不同的域名下 ②示例一123location /xiaoyuan/ &#123; rewrite ^/xiaoyuan(.*) http://ehall.xidian.edu.cn$1;&#125; 跳转前：http://a.com/xiaoyuan/jwapp/sys/cjcx 跳转后： 通过 location /xiaoyuan/ 匹配所有以 /xiaoyuan/ 开头的请求 rewrite 为固定关键字 regex 部分表示匹配完整的域名和之后的路径 replacement 部分中的 $1 取自 regex 部分 ( ) 中的内容 即 nginx 将 a.com/xiaoyuan 之后的路径拼接到了 http://ehall.xidian.edu.cn 后 ③示例二123location /houqin/ &#123; rewrite ^/houqin(.*) http://1000.xidian.edu.cn$1;&#125; 跳转前：http://a.com/houqin/index.php/Request/... 跳转后： 通过 location /houqin/ 匹配所有以 /houqin/ 开头的请求 rewrite 为固定关键字 regex 部分表示匹配完整的域名和之后的路径 replacement 部分中的 $1 取自 regex 部分 ( ) 中的内容 即 nginx 将 a.com/houqin 之后的路径拼接到了 http://1000.xidian.edu.cn 后 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#x6a;&#x79;&#109;&#x65;&#115;&#x73;&#105;&#64;&#49;&#54;&#x33;&#x2e;&#99;&#x6f;&#x6d;]]></content>
      <categories>
        <category>Linux</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx之访问服务器静态资源]]></title>
    <url>%2F2019%2F09%2F12%2FNginx%E4%B9%8B%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[ps：每次修改配置后，需要重启 Nginx。命令：systemctl restart nginx。Nginx 的配置文件：/etc/nginx/nginx.conf。 1.相关博客 阿里云CentOS7安装Nginx Tomcat+Nginx配置HTTPS Nginx之rewrite配置域名跳转 2.通过域名/文件名.文件类型的URL格式访问 应用场景：小程序业务域名的验证。 ①方法一 当 server 的配置中不存在 location / { ... } 时 配置示例 123456server &#123; listen 80 default_server; # 监听80端口 server_name localhost; # 可自定义域名 root /usr; # 注意：/usr为文件所在目录,可任意设置 # root /; # 当文件在根目录时如此配置&#125; ②方法二 当 server 的配置中存在 location / { ... } 时 配置示例 1234567在server中添加：location /文件名.文件类型 &#123; root /usr; # 注意：/usr为文件所在目录,可任意设置 # root /; # 当文件在根目录时如此配置 expires 30d; access_log off;&#125; 通过 /文件名.文件类型 匹配以 /文件名.文件类型 开头的请求 ③验证配置 3.通过域名/自定义/文件名.文件类型的URL格式访问 应用场景：搭建 Nginx 图片服务器。 配置示例 12345location /images/ &#123; root /usr/local/javaweb/xdxlb/; # 将/images/映射到/usr/local/javaweb/xdxlb/images/ autoindex on; # 打开浏览功能&#125; 通过 location /images/ 匹配所有以 /images/ 开头的请求 验证配置： 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#121;&#x6d;&#x65;&#115;&#115;&#105;&#64;&#49;&#54;&#x33;&#x2e;&#x63;&#111;&#x6d;]]></content>
      <categories>
        <category>Linux</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java发起HTTP请求的工具类]]></title>
    <url>%2F2019%2F09%2F12%2FJava%E5%8F%91%E8%B5%B7HTTP%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[ps：CloseableHttpClient 是 HttpClient 接口的实现类 1.发起GET请求①无参数的GET请求123456789101112/** * 功能描述: 无参数的GET请求 * * @param: [url] * @return: java.lang.String * @auther: wjy * @date: 2019/5/31 22:06 */public static String doGet(String url) &#123; return doGet(url, null);&#125; ②有参数的GET请求12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 功能描述: 有参数的GET请求 * * @param: [url, param] * @return: java.lang.String * @auther: wjy * @date: 2019/5/31 22:05 */ public static String doGet(String url, LinkedHashMap&lt;String, String&gt; param) &#123; // 创建HttpClient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); CloseableHttpResponse response = null; // GET请求的返回内容 String resultString = ""; try &#123; URIBuilder builder = new URIBuilder(url); // 设置请求参数 if (param != null) &#123; for (String key : param.keySet()) &#123; builder.addParameter(key, param.get(key)); &#125; &#125; // 构建一个URI对象 URI uri = builder.build(); // 创建GET请求 HttpGet httpGet = new HttpGet(uri); // 执行GET请求 response = httpClient.execute(httpGet); // 获取响应状态码 if (response.getStatusLine().getStatusCode() == 200) &#123; resultString = EntityUtils.toString(response.getEntity(), "UTF-8"); &#125; &#125; catch (URISyntaxException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; log.error("GET Method Catch Unexception Hanlder:&#123;&#125;, message:&#123;&#125;", e, e.getMessage()); throw new ServiceException(e.getMessage()); &#125; finally &#123; try &#123; if (response != null) &#123; response.close(); &#125; httpClient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return resultString; &#125; 2.发起POST请求①参数为Map对象的POST请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 功能描述: 有参数(Map对象)的POST请求 * * @param: [url, param] * @return: java.lang.String * @auther: wjy * @date: 2019/5/31 22:06 */ public static String doPost(String url, Map&lt;String, String&gt; param) &#123; // 创建HttpClient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); CloseableHttpResponse response = null; // POST请求的返回内容 String resultString = ""; try &#123; // 创建POST请求 HttpPost httpPost = new HttpPost(url); // 创建请求参数列表 if (param != null) &#123; List&lt;NameValuePair&gt; paramList = new ArrayList&lt;&gt;(); for (String key : param.keySet()) &#123; paramList.add(new BasicNameValuePair(key, param.get(key))); &#125; // 构造form表单式的实体 UrlEncodedFormEntity entity = new UrlEncodedFormEntity(paramList); httpPost.setEntity(entity); &#125; // 执行POST请求 response = httpClient.execute(httpPost); // 获取响应状态码 if (response.getStatusLine().getStatusCode() == 200) &#123; resultString = EntityUtils.toString(response.getEntity(), "UTF-8"); &#125; &#125; catch (IOException e) &#123; log.error("POST Method Catch Unexception Hanlder:&#123;&#125;, message:&#123;&#125;", e, e.getMessage()); throw new ServiceException(e.getMessage()); &#125; finally &#123; try &#123; if (response != null) &#123; response.close(); &#125; httpClient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return resultString; &#125; ②参数为JSON字符串的POST请求12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 功能描述: 有参数(Json字符串)的POST请求 * * @param: [url, jsonData] * @return: java.lang.String * @author: wjy * @date: 2019/6/25 17:39 */public static String doPost(String url, String jsonData) &#123; // 创建HttpClient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); CloseableHttpResponse response = null; // POST请求的返回内容 String resultString = ""; try &#123; // 创建POST请求 HttpPost httpPost = new HttpPost(url); // 解析Json数据并构造实体 StringEntity stringEntity = new StringEntity(jsonData, ContentType.APPLICATION_JSON); httpPost.setEntity(stringEntity); // 执行POST请求 response = httpClient.execute(httpPost); // 获取响应状态码 if (response.getStatusLine().getStatusCode() == 200) &#123; resultString = EntityUtils.toString(response.getEntity(), "UTF-8"); &#125; &#125; catch (IOException e) &#123; log.error("POST Method Catch Exception Handler:&#123;&#125;, message:&#123;&#125;", e, e.getMessage()); &#125; finally &#123; try &#123; if (response != null) &#123; response.close(); &#125; httpClient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return resultString;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#121;&#x6d;&#x65;&#115;&#115;&#105;&#64;&#49;&#54;&#x33;&#46;&#x63;&#x6f;&#109;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在命令行中使用SSH免密登录服务器]]></title>
    <url>%2F2019%2F05%2F25%2F%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E4%BD%BF%E7%94%A8SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1.生成公钥和私钥 打开命令行 输入 ssh-keygen -t rsa 然后连续按三个回车(第一个回车表示不重命名文件 第二、三个回车表示不设置密码) 最后在 C 盘找到生成的公钥和私钥 2.将公钥写入服务器 ps：需要服务器的防火墙放行 22 端口。 在命令行使用密码登录服务器 将生成的公匙内容粘贴到 authorized_keys 文件中 退出服务器 重新连接时 不用输入密码即可登录！ 3.解决WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! 重置服务器之后再配置 SSH 连接时 会报这个错误：远程主机标识已更改！ 这时需要将电脑上的旧连接信息删除（根据服务器IP） 删除后重新连接即可 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#x6a;&#x79;&#x6d;&#x65;&#x73;&#x73;&#x69;&#x40;&#x31;&#54;&#51;&#46;&#x63;&#111;&#x6d;]]></content>
      <categories>
        <category>Linux</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目管理利器-maven]]></title>
    <url>%2F2019%2F05%2F16%2F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%88%A9%E5%99%A8-maven%2F</url>
    <content type="text"><![CDATA[maven 是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型(POM)的概念，它可以从一个中心资料片管理项目构建、报告和文件。它也是一套强大的自动化构建工具，覆盖了编译、测试、运行、清理、打包和部署等整个项目构建的周期。并且它提供了一个仓库的概念，可以统一地管理项目所依赖的第三方 jar 包。 1.安装 maven①下载 maven 下载地址：https://maven.apache.org/download.cgi 然后解压压缩包 ②安装目录介绍 ③配置环境变量12M2_HOME: D:\apache-maven-3.5.4(安装目录)path: %M2_HOME%\bin 注意：%环境变量% 相当于引用这个环境变量的路径。 配置完 path 环境变量后，需要重启命令行(重新加载环境变量)。 ④验证配置 mvn -v 命令：查看 maven 版本 如果出现上图文字 说明安装成功 2.第一个 maven 项目①目录结构 使用 maven 管理的 Java 项目都有着相同的项目结构(强制) ②编写代码 编写 “Hello Maven!” 类： 123456public class HelloMaven &#123; public String say() &#123; return "Hello Maven!"; &#125;&#125; 编写测试类： 123456789101112import org.junit.Assert.*;import org.junit.*;public class HelloMavenTest &#123; // 表明该方法为测试方法。 @Test public void test() &#123; // 检验new HelloMaven().say()的返回值是否为"Hello Maven!"。 Assert.assertEquals("Hello Maven!", new HelloMaven().say()); &#125;&#125; 目录结构如下： ③新建 pom.xml 文件 pom.xml：用于管理项目依赖和构建过程(维护当前项目的 jar 包)。 写完代码后 还需要 pom.xml 文件管理项目的依赖 新建 pom.xml 文件 并将之移至项目根目录 1234567891011121314151617181920212223242526272829&lt;!-- 以下文字:&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 组织名 --&gt; &lt;groupId&gt;wjy-maven1&lt;/groupId&gt; &lt;!-- 模块名 --&gt; &lt;artifactId&gt;maven1-model&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 导入junit依赖(测试框架) --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 增加jdk的设置 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt;&lt;/project&gt; !--&gt; ④编译运行(进入项目根目录) mvn compile：编译项目 mvn test：测试运行项目 编译运行后，项目根目录会自动生成一个 target 目录，里面存放着测试报告、编译生成的 class 文件等。 3.核心知识①常用构建命令 mvn -v：查看 maven 版本 mvn clean：清理上一次构建生成的所有文件 mvn compile：编译 mvn test：测试运行 mvn package：将项目打包 mvn install：安装 jar 包到本地仓库 若要在 a 包的类中导入 b 包类，一般需要把包含 b 包类的 jar 包加入到 classpath 路径中。而 maven 为我们提供了更方便的方法：在 b 包的根目录下，我们使用 mvn install 命令将包含其所有类的 jar 文件发布到本地仓库中，然后在 a 包的 pom.xml 文件中添加 b 包的坐标，之后 maven 会自动帮我们进行依赖管理操作。原理：在编译源代码时，若程序用到了其他的包，maven 会在 pom.xml 文件中查找程序是否引入了该包的坐标。若是已经引入，maven 会在本地仓库中查找其对应的 jar 包并添加到 classpath 路径中，若是没有找到 jar 包，maven 会上网在中央仓库中下载 jar 包并放入本地仓库。若是没有引入，则返回异常信息。 ②自动创建目录结构 archetype 插件：用于自动创建符合 maven 规定的目录结构| 目录结构详情见 2-① 创建目录结构的两种方式： 1.输入 mvn archetype:generate -DarchetypeCatalog=internal 后按照命令行提示进行创建： 2.一次性写入以下代码： 1234mvn archetype:generate -DarchetypeCatalog=internal -DgroupId=wjy-maven02 -DartifactId=maven02-model -Dversion=1.0-SNAPSHOT -Dpackage=maven02.model# groupId: 组织名，一般为公司网址的反写-项目名。# artifactId: 一般为项目名-模块名，它是maven项目在组织中的唯一标识。# package: 代码所存在的包名，应该和groupId名、artifactId名相吻合。 ③坐标 在 maven 中，任何一个依赖、插件、项目构件的输出都可被称为构件。所有构件都通过坐标作为其唯一标识。&lt;groupId&gt;、&lt;artifactId&gt;、&lt;version&gt; 组成了 maven 的基本坐标。 ④仓库 仓库：用来管理项目的依赖。 a.本地仓库 在本地仓库中找不到项目所需要的构件时 会自动到远程仓库中查找并下载 b.远程仓库 远程仓库：即全球中央仓库 地址为 https://repo.maven.apache.org/maven2 远程仓库中包含了绝大多数开源的 Java 项目 但访问速度较慢(访问量大、且在国外) c.镜像仓库 镜像仓库：与全球中央仓库的功能相同 可以将默认的远程仓库改为国内的镜像仓库(访问速度更快、更稳定) 修改方法(将下列内容添加到 settings.xml 文件中)： 12345678&lt;!--设置镜像仓库为阿里云--&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;!-- 为中央仓库配置镜像。 --&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;&lt;/mirror&gt; 修改后 访问远程仓库的操作会转为访问镜像仓库 d.更改仓库默认位置 maven 的本地仓库默认存放在 C 盘中(占用 C 盘内存！) 修改上文的 settings.xml 文件 可以更改本地仓库的位置 然后在 maven 项目下执行 mvn clean compile 命令 会更新本地仓库的位置 最后将 setting.xml 文件放入新仓库中 防止 maven 升级后需要重新配置此文件 4.项目构建过程①项目构建与插件 完整的项目构建过程包括：清理(clean)、编译(compile)、测试(test)、打包(package)、集成测试、验证、部署(deploy)等。maven 和插件是密不可分的，maven 抽象出一套项目构建的生命周期，而插件是对 maven 抽象的具体实现，即 maven 中的所有命令都是调用插件实现的。在 maven 官网中，提供了很多插件。插件地址：https://mvnrepository.com/open-source/maven-plugins ②生命周期 maven 定义了三套相互独立的生命周期(clean、default、site)，每套生命周期包含一些有顺序的阶段，后面的阶段依赖于前面的阶段。即执行某个阶段时，其之前同一周期的阶段会顺序执行，如执行 package 命令时，complie、test 命令会自动顺序执行。 在 IDEA 中 pom.xml 文件会自动导入与生命周期有关的插件 a.clean—清理项目 pre-clean：执行清理前的工作 clean：清理上一次构建生成的所有文件 post-clean：执行清理后的工作 b.default(最核心)—构建项目 compile：编译 test：测试 package：打包 install：安装 jar 包到本地仓库 c.site—生成项目站点 pre-site：在生成项目站点之前要完成的工作 site：生成项目的站点文档 post-site：在生成项目站点之后要完成的工作 site-deploy：将生成的站点发布到服务器上 5.pom.xml 详解①pom pom 是 maven 项目的核心管理文件，用于项目描述、组织管理、依赖管理和构建信息的管理。方便的第三方框架的管理和便捷的项目构建过程，大大提高了工作效率。 ②pom 常用元素1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!-- project是pom.xml文件的根元素，包含了一些约束信息。 --&gt;&lt;project&gt; &lt;!-- modelVersion为必须元素，指定了当前文件的版本。 --&gt; &lt;modelVersion&gt;&lt;/modelVersion&gt; &lt;!-- 坐标信息: --&gt; &lt;!-- maven项目与实际项目不同，maven项目体现了模块化的概念，一个实际项目往往被划分为多个模块。 --&gt; &lt;!-- groupId为主项目标识，一般为反写的公司网址+项目名。 --&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;!-- artifactId为实际项目中的一个模块，一般为项目名+模块名。 --&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;!-- version为当前项目的版本号。 第一个0是大版本号，第二个0是分支版本号，第三个0是小版本号，如0.0.1。 napshot: 快照版、alpha: 内测版、beta: 公测版、Release: 稳定版、GA: 正式版。 --&gt; &lt;version&gt;&lt;/version&gt; &lt;!-- package为maven项目的打包方式，默认打包为war，也可以是jar、zip、pom等。 --&gt; &lt;packaging&gt;&lt;/packaging&gt; &lt;!-- name为项目的描述名，产生项目文档时才会使用。 --&gt; &lt;name&gt;&lt;/name&gt; &lt;!-- url为项目地址。 --&gt; &lt;url&gt;&lt;/url&gt; &lt;!-- description为项目描述。 --&gt; &lt;description&gt;&lt;/description&gt; &lt;!-- developers为开发人员列表。 --&gt; &lt;developers&gt;&lt;/developers&gt; &lt;!-- licenses为许可证信息。 --&gt; &lt;licenses&gt;&lt;/licenses&gt; &lt;!-- organization为组织信息。 --&gt; &lt;organization&gt;&lt;/organization&gt; &lt;!-- dependencies为依赖列表，其下包含多个依赖项(dependency)，一个坐标唯一标识一个依赖项。 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;type&gt;&lt;/type&gt; &lt;!-- optional设置该依赖是否可选，默认为false。若为true，项目必须显式引入该依赖，若为false，项目默认继承该依赖。 --&gt; &lt;optional&gt;&lt;/optional&gt; &lt;!-- 依赖范围。 --&gt; &lt;scope&gt;&lt;/scope&gt; &lt;!-- exclusions是排除依赖传递的列表。 --&gt; &lt;exclusions&gt; &lt;exclusion&gt;&lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- dependencyManagement为依赖的管理，主要定义在父模块中，供子模块继承。 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!-- 对构建行为提供一个支持。 --&gt; &lt;build&gt; &lt;!-- 插件列表: --&gt; &lt;plugins&gt; &lt;!-- 一个坐标唯一标识一个插件。 --&gt; &lt;plugin&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!-- 用于子模块中，是对父模块的一个继承。 --&gt; &lt;parent&gt;&lt;/parent&gt; &lt;!-- 用来聚合多个maven项目，使多个maven模块可以一起编译并运行。 --&gt; &lt;modules&gt;&lt;/modules&gt;&lt;/project&gt; 6.依赖①依赖范围 关于 &lt;scope&gt;&lt;/scope&gt; 12345678910&lt;!-- 平时开发时，若使用某一框架，就要将该框架的jar包引入到项目的classpath路径中，这样项目就可以使用该框架为我们封装好的一些方法。而maven为我们提供了三种classpath，分别为编译、测试、运行(时有效)，依赖的范围就是用来控制依赖与三种classpath的关系的。 scope标签的值有六种，分别为: compile(测试、编译和运行时都有效，默认选项)、 provided(测试、编译时有效，适用于一些web容器中已经包含的jar(运行时不需要再引入)，如servlet)、 runtime(测试、运行时有效，适用于JDBC驱动，项目主代码的编译只需要jdk提供的JDBC的API，只有测试或运行时才需要具体驱动的API)、 test(测试时有效，如junit测试框架)、 system(测试、编译时有效，但具有不可移植性，需要与本地系统相关联)、 import(导入，它只使用在dependencyManagement标签中，表示从其它的pom中继承过来的依赖)。 --&gt; 将 A 中的依赖导入到 B 中 12345678910111213141516171819&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;WJY-Test&lt;/groupId&gt; &lt;artifactId&gt;Test-B&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;name&gt;B&lt;/name&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;WJY-Test&lt;/groupId&gt; &lt;artifactId&gt;Test-A&lt;/artifactId&gt; &lt;type&gt;pom&lt;/type&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; ②排除依赖传递123456789101112131415161718192021&lt;!-- exclusions是排除依赖传递的列表。 若模块C依赖模块B的jar，模块B依赖模块A的jar，模块A对模块C来说就是传递依赖，默认模块C也会依赖模块A的jar。 若模块C不想依赖模块A的jar，可以使用这个标签，在模块C的pom.xml文件中添加以下内容便可排除模块A的依赖。 --&gt; &lt;!-- 此时模块C只依赖模块B的jar。 --&gt; &lt;dependency&gt; &lt;groupId&gt;WJY-Maven&lt;/groupId&gt; &lt;artifactId&gt;Mavan-B&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 排除依赖。 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;WJY-Maven&lt;/groupId&gt; &lt;artifactId&gt;Maven-A&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- 注意: 先要将模块A的jar发布到本地仓库中，模块B才能通过坐标在本地仓库中找到模块A的jar，再将模块B的jar发布到本地仓库中，模块C才能通过坐标在本地仓库中找到模块B的jar。 --&gt; ③依赖冲突 如果 A 和 B 分别有不同版本的相同构件，而 C 同时依赖于 A 和 B，此时会发生依赖冲突。 解决依赖冲突的两个原则： 1.短路优先—优先解析路径短(依赖级数少)的版本 2.如果路径相同 则看依赖的先后(先声明依赖哪个 就选择哪个依赖的版本) ④聚合 聚合：在 maven 中，将多个项目(模块)放在一起运行。聚合时，需要新建一个 maven 项目(父模块)，新建项目的 pom 将作为其他 pom 的容器。 1234567891011121314151617&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 作为其他pom的容器。 --&gt; &lt;groupId&gt;WJY-Maven&lt;/groupId&gt; &lt;artifactId&gt;Maven-0&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;!-- 此pom项目里不执行任何代码，只是为了聚合或传递依赖。--&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;!-- 用来聚合多个maven项目，使多个maven模块可以一起编译并运行。 --&gt; &lt;!-- 聚合后，还需要引入这些maven项目的依赖！ --&gt; &lt;modules&gt; &lt;module&gt;../Maven-1&lt;/module&gt; &lt;module&gt;../Maven-2&lt;/module&gt; &lt;module&gt;../Maven-3&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; ⑤继承123456&lt;!-- dependencyManagement为依赖的管理，可以声明依赖列表，但不会被引入到实际依赖中。主要定义在父模块中，供子模块继承(继承版本号等信息)。 即若多个模块都包括同一个依赖，可以抽象出来一个父模块，在父模块中对其进行一个定义，其他子模块只需要继承即可。 注意: 子模块还是需要显式地声明依赖。 优点: 如果有多个子模块都需要引用同样的依赖，则此标签可以避免在每个子模块中重复声明版本号等信息，便于整体修改。如果某个子模块需要其他版本，只需要单独声明version。 --&gt; 父 pom.xml 中： 12345678910111213141516171819202122&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;WJY-Maven&lt;/groupId&gt; &lt;artifactId&gt;Maven-1&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;junit.version&gt;4.11&lt;/junit.version&gt; &lt;/peoperties&gt; &lt;!-- 要被继承的依赖: --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 子 pom.xml 中： 123456&lt;parent&gt; &lt;!-- 父坐标: --&gt; &lt;groupId&gt;WJY-Maven&lt;/groupId&gt; &lt;artifactId&gt;Maven-1&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; 7.IDEA 中使用 maven 构建 web 项目①新建工程 注意：模板 maven-archetype-quickstart 的目录结构如下图所示，应该根据需要选择合适的模板。 ②创建目录结构 在 src/main 目录下新建 java 目录 将 java 目录作为 Sources Root 在 src/main 目录下新建 resources 目录 将 resources 目录作为 Resources Root 在 src/test 目录下新建 java 目录 将 java 目录作为 Test Sources Root 在 src/test 目录下新建 resources 目录 将 resources 目录作为 Test Resources Root 目录结构如下： ③配置 tomcat 新建 tomcat： tomcat 热部署： ④运行 tomcat 如果出现上图内容 说明配置成功 ⑤IDEA 中管理 maven 的生命周期 修改以下部分 并新增工程入口类 使用 package 命令 可以将工程打包 ⑥运行 jar 包 用 360压缩 打开 jar 包 编辑 MANIFEST.MF 文件 添加划线部分 保存并退出 在命令行运行 jar 包 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#121;&#x6d;&#x65;&#x73;&#x73;&#x69;&#64;&#49;&#x36;&#x33;&#46;&#x63;&#111;&#109;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[域名解析到服务器]]></title>
    <url>%2F2019%2F05%2F14%2F%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1.域名与服务器 域名是网站的入口，是 IP 的别名，便于记忆而存在，域名最终会通过 DNS 解析成 IP 地址。所以将域名解析到服务器后，域名 == 服务器 IP(一样的作用)！ 2.域名解析到服务器①域名解析 登录阿里云 打开 控制台-域名 选择域名 点击 解析 点击 添加记录 解析类型为 A-将域名解析到服务器 ②验证解析 验证网址：17CE 选择 Dns 并输入域名 如果画圈处的 IP 地址正确 说明解析成功 ps：解析成功后，使用 www.域名/域名 均可代替服务器 IP。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#x79;&#109;&#x65;&#115;&#x73;&#x69;&#64;&#49;&#54;&#x33;&#46;&#99;&#111;&#109;]]></content>
      <categories>
        <category>Linux</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云CentOS7安装Nginx]]></title>
    <url>%2F2019%2F05%2F07%2F%E9%98%BF%E9%87%8C%E4%BA%91CentOS7%E5%AE%89%E8%A3%85Nginx%2F</url>
    <content type="text"><![CDATA[1.准备工作①添加安全组规则 服务器的安全组默认未设置任何自定义放行规则，这将会导致无法访问实例端口，若需访问需要添加安全组规则放行对应的端口。 放行 80 端口 ②设置防火墙 防火墙是系统的第一道防线，其作用是防止非法用户的进入。服务器的防火墙默认未设置任何自定义放行规则，这将会导致无法访问实例端口，若需访问需要防火墙放行对应的端口。注意：CentOS7 默认使用 firewalld 作为防火墙。 firewalld 默认是关闭 http 服务的。 1234567891011firewall-cmd --state # 查看防火墙状态systemctl start firewalld.service # 开启防火墙systemctl stop firewalld.service # 关闭防火墙systemctl enable firewalld.service # 打开防火墙的开机自启systemctl disable firewalld.service # 关闭防火墙的开机自启firewall-cmd --permanent --zone=public --add-port=80/tcp # 让防火墙永久开放80端口firewall-cmd --reload # 加载配置 使得修改有效firewall-cmd --permanent --zone=public --list-ports # 查看开放的端口号firewall-cmd --permanent --zone=public --add-service=http # 让防火墙永久打开http服务firewall-cmd --reload # 加载配置 使得修改有效firewall-cmd --permanent --zone=public --list-service # 查看开放的服务 2.yum安装Nginx Nginx 是一个高性能的 HTTP 和反向代理服务器。 ①下载和安装123rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm # 将nginx添加到yum源的repo中yum repolist # 查看yum源的repoyum install nginx # yum源安装nginx ②启动1234systemctl enable nginx # 设置开机启动systemctl start nginx # 启动nginxsystemctl reload nginx # 重新加载nginxsystemctl status nginx # 查看nginx启动状态 ③验证配置 访问 公网ip:80 如果出现上图内容 说明配置成功 ④安装后的目录结构1234567查看刚安装的所有目录：rpm -ql nginx启动nginx：/usr/sbin/nginx主配置文件：/etc/nginx/nginx.conf 首页的html网页所在路径：/usr/share/nginx/html缓存目录：/var/cache/nginx/fastcgi_temp代理目录：/var/cache/nginx/proxy_temp... 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#121;&#x6d;&#101;&#x73;&#115;&#105;&#64;&#x31;&#54;&#x33;&#x2e;&#x63;&#111;&#x6d;]]></content>
      <categories>
        <category>Linux</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录GitHub+Hexo搭建博客过程]]></title>
    <url>%2F2019%2F05%2F04%2F%E8%AE%B0%E5%BD%95GitHub-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1.next 主题使用文档 官方文档 2.搭建博客教程 使用GitHub+Hexo搭建博客 3.使用基础①常用技巧 hexo 命令 出错时 可使用 hexo –debug 查看错误 安装插件命令是 install 卸载插件命令是 uninstall hexo clean：清除缓存文件和已生成的静态文件(public) 每次更新修改：| hexo g：重新生成缓存和静态文件。| hexo d/deploy：重新部署到服务器。 在博客文章中插入图片：点击查看| 注意：对于 next 主题，引入图片时使用 ![图片代替名](图片名.jpg) 的格式。 ②修改根目录下的 _config.yml 文件123456title: # 你的标题subtitle: # 副标题description: # 网站描述，便于搜索引擎用关键词检索。author: wjy # 作者language: # 语言timezone: Asia/Shanghai ③添加 about 等页面 使用此命令：hexo new page about| 会看到在 source 文件夹中生成了一个 about 文件夹，里面包含一个 index.md 文件。| 在这个 markdown 文件内，我们可以编写一些 about 页面的信息。 然后修改主题目录下的 _config.yml 文件 在 menu 中添加 about 页面的链接 添加其他页面同理，下列文字是为 next 主题配置页面链接。 12345678910menu: home: / || home archives: /archives/ || archive tags: /tags/ || tags categories: /categories/ || th 最爱: /love/ || soccer-ball-o 电影: /movies/ || film 书籍: /books/ || book 旅行: /photos/ || camera-retro about: /about/ || user 配置后会在页面菜单中生成一个关于 about 页面的链接 点击 about 就可跳转到 about 页面 ④写文章时添加分类、标签格式123456categories:- 分类1 - 分类2tags:- 标签1- 标签2 4.我的博客配置 我的博客：http://messi1002.top 语言：zh-Hans(中文) √ ①侧边栏 侧边栏排版(签名)及头像 √ 侧边栏作者头像旋转 √ 配置侧边栏中的社交账号及其图标 √ 侧边栏推荐阅读 √ DaoVoice 在线联系功能 √ 添加 RSS 订阅 √ ②网站主页 菜单栏优化及签名 √ 添加顶部加载条 √ 修改网页 icon √ 首页不显示全文 √ 添加 fork me on github √ 增加动态线段背景 √ 爆炸效果图 √ 增加宠物 √ 隐藏网页底部的 … By Hexo √ 文章添加阴影效果(好看) √ 修改网页底部的星星 √ 网站底部访问量统计 √ 网站底部字数统计 √ 博文置顶 √ 修改内容宽度 √ 添加博客背景 √ 设置站点图标 √ ③网站功能 添加本地搜索 √ 添加评论功能(来必力) √ 添加打赏功能 √ 添加 README.md 文件 √ 引入豆瓣电影和读书 √ 引入相册功能(两个) √| 最爱页—使用 GitHub 存放图片(简单)| 旅行页—使用阿里云存放图片(速度) ④文章细节 文章内容统计功能 √ 在文章底部增加版权信息 √ 修改文章内链接文本样式 √ 修改文章底部的带 # 号的标签 √ 添加热度 √ 代码高亮 √ 文章加密访问 √ 配置教程参考：Next主题配置博客 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#121;&#x6d;&#x65;&#115;&#115;&#x69;&#64;&#x31;&#x36;&#51;&#46;&#x63;&#111;&#x6d;]]></content>
      <categories>
        <category>博客相关</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[阿里云CentOS7安装 jdk8+tomcat8+maven+MySQL5.7+redis5]]></title>
    <url>%2F2019%2F04%2F27%2F%E9%98%BF%E9%87%8C%E4%BA%91CentOS7%E5%AE%89%E8%A3%85-jdk8-tomcat8-maven-MySQL5-7-redis5%2F</url>
    <content type="text"><![CDATA[1.我的服务器配置 2.准备工作①下载压缩包 下载 jdk8：https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 下载 tomcat8：https://tomcat.apache.org/download-80.cgi 下载 maven：http://maven.apache.org/download.cgi 下载 redis5：https://redis.io/download ②下载 Xftp6 Xftp6 是一款功能强大，主要用于 SFTP、FTP 文件传输的软件，能够帮助用户安全地在 UNIX/Linux 和 Windows PC 之间传输文件。我们需要使用此软件，将压缩包上传至阿里云服务器。 请自行搜索安装包 下载并安装 ③添加安全组规则 服务器的安全组默认未设置任何自定义放行规则，这将会导致无法访问实例端口，若需访问需要添加安全组规则放行对应的端口。 我们需要放行常用的端口号：8080、3306、22、6379 等 添加安全组规则： ④上传压缩包至服务器 打开 Xftp6 工具 点击 文件 – 新建 按下图填写信息并连接服务器 然后在 /usr/local/ 目录下新建 javaweb 文件夹 将压缩包上传到此文件夹中 ⑤设置防火墙 防火墙是系统的第一道防线，其作用是防止非法用户的进入。服务器的防火墙默认未设置任何自定义放行规则，这将会导致无法访问实例端口，若需访问需要防火墙放行对应的端口。注意：CentOS7 默认使用 firewalld 作为防火墙。 1234567891011firewall-cmd --state # 查看防火墙状态systemctl start firewalld.service # 开启防火墙systemctl stop firewalld.service # 关闭防火墙systemctl enable firewalld.service # 打开防火墙的开机自启systemctl disable firewalld.service # 关闭防火墙的开机自启firewall-cmd --permanent --zone=public --add-port=8080/tcp # 让防火墙永久开放8080端口firewall-cmd --permanent --zone=public --add-port=3306/tcp # 让防火墙永久开放3306端口firewall-cmd --permanent --zone=public --add-port=22/tcp # 让防火墙永久开放22端口firewall-cmd --permanent --zone=public --add-port=6379/tcp # 让防火墙永久开放6379端口firewall-cmd --reload # 加载配置 使得修改有效firewall-cmd --permanent --zone=public --list-ports # 查看开放的端口号 3.安装 jdk8 注意：若服务器版本是 CentOS7 系列，尽量不要安装系统自带的 openJDK (会有坑)！ ①解压安装包123cd /usr/local/javaweb # 进入该目录tar -zxvf jdk-8u201-linux-x64.tar.gz # 解压压缩包mv jdk1.8.0_201 jdk8 # 重命名文件夹 ②配置环境 使用 vim 命令打开文件 1vim /etc/profile # 配置环境变量 然后按 i 进入编辑模式 插入以下文字 123export JAVA_HOME=/usr/local/javaweb/jdk8 # jdk所在位置的绝对路径export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin 最后按 Esc 并输入 :wq 回车退出 1source /etc/profile # 使脚本文件生效 ③验证配置12javacjava -version 如果出现上图内容 说明配置成功 4.安装 tomcat8①解压安装包123cd /usr/local/javaweb # 进入该目录tar -zxvf apache-tomcat-8.5.39.tar.gz # 解压压缩包mv apache-tomcat-8.5.39 tomcat8 # 重命名文件夹 ②启动 tomcat812cd /usr/local/javaweb/tomcat8/bin # 进入该目录./startup.sh # 启动tomcat ③验证配置 访问 公网ip:8080 如果出现上图内容 说明配置成功 5.安装 maven①解压安装包123cd /usr/local/javaweb # 进入该目录tar -zxvf apache-maven-3.6.0-bin.tar.gz # 解压压缩包mv apache-maven-3.6.0 maven3 # 重命名文件夹 ②配置环境 使用 vim 命令打开文件 1vim /etc/profile.d/maven.sh # 配置环境变量 然后按 i 进入编辑模式 插入以下内容 123#!/bin/bashexport M2_HOME=/usr/local/javaweb/maven3 # maven所在位置的绝对路径export PATH=$PATH:$M2_HOME/bin 最后按 Esc 并输入 :wq 回车退出 1source /etc/profile.d/maven.sh # 使脚本文件生效 ③验证配置1mvn -v # 查看maven版本 如果出现上图内容 说明配置成功 6.安装 MySQL5.7①下载和安装12345rpm -ivh http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm # 下载安装包yum install -y mysql-server # 安装MySQLsystemctl enable mysqld.service # 设置开机自启动MySQLsystemctl start mysqld.service # 启动MySQLgrep &apos;temporary password&apos; /var/log/mysqld.log # 查看MySQL默认密码 ②登录 MySQL123mysql -uroot -p # 登录MySQL 然后输入默认密码(系统自动生成)SET PASSWORD = PASSWORD(&apos;Zxcvbnm10!_&apos;); # 修改默认密码 新密码必须包含大小写字母、数字、下划线和感叹号eixt # 退出MySQL 用新密码重新登录 ps：如果觉得新密码太复杂，可以修改以下两个字段来降低默认的密码安全级别。 12set global validate_password_policy=0; 设置密码安全级别为LOWset global validate_password_length=6; 设置密码最短长度为6 ③远程连接12GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;新密码&apos; WITH GRANT OPTION; # 开启root用户的远程访问权限flush privileges; # 使命令执行生效 使用 Navicat 远程访问数据库 连接后可以通过 Navicat 管理远程数据库 7.安装 redis5①解压安装包123cd /usr/local/javaweb # 进入该目录tar -zxvf redis-5.0.4.tar.gz # 解压压缩包mv redis-5.0.4 redis5 # 重命名文件夹 ②配置环境1234567cd /usr/local/javaweb/redis5 # 进入解压后的目录make # 编译mkdir -p /usr/local/javaweb/redis # 新创建目录存储rediscp /usr/local/javaweb/redis5/src/redis-server /usr/local/javaweb/redis/ # 复制redis-server到新目录cp /usr/local/javaweb/redis5/src/redis-cli /usr/local/javaweb/redis/ # 复制redis-cli到新目录cp /usr/local/javaweb/redis5/redis.conf /usr/local/javaweb/redis/ # 复制redis.conf到新目录cd /usr/local/javaweb/redis/ # 进入新目录 使用 vim 命令打开文件 1vim /usr/local/javaweb/redis/redis.conf # 编辑配置文件 然后按 i 进入编辑模式 编辑以下字段 1234bind 127.0.0.1 ——&gt; # bind 127.0.0.1 # 将此行注释掉protected-mode yes ——&gt; protected-mode nodaemonize no ——&gt; daemonize yes# requirepass foobared ——&gt; requirepass 123456 # 设置密码为123456 最后按 Esc 并输入 :wq 回车退出 使用 vim 命令打开文件 1vim /etc/init.d/redis #编辑redis开机启动脚本 然后按 i 进入编辑模式 插入以下文字 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/bin/sh # chkconfig: 2345 80 90 # description: Start and Stop redis #PATH=/usr/local/bin:/sbin:/usr/bin:/bin REDISPORT=6379 EXEC=/usr/local/javaweb/redis/redis-server REDIS_CLI=/usr/local/javaweb/redis/redis-cli PIDFILE=/var/run/redis_6379.pid CONF=&quot;/usr/local/javaweb/redis/redis.conf&quot; AUTH=&quot;123456&quot;case &quot;$1&quot; in start) if [ -f $PIDFILE ] then echo &quot;$PIDFILE exists, process is already running or crashed&quot; else echo &quot;Starting Redis server...&quot; $EXEC $CONF fi if [ &quot;$?&quot;=&quot;0&quot; ] then echo &quot;Redis is running...&quot; fi ;; stop) if [ ! -f $PIDFILE ] then echo &quot;$PIDFILE does not exist, process is not running&quot; else PID=$(cat $PIDFILE) echo &quot;Stopping ...&quot; $REDIS_CLI -p $REDISPORT SHUTDOWN while [ -x $&#123;PIDFILE&#125; ] do echo &quot;Waiting for Redis to shutdown ...&quot; sleep 1 done echo &quot;Redis stopped&quot; fi ;; restart|force-reload) $&#123;0&#125; stop $&#123;0&#125; start ;; *) echo &quot;Usage: /etc/init.d/redis &#123;start|stop|restart|force-reload&#125;&quot; &gt;&amp;2 exit 1esac 最后按 Esc 并输入 :wq 回车退出 使用 vim 命令打开文件 1vim /etc/rc.local # 添加开机启动服务 然后按 i 进入编辑模式 插入以下文字 1service redis start 最后按 Esc 并输入 :wq 回车退出 ③登录 redis12345678910chmod 755 /etc/init.d/redis # 设置权限chkconfig --add redis # 注册系统服务service redis start # 启动redis服务ps -ef|grep redis # 查看当前状态ln -s /usr/local/javaweb/redis/redis-cli /usr/bin/redis # 创建redis命令软连接cd /redis # 进入redisauth 123456 # 密码验证set name wiy # 增加用户get name ④验证配置 如果上图命令没有报错 说明配置成功 ⑤远程连接 使用 Redis Desktop Manager 远程访问数据库 连接后可以通过 Redis Desktop Manager 管理远程数据库 ⑥参考博客 https://blog.csdn.net/lc1010078424/article/details/78295482 8.部署 Springboot 项目①打包项目123本地命令行中: cd 项目根目录 # 进入该目录mvn package # 将项目打包 ②上传 jar 包 使用 Xftp6 工具上传 jar 包至服务器 ③运行 jar 包 方式一：在当前窗口运行 12cd /usr/local/javaweb/springboot # 进入该目录java -jar luckymoney-0.0.1-SNAPSHOT.jar # 运行此jar包 方式二：使 jar 包一直处于后台运行 123cd /usr/local/javaweb/springboot # 进入该目录nohup java -jar luckymoney-0.0.1-SNAPSHOT.jar &amp; # 运行此jar包cat nohup.out # 此文件存放控制台的实时输出内容 ④验证配置 如上图内容 我们成功地访问了这个 springboot 项目 间接说明了配置的正确性！ Ctrl + v：停止运行项目 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#x79;&#109;&#101;&#115;&#x73;&#105;&#x40;&#x31;&#x36;&#51;&#x2e;&#x63;&#x6f;&#x6d;]]></content>
      <categories>
        <category>Linux</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git-版本控制工具]]></title>
    <url>%2F2019%2F04%2F15%2FGit-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[版本控制工具的发展： git 是分布式版本控制系统，能记录所有文件的所有版本，并有效地追踪文件的变化，也容易回滚到文件之前的状态。 1.安装与配置①下载 git 下载地址：https://git-scm.com/downloads 然后按默认选项安装即可 ②验证安装 打开命令行 输入 git 如果出现上图内容 说明安装成功 ③配置用户信息 安装好 git 后，需要配置用户信息(绑定 GitHub 用户名 和邮箱)。 2.Git 仓库 仓库又名版本库，英文名是 repository，可以将之理解为一个目录，目录中的所有文件都可被 git 管理。每个文件的修改、删除等操作都可以被 git 追踪。 git 仓库的相关操作： 12345678910111213141516171819202122pwd: 查看目前位置。cd 文件夹名: 进入该目录。cd ..: 进入上级目录。git init: 初始化版本库。git add: 添加文件到暂存区。git commit: 将文件从暂存区提交到仓库。git status: 查看仓库状态信息。ll: 展示当前目录的详细信息，等价于ls -l。ls -a: 展示隐藏和非隐藏文件。 一般点开头的文件都是隐藏文件。 创建仓库详情: mkdir test // 创建test目录。 cd test // 进入test目录。 git init // 初始化版本库。 ll // 目录为空。 ls -a // 展示.git隐藏目录。 echo &quot;......&quot; &gt;&gt; test.txt // 将&apos;......&apos;追加到test.txt文件中。 cat test.txt // 展示当前文件内容。 git add test.txt // 添加文件到版本库(即本地暂存区)。 git commit -m &quot;repo first commit&quot; // 提交到仓库中，&quot;repo first commit&quot;为本次提交的描述信息。 git status // 查看仓库状态。 3.Git 工作流 原理分析：当工作区使用 git add 命令将修改后的文件提交到暂存区时，暂存区中的文件将会被提交到 object 文件目录中，index 的指针也会指向 object 文件目录中的新文件 id。执行 git commit 命令后，master 分支更新，其中的指针也会指向 object 文件目录中的新文件 id。 ①暂存区到工作区的回滚 一般开发完成但还没有测试的文件都会被提交到暂存区 如果不想要暂存区的最新版本 可以直接丢弃| git reset HEAD 文件名(将暂存区的内容还原为最后一次提交的内容)| git checkout – 文件名(将工作区的内容还原为最后一次提交的内容) ②已提交版本的回滚 要找到以前的提交版本 需要回滚 我们先创建一次提交： 现在查看 commit 号：git log 此时代码需要回到过去 即将 hard 指针(当前环境的版本指针)修改到某次 commit 上：git reset –hard commit号 回到过去后 使用 git reflog 可以查看”未来”的版本号 ③清空仓库 清空本地仓库： git rm –cache 文件名：删除添加到暂存区的文件 git rm 文件名：同时删除工作区和暂存区的文件 注意：以上所有操作只是提交给本地仓库，并不是 Github。 4.远程仓库 本地仓库：在电脑上的仓库 远程仓库：在公网服务器上的仓库 通过 git push 提交修改到远程仓库时，需要 ssh 连接(连接后每次提交都不需要重新输入密码)。ssh 连接的具体步骤：https://blog.csdn.net/qq_41979043/article/details/83046278 —— 3.安装git 关联远程仓库： 每次可以使用 git push 命令 将本地仓库的 master 分支同步到远程仓库的 master 分支 5.克隆仓库 将远程仓库克隆到本地： 1.Clone with SSH：git clone git@github.com:messi1002/test.git 2.Clone with HTTPS：git clone https://github.com/messi1002/test.git 将远程仓库的文件更新到本地仓库：git pull origin master 6.标签管理 当需要发布新的版本时，需要在版本库中打一个标签(确定该标签对应的版本时刻)。以后想要回滚到某个版本时，可以直接通过标签(版本号)回滚。 新建标签并指定提交信息：git tag -a name -m “comment” 删除标签：git tag -d name 7.分支管理 当我们需要修改正在更新的项目的 bug 时，可以新建一个分支，以已经发布的项目代码为基础，修改 bug 后重新发布代码，最后再将此分支合并到正在开发的分支上。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#121;&#109;&#101;&#x73;&#115;&#105;&#x40;&#x31;&#54;&#x33;&#x2e;&#99;&#111;&#x6d;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON快速入门(JAVA版)]]></title>
    <url>%2F2019%2F04%2F11%2FJSON%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-JAVA%E7%89%88%2F</url>
    <content type="text"><![CDATA[org.json、gson 等 jar 包的下载：链接：https://pan.baidu.com/s/1sjMDVajQgR-ihFvAZ54ymg提取码：dt84 1.了解 JSON 它的全称为 JavaScript Object Notation。 ①优点 JSON 是一种与开发语言无关的、轻量级的数据交换格式。| 它采用完全独立于编程语言的文本格式来存储和表示数据。| 最初来自 JS，后来几乎每种常用语言都有处理 JSON 的 API，它支持多种服务器端语言，便于服务器端的解析。 JSON 是行业内使用最为广泛的数据传输格式。| 调用服务端 API 时会使用 JSON 作为返回格式。 JSON 是数据存储的一种格式，格式简单、易于读写、占用带宽小。| 它易于易于程序的解析和生成，并能有效的提升网络传输效率。 ②缺点 要求字符集必须是 Unicode，受约束性强。 ③实例 { }：标识一个 JSON 对象(即结构体)。| { } 中包含键值对结构，key 必须是 String 类型，value 为任何基本类型、对象或数组，多个键值对之间用逗号分隔。 []：数组 Array，用逗号分隔元素。| 在 Java 中，可用集合、string[] 等定义。 元素基本类型：String、number、true、false、null。| JSON 中的数字没有浮点数、整数 … 之分。但在 Java 中，JSONObject 的 put 方法会自动区分不同的数字格式。这是一种 JSON 原生数据格式到 Java 数据格式的映射关系。| 标准 JSON 中不支持任何形式的注释。| JSON 中没有日期 / 时间数据格式。 2.org.json 包的使用①使用 JSONObject 构建 JSON 对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package json;import org.json.JSONException;import org.json.JSONObject;/** * @Auther: wjy * @Date: 2019/4/10 16:34 * @Description: 使用JSONObject构建JSON对象。 */public class jsonTest &#123; public static void main(String[] args) &#123; JSONObject messi = new JSONObject(); Object null1 = null; try &#123; messi.put("name", "messi"); // put方法具有替代性，第二次赋值会代替第一次赋值。 messi.put("name", "梅西"); messi.put("age", 31.8); // JSON中用String类型代替日期类型。 messi.put("birthday", "1987-06-24"); messi.put("home", "Barcelona"); // 可用集合、string[]等定义JSON数组。 messi.put("major", new String[]&#123;"player", "star"&#125;); messi.put("car", true); messi.put("house", true); // 直接使用null会产生二义性。 messi.put("daughter", null1); messi.put("girlfriend", "安东内拉"); // 此键值作为JSON数据的注释。 messi.put("comment", "love him!!"); // 打印JSON格式的数据。 /* * 自动去除空格 —— 压缩数据。 * 与键值的插入顺序不同。 * &#123;"birthday":"1987-06-24","girlfriend":"安东内拉","major":["player","star"],"car":true,"name":"梅西","comment":"love him!!","house":true,"age":31.8,"home":"Barcelona"&#125; */ System.out.println(messi.toString()); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ②使用 Map 构建 JSON 对象1234567891011121314151617181920212223242526272829303132333435363738394041424344package json;import org.json.JSONObject;import java.util.HashMap;/** * @Auther: wjy * @Date: 2019/4/10 16:34 * @Description: 使用Map构建JSON对象。 */public class jsonTest &#123; public static void main(String[] args) &#123; HashMap&lt;String, Object&gt; messi = new HashMap&lt;String, Object&gt;(); Object null1 = null; messi.put("name", "messi"); // put方法具有替代性，第二次赋值会代替第一次赋值。 messi.put("name", "梅西"); messi.put("age", 31.8); // JSON中用String类型代替日期类型。 messi.put("birthday", "1987-06-24"); messi.put("home", "Barcelona"); // 可用集合、string[]等定义JSON数组。 messi.put("major", new String[]&#123;"player", "star"&#125;); messi.put("car", true); messi.put("house", true); // 直接使用null会产生二义性。 messi.put("daughter", null1); messi.put("girlfriend", "安东内拉"); // 此键值作为JSON数据的注释。 messi.put("comment", "love him!!"); // 打印JSON格式的数据。 /* * 通过JSONObject的构造函数传入Map对象,来构建一个JSON对象。 * 自动去除空格 —— 压缩数据。 * 与键值的插入顺序不同。 * &#123;"birthday":"1987-06-24","girlfriend":"安东内拉","major":["player","star"],"car":true,"name":"梅西","comment":"love him!!","house":true,"age":31.8,"home":"Barcelona"&#125; */ System.out.println(new JSONObject(messi).toString()); &#125;&#125; ③使用 Javabean 构建 JSON 对象(推荐使用)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package json;/** * @Auther: wjy * @Date: 2019/4/10 17:21 * @Description: 封装数据的Javabean。 */public class lover &#123; private String name; private double age; // 日期类型需要用字符串类型代替。 private String birthday; private String home; private String[] major; private Boolean car; private Boolean house; private String girlfriend; private Object daugter; private String comment; public lover() &#123;&#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getAge() &#123; return age; &#125; public void setAge(double age) &#123; this.age = age; &#125; public String getBirthday() &#123; return birthday; &#125; public void setBirthday(String birthday) &#123; this.birthday = birthday; &#125; public String getHome() &#123; return home; &#125; public void setHome(String school) &#123; this.home = home; &#125; public String[] getMajor() &#123; return major; &#125; public void setMajor(String[] major) &#123; this.major = major; &#125; public Boolean getCar() &#123; return car; &#125; public void setCar(boolean car) &#123; this.car = car; &#125; public Boolean getHouse() &#123; return house; &#125; public void setHouse(boolean house) &#123; this.house = house; &#125; public String getGirlfriend() &#123; return girlfriend; &#125; public void setGirlfriend(String girlfriend) &#123; this.girlfriend = girlfriend; &#125; public Object getDaughter() &#123; return daugter; &#125; public void setDaughter(Object daugter) &#123; this.daugter = daugter; &#125; public String getComment() &#123; return comment; &#125; public void setComment(String comment) &#123; this.comment = comment; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637package json;import org.json.JSONObject;/** * @Auther: wjy * @Date: 2019/4/10 16:34 * @Description: 使用Javabean构建JSON对象。 */public class jsonTest &#123; public static void main(String[] args) &#123; // 声明一个bean的实例。 lover messi = new lover(); Object null1 = null; // 给bean的属性赋值。 messi.setName("梅西"); messi.setAge(31.8); messi.setBirthday("1987-06-24"); messi.setHome("Barcelona"); messi.setMajor(new String[]&#123;"player", "star"&#125;); messi.setCar(true); messi.setHouse(true); messi.setDaughter(null1); messi.setGirlfriend("安东内拉"); messi.setComment("love him!!"); /* * 通过JSONObject的构造函数传入Javabean实例，来构建一个JSON对象。 * 并不是直接对JSONObject进行操作，没有将属性直接put到JSONObject中。而是先创建一个Javabean对象，给此对象的属性赋值，便于重用Javabean。 * &#123;"birthday":"1987-06-24","girlfriend":"安东内拉","major":["player","star"],"car":true,"name":"梅西","comment":"love him!!","daughter":null,"house":true,"age":31.8,"home":null&#125; */ System.out.println(new JSONObject(messi).toString()); &#125;&#125; ④从文件中读取 JSON 需要将此 JSON 文件放在工程根目录下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package json;import java.io.File;import java.io.IOException;import org.apache.commons.io.FileUtils;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;/** * @Auther: wjy * @Date: 2019/4/10 18:31 * @Description: 从文件中读取JSON数据。 * 注意: JSONObject不支持将JSON数据反解析为Javabean。 */public class readJsonTest &#123; public static void main(String[] args) throws IOException, JSONException &#123; // 获取文件。 File file = new File(readJsonTest.class.getResource("../messi.json").getFile()); // 读取文件内容。 String content = FileUtils.readFileToString(file); // 将文件内容转换为JSON对象。 JSONObject json = new JSONObject(content); // 增加程序的健壮性。 if (!json.isNull("name")) System.out.println("name: " + json.getString("name")); // 解析JSON格式的数据。 System.out.println("age: " + json.getDouble("age")); System.out.println("birthday: " + json.getString("birthday")); System.out.println("home: " + json.getString("home")); System.out.println("car? " + json.getBoolean("car")); System.out.println("house? " + json.getBoolean("house")); System.out.println("comment: " + json.getString("comment")); // JSONObject对象不能解析JSON格式中的数组，需要JSONArray对象解析。 // 获取JSON格式中的数组。 JSONArray array = json.getJSONArray("major"); // 遍历获取到的数组。 /* * 专业-1: player * 专业-2: star */ for (int i = 0; i &lt; array.length(); i++) System.out.println("专业-" + (i+1) + ": " + array.getString(i)); &#125;&#125; 3.GSON 的使用 Google 提出的开源项目(第三方工具)，相比于 JSONObject，功能更强大、性能更出色、使用方式更简单。 ①使用 Javabean 构建 JSON 对象(推荐使用)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package gson;/** * @Auther: wjy * @Date: 2019/4/11 17:21 * @Description: 封装数据的JavaBean。 */public class lover1 &#123; private String name; private double age; private String birthday; private String home; private String[] major; private Boolean car; private Boolean house; private String girlfriend; private Object daughter; private String comment; public lover1() &#123;&#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getAge() &#123; return age; &#125; public void setAge(double age) &#123; this.age = age; &#125; public String getBirthday() &#123; return birthday; &#125; public void setBirthday(String birthday) &#123; this.birthday = birthday; &#125; public String getHome() &#123; return home; &#125; public void setHome(String home) &#123; this.home = home; &#125; public String[] getMajor() &#123; return major; &#125; public void setMajor(String[] major) &#123; this.major = major; &#125; public Boolean getCar() &#123; return car; &#125; public void setCar(boolean car) &#123; this.car = car; &#125; public Boolean getHouse() &#123; return house; &#125; public void setHouse(boolean house) &#123; this.house = house; &#125; public String getGirlfriend() &#123; return girlfriend; &#125; public void setGirlfriend(String girlfriend) &#123; this.girlfriend = girlfriend; &#125; public Object getDaughter() &#123; return daughter; &#125; public void setDaughter(Object daugter) &#123; this.daughter = daugter; &#125; public String getComment() &#123; return comment; &#125; public void setComment(String comment) &#123; this.comment = comment; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435package gson;import com.google.gson.Gson;/** * @Auther: wjy * @Date: 2019/4/11 10:13 * @Description: 使用Javabean构建JSON对象。 */public class gsonTest &#123; public static void main(String[] args) &#123; lover1 messi = new lover1(); Object null1 = null; Gson gson = new Gson(); messi.setName("messi"); messi.setAge(31.8); messi.setBirthday("1987-06-24"); messi.setHome("Barcelona"); messi.setMajor(new String[]&#123;"player", "star"&#125;); messi.setCar(true); messi.setHouse(true); messi.setDaughter(null1); messi.setGirlfriend("安东内拉"); messi.setComment("love him!!"); // 生成JSON格式的数据。 /* * &#123;"name":"messi","age":31.8,"birthday":"1987-06-24","home":"Barcelona","major":["player","star"],"car":true,"house":true,"girlfriend":"安东内拉","comment":"love him!!"&#125; */ System.out.println(gson.toJson(messi)); &#125;&#125; ②个性化定制 JSON123456789101112131415161718192021222324252627282930313233343536373839404142package gson;import com.google.gson.annotations.SerializedName;/** * @Auther: wjy * @Date: 2019/4/11 17:21 * @Description: 封装数据的JavaBean。 * GSON有更强的灵活性。 */public class lover2 &#123; // 通过添加注解的方式，标识生成JSON对象的一个key。 // 将name转换为NAME，相当于解析的时候重新命名key值。 @SerializedName("NAME") private String name; private double age; // 隐藏某个属性。 private transient String ignore; public lover2() &#123;&#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getAge() &#123; return age; &#125; public void setAge(double age) &#123; this.age = age; &#125; public String getIgnore() &#123; return ignore; &#125; public void setIgnore(String ignore) &#123; this.ignore = ignore; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package gson;import com.google.gson.Gson;import com.google.gson.GsonBuilder;/** * @Auther: wjy * @Date: 2019/4/11 10:13 * @Description: 使用Javabean构建JSON对象。 * 个性化构建JSON格式。 */public class gsonTest &#123; public static void main(String[] args) &#123; lover2 messi = new lover2(); GsonBuilder gb = new GsonBuilder(); // 通过Javabean类中的注解将name变为NAME，即在构建过程中将key个性化，一直有效。 messi.setName("messi"); messi.setAge(31.8); // 通过传入回调参数将age变为AGE，即在构建过程中将key个性化，仅在这个gb对象中有效。 gb.setFieldNamingStrategy(field -&gt; &#123; if (field.getName().equals("age")) return "AGE"; else return field.getName(); &#125;); // 生成JSON格式的数据。 /* * &#123;"NAME":"messi","AGE":31.8&#125; */ System.out.println(gb.create().toJson(messi)); // 美化JSON格式。 gb.setPrettyPrinting(); // 生成JSON格式的数据。 /* * &#123; * "NAME": "messi", * "AGE": 31.8 * &#125; */ System.out.println(gb.create().toJson(messi)); Gson gson = new Gson(); // 在JavaBean中构建JSON对象时隐藏某个属性(private transient String 属性名)。 messi.setIgnore("I love you!"); // 生成JSON格式的数据。 /* * 隐藏了ignore属性。 * &#123;"NAME":"messi","age":31.8&#125; */ System.out.println(gson.toJson(messi)); &#125;&#125; ③从文件中读取 JSON + 将 JSON 数据反解析为 Javabean 对象 将 JSON 数据反解析为 Javabean 对象时，GSON 支持将 String 类型的日期转换为日期类型。GSON 会将 JSON 数据中的数组自动转换为 Javabean 对象中的集合类型。 1234567891011121314151617181920212223242526272829303132333435363738394041package gson;import java.util.Date;import java.util.List;/** * @Auther: wjy * @Date: 2019/4/11 17:21 * @Description: 封装数据的Javabean。 * 将JSON数据反解析为Javabean对象。 */public class lover3 &#123; private double age; // 日期类型。 private Date birthday; // 集合类型。 private List&lt;String&gt; major; public lover3() &#123;&#125; public double getAge() &#123; return age; &#125; public void setAge(double age) &#123; this.age = age; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public List&lt;String&gt; getMajor() &#123; return major; &#125; public void setMajor(List&lt;String&gt; major) &#123; this.major = major; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243package gson;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import org.apache.commons.io.FileUtils;import java.io.File;import java.io.IOException;/** * @Auther: wjy * @Date: 2019/4/11 20:00 * @Description: 从文件中读取JSON。 * 将JSON数据反解析为Javabean对象。 */public class readJsonTest &#123; public static void main(String[] args) throws IOException &#123; // 从文件中读取JSON。 File file = new File(readJsonTest.class.getResource("../messi.json").getFile()); String content = FileUtils.readFileToString(file); // 使用GsonBuilder的setDateFormat("日期模板")方法可以将JSON对象中String类型的日期转换成Date类型。 Gson gson = new GsonBuilder().setDateFormat("yyyy-MM-dd").create(); // JSON对象中的key与Javabean的属性一一对应。 // 将JSON数据反解析为Javabean对象。 lover3 messi = gson.fromJson(content, lover3.class); /* * Wed Jun 24 00:00:00 CDT 1987 * 31.8 * gson.lover3@1e4a7dd4 * GSON会将JSON数据中的数组自动转换为Javabean对象中的集合类型。 * [player, star] * class java.util.ArrayList */ System.out.println(messi.getBirthday()); System.out.println(messi.getAge()); System.out.println(messi.toString()); System.out.println(messi.getMajor()); System.out.println(messi.getMajor().getClass()); &#125;&#125; org.json 是 Android SDK 的官方库。GSON 应用于服务端开发，功能更强大。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#x6a;&#121;&#x6d;&#101;&#115;&#115;&#105;&#64;&#49;&#54;&#51;&#x2e;&#x63;&#x6f;&#x6d;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10 + Ubuntu 18.04 双系统安装]]></title>
    <url>%2F2019%2F04%2F06%2Fwin10-Ubuntu-18-04-%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[1.准备工作①下载 Ubuntu 18.04.2 LTS 官网地址：https://www.ubuntu.com/download/desktop ②下载 Rufus Rufus 是 Ubuntu 官网推荐的 USB 启动盘制作工具。 官网地址：https://rufus.ie/ 或者我的网盘分享：https://pan.baidu.com/s/1uWUmyNQuupPJIp2YDhKDgg，提取码：fwea。 ③制作 Ubuntu 18.04 U盘启动 打开下载好的 Rufus 并将空U盘插入电脑，点击 选择，添加 Ubuntu 18.04.2 LTS。 其他设置如图所示，点击 开始 后，一直选择 OK 即可。 按照上图设置后，软件会把 ubuntu-18.04.2-desktop-amd64.iso 文件写入U盘，制作系统启动盘。 写入完成，点击 关闭。 刻录完成后的U盘内部： ④关闭 win10 的快速启动 关闭快速启动：https://jingyan.baidu.com/article/ca00d56c7a40e6e99febcf4f.html#!/article/ca00d56c7a40e6e99febcf4f ⑤磁盘分区 使用快捷键 win + x + Ctrl + k 打开 win10 的 磁盘管理 选择剩余空间较大的可分配磁盘，点击 右键 并选择 压缩卷，压缩 50~80 G。 压缩成功： 2.安装过程①BIOS 设置 重启电脑，按 F12。 进入 BIOS 设置后，如下图操作。 然后插入U盘，保存设置并退出，电脑会自动重启。 继续按 F12，选择如何启动电脑。 ②进入 Ubuntu 每次选择空闲设备中内存最大的设备——用于设置分区(四个分区)。| /：存储系统文件。| swap：交换分区。| /boot：包含系统内核和系统启动文件。| /home：存放文件。 然后将剩余空间全部用于创建 home 分区| 类型：逻辑分区。| 用于：Ext4 日志文件系统。| 挂载点：/home。 分区效果图： 最后设置时区、注册账号、重启电脑，即可完成安装。 3.问题总结①系统时间不同步 修改 Linux 系统时间： 123456# 安装ntpdate。sudo apt-get install ntpdate# 校准时间。sudo ntpdate time.windows.com# 将时间更新到硬件上。sudo hwclock --localtime --systohc 修改 win 系统时间：https://jingyan.baidu.com/article/60ccbcebbb041b64cab19730.html ②WIFI 无法开启 如图：优先级较前的 ideapad_wlan 的 Hard blocked 默认为 yes，说明 Ubuntu 默认关闭了硬件 wifi 开关，我们需要将这个模块移除，以便使用序号 3 模块(wifi 开关是打开的)。 注意：每次重启 Ubuntu 系统都要重新将第一个模块移除。 ③Linux 无法关机/重启 进入 软件和更新，选择 附加驱动，安装 NVDIA 专用驱动即可。 ④分区详解 https://blog.csdn.net/cl_cjh/article/details/69396906 ⑤误删 win10 引导 用快启动 pe 修复 win10 系统引导：https://blog.csdn.net/jessical1020/article/details/72933056 4.参考博客 安装教程：https://blog.csdn.net/lipengfei0427/article/details/83116527http://tieba.baidu.com/p/5276785632 更改系统时间：https://blog.csdn.net/hansion3333/article/details/60469583 WIFI 无法开启：https://www.linuxidc.com/Linux/2015-04/116077.htm 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#106;&#121;&#109;&#101;&#x73;&#x73;&#x69;&#64;&#x31;&#54;&#51;&#x2e;&#x63;&#x6f;&#109;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识微信公众号开发]]></title>
    <url>%2F2019%2F03%2F19%2F%E5%88%9D%E8%AF%86%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[1.了解微信公众号①明确概念 公众号与微信聊天的区别 公众号类型介绍| 企业号：消息出现在好友会话列表首层、每分钟最多群发 200 条消息、通讯录关注、支持保密消息。| 服务号：消息出现在好友会话列表首层、每周最多群发一条消息、查找关注。| 订阅号：支持个人申请、每天最多群发一条消息、查找关注、不支持高级接口权限。 以下内容，仅针对订阅号。 ②申请公众号 注册地址：微信公众平台 微信公众平台是腾讯为了让用户申请和管理微信公众账号而推出的一个 web 平台。 登记信息 填写账号名称和功能介绍 个性化公众号 ③功能模块 可群发文字、图片、语音、视频或图文消息(每天 1 条) 自动回复| 被添加自动回复| 固定自动回复(每小时提示一次)| 关键词自动回复(灵活) 自定义菜单| 最多三个 1 级菜单| 最多五个 2 级菜单 投票功能(文章中加入) … ④管理模块 消息管理(回复消息) 用户管理(管理已关注的用户) 素材管理(保存公众号的群发内容) ⑤编辑模式 微信公众号开发的模式之一——编辑模式。 所谓编辑模式 就是在官网网页上操作基本功能 添加被关注自动回复 &emsp; 根据服务功能设置关键字回复(关注中英文差异) &emsp; 素材管理| 单图文消息可显示摘要，多图文消息只显示标题。| 如下为多图文消息： &emsp; 自定义菜单| click 类型(发送消息)| view 类型(跳转到网页) &emsp; &emsp; 群发消息(每天 1 次) 2.开发前奏①开发准备 开发环境下，要想与微信后台对接，需要在公网上访问本机服务器 URL 地址(只能使用 80 端口 / 443 端口)。因此，需要用映射工具将本机地址映射到公网上。 一个微信公众号 外网映射工具(开发调试) ②映射工具 ngrok：服务器在国外、访问速度慢、每次映射地址不同(现在国内有很多使用它的方法)。 tunnel：部署在国内、支持 ngrok 的绝大数功能(现在不可用)。 正在使用 NATAPP.cn，教程见用NATAPP进行微信本地开发调试—1。 ③访问模式 映射成功后，使用以下格式进行公网访问。 本地访问：http://localhost:8080/Test/index.jsp 对应的公网访问：(映射公网)/Test/index.jsp 3.开发模式 微信公众号开发的模式之一——开发模式。注意：开发模式和编辑模式是互斥关系，两者的设置不共存。只能使用一种模式，选择之后公众号会应用该模式的所有设置。 ①数据交互原理 如下所示： &emsp; 其中，微信公众号服务器就是我们在开发模式下需要开发的内容。 ②开发模式接入 具体操作参见：用NATAPP进行微信本地开发调试—2 通过之前的操作 我们已经进入了开发模式 启用了开发模式 编辑模式的设置会自动失效| 此时编辑模式下的自动回复和菜单栏都跑了。 &emsp; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#106;&#121;&#x6d;&#x65;&#x73;&#115;&#105;&#64;&#49;&#54;&#x33;&#46;&#99;&#x6f;&#109;]]></content>
      <categories>
        <category>微信开发</category>
      </categories>
      <tags>
        <tag>微信公众号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用NATAPP进行微信本地开发调试]]></title>
    <url>%2F2019%2F03%2F11%2F%E7%94%A8NATAPP%E8%BF%9B%E8%A1%8C%E5%BE%AE%E4%BF%A1%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[开发环境下，要想与微信后台对接，需要在公网上访问本机服务器 URL 地址(只能使用 80 端口 / 443 端口)。因此，需要用映射工具将本机地址映射到公网上。 1.使用NATAPP①购买隧道 地址：https://natapp.cn/ 注册之后 点击 登录 然后购买隧道| 注意：免费隧道在每次启动窗口时都会更换映射地址。 &emsp;&emsp; 填写 80 端口 / 443 端口(微信仅支持这两个端口号) &emsp;&emsp; 然后进入刚刚购买的隧道 记住你的 authtoken ②映射 下载客户端 &emsp;&emsp; 新建一个 config.ini 文件 内容如下| 将 authtoken 字段的值修改为刚刚购买的隧道的 authtoken。 12345678#将本文件放置于natapp同级目录,程序将读取[default]段。#在命令行参数模式如 natapp -authtoken=xxx 等相同参数将会覆盖掉此配置。[default]authtoken=你的authtoken #对应一条隧道的authtoken。clienttoken= #对应客户端的clienttoken,将会忽略authtoken,若无请留空。log=none #log 日志文件,可指定本地文件,none=不做记录,stdout=直接屏幕输出,默认为none。loglevel=ERROR #日志等级DEBUG,INFO,WARNING,ERROR默认为DEBUG。http_proxy= #代理设置 如 http://10.123.10.10:3128 非代理上网用户,请务必留空。 将客户端程序和 config.ini 文件放入同一个文件夹中 启动命令行 进入该文件夹 输入 natapp -authtoken=你的authtoken 即可得到如下结果 &emsp;&emsp; 再注意！！对于免费隧道来说，每次启动 natapp.exe 进行映射时，其外网映射地址都会改变。 ③映射测试 将工程的 Tomcat 端口号改为 80 端口或 443 端口(对应隧道的端口号)| 在 Spring Boot 工程中，按照以下方式修改： &emsp;&emsp; &emsp;&emsp; | 其他工程的修改方式： &emsp;&emsp; 若此时访问 127.0.0.1:80(或localhost:80) 和访问 映射外网:80 是同一个效果，说明映射成功！ 2.微信开发者模式接入①填写服务器配置 服务器地址 URL：所映射的外网地址 / 工程校验代码的访问地址。| 如： http://qc95we.natappfree.cc/weixinA。 Token：开发者随意填写 在接入认证时生成一个签名。| 需要在校验代码中定义一个字符串名为 Token，此字符串值对应所填写内容，具体看下文。 ②验证服务器地址的有效性 开发者提交信息后，微信服务器会发送 GET 请求到填写的服务器地址 URL 上，GET 请求携带以下四个参数。 &emsp;&emsp; signature 微信加密签名 &emsp;&emsp; timestamp 时间戳 &emsp;&emsp; nonce 随机数 &emsp;&emsp; echostr 随机字符串 需要开发者将 token、timestamp、nonce 这三个参数进行排序，再拼接成字符串并对其进行 sha1 加密，再将加密后的字符串与微信加密签名( signature )进行对比，两个字符串相同时(可标识该 GET 请求来自微信服务器)返回 echostr 参数内容，此时开发者接入成功。 ③具体代码 我在 Spring Boot 工程中配置了 Servlet 校验代码。如果你不想在 Spring Boot 工程中测试，可以在其他 web 应用的 web.xml 文件中自行配置 Servlet。只是配置文件不同，校验代码都相同。 工程目录结构如下： &emsp;&emsp; 附上我的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package com.example.springbootdemo.config;import com.example.springbootdemo.util.CheckUtil;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * @Auther: wjy * @Date: 2018/12/4 20:56 * @Description: 获得参数。 */public class WeixinServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; request.setCharacterEncoding("UTF-8"); response.setCharacterEncoding("UTF-8"); PrintWriter out = response.getWriter(); String echostr = request.getParameter("echostr"); String signature = request.getParameter("signature"); String timestamp = request.getParameter("timestamp"); String nonce = request.getParameter("nonce"); if (CheckUtil.check(timestamp, nonce, signature) == true) out.print(echostr); &#125;&#125;--------------------------------------------------------------------------------package com.example.springbootdemo.util;import java.security.MessageDigest;import java.util.Arrays;/** * @Auther: wjy * @Date: 2018/12/4 21:57 * @Description: 开发者校验。 */public class CheckUtil &#123; public static String token = "weixinAAAA"; /* * 按照微信公众号平台要求校验。 */ public static boolean check(String timestamp, String nonce, String signature) &#123; String[] string = new String[]&#123;timestamp, nonce, token&#125;; String s = new String(); String encrypt = null; Arrays.sort(string); for (int i = 0; i &lt; string.length; i++) s += string[i]; encrypt = getSha1(s); System.out.println(encrypt); if (encrypt.equals(signature)) return true; else return false; &#125; /* * 加密。 */ public static String getSha1(String decript) &#123; if(decript == null | decript .length() == 0) return null; char hexDigits[] = &#123;'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'&#125;; try &#123; MessageDigest mdTemp = MessageDigest.getInstance("SHA1"); mdTemp.update(decript.getBytes("UTF-8")); byte[] md = mdTemp.digest(); int j = md.length, k = 0; char buf[] = new char[j*2]; for (int i = 0; i &lt; j; i++) &#123; byte byte0 = md[i]; buf[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf]; buf[k++] = hexDigits[byte0 &amp; 0xf]; &#125; return new String(buf); &#125; catch (Exception e) &#123; return null; &#125; &#125;&#125;--------------------------------------------------------------------------------package com.example.springbootdemo.servlet;import com.example.springbootdemo.config.WeixinServlet;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;import org.springframework.context.annotation.Bean;/** * @Auther: wjy * @Date: 2018/12/4 21:33 * @Description: SpringBoot中的Servlet配置。 */@SpringBootApplicationpublic class ServletConfig extends SpringBootServletInitializer &#123; public static void main(String[] args) &#123; SpringApplication.run(ServletConfig.class, args); &#125; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(ServletConfig.class); &#125; // 注册Servlet。 @Bean public ServletRegistrationBean wexinA() &#123; return new ServletRegistrationBean(new WeixinServlet(), "/weixinA"); &#125;&#125; ④映射调试 此时可通过 映射地址/wenxinA 或 localhost:80/weixinA 访问这个 Servlet| 注意：因为访问此校验代码需要传入四个参数，所以如下直接访问时，控制台报出的空指针异常，不是配置的问题！！ &emsp;&emsp; &emsp;&emsp; 将可以访问 Servlet 的 URL 配置到微信公共平台的服务器 URL 一栏 最后再填写 Token 对应的值| 我的校验代码中，Token 字符串的值为 wenxinAAAA。 &emsp; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#x79;&#109;&#x65;&#115;&#x73;&#105;&#x40;&#x31;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;]]></content>
      <categories>
        <category>微信开发</category>
      </categories>
      <tags>
        <tag>外网映射——NATAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言常用库函数整理]]></title>
    <url>%2F2019%2F02%2F20%2FC%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[PS：include 称为文件包含命令，即它把 &lt; &gt; 或 &quot; &quot; 内指定的文件包含到程序中。被包含的(头)文件通常是由系统提供的，其扩展名为 .h。如下介绍了 stdio.h、stdlib.h、string.h、math.h 等系统提供的文件。 1.stdio.h 标准 I/O 库。 int scanf(char *format, args, …)：按 format 指定的格式将输入数据存入到 args，… 指定的内存中(读取到空格就停止)。 int printf(char *format, args, …)：将 args，… 的值以 format 指定的格式输出。 char gets(char \str)：从标准输入中读取一行，并把它存储在 str 所指向的字符串中(读取到换行符或者到达文件末尾时停止，读取到空格不停止)。 int getchar(void)：从标准输入中读取下一个字符。| 如果没有错误发生，返回相同的字符，如果碰到文件结尾或者有错误发生，则返回 EOF。 int putchar(int character)：将字符输出到标准输出中。| 如果没有错误发生，返回相同的字符，如果有错误发生，则返回 EOF。 int sprintf(char *str, const char *format, …)：格式化输出到 str 所指向的字符串。 12345int a = 123;char* s1 = "abc";char* s2;sprintf(s2, "%d %s", a, s1);printf("%s", s2); // 123 abc。 宏 EOF 是一个负整数，通常在有函数调用错误或者碰到文件结尾时返回。 1234// 判断是否到达输入流末尾。if (scanf("%d", %num) != EOF) &#123; ...&#125; 2.stdlib.h①分配空间 void *calloc(unsigned n, unsigned size)：分配所需的内存空间，并返回一个指向它的指针。 void *malloc(unsigned size)：分配所需的内存空间，并返回一个指向它的指针。 1234// 如: 向系统申请分配100个int型的连续内存空间。// 并返回所分配的内存空间的首地址。int* array = malloc(sizeof(int)*100); int* array = calloc(100, sizeof(int)); void *realloc(void *ptr, unsigned size)：重新调整之前调用 malloc 或 calloc 所分配的内存块的大小(其中 ptr 为指向内存块的指针)。 void free(void *ptr)：释放调用 calloc、malloc 或 realloc 所分配的内存空间(即释放 ptr 指针所指向的内存空间)。 ②算法相关 执行快速排序： 12345678910// 主函数外声明一个compare函数，决定升序/降序。int compare(const void* a, const void* b) &#123; // 升序。 return (*(待排元素类型*)a) -/&gt; (*(待排元素类型*)b); // 降序。 return (*(待排元素类型*)b) -/&gt; (*(待排元素类型*)a);&#125;// 主函数内调用快排函数，进行快速排序。qsort(待排数组首地址, 待排元素总个数, sizeof(待排元素类型), compare(函数，决定升序/降序)); 执行二分查找： 1234567891011// 主函数外声明一个compare函数，决定升序/降序。int compare(const void* a, const void* b) &#123; // 升序。 return (*(待排元素类型*)a) -/&gt; (*(待排元素类型*)b); // 降序。 return (*(待排元素类型*)b) -/&gt; (*(待排元素类型*)a);&#125;// 主函数内调用二分查找函数，查找某个元素。int* ptr;ptr = (int*)bsearch(指向要查找元素的指针, 待查数组首地址, 待查数组的元素总个数, sizeof(待排元素类型), compare(函数，决定升序/降序)); 如果查找成功，则返回一个指向数组中匹配元素的指针，否则返回空指针。 ③其他 int rand(void)：返回一个范围在 0 - RAND_MAX(32767) 之间的伪随机数。 123456// 返回[0-10)之间的随机数。printf("%d", rand()%10);// 返回[20-30)之间的随机数。printf("%d", rand()%10+20);// 返回[m,n)范围内的随机数num，可用：prinrf("%d", rand()%(n-m)+m); int abs(int x)：求整数 x 的绝对值。 long int labs(long int x)：返回长整型 x 的绝对值。 int atoi(const char *str)：把参数 str 所指向的字符串转换为一个 int 型整数。 123char* s = "521 abc";int a = atoi(s);printf("%d", a); // 521。 double atof(const char *str)：把参数 str 所指向的字符串转换为一个 double 型浮点数。 long int atol(const char *str)：把参数 str 所指向的字符串转换为一个 long int 型长整数。 void exit(int status)：使一个程序正常终止(status 为 0)，或非正常终止(status 为 1)。 void abort(void)：使一个异常程序终止。 ④库宏RAND_MAX： rand 函数返回的最大值。NULL：是一个空指针常量的值。 NULL——stdio.h、string.h 头文件中也有此宏。 3.string.h string.h 头文件定义了各种操作字符数组的函数。 int strcmp(const char *str1, const char *str2)：把 str1 所指向的字符串和 str2 所指向的字符串进行比较。 12345678910111213/* strcmp()函数会按照ASCII码顺序比较两个字符串，并由函数返回值返回比较结果。 字符串1 ＝ 字符串2，返回值 ＝ 0。 字符串2 &gt; 字符串2，返回值 &gt; 0。 字符串1 &lt; 字符串2，返回值 &lt; 0。 */char* s1 = "asd";char* s2 = "asd";// 两字符串相等，返回1，否则，返回0。if (strcmp(s1, s2) == 0) return 1; else return 0; size_t strlen(const char *str)：计算字符串 str 的长度。 char *strcpy(char *dest, const char *src)：把 src 所指向的字符串复制到 dest。 char *strcat(char *dest, const char *src)：把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。 12345678910// 注意: 以下代码会出现错误。char* s = malloc(sizeof(char)*10);char arr[5] = "abcde";strcat(s, arr);// ×，必须给s赋初值，再使用此函数。// 正确操作。char s[5] = "aaaaa";char arr[5] = "bbbbb";strcat(s, arr);printf("%s", s);// aaaaabbbbb。 void *memcpy(void *str1, const void *str2, size_t n)：从存储区 str2 复制 n 个字符到存储区 str1。| 返回一个指向目标存储区 str1 的指针。 char *strtok(char *str, const char *delim)：分解字符串 str，其中 delim 为分隔符。| str — 要被分解的字符串。| delim — 包含分隔符的 C 字符串。 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main() &#123; char s[15] = "I am so cold"; char** arr = (char**)malloc(sizeof(char*)*4); int i = 0; arr[i] = (char*)malloc(sizeof(char)*5); arr[i] = strtok(s, " "); /* 输出: I am so cold */ while (arr[i] != NULL) &#123; printf("%s\n", arr[i]); i++; arr[i] = (char*)malloc(sizeof(char)*5); arr[i] = strtok(NULL, " "); &#125; return 0;&#125; 4.math.h math.h 头文件定义了各种数学函数，此库中所有函数都带有一个 double 类型的参数，且都返回 double 类型的结果。 ①普通数字处理 double fabs(double x)：求浮点数 x 的绝对值。 double sqrt(double x)：计算 x 的平方根。 double pow(double x, double y)：计算 x 的 y 次幂。 double fmod (double x, double y)：返回 x / y 的余数。 double exp(double x)：求 e 的 x 次幂，e = 2.718281828。 double log(double x)：计算 x 的自然对数，即 e 为底数，x 的值应大于零。 double log10(double x)：计算 x 的常用对数，即 10 为底数，x 的值应大于零。 double floor(double x)：求不大于 x 的最大整数。| 返回 x 的下限，如 74.12 的下限为 74，-74.12 的下限为 -75，返回值为 double 类型。 double ceil(double x)：求不小于 x 的最小整数。| 返回 x 的上限，如 74.12 的上限为 75，-74.12 的上限为 -74，返回值为 double 类型。 ②三角函数 double cos(double x)：求 x (弧度表示)的余弦值。 double sin(double x)：求 x (弧度表示)的正弦值。 double tan(double x)：求 x (弧度表示)的正切值。 ③其他 double hypot(double x, double y)：x、y 为直角三角形的两个直角边，返回其斜边的长度。 double modf(double x, double *ip)：将 x 的整数部分通过指针回传，返回其小数部分，并将整数部分保存在 *ip 中。 5.ctype.h 如果参数 c 满足函数条件，则如下函数返回非零值(即 true)。如果不满足，则如下函数返回零(即 false)。 int isalnum(int c)：检查所传的字符是否是字母和数字。 int isalpha(int c)：该函数检查所传的字符是否是字母。 int islower(int c)：检查所传的字符是否是小写字母。 int isupper(int c)：检查所传的字符是否是大写字母。 int isdigit(int c)：检查所传的字符是否是十进制数字。 int isxdigit(int c)：检查所传的字符是否是十六进制数字。 int tolower(int c)：把大写字母转换为小写字母。 int toupper(int c)：把小写字母转换为大写字母。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#121;&#109;&#x65;&#115;&#115;&#105;&#64;&#49;&#x36;&#51;&#46;&#x63;&#x6f;&#x6d;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言库函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASC2码]]></title>
    <url>%2F2019%2F02%2F18%2FASC%E2%85%A1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[方便用时查看。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#121;&#x6d;&#101;&#x73;&#x73;&#x69;&#64;&#x31;&#x36;&#51;&#46;&#99;&#x6f;&#109;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[写给阿根廷]]></title>
    <url>%2F2018%2F11%2F27%2F%E5%86%99%E7%BB%99%E9%98%BF%E6%A0%B9%E5%BB%B7%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 东南 再东南&emsp;&emsp; 穿过太平洋&emsp;&emsp; 五月的太阳&emsp;&emsp; 晴空的蓝 浮云的白 &emsp;&emsp; 耶稣山上的圣象&emsp;&emsp; 张开双臂俯视世间万物&emsp;&emsp; …&emsp;&emsp; … &emsp;&emsp; 雄鹰蓦地折断翅膀&emsp;&emsp; 蓝白色海洋陷入死寂&emsp;&emsp; 眼中闪着点点泪光&emsp;&emsp; 蓝白色是不变的信仰 &emsp;&emsp; 战车上的残翼&emsp;&emsp; 无法挫伤你的锐气&emsp;&emsp; 潘帕斯雄鹰&emsp;&emsp; 依旧是绿茵场上的传奇&emsp;&emsp;&emsp;&emsp; ——记2014年巴西世界杯 围巾一 &emsp;&emsp; 重新想起以前写的这首诗，有些片段忘记了，慢慢回忆吧。ps：不管有没有世界杯冠军，你都是当之无愧的球王！ 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#x79;&#109;&#x65;&#x73;&#x73;&#105;&#x40;&#49;&#x36;&#x33;&#46;&#99;&#111;&#109;]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于Markdown]]></title>
    <url>%2F2018%2F11%2F27%2F%E5%85%B3%E4%BA%8EMarkdown%2F</url>
    <content type="text"><![CDATA[1.认识Markdown Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的 HTML 页面。 —— 维基百科 Markdown 的目标是实现易读易写。其语法全由一些符号组成，并且符号的作用一目了然。语法目标：成为一种适用于网络的书写语言。它的语法种类很少，只对应于 HTML 标记的一小部分。理念是能使文档更易读、写和随意更改。 一般 Markdown 编译器的左边是编辑区，右边显示的样式是转换为 HTML 后加上 CSS 样式显示的。 同理在 Hexo 博客中，Markdown 文章需要解析成 HTML 格式，再输出到网页中。 2.Markdown和HTML HTML 是一种发布的格式。 Markdown 是一种书写的格式，其格式语法只涵盖纯文本可以涵盖的范围。 不在 Markdown 涵盖范围之内的标签，都可以直接在文档里用 HTML 撰写。 3.特殊字符自动转换①HTML中 在 HTML 文件内，有些字符需要特殊处理(相当于”转义”)，才能使用。如 &lt; 符号用于起始标签，&amp; 符号用于标记 HTML实体 。要想单纯的显示这两个字符原型，必须要使用实体的形式，即避免它们被当成标签的一部分。 字符实体有三部分：一个 &amp;符号、一个 实体名称 或&emsp; # 和 实体编号 、一个 ; 。如： &lt; == &amp;lt; == &amp;#60; || &amp; == &amp;amp; == &amp;#38; 。链接内、网址名中的 &amp; 也是要转换成实体后，再放到 &lt;a&gt; 标签的 herf 属性中去。 ②Markdown中 而 Markdown 可以让我们自然地书写字符。你只需正常的写，Markdown 编译器会进行判断，然后在生成 HTML 代码时自动转换，无须编写者关注。 即如果使用的 &amp; 是 HTML 字符实体的一部分(即是标识实体的特殊字符时)，它会保留原状，*否则自动转换成 &amp;amp; *。 或如果把使用的 &lt; 作为 HTML 标签的定界符使用，它会保留原状，否则自动转换为其实体名。 4.区块元素①段落与换行 一个 Markdown 段落的前后要有一个以上的空行(即无文本行)。若一行只包含空格和制表符，则该行会被视为空行。 与 HTML 的空格和换行设定一样，不管换(空)多少行(格)，只一个符号有效。可以用 HTML 标签实现多个换行与空格功能。 ②标题 Markdown 支持两种标题的语法，类Setext 和 类atx 形式。 类setext 形式：用底线的形式，=表示一级标题，–表示二级标题。 类Atx 形式：在行首插入1-6个 # ，对应1到6级标题。 作为美观,可以在行尾使用 # 闭合 类atx 样式的标题。 ③区块引用 Markdown 文件中建立一个区块引用，每行的最前面加上 &gt; 。 区块引用可以嵌套(例如：引用内的引用)，只要根据层次加上不同数量的 &gt; 。引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等。 ④列表 Markdown 支持有序列表和无序列表。 无序列表使用 * 、+ 或 - 接一个 空格 作为列表标记。 有序列表则使用 数字 接 . 再接一个 空格 作为列表标记。 如果要在列表项目内放进引用,那就需要缩进：空格 + 两个 Tab 为宜。 1 2 3 1 2 3 ⑤分隔线 在一行中用三个以上的 * 、 - 、 _ 可建立一个分隔线，行内不能有其他东东。也可以在 * 或是 - 中间插入空格。 ps：使用 --- 必须上下行都是空行，防止它作用在文字底部加粗文字。 ⑥表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 5.区段元素①文字链接 123 ②强调 Markdown使用 * 和下划线 _ 作为标记强调文字的符号。 斜体：被一个 * 或 _ 包围的文字，会被转成用 &lt;em&gt; 标签包围。 加粗：用两个 * 或 _ 包围的文字，会被转成用 &lt;strong&gt; 标签包围。 加粗斜体：被三个 * / _ 包围。 删除线：被~~ 包围 / &lt;del&gt; 标签。 强调也可以直接插在文字中间。 但是如果你的 * 和 _ 两边都有空白的话，它们就会被当成普通的符号。 如果要在文字前后直接插入普通的星号或底线，你可以用反斜线。 ③代码 如果要标记一小段行内代码，你可以用 反引号 把它包起来。 如果要标记多行代码： 1**123** 在代码区段内，&amp; 和 &lt; 都会被自动地转成 HTML 实体，这使得插入 HTML 原始代码变得很容易。代码区段中的Markdown 语法不会被转换，它们只是有高亮的普通文本。 ④图片![图片的代替文字](URL) Markdown 没有办法指定图片的宽高。如果需要，可以使用普通的 &lt;img&gt; 标签。 ⑤网址/邮箱链接 用尖括号包起来，Markdown 就会自动把它转成链接。 &lt;http:messi1002.top&gt; ⑥反斜杠 Markdown 支持以下符号前面加上反斜杠来帮助插入普通的符号：即反斜杠可以转义 Markdown 中的特殊字符！ 123456789101112\：反斜线。`：反引号。*：星号。_：底线。。&#123;&#125;：花括号。[]：方括号。()：括弧。#：井字号。+：加号。-：减号。.：英文句点。!：惊叹号。 如果想在行首出现 数字.空格 ，而不生成列表样式，可以在句点前面加上反斜杠。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#x79;&#109;&#x65;&#115;&#x73;&#x69;&#x40;&#x31;&#x36;&#51;&#x2e;&#99;&#x6f;&#109;]]></content>
      <categories>
        <category>博客相关</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
