<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java并发编程之活跃性问题]]></title>
    <url>%2F2020%2F06%2F16%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B4%BB%E8%B7%83%E6%80%A7%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020秋招复习之数据结构与算法]]></title>
    <url>%2F2020%2F06%2F08%2F2020%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.面经相关①相关博客 大厂秋招笔试真题汇总 大厂秋招笔试真题分类统计 ②分类优先级29.多线程 &gt; 15.设计 &gt; 23.线段树 &gt; 22.字典树 &gt; 19.堆 &gt; 20.分治算法 &gt; 4.动态规划 &gt; 14.回溯算法 &gt; 11.贪心算法 &gt; 8.图 &gt; 7.树 &gt; 13.栈 &gt; 24.队列 &gt; 16.位运算 &gt; 17.排序 &gt; 18.链表 &gt; 21.递归 &gt; 12.滑动窗口 &gt; 10.二分查找 &gt; 9.哈希表 &gt; 12.双指针 &gt; 6.数学 &gt; 5.字符串 &gt; 3.数组 2.算法复杂度 什么是算法复杂度 时间 / 空间复杂度的含义 大 O 复杂度具体指的是什么？ 有哪些常见的时间复杂度，分别举一个例子。 多举几个 O(1) 时间复杂度的例子 3.数组①知识点整理 数组和链表的差别 标记数组 ②LeetCode 必刷题目（49） 剑指 Offer（3） 面试题21. 调整数组顺序使奇数位于偶数前面 面试题29. 顺时针打印矩阵 面试题66. 构建乘积数组 简单（34） 66. 加一 118. 杨辉三角 119. 杨辉三角 II 189. 旋转数组 414. 第三大的数 448. 找到所有数组中消失的数字 485. 最大连续1的个数 509. 斐波那契数 561. 数组拆分 I 566. 重塑矩阵 581. 最短无序连续子数组 661. 图片平滑器 665. 非递减数列 674. 最长连续递增序列 697. 数组的度 717. 1比特与2比特字符 724. 寻找数组的中心索引 747. 至少是其他数字两倍的最大数 766. 托普利茨矩阵 830. 较大分组的位置 832. 翻转图像 867. 转置矩阵 888. 公平的糖果交换 896. 单调数列 905. 按奇偶排序数组 941. 有效的山脉数组 985. 查询后的偶数和 989. 数组形式的整数加法 999. 可以被一步捕获的棋子数 1051. 高度检查器 1085. 最小元素各数位之和 1295. 统计位数为偶数的数字 1304. 和为零的N个唯一整数 1313. 解压缩编码列表 中等（11） 面试题 01.07. 旋转矩阵 31. 下一个排列 48. 旋转图像 54. 螺旋矩阵 59. 螺旋矩阵 II 73. 矩阵置零 229. 求众数 II 238. 除自身以外数组的乘积 289. 生命游戏 442. 数组中重复的数据 729. 我的日程安排表 I 困难（1） 41. 缺失的第一个正数 ③相关博客 4.动态规划 5.字符串①知识点整理 KMP 算法 正则表达式 ②LeetCode 必刷题目（40） 剑指 Offer（3） 面试题05. 替换空格 面试题58 - I. 翻转单词顺序 面试题58 - II. 左旋转字符串 简单（27） 14. 最长公共前缀 38. 外观数列 58. 最后一个单词的长度 157. 用 Read4 读取 N 个字符 383. 赎金信 415. 字符串相加 434. 字符串中的单词数 443. 压缩字符串 459. 重复的子字符串 520. 检测大写字母 521. 最长特殊序列 Ⅰ 541. 反转字符串 II 551. 学生出勤记录 I 557. 反转字符串中的单词 III 657. 机器人能否返回原点 680. 验证回文字符串 Ⅱ 686. 重复叠加字符串匹配 696. 计数二进制子串 709. 转换成小写字母 788. 旋转数字 804. 唯一摩尔斯密码词 824. 山羊拉丁文 893. 特殊等价字符串组 929. 独特的电子邮件地址 1108. IP 地址无效化 1119. 删去字符串中的元音 1165. 单行键盘 中等（8） 6. Z 字形变换 151. 翻转字符串里的单词 165. 比较版本号 186. 翻转字符串里的单词 II 539. 最小时间差 556. 下一个更大元素 II 583. 两个字符串的删除操作 678. 有效的括号字符串 困难（2） 214. 最短回文串 564. 寻找最近的回文数 ③相关博客 Java 的字符串操作： 6.数学①知识点整理 约瑟夫环 牛顿迭代法 排列组合 前 n 项和 快速幂算法 ②LeetCode 必刷题目（41） 剑指 Offer（7） 面试题17. 打印从1到最大的n位数 面试题20. 表示数值的字符串 面试题43. 1～n整数中1出现的次数 面试题44. 数字序列中某一位的数字 面试题49. 丑数 面试题62. 圆圈中最后剩下的数字 面试题67. 把字符串转换成整数 简单（23） 7. 整数反转 9. 回文数 13. 罗马数字转整数 67. 二进制求和 168. Excel表列名称 171. Excel表列序号 172. 阶乘后的零 202. 快乐数 258. 各位相加 263. 丑数 326. 3的幂 453. 最小移动次数使数组元素相等 507. 完美数 598. 范围求和 II 628. 三个数的最大乘积 633. 平方数之和 728. 自除数 868. 二进制间距 908. 最小差值 I 942. 增减字符串匹配 1056. 易混淆数 1281. 整数的各位积和之差 1323. 6 和 9 组成的最大数字 中等（9） 8. 字符串转换整数 (atoi) 12. 整数转罗马数字 43. 字符串相乘 264. 丑数 II 372. 超级次方 400. 第N个数字 462. 最少移动次数使数组元素相等 II 537. 复数乘法 754. 到达终点数字 困难（2） 233. 数字 1 的个数 458. 可怜的小猪 ③相关博客 172. 阶乘后的零（Easy）C语言题解 172. 阶乘后的零（Easy）Java语言题解 7.树①知识点整理 树的概念 二叉树有哪几种形式？ 什么是平衡二叉树、满二叉树、完全二叉树 Trie 树和二叉树的区别 树和链表的区别？ 讲讲树和图，它们有什么区别？ 树的遍历 递归求解树 路径相关 二叉搜索树 在含有 100 个节点的二叉搜索树中找到其中第 80 大的节点 ②LeetCode 必刷题目（78） 剑指 Offer（14） 面试题07. 重建二叉树 面试题26. 树的子结构 面试题27. 二叉树的镜像 面试题28. 对称的二叉树 面试题32 - I. 从上到下打印二叉树 面试题32 - II. 从上到下打印二叉树 II 面试题32 - III. 从上到下打印二叉树 III 面试题33. 二叉搜索树的后序遍历序列 面试题34. 二叉树中和为某一值的路径 面试题54. 二叉搜索树的第k大节点 面试题55 - I. 二叉树的深度 面试题55 - II. 平衡二叉树 面试题68 - I. 二叉搜索树的最近公共祖先 面试题68 - II. 二叉树的最近公共祖先 树的遍历（19） 144. 二叉树的前序遍历 94. 二叉树的中序遍历 145. 二叉树的后序遍历 102. 二叉树的层序遍历 107. 二叉树的层次遍历 II 103. 二叉树的锯齿形层次遍历 314. 二叉树的垂直遍历 987. 二叉树的垂序遍历 897. 递增顺序查找树 637. 二叉树的层平均值 105. 从前序与中序遍历序列构造二叉树 106. 从中序与后序遍历序列构造二叉树 199. 二叉树的右视图 337. 打家劫舍 III 449. 序列化和反序列化二叉搜索树 863. 二叉树中所有距离为 K 的结点 429. N叉树的层序遍历 589. N叉树的前序遍历 590. N叉树的后序遍历 适合递归求解（21） 100. 相同的树 101. 对称二叉树 104. 二叉树的最大深度 110. 平衡二叉树 111. 二叉树的最小深度 114. 二叉树展开为链表 222. 完全二叉树的节点个数 226. 翻转二叉树 404. 左叶子之和 513. 找树左下角的值 515. 在每个树行中找最大值 563. 二叉树的坡度 572. 另一个树的子树 606. 根据二叉树创建字符串 617. 合并二叉树 654. 最大二叉树 655. 输出二叉树 671. 二叉树中第二小的节点 872. 叶子相似的树 951. 翻转等价二叉树 965. 单值二叉树 路径相关（8） 112. 路径总和 113. 路径总和 II 124. 二叉树中的最大路径和 236. 二叉树的最近公共祖先 257. 二叉树的所有路径 437. 路径总和 III 543. 二叉树的直径 687. 最长同值路径 二叉搜索树（16） 98. 验证二叉搜索树 99. 恢复二叉搜索树 108. 将有序数组转换为二叉搜索树 230. 二叉搜索树中第K小的元素 235. 二叉搜索树的最近公共祖先 450. 删除二叉搜索树中的节点 501. 二叉搜索树中的众数 530. 二叉搜索树的最小绝对差 538. 把二叉搜索树转换为累加树 653. 两数之和 IV - 输入 BST 669. 修剪二叉搜索树 700. 二叉搜索树中的搜索 701. 二叉搜索树中的插入操作 776. 拆分二叉搜索树 783. 二叉搜索树节点最小距离 938. 二叉搜索树的范围和 ③相关博客 二叉树的定义及性质 树的遍历(递归+迭代) 二叉树的 Morris 遍历 二叉搜索树的常用操作 8.图①知识点整理 BFS（广度优先搜索） DFS（深度优先搜索） 最短路径算法 说一下数据结构中的图如何存储 一个有向图用邻接矩阵表示，并且是有权图，怎么判断图中有没有环（有向图判断循环引用） ②LeetCode 必刷题目（11） 剑指 Offer（1） 面试题13. 机器人的运动范围 中等（8） 133. 克隆图 200. 岛屿数量 207. 课程表 210. 课程表 II 310. 最小高度树 332. 重新安排行程 399. 除法求值 684. 冗余连接 困难（2） 269. 火星词典 685. 冗余连接 II ③相关博客 9.哈希表①知识点整理 怎么防止 hash 碰撞 K—V ②LeetCode 必刷题目（47） 剑指 Offer（2） 面试题03. 数组中重复的数字 面试题50. 第一个只出现一次的字符 简单（31） 1. 两数之和 204. 计数质数 205. 同构字符串 217. 存在重复元素 219. 存在重复元素 II 242. 有效的字母异位词 290. 单词规律 299. 猜数字游戏 349. 两个数组的交集 350. 两个数组的交集 II 387. 字符串中的第一个唯一字符 409. 最长回文串 447. 回旋镖的数量 463. 岛屿的周长 500. 键盘行 575. 分糖果 594. 最长和谐子序列 599. 两个列表的最小索引总和 645. 错误的集合 748. 最短完整词 760. 找出变位映射 771. 宝石与石头 811. 子域名访问计数 884. 两句话中的不常见单词 953. 验证外星语词典 961. 重复 N 次的元素 1002. 查找常用字符 1160. 拼写单词 1189. “气球” 的最大数量 1207. 独一无二的出现次数 1213. 三个有序数组的交集 中等（9） 3. 无重复字符的最长子串 18. 四数之和 36. 有效的数独 49. 字母异位词分组 380. 常数时间插入、删除和获取随机元素 454. 四数相加 II 525. 连续数组 535. TinyURL 的加密与解密 560. 和为K的子数组 困难（5） 30. 串联所有单词的子串 76. 最小覆盖子串 149. 直线上最多的点数 381. O(1) 时间插入、删除和获取随机元素 - 允许重复 632. 最小区间 ③相关博客 Java 集合的用法 10.二分查找①知识点整理②LeetCode 必刷题目（31） 剑指 Offer（4） 面试题11. 旋转数组的最小数字 面试题16. 数值的整数次方 面试题53 - I. 在排序数组中查找数字 I 面试题53 - II. 0～n-1中缺失的数字 简单（13） 35. 搜索插入位置 69. x 的平方根 167. 两数之和 II - 输入有序数组 278. 第一个错误的版本 367. 有效的完全平方数 374. 猜数字大小 441. 排列硬币 475. 供暖器 704. 二分查找 744. 寻找比目标字母大的最小字母 852. 山脉数组的峰顶索引 1064. 不动点 1150. 检查一个数是否在数组中占绝大多数 中等（12） 29. 两数相除 33. 搜索旋转排序数组 34. 在排序数组中查找元素的第一个和最后一个位置 50. Pow(x, n) 74. 搜索二维矩阵 81. 搜索旋转排序数组 II 153. 寻找旋转排序数组中的最小值 162. 寻找峰值 209. 长度最小的子数组 287. 寻找重复数 436. 寻找右区间 718. 最长重复子数组 困难（2） 154. 寻找旋转排序数组中的最小值 II 668. 乘法表中第k小的数 ③相关博客 二分查找法代码实现 35.搜索插入位置（Easy）Java语言题解 35.搜索插入位置（Easy）C语言题解 你真的会写二分查找吗？ 11.贪心算法①知识点整理②LeetCode 必刷题目（13） 简单（2） 122. 买卖股票的最佳时机 II 455. 分发饼干 中等（8） 55. 跳跃游戏 134. 加油站 402. 移掉K位数字 406. 根据身高重建队列 452. 用最少数量的箭引爆气球 621. 任务调度器 738. 单调递增的数字 921. 使括号有效的最少添加 困难（3） 45. 跳跃游戏 II 135. 分发糖果 316. 去除重复字母 ③相关博客 12.双指针（滑动窗口）①知识点整理 滑动窗口 ②LeetCode 必刷题目（26） 剑指 Offer（4） 面试题04. 二维数组中的查找 面试题48. 最长不含重复字符的子字符串 面试题57. 和为s的两个数字 面试题57 - II. 和为s的连续正数序列 简单（13） 面试题 10.01. 合并排序的数组 26. 删除排序数组中的重复项 27. 移除元素 28. 实现 strStr() 88. 合并两个有序数组 125. 验证回文串 283. 移动零 344. 反转字符串 345. 反转字符串中的元音字母 532. 数组中的K-diff数对 925. 长按键入 977. 有序数组的平方 1176. 健身计划评估 中等（9） 11. 盛最多水的容器 15. 三数之和 16. 最接近的三数之和 80. 删除排序数组中的重复项 II 259. 较小的三数之和 360. 有序转化数组 424. 替换后的最长重复字符 567. 字符串的排列 713. 乘积小于K的子数组 ③相关博客 13.栈①知识点整理 堆与栈的区别 栈的时间复杂度、空间复杂度 栈的应用场景 ②LeetCode 必刷题目（25） 剑指 Offer（3） 面试题09. 用两个栈实现队列 面试题30. 包含min函数的栈 面试题31. 栈的压入、弹出序列 简单（9） 20. 有效的括号 155. 最小栈 225. 用队列实现栈 232. 用栈实现队列 496. 下一个更大元素 I 682. 棒球比赛 844. 比较含退格的字符串 1021. 删除最外层的括号 1047. 删除字符串中的所有相邻重复项 中等（7） 71. 简化路径 150. 逆波兰表达式求值 385. 迷你语法分析器 503. 下一个更大元素 II 739. 每日温度 856. 括号的分数 946. 验证栈序列 困难（6） 42. 接雨水 84. 柱状图中最大的矩形 85. 最大矩形 224. 基本计算器 591. 标签验证器 726. 原子的数量 ③相关博客 14.回溯算法①知识点整理②LeetCode 必刷题目（23） 剑指 Offer（1） 面试题38. 字符串的排列 简单（2） 401. 二进制手表 784. 字母大小写全排列 中等（17） 17. 电话号码的字母组合 22. 括号生成 39. 组合总和 40. 组合总和 II 46. 全排列 47. 全排列 II 60. 第k个排列 77. 组合 78. 子集 79. 单词搜索 89. 格雷编码 90. 子集 II 93. 复原IP地址 131. 分割回文串 216. 组合总和 III 306. 累加数 526. 优美的排列 困难（3） 37. 解数独 51. N皇后 52. N皇后 II ③相关博客 15.设计①知识点整理②LeetCode 必刷题目（21） 剑指 Offer（2） 面试题37. 序列化二叉树 面试题41. 数据流中的中位数 简单（6） 170. 两数之和 III - 数据结构设计 359. 日志速率限制器 604. 迭代压缩字符串 705. 设计哈希集合 706. 设计哈希映射 716. 最大栈 中等（9） 面试题 16.25. LRU缓存 146. LRU缓存机制 173. 二叉搜索树迭代器 208. 实现 Trie (前缀树) 211. 添加与搜索单词 - 数据结构设计 284. 顶端迭代器 341. 扁平化嵌套列表迭代器 355. 设计推特 707. 设计链表 困难（4） 295. 数据流的中位数 297. 二叉树的序列化与反序列化 432. 全 O(1) 的数据结构 460. LFU缓存 ③相关博客 16.位运算①知识点整理 进制转换 运算符 ②LeetCode 必刷题目（26） 剑指 Offer（4） 面试题15. 二进制中1的个数 面试题56 - I. 数组中数字出现的次数 面试题56 - II. 数组中数字出现的次数 II 面试题65. 不用加减乘除做加法 简单（14） 136. 只出现一次的数字 190. 颠倒二进制位 191. 位1的个数 231. 2的幂 268. 缺失数字 342. 4的幂 371. 两整数之和 389. 找不同 405. 数字转换为十六进制数 461. 汉明距离 476. 数字的补数 693. 交替位二进制数 762. 二进制表示中质数个计算置位 1290. 二进制链表转整数 中等（8） 137. 只出现一次的数字 II 187. 重复的DNA序列 201. 数字范围按位与 260. 只出现一次的数字 III 318. 最大单词长度乘积 393. UTF-8 编码验证 397. 整数替换 477. 汉明距离总和 ③相关博客 Java进制转换及位运算 17.排序①知识点整理 比较排序 交换排序类：简单交换排序、冒泡排序、快速排序 选择排序类：简单选择排序、堆排序 插入排序类：直接插入排序、希尔排序 归并排序类：归并排序 非比较排序 计数排序 桶排序 基数排序 ②LeetCode 必刷题目（21） 剑指 Offer（3） 面试题45. 把数组排成最小的数 面试题51. 数组中的逆序对 面试题61. 扑克牌中的顺子 简单（3） 252. 会议室 922. 按奇偶排序数组 II 976. 三角形的最大周长 中等（11） 56. 合并区间 75. 颜色分类 147. 对链表进行插入排序 148. 排序链表 179. 最大数 220. 存在重复元素 III 274. H 指数 280. 摆动排序 324. 摆动排序 II 524. 通过删除字母匹配到字典里最长单词 969. 煎饼排序 困难（4） 57. 插入区间 164. 最大间距 296. 最佳的碰头地点 527. 单词缩写 ③相关博客 八种排序算法的总结及性能分析 漫画：“排序算法” 大总结 面试时写不出排序算法？看这篇就够了 18.链表①知识点整理 单链表和双链表的区别及应用场景 链表和数组的区别 用数组实现循环链表 ②LeetCode 必刷题目（31） 剑指 Offer（7） 面试题06. 从尾到头打印链表 面试题18. 删除链表的节点 面试题22. 链表中倒数第k个节点 面试题24. 反转链表 面试题25. 合并两个排序的链表 面试题35. 复杂链表的复制 面试题52. 两个链表的第一个公共节点 简单（9） 21. 合并两个有序链表 83. 删除排序链表中的重复元素 141. 环形链表 160. 相交链表 203. 移除链表元素 206. 反转链表 234. 回文链表 237. 删除链表中的节点 876. 链表的中间结点 中等（14） 2. 两数相加 19. 删除链表的倒数第N个节点 24. 两两交换链表中的节点 61. 旋转链表 82. 删除排序链表中的重复元素 II 86. 分隔链表 92. 反转链表 II 138. 复制带随机指针的链表 142. 环形链表 II 143. 重排链表 328. 奇偶链表 369. 给单链表加一 445. 两数相加 II 725. 分隔链表 困难（1） 25. K 个一组翻转链表 ③相关博客 19.堆①知识点整理②LeetCode 必刷题目（11） 剑指 Offer（1） 面试题40. 最小的k个数 简单（1） 703. 数据流中的第K大元素 中等（7） 215. 数组中的第K个最大元素 264. 丑数 II 313. 超级丑数 347. 前 K 个高频元素 378. 有序矩阵中第K小的元素 451. 根据字符出现频率排序 973. 最接近原点的 K 个点 困难（2） 23. 合并K个排序链表 407. 接雨水 II ③相关博客 20.分治算法①知识点整理②LeetCode 必刷题目（11） 剑指 Offer（3） 面试题36. 二叉搜索树与双向链表 面试题39. 数组中出现次数超过一半的数字 面试题42. 连续子数组的最大和 简单（2） 53. 最大子序和 169. 多数元素 中等（2） 240. 搜索二维矩阵 II 241. 为运算表达式设计优先级 困难（4） 4. 寻找两个正序数组的中位数 312. 戳气球 315. 计算右侧小于当前元素的个数 327. 区间和的个数 ③相关博客 21.递归①知识点整理 常见递归算法的时间复杂度分析 ②LeetCode 必刷题目（7） 剑指 Offer（2） 面试题10- I. 斐波那契数列 面试题64. 求1+2+…+n 简单（1） 1137. 第 N 个泰波那契数 中等（3） 247. 中心对称数 II 544. 输出比赛匹配对 625. 最小因式分解 困难（1） 248. 中心对称数 III ③相关博客 22.字典树①知识点整理②LeetCode 必刷题目（8） 简单（1） 720. 词典中最长的单词 中等（5） 421. 数组中两个数的最大异或值 648. 单词替换 676. 实现一个魔法字典 677. 键值映射 692. 前K个高频单词 困难（2） 212. 单词搜索 II 336. 回文对 ③相关博客 23.线段树①知识点整理②LeetCode 必刷题目（6） 中等（1） 307. 区域和检索 - 数组可修改 困难（5） 218. 天际线问题 315. 计算右侧小于当前元素的个数 327. 区间和的个数 493. 翻转对 732. 我的日程安排表 III ③相关博客 24.队列①知识点整理②LeetCode 必刷题目（6） 剑指 Offer（2） 面试题59 - I. 滑动窗口的最大值 面试题59 - II. 队列的最大值 简单（2） 346. 数据流中的移动平均值 933. 最近的请求次数 中等（2） 622. 设计循环队列 641. 设计循环双端队列 ③相关博客 25.红黑树①知识点整理 左旋和右旋怎么做？ 红黑树的时间复杂度 红黑树和平衡二叉树的区别 红黑树的应用 ②相关博客 红黑树详解 腾讯面试题：有了二叉查找树、平衡树为啥还需要红黑树？ 红黑树、AVL树、B树的比较 红黑树详细分析(图文详解)，看了都说好 红黑树和B树应用场景总结 2-3树与红黑树 红黑树，超强动静图详解，简单易懂 26.海量数据处理 27.限流算法①计数器算法②令牌桶算法③漏桶算法 28.查找算法①顺序查找②二分查找③插值查找④斐波那契查找⑤树表查找a.二叉搜索树b.平衡查找树之 2-3 Treec.平衡查找树之红黑树⑥分块查找⑦哈希查找 29.多线程①知识点整理 实现多线程同步的 ATM 存款取款 生产者—消费者模型 设计线程安全的阻塞队列（队列空时消费者阻塞、队列满时生产者阻塞） 死锁代码示例 设计一个线程池 ②LeetCode 必刷题目（7） 简单（1） 1114. 按序打印 中等（6） 1115. 交替打印FooBar 1116. 打印零与奇偶数 1117. H2O 生成 1118.设计有限阻塞队列 1195. 交替打印字符串 1226. 哲学家进餐 ③相关博客 Java并发编程之基础概念 Synchronized关键字 finnal关键字 volatile关键字 ReentrantLock锁 Java并发编程之线程8大核心基础 Java并发编程之Java内存模型 Java并发编程之死锁的前生今世 Java并发工具类简介 [LeetCode] 1114. 按序打印（Easy）Java语言题解 [LeetCode] 1115. 交替打印FooBar（Medium）Java语言题解 [LeetCode] 1116. 打印零与奇偶数（Medium）Java语言题解 [LeetCode] 1188. 设计有限阻塞队列（Medium）Java语言题 [LeetCode] 1195. 交替打印字符串（Medium）Java语言题解 [LeetCode] 1226. 哲学家进餐（Medium）Java语言题解 30.智力题 292. Nim 游戏 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#x79;&#x6d;&#101;&#115;&#115;&#105;&#x40;&#49;&#54;&#51;&#46;&#x63;&#111;&#109;]]></content>
      <categories>
        <category>2020秋招</category>
        <category>知识点总结</category>
      </categories>
      <tags>
        <tag>知识点总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[要怎样努力，才能成为很厉害的人？]]></title>
    <url>%2F2020%2F04%2F15%2F%E8%A6%81%E6%80%8E%E6%A0%B7%E5%8A%AA%E5%8A%9B%EF%BC%8C%E6%89%8D%E8%83%BD%E6%88%90%E4%B8%BA%E5%BE%88%E5%8E%89%E5%AE%B3%E7%9A%84%E4%BA%BA%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[1.Q转自：https://www.zhihu.com/question/22921426 「怎样才是很厉害的人？」「自然是 有好看的身材以及容颜 被很多人喜欢 有很多厉害又有趣的朋友 有对的人 嘻嘻哈哈打打闹闹笑笑人生」 详见：你身上发生过什么事情让你觉得上天特别不公平，你是如何面对的？ 题主想兑现一个承诺努力了4年 心如死灰 2014.3.7补充虽然不想说 不过好像有点儿表达不清 题主是男生 目前在景色优美的某大学念书题主以前很喜欢一个女生 刚好女生也很喜欢题主 所谓真命天女好像就是那样子在一起 甜蜜又青涩 题主觉得自己是被她所成就的 后来发生不幸的事情 女生去了另外一个世界过了好久 我才回神过来 整个人都不好了后来做了个梦 梦里面题主答应女生 要找到比她更漂亮更有趣的女朋友题主想成为很厉害很厉害的人 就是这样的故事 告诉了一些亲近之人题主其实很糟糕 不懂如何与人相处 酷到没朋友一生别扭 孩子气 喜欢看热血漫 所以即使大大的颓唐仍然固执的想看到希望一直很努力 一直不认输可是 感觉这样下去 什么也改变不了吧 诚心请教诸君 因为越长越大 已经快不知道 要怎么办了 2.A朱炫闷骚而近妖 微博：大师兄_朱炫收录于 知乎周刊 •张振衣 等 91165 人赞同谢邀 首先，少年，答应别人的承诺，就一定要兑现。 我以前啊，和你一样，很想成为一个很厉害很厉害很厉害的人。 喜欢看热血的东西，幻想自己是屠龙的勇士，登塔的先锋，我左手有剑，右手有光，没头没脑的燃烧自己，敌人的骑军来了，我说你们何人堪与之战，我的女人在等我。 后来我现实了一点，我觉得我要成为那种说走就走，说日就日的男人，我梳大背头，流浪在欧洲或者新几内亚的，我拍孩子，拍野兽，拍流浪的雏妓，与罗伯特德尼罗握手，说嘿，我给你写了愤怒的公牛2。 再后来，我觉得我人生的梦想，是在城市中心买上一间顶层公寓，把一整面墙都改造成钢化玻璃，在灯火通明的夜晚，我就要端着酒站在巨大的窗前，看整个城市在呼吸，然后我的朋友叩门，他带来了一打嫩模，我们就玩一些成年人的游戏 现在，我发现龙并不存在，我不会骑马，不会用单反，家住2楼，我能做的，就是把眼前的事儿做好，赚到足够的钱，这样我可以给我的姑娘一个地球仪，然后用飞镖扎它，扎到哪儿，就去哪儿玩。 这样看来，虽然我的想法随着生殖器的发育，始终在变，但那个很厉害很厉害的人，一直离我很远，甚至越来越远。 我心中曾经执剑的少年，此刻也混迹在市井之间。 血似乎都凉了。 我也不是没有惶恐过，是不是我这一生，都不能左手持剑，右手握着罗伯特德尼罗，说这里的嫩模随便你玩但是你他妈别从窗户上掉下去。 这样一看，我逊得不行，我的朋友都是一些凡人，比我还逊，业余生活就是推塔、中单、跪。 我心想，我是不是这辈子都要做一个逊逼，直到我的坟墓上写好墓志铭，我甚至都想好了： 我来，我见，我挂了。 最后我给了自己一个否定的答复，我不要。 我喜欢我的朋友们，喜欢我现在的生活，首先我希望你明白，没有厉害与逊逼得区分，只有血的凉与热，有的人觉得生活就这样吧，我算了，现在没什么不好。 有的人觉得生活这样挺好，但是我还要更好。 这种只要剧情稍微热血一点就会热泪盈眶的傻逼，已经不多了，一刻也不要停留。 所以现在，我和你不一样了，我仍然想成为一个很厉害很厉害很厉害的人，像我们这种剧情稍微热血一点就会热泪盈眶的傻逼，要好好珍惜自己。 很多人坐下来了，跟你说你不行，说你省点儿心吧，说你请静一静。 汹涌的人群就把你这样的少年淹没了，人群散去的时候，你也不见了，你那些承诺，谁也听不见，这个世界对于你，就再不可能有什么更有趣更漂亮的女朋友。 你就失约了，小逼崽子。 这么跟你说。 虽然随着年龄的增长，我趋于现实，不能像你那样分分钟冲动的燃烧，然而我每时每刻都有想做的事，有想达成的目标。 不排除以后的某一年，我会握着罗伯特德尼罗的手，他说这是你写得吗，愤怒的公牛2，只要他还没死。 故事里拳王拉莫塔忍着伤，他举着铁拳，挥汗如雨，要和命运斗争，他说我怎么能失约呢，我是那个要成为很厉害很厉害的拳王拉莫塔！ 小伙儿，成为很厉害很厉害的人，最重要的，就是要热血，永远也不要让你的血凉下去，你凉下去了，就再也不能找到一个更有趣更漂亮的女友，你就失约了，于是那天她踏梦而来，就成了一个彻头彻尾的笑话。 当有一天你成为你讨厌的那种人，浑浑噩噩，你走在街上，看见那些更有趣更漂亮的女孩，你会不会想起多年以前，你说我答应你，在一个承诺就是永远的年纪。 读书，交友，美容，都不如你这一腔狗血，滚烫，灼人，你要燃上大半辈子，才对得起你现在说的这些话。 我听闻最美的故事，是公主死去了，屠龙的少年还在燃烧。 火苗再小，你都要反复的点燃。 所谓热血的少年，青涩的爱恋，死亡与梦之约。 这么好的故事。 你可别演砸了。 最后我给你点个人建议： 1.读书，读到倦，网上有很多方法，但你从来沉不下心看。2.学习，学到疼，网上有很多方法，但你从来沉不下心看。3.开口说话，冷场也要说话，脸皮薄也要说话，挨打也要说话。4.如果你现在不知道做什么，至少你还可以先从做一个牛逼的学生开始。5.更漂亮更有趣的女孩，五年以后再找。6.承诺是鞭子，不是兴奋剂。7.年纪大了，也不要说什么心如死灰。 改变自己是非常，非常，非常痛苦的，我能看出来你一腔热血的优点，自然知道你孤僻懒散自以为是的缺点，方法很多，不过我不确定你吃不吃得了苦，我和你共勉吧。 在成为最厉害最厉害最厉害的道路上。 完 3.我想说的2020/4/17：在复习的时候看到了这篇文章，突然很有感触。从去年九月到现在，我好像一直都在急匆匆地赶路，毫无经验，慢慢的耗尽了自己的一腔热血。无论是过去四年的感情，还是期待了很久的春招，都在赶路的过程中离我远去了。留下的，只有迷茫。学习方法的问题，学习内容的取舍，以及自己想要什么样的伴侣，怎样的未来…… 我尽力面对，试图解决，最后还是一团糟。 2020/5/15： 我已经很努力很努力地忽略原生家庭的问题，控制自己的情绪，忘记过去，专注学习，可是还是很失败。 2020/6/2：每时每刻都有想做的事，有想达成的目标。 2020/6/8：对于生活的一腔热血还在，我相信只要不断努力，生活总会越来越好的，未来也会越来越顺利的。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#121;&#109;&#x65;&#115;&#x73;&#x69;&#x40;&#x31;&#54;&#51;&#x2e;&#99;&#111;&#x6d;]]></content>
      <categories>
        <category>随笔</category>
        <category>转载</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程之线程8大核心基础]]></title>
    <url>%2F2020%2F04%2F03%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程之死锁的前生今世]]></title>
    <url>%2F2020%2F04%2F03%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%AD%BB%E9%94%81%E7%9A%84%E5%89%8D%E7%94%9F%E4%BB%8A%E4%B8%96%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树详解]]></title>
    <url>%2F2020%2F03%2F18%2F%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.相关博客 二叉树的定义及性质 树的遍历（递归加迭代） 二叉搜索树的常用操作 2.2-3 树①定义 虽然它不是一种二叉树，但是它满足二分搜索树的基本性质。每次操作节点时，都按照二分搜索树的策略查找它的位置。 它有两种节点，一种节点可以存放一个元素（与普通的二分搜索树的节点一样，有左右两个孩子，左孩子的值小于该节点的值，右孩子的值大于该节点的值），另一种节点可以存放两个元素（有三个孩子，三个孩子分别在第一个元素的左侧、两个元素的中间和第二个元素的右侧。且这个节点左孩子的值小于左侧元素的值，中间孩子的值在两个元素之间，右孩子的值大于右侧元素的值），所以存放两个元素的节点也满足二分搜索树的基本性质。 2-3 树的每个节点有 2 个或者 3 个孩子，通常将存放一个元素且有两个孩子的节点叫做 2 节点，将存放两个元素且有三个孩子的节点叫做 3 节点。 下图为一颗 2-3 树： ②性质—绝对平衡性 2-3 树是一颗绝对平衡的树（与 2-3 树本身插入元素时的构建方法相关） 绝对平衡：从根节点到任意一个叶子节点所经过的节点数量一定是相同的（即对于任意一个节点来说，左右子树的高度一定是相同的，可以将 2-3 树类比为满二叉树） 2-3 树如何维持绝对的平衡：添加节点将永远不会添加到一个空的位置，只会和最后找到的叶子节点做融合，若最后找到的叶子节点是 2 节点，则添加进 2 节点，形成一个 3 节点，否则添加进 3 节点，暂时形成一个 4 节点，然后对 4 节点做一个变形处理，形成由三个 2 节点组成的子树。 若暂时形成的 4 节点是根节点，则变形处理即可。 若暂时形成的 4 节点是叶子节点，则在变形处理后，将子树的根节点继续向其父亲节点（即变形处理前 4 节点的父亲节点，简称 A）融合。如果 A 为 2 节点，则融合后 A 变成一个 3 节点，子树中剩下的两个节点变为 A 的左孩子和中孩子（或者中孩子和右孩子）。如果 A 为 3 节点，则暂时形成一个 4 节点，然后对 4 节点做一个变形处理，再形成由三个 2 节点组成的子树，将子树的根节点继续向其父亲节点融合……直到融合到根节点或者 2 节点。 ③模拟添加节点的过程 下面我们通过向 2-3 树中添加节点，来看看 2-3 树是如何维持绝对平衡的。 添加第一个节点：作为根节点，形成一个 2 节点。 添加第二个节点：和最后找到的叶子节点（42）做融合，形成一个 3 节点。 添加第三个节点：和最后找到的叶子节点（37 | 42）做融合，暂时形成一个 4 节点，然后将 4 节点变形成由三个 2 节点组成的平衡的树。 添加第四个节点：和最后找到的叶子节点（12）做融合，形成一个 3 节点。 添加第五个节点：和最后找到的叶子节点（12 | 18）做融合，暂时形成一个 4 节点，然后将 4 节点变形成由三个 2 节点组成的子树，将子树的根节点（12）继续向上融合，融合后形成一个 3 节点。 添加第六个节点：和最后找到的叶子节点（6）做融合，形成一个 3 节点。 添加第七个节点：和最后找到的叶子节点（6 | 11）做融合，暂时形成一个 4 节点，然后将 4 节点变形成由三个 2 节点组成的子树，将子树的根节点（6）继续向上融合，融合后又形成一个 4 节点，继续将 4 节点变形成由三个 2 节点组成的子树，此时已经融合到根节点，表示添加成功。 ④红黑树和 2-3 树的等价性 红黑树本质上与 2-3 树是等价的 2-3 树是包含两种节点（2 节点和 3 节点）的树结构，而红黑树是包含一种节点（每个节点只能存储一个元素）的树结构。虽然红黑树与 2-3 树的数据结构不同，但是它们实现了相同的逻辑。 红黑树是一种自平衡的二分搜索树，在红黑树中，对每一个节点都附着了一个颜色 — 红色或者黑色。 黑色节点：普通节点，表示在原来的 2-3 树中的 2 节点。 红色节点：和其父亲节点（黑色节点）一起表示在原来的 2-3 树中的 3 节点 左倾红黑树：所有的红色节点都是向左倾斜的。左倾红节点来表示 2-3 树中的 3 节点（2-3 树的 3 节点的左边元素在红黑树中通过红色节点（简称 A）表示，3 节点的右边元素在红黑树中通过黑色节点（简称 B）表示，并且 A 是 B 的左孩子，表示 A 与 B 在原来的 2-3 树中是并列关系，一起存放在一个 3 节点中）。 右倾红黑树：所有的红色节点都是向右倾斜的。右倾红节点来表示 2-3 树中的 3 节点（2-3 树的 3 节点的左边元素在红黑树中通过黑色节点（简称 A）表示，3 节点的右边元素在红黑树中通过红色节点（简称 B）表示，并且 B 是 A 的右孩子，表示 A 与 B 在原来的 2-3 树中是并列关系，一起存放在一个 3 节点中）。 ps：左倾红黑树是红黑树相对标准的一种实现方式，但并不是唯一的实现方式，这篇博客的后续内容都以左倾红黑树为例进行分析。 与 2-3 树等价的红黑树：2-3 树中有三个 3 节点 —&gt; 红黑树中有三个红色节点，每一个 3 节点产生一个红色节点。 对于任何一颗 2-3 树，我们都可以使用以上规则将之转化成一颗红黑树。 3.红黑树①概念 红黑树（Red Black Tree）是一种自平衡的二分搜索树，它在每个结点上增加一个存储位来表示结点的颜色，可以是 Red 或 Black。红黑树通过对任意一条从根到叶子的路径上的各个结点着色方式的限制，确保没有一条路径会比其他路径长出两倍，因而是接近平衡的。 下图为一颗红黑树： ②基本性质 红黑树必须满足如下条件： ①（定义）每个节点或者是红色的，或者是黑色的。 ②根节点是黑色的 在 2-3 树中，根节点或者是 2 节点，或者是 3 节点，而 2 节点和 3 节点在与之等价的红黑树（左倾红黑树）中表示为下图的两种情况。 由下图可见， 2-3 树中的 2 节点和 3 节点对应到与之等价的红黑树中，根节点都是黑色的。 ③（定义）每一个叶子节点（这里的叶子节点指的是最后的空节点）是黑色的 相当于定义空节点本身是黑色的， 一颗空树本身也是一颗红黑树，它的根节点和叶子节点都是空节点（空节点是黑色节点），同时满足 ②、③ 条性质。 ④如果一个节点是红色的，那么它的孩子节点都是黑色的。 在红黑树中，只有表示原来的 2-3 树中的 3 节点时，才会出现红色节点。此时红色节点的两个孩子节点是原来的 2-3 树中 3 节点的左孩子和中间的孩子，不管两个孩子是 2 节点还是 3 节点，其对应到红黑树中，根结点都是黑色的（具体见 性质②）。 黑色节点的右孩子一定是黑色的节点（对于左倾红黑树来说，这是我们的定义），它的左孩子可能是红色的节点，也可能是黑色的节点。如果是红色的，表示这两个节点是原来的 2-3 树中的一个 3 节点。如果是黑色的，表示这两个节点是原来的 2-3 树中的两个节点。 ⑤（核心）从任意一个节点到其每个叶子节点（空节点），经过的黑色节点数量是一样的。 2-3 树是一颗绝对平衡的树，从 2-3 树的任意一个节点出发到其每个叶子节点，经过的节点数量是一样的。 因为 2-3 树的 2 节点或 3 节点转换成红黑树中的节点表示时，都会有一个黑色的节点，所以从红黑树的任意一个节点出发，每经过一个黑色节点，等于一定经过了原来的 2-3 树中的某个节点。 红黑树是保持 “黑平衡” 的二叉树（黑平衡是指从根节点到任意一个叶子节点，经过的黑色节点数量是一样的）。从严格意义上讲，红黑树不是平衡二叉树，平衡二叉树的定义为左右子树的高度差不能超过 1，红黑树并不符合。 ③数据结构12345678910111213141516171819202122public class RBTree &#123; private static final boolean RED = true; private static final boolean BLACK = false; private class TreeNode &#123; public int key; public int value; public TreeNode left; public TreeNode right; public boolean color; TreeNode(int key, int value) &#123; this.key = key; this.value = value; this.left = null; this.right = null; // 默认的节点颜色为红色 this.color = RED; &#125; &#125;&#125; 为什么默认的节点颜色为红色？ 在 2-3 树中添加一个节点，永远是和最后找到的叶子节点做融合，融合后或者形成一个 3 节点，或者形成一个临时的 4 节点。在红黑树中，红色节点代表它和它的父亲节点（黑色节点）在原来的 2-3 树中是在一起的，等价于 2-3 树中的一个 3 节点。所以在红黑树中，总是将新添加的节点的颜色设置为红色，等价于在 2-3 树中永远将新节点融合进已有的节点中。 在红黑树中添加红色节点后，可能会破坏红黑树的基本性质，此时需要再做一些调整工作（具体见下文）。 ④保持根节点为黑色 红黑树中添加新元素之保持根节点为黑色 添加根节点：添加第一个红色节点，作为红黑树的根节点。由红黑树的基本性质②（根节点是黑色的）可知，需要将根节点变成黑色。 结论：若插入的红色节点是红黑树的根结点，应该将红色节点变为黑色节点。 添加普通节点：在原来的 2-3 树中添加元素 4 时，元素 4 应该添加到元素 2 和元素 5 组成的 3 节点中，形成一个临时的 4 节点（2 | 4 | 5）。然后将临时的 4 节点变形成由三个 2 节点组成的子树，让子树的根节点（即节点 4） 向上融合（与元素 6 和元素 8 所在的 3 节点进行融合），再形成一个临时的 4 节点（4 | 6 | 8），然后再将它变形成由三个 2 节点组成的子树，此时这颗子树的根节点是整棵 2-3 树的根节点，不再向上融合。由于元素 4 和元素 6 在原来的 2-3 树中是向上融合的，所以在与之等价的红黑树中，它们所在的节点是红色的。由于节点 6 是最后的根节点，所以在与之等价的红黑树中，元素 6 所在的节点是黑色的。 结论：对于临时的 4 节点，在 2-3 树的添加过程中每次都要向上融合一个元素，这个元素所在的节点在红黑树的表示中应该是红色的节点。直到它融合到了根节点，再也不能向上走时，变为黑色的节点。 代码实践：保持根节点为黑色 1234567891011121314/** * 功能描述: 向红黑树中添加新的节点(key, value) * * @param: [key, value] * @return: void * @auther: wjy * @date: 2020/3/15 17:55 */public void insert(int key, int value) &#123; // 见⑧添加新元素 node = insert(node, key, value); // 保持根节点为黑色 node.color = BLACK;&#125; ⑤左旋转 向 2-3 树的 2 节点中添加一个新元素的第一种情况 —&gt; 对应到红黑树中表示：如下图所示。 在上图的红黑树中，添加的新元素（红色节点）在黑色节点的左侧：直接添加（对应 2-3 树中的一个 3 节点） 向 2-3 树的 2 节点中添加一个新元素的第二种情况 —&gt; 对应到红黑树中表示：如下图所示。 在上图的红黑树中，添加的新元素（红色节点）在黑色节点的右侧：先添加（此时红黑树不满足我们定义的左倾红黑树的性质) 、再调整（进行一次左旋转）。 左旋转的过程（注意：旋转前后的红黑树都要满足二分搜索树的性质） 让 x 的左子树 T2 变成 node 的右子树 让 node 变成 x 的左子树 维护节点的颜色 x 的颜色等于 node 的颜色（可能是红色，也可能是黑色）。因为在左旋转之前的树中，node 是根节点，现在 x 变成了根节点，根节点的颜色应该保持一致。 node 的颜色应该设置为红色。在原来的 2-3 树中，新加入的节点 42 与 37 形成了一个新的 3 节点。通过左旋转之后，并没有改变 3 节点中的两个元素，只是置换了两个元素的位置（在红黑树中）。所以为了表示它们在旋转前后都是原来的 2-3 树中的同一个 3 节点，node 节点要设置为红色。 注意： 左旋转只是一个子过程，在左旋转的过程中并不维持红黑树的性质，我们只需要通过旋转操作让两个元素对应是原来的 2-3 树中的一个 3 节点即可。 在左旋转之后有可能产生两个连续的红色节点。 代码实践：左旋转 123456789101112131415161718192021222324252627/** * 功能描述: 对传入的node节点进行左旋转 * 返回旋转之后新的子树的根节点 * * node x * / \ 左旋转(node) / \ * T1 x ---------&gt; node T3 * / \ / \ * T2 T3 T1 T2 * * @param: [node] * @return: tree.redblacktree.RBTree.TreeNode * @auther: wjy * @date: 2020/3/15 23:53 */private TreeNode leftRotate(TreeNode node) &#123; // 记录node节点的右孩子x TreeNode x = node.right; // 左旋转 node.right = x.left; x.left = node; // 维持节点的颜色 x.color = node.color; node.color = RED; // 返回旋转后子树的新的根节点，在添加元素的操作中会对根节点的颜色做进一步的处理。 return x;&#125; ⑥颜色翻转 向 2-3 树的 3 节点中添加一个新元素的第一种情况 —&gt; 对应到红黑树中表示：如下图所示。 在上图的红黑树中添加一个新元素 66，应该添加到 42 的右孩子。—&gt; 对应到 2-3 树中表示：原来的 2-3 树中有一个 3 节点（37 | 42），添加一个新元素 66，形成一个临时的 4 节点（37 | 42 | 66）。 然后将临时的 4 节点变形成由 3 个 2 节点组成的子树。 —&gt; 对应到红黑树中表示：三个节点都应该是黑色的节点，我们需要将两个红色节点的颜色翻转成黑色。 最后由 3 个 2 节点组成的子树的根节点要继续向上与其父亲节点进行融合。—&gt; 对应到红黑树中表示：需要将根节点的颜色翻转成红色。 代码实践：颜色翻转 1234567891011121314/** * 功能描述: 颜色翻转 * 调用前需要保证以node为根的子树满足翻转条件 * * @param: [node] * @return: void * @auther: wjy * @date: 2020/3/15 11:16 */private void flipColors(TreeNode node) &#123; node.color = RED; node.left.color = BLACK; node.right.color = BLACK;&#125; ⑦右旋转 向 2-3 树的 3 节点中添加一个新元素的第二种情况 —&gt; 对应到红黑树中表示：如下图所示。 在上图的红黑树中添加一个新元素 12，应该添加到 37 的左孩子。—&gt; 对应到 2-3 树中表示：原来的 2-3 树中有一个 3 节点（37 | 42），添加一个新元素 12，形成一个临时的 4 节点（12 | 37 | 42）。 然后将临时的 4 节点变形成由 3 个 2 节点组成的子树 —&gt; 对应到红黑树中表示：需要先对节点 42 进行一次右旋转，右旋转之后，红黑树的结构满足进行颜色翻转的条件，此时再对红黑树进行一次颜色翻转，具体见 ⑥颜色翻转。 右旋转的过程（注意：旋转前后的红黑树都要满足二分搜索树的性质） 让 x 的右子树 T1 变成 node 的左子树 让 node 变成 x 的右子树 维护节点的颜色 x 的颜色等于 node 的颜色（可能是红色，也可能是黑色），因为在右旋转之前的树中，node 是根节点，现在 x 变成了根节点，根节点的颜色应该保持一致。 node 的颜色应该设置为红色。因为在右旋转之后，三个节点对应到原来的 2-3 树中还是临时的 4 节点，所以 node 节点是红色表示它和它的父亲节点在原来的 2-3 树中是融合在一起的。 代码实践：右旋转 12345678910111213141516171819202122232425262728/** * 功能描述: 对传入的node节点进行右旋转 * 返回旋转之后新的子树的根节点 * * y x * / \ / \ * x T4 向右旋转(y) z y * / \ - - - - - - - -&gt; / \ / \ * z T3 T1 T2 T3 T4 * / \ * T1 T2 * * @param: [node] * @return: tree.redblacktree.RBTree.TreeNode * @auther: wjy * @date: 2020/3/15 11:29 */private TreeNode rightRotate(TreeNode node) &#123; // 记录node节点的左孩子x TreeNode x = node.left; // 右旋转 node.left = x.right; x.right = node; // 维持节点的颜色 x.color = node.color; node.color = RED; return x;&#125; 向 2-3 树的 3 节点中添加一个新元素的第三种情况 —&gt; 对应到红黑树中表示：如下图所示。 在上图的红黑树中添加一个新元素 40，应该添加到 37 的右孩子。—&gt; 对应到 2-3 树中表示：原来的 2-3 树中有一个 3 节点（37 | 42），添加一个新元素 12，形成一个临时的 4 节点（37 | 40 | 42）。 然后将临时的 4 节点变形成由 3 个 2 节点组成的子树 —&gt; 对应到红黑树中表示：需要先对节点 37 进行一次左旋转，左旋转之后，红黑树的结构满足进行右旋转的条件，此时再对红黑树进行一次右旋转，具体见 ⑦右旋转。 ⑧添加新元素 下图总结了在红黑树中添加新元素的所有情况： 添加新元素后维护红黑树性质的方法：使用二分搜索树的策略将新元素添加进红黑树后，按照上图顺序依次判断该子树是否需要左旋转、右旋转和颜色翻转，然后将维护后的新的根节点返回给递归调用的上一层，在上一层继续维护红黑树的性质。 代码实践：添加新元素 12345678910111213141516171819202122232425262728293031323334353637383940/** * 功能描述: 向以node为根的红黑树中插入新的节点(key, value) * 返回插入新节点后红黑树的根 * * @param: [node, key, value] * @return: tree.redblacktree.RBTree.TreeNode * @auther: wjy * @date: 2020/3/15 17:50 */private TreeNode insert(TreeNode node, int key, int value) &#123; // 搜索插入位置 if (node == null) &#123; count++; // 默认插入红色节点 return new TreeNode(key, value); &#125; if (key == node.key) &#123; node.value = value; &#125; else if (key &lt; node.key) &#123; node.left = insert(node.left, key, value); &#125; else &#123; node.right = insert(node.right, key, value); &#125; // 红黑树性质的维护 // 是否需要左旋转 if (isRed(node.right) &amp;&amp; !isRed(node.left)) &#123; node = leftRotate(node); &#125; // 是否需要右旋转 if (isRed(node.left) &amp;&amp; isRed(node.left.left)) &#123; node = rightRotate(node); &#125; // 是否需要翻转 if (isRed(node.left) &amp;&amp; isRed(node.right)) &#123; flipColors(node); &#125; return node;&#125; ⑨删除新元素 参考链接 ⑩代码实现 + 测试 查找方法与二分搜索树（红黑树是一种自平衡的二分搜索树）的查找方法一致 前序、中序、后序和层序遍历方法与树的遍历方法一致 红黑树的全部操作如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345package tree.redblacktree;import java.util.LinkedList;import java.util.Queue;/** * @author: wjy * @date: 2020/3/15 * @description: 红黑树 */public class RBTree &#123; private static final boolean RED = true; private static final boolean BLACK = false; private class TreeNode &#123; public int key; public int value; public TreeNode left; public TreeNode right; public boolean color; TreeNode(int key, int value) &#123; this.key = key; this.value = value; this.left = null; this.right = null; // 默认的节点颜色为红色 this.color = RED; &#125; &#125; private TreeNode node; private int count; public RBTree() &#123; this.node = null; this.count = 0; &#125; /** * 功能描述: 判断节点的颜色 * * @param: [node] * @return: boolean * @auther: wjy * @date: 2020/3/15 12:23 */ private boolean isRed(TreeNode node) &#123; if (node == null) &#123; return BLACK; &#125; return node.color; &#125; /** * 功能描述: 查看以node为根的红黑树中是否包含键值为key的节点 * * @param: [node, key] * @return: boolean * @auther: wjy * @date: 2020/3/15 17:58 */ private boolean contain(TreeNode node, int key) &#123; if (node == null) &#123; return false; &#125; if (key == node.key) &#123; return true; &#125; else if (key &lt; node.key) &#123; return contain(node.left, key); &#125; else &#123; return contain(node.right, key); &#125; &#125; /** * 功能描述: 对传入的node节点进行左旋转 * 返回旋转之后新的子树的根节点 * * node x * / \ 左旋转(node) / \ * T1 x ---------&gt; node T3 * / \ / \ * T2 T3 T1 T2 * * @param: [node] * @return: tree.redblacktree.RBTree.TreeNode * @auther: wjy * @date: 2020/3/15 23:53 */ private TreeNode leftRotate(TreeNode node) &#123; // 记录node节点的右孩子x TreeNode x = node.right; // 左旋转 node.right = x.left; x.left = node; // 维持节点的颜色 x.color = node.color; node.color = RED; // 返回旋转后子树的新的根节点，在添加元素的操作中会对根节点的颜色做进一步的处理。 return x; &#125; /** * 功能描述: 对传入的node节点进行右旋转 * 返回旋转之后新的子树的根节点 * * y x * / \ / \ * x T4 向右旋转(y) z y * / \ - - - - - - - -&gt; / \ / \ * z T3 T1 T2 T3 T4 * / \ * T1 T2 * * @param: [node] * @return: tree.redblacktree.RBTree.TreeNode * @auther: wjy * @date: 2020/3/15 11:29 */ private TreeNode rightRotate(TreeNode node) &#123; // 记录node节点的左孩子x TreeNode x = node.left; // 右旋转 node.left = x.right; x.right = node; // 维持节点的颜色 x.color = node.color; node.color = RED; return x; &#125; /** * 功能描述: 颜色翻转 * 调用前需要保证以node为根的子树满足翻转条件 * * @param: [node] * @return: void * @auther: wjy * @date: 2020/3/15 11:16 */ private void flipColors(TreeNode node) &#123; node.color = RED; node.left.color = BLACK; node.right.color = BLACK; &#125; /** * 功能描述: 向以node为根的红黑树中插入新的节点(key, value) * 返回插入新节点后红黑树的根 * * @param: [node, key, value] * @return: tree.redblacktree.RBTree.TreeNode * @auther: wjy * @date: 2020/3/15 17:50 */ private TreeNode insert(TreeNode node, int key, int value) &#123; // 搜索插入位置 if (node == null) &#123; count++; // 默认插入红色节点 return new TreeNode(key, value); &#125; if (key == node.key) &#123; node.value = value; &#125; else if (key &lt; node.key) &#123; node.left = insert(node.left, key, value); &#125; else &#123; node.right = insert(node.right, key, value); &#125; // 红黑树性质的维护 // 是否需要左旋转 if (isRed(node.right) &amp;&amp; !isRed(node.left)) &#123; node = leftRotate(node); &#125; // 是否需要右旋转 if (isRed(node.left) &amp;&amp; isRed(node.left.left)) &#123; node = rightRotate(node); &#125; // 是否需要翻转 if (isRed(node.left) &amp;&amp; isRed(node.right)) &#123; flipColors(node); &#125; return node; &#125; /** * 功能描述: 对以node为根的红黑树进行层序遍历 * * @param: [node] * @return: void * @auther: wjy * @date: 2020/3/15 18:12 */ private void levelOrder(TreeNode node) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(node); while (!queue.isEmpty()) &#123; TreeNode treeNode = queue.poll(); System.out.print(treeNode.key + "(" + treeNode.color + ") "); if (treeNode.left != null) &#123; queue.add(treeNode.left); &#125; if (treeNode.right != null) &#123; queue.add(treeNode.right); &#125; &#125; &#125; /** * 功能描述: 对以node为根的红黑树进行前序遍历 * * @param: [node] * @return: void * @auther: wjy * @date: 2020/3/15 1:29 */ private void preOrder(TreeNode node) &#123; if (node == null) &#123; return; &#125; System.out.print(node.key + " "); preOrder(node.left); preOrder(node.right); &#125; /** * 功能描述: 对以node为根的红黑树进行中序遍历 * * @param: [node] * @return: void * @auther: wjy * @date: 2020/3/15 17:58 */ private void inOrder(TreeNode node) &#123; if (node == null) &#123; return; &#125; inOrder(node.left); System.out.print(node.key + " "); inOrder(node.right); &#125; /** * 功能描述: 对以node为根的红黑树进行后序遍历 * * @param: [node] * @return: void * @auther: wjy * @date: 2020/3/15 1:30 */ private void postOrder(TreeNode node) &#123; if (node == null) &#123; return; &#125; postOrder(node.left); postOrder(node.right); System.out.print(node.key + " "); &#125; public int size() &#123; return count; &#125; public boolean isEmpty() &#123; return count == 0; &#125; /** * 功能描述: 判断是否包含key * * @param: [key] * @return: boolean * @auther: wjy * @date: 2020/3/15 17:55 */ public boolean contain(int key) &#123; return contain(node, key); &#125; /** * 功能描述: 向红黑树中添加新的节点(key, value) * * @param: [key, value] * @return: void * @auther: wjy * @date: 2020/3/15 17:55 */ public void insert(int key, int value) &#123; node = insert(node, key, value); // 保持根节点为黑色 node.color = BLACK; &#125; /** * 功能描述: 红黑树的层序遍历 * * @param: [] * @return: void * @auther: wjy * @date: 2020/3/15 17:45 */ public void levelOrder() &#123; levelOrder(node); &#125; /** * 功能描述: 红黑树的前序遍历 * * @param: [] * @return: void * @auther: wjy * @date: 2020/3/15 18:05 */ public void preOrder() &#123; preOrder(node); &#125; /** * 功能描述: 红黑树的中序遍历 * * @param: [] * @return: void * @auther: wjy * @date: 2020/3/15 18:05 */ public void inOrder() &#123; inOrder(node); &#125; /** * 功能描述: 红黑树的后序遍历 * * @param: [] * @return: void * @auther: wjy * @date: 2020/3/15 18:05 */ public void postOrder() &#123; postOrder(node); &#125;&#125; 测试红黑树的代码： 1234567891011121314151617181920212223242526package tree.redblacktree;/** * @author: wjy * @date: 2020/3/15 * @description: 测试红黑树 */public class Test &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;42, 37, 12, 18, 6, 11&#125;; RBTree rbTree = new RBTree(); System.out.println("红黑树是否为空: " + rbTree.isEmpty()); for (int i = 0; i &lt; 6; i++) &#123; rbTree.insert(arr[i], i); &#125; System.out.println("红黑树的节点个数: " + rbTree.size()); System.out.println("红黑树的层序遍历: "); rbTree.levelOrder(); System.out.println("\n红黑树的前序遍历: "); rbTree.preOrder(); System.out.println("\n红黑树的中序遍历: "); rbTree.inOrder(); System.out.println("\n红黑树的后序遍历: "); rbTree.postOrder(); &#125;&#125; 通过前序、中序、后序和层序遍历的结果可以推算出红黑树的结构： 也可以推算出与其等价的 2-3 树的结构： 4.常见面试问题①红黑树的数据结构是怎么定义的？ 具体见 3.红黑树—③数据结构 ②红黑树有哪些性质？ 具体见 3.红黑树—②基本性质 ③红黑树的各种操作的时间复杂度是多少？ 最大高度： 2logn（logn 个红色节点 + logn 个黑色节点，此时该条路径上每一个黑色节点的左孩子都是红色节点。） 增删改查的时间复杂度：O（logn） ④红黑树相比于 BST 和 AVL 树有什么优点？ BST：最大高度不定，可能会退化为链表。 优点：内部实现简单，没有复杂的维持平衡的操作。对于完全随机的数据，并不会退化为链表。 缺点：极端情况会退化为链表（数据按顺序进入二分搜索树时）或者高度不平衡（数据近乎有序时） AVL 树：采用了平衡二叉树的策略，最大高度为 logn，且不会退化为链表，对于查询操作（get、set、contain 等方法）性能较高。 红黑树：并不完全满足平衡二叉树的定义，最大高度为 2logn，它可以保持自平衡而不会退化为链表，对于插入和删除操作（insert、delete 等方法）性能较高。 AVL 树和红黑树的对比： 它们都是在二分搜索树的基础上添加了一些其他的性质，来保证自己不会退化为链表。 红黑树的增删操作快于 AVL 树，查找操作慢于 AVL 树（因为 AVL 树的最大高度是 logn，红黑树的最大高度是 2logn，它们是常数级别的差异），所以 AVL 树适用于查询较多的情况，而红黑树适用于插入和删除较多的情况。 红黑树的统计性能更优，虽然其时间复杂度与 AVL 树是同一个级别的，但是综合增删改查所有的操作，红黑树在平均情况下更好一些。 总结：红黑树相对于 AVL 树来说，牺牲了部分平衡性以换取插入 / 删除操作时少量的旋转操作，整体性能要优于 AVL 树。 ⑤红黑树的应用？ 由于红黑树的统计性能（综合增删改查所有的操作）更优，所以很多语言内部的容器类中的有序映射都是基于红黑树实现的。例如：Java 中的 TreeMap、TreeSet、JDK 1.8 后的 HashMap 和 C++ 的 STL 中的 map 和 set。 Java集合框架总结+源码分析 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#x79;&#x6d;&#x65;&#115;&#x73;&#x69;&#x40;&#49;&#54;&#x33;&#46;&#x63;&#x6f;&#109;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 1115. 交替打印FooBar（Medium）Java语言题解]]></title>
    <url>%2F2020%2F03%2F01%2FLeetCode-1115-%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0FooBar%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.题目相关①题目及示例 ②相关标签 多线程 ③题目地址 1115. 交替打印FooBar — 力扣网 2.解题方法①synchronized 关键字 + this 锁对象 原因：两个线程属于同一个实例，虽然两个线程访问的是一个类的不同的普通同步方法，但是两个普通同步方法默认都是以 this 对象作为同步方法的锁，所以它们会争抢同一把锁（对于同一个实例来讲，两个方法的 this 对象是同一个）。 结果：两个线程争抢同一把锁，同一时刻只能有一个线程执行该线程对应的同步方法，然后再使用 wait 方法和 notify 方法，使得两个线程交替运行。 ②lock + condition lock 代替 synchronized 关键字 condition 中的 await 方法和 release 方法代替 Object 对象的 wait 方法和 notify 方法 ③信号量 两个线程第一次执行时，因为 bar 信号量的计数器初始值为 0，所以需要等 foo 线程中释放了 bar 信号量，bar 线程才能开始执行。而 foo 信号量在获取了一个许可后，其计数器值也变为 0，所以 foo 线程在下一次循环开始时需要等 bar 线程中释放了 foo 信号量，foo 线程才能继续执行。 ④CountDownLatch + CyclicBarrier CyclicBarrier 用于保证任务按组循环执行 CounDownLatch 用于保证一个循环内线程执行的先后顺序 具体实现见代码 3.代码详解①synchronized 关键字 + this 锁对象1234567891011121314151617181920212223242526272829303132333435// 1.synchronized关键字+this锁对象(两个不同的线程将会共用一个FooBar实例)class FooBar &#123; private int n; public FooBar(int n) &#123; this.n = n; &#125; public void foo(Runnable printFoo) throws InterruptedException &#123; for (int i = 0; i &lt; n; i++) &#123; synchronized (this) &#123; printFoo.run(); // 唤醒另一个线程 this.notify(); // 自己陷入等待 this.wait(); &#125; &#125; &#125; public void bar(Runnable printBar) throws InterruptedException &#123; for (int i = 0; i &lt; n; i++) &#123; synchronized (this) &#123; printBar.run(); // 唤醒另一个线程 this.notify(); // 防止线程在最后一次打印Bar时睡眠，从而造成死锁。 if (i != n - 1) &#123; // 自己陷入等待 this.wait(); &#125; &#125; &#125; &#125;&#125; ②lock + condition12345678910111213141516171819202122232425262728293031323334353637// 2.lock+conditionclass FooBar &#123; private int n; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public FooBar(int n) &#123; this.n = n; &#125; public void foo(Runnable printFoo) throws InterruptedException &#123; for (int i = 0; i &lt; n; i++) &#123; lock.lock(); printFoo.run(); // 唤醒另一个线程 condition.signalAll(); // 自己陷入等待 condition.await(); lock.unlock(); &#125; &#125; public void bar(Runnable printBar) throws InterruptedException &#123; for (int i = 0; i &lt; n; i++) &#123; lock.lock(); printBar.run(); // 唤醒另一个线程 condition.signalAll(); // 防止线程在最后一次打印Bar时睡眠，从而造成死锁。 if (i != n - 1) &#123; // 自己陷入等待 condition.await(); &#125; lock.unlock(); &#125; &#125;&#125; ③信号量123456789101112131415161718192021222324252627282930// 3.信号量(Semaphore)class FooBar &#123; private int n; private Semaphore foo = new Semaphore(1); private Semaphore bar = new Semaphore(0); public FooBar(int n) &#123; this.n = n; &#125; public void foo(Runnable printFoo) throws InterruptedException &#123; for (int i = 0; i &lt; n; i++) &#123; // 获取foo信号量的一个许可 foo.acquire(); printFoo.run(); // 释放bar信号量的一个许可 bar.release(); &#125; &#125; public void bar(Runnable printBar) throws InterruptedException &#123; for (int i = 0; i &lt; n; i++) &#123; // 获取bar信号量的一个许可 bar.acquire(); printBar.run(); // 释放foo信号量的一个许可 foo.release(); &#125; &#125;&#125; ④CountDownLatch + CyclicBarrier12345678910111213141516171819202122232425262728293031323334353637// 4.CountDownLatch+CyclicBarrierclass FooBar &#123; private int n; // CyclicBarrier用于保证任务按组循环执行 private CyclicBarrier barrier = new CyclicBarrier(2); // CounDownLatch用于保证一个循环内线程执行的先后顺序 private CountDownLatch latch = new CountDownLatch(1); public FooBar(int n) &#123; this.n = n; &#125; public void foo(Runnable printFoo) throws InterruptedException &#123; for (int i = 0; i &lt; n; i++) &#123; try&#123; printFoo.run(); // 触发bar线程执行 latch.countDown(); // 等待bar线程执行完成 barrier.await(); &#125; catch(Exception e) &#123;&#125; &#125; &#125; public void bar(Runnable printBar) throws InterruptedException &#123; for (int i = 0; i &lt; n; i++) &#123; try &#123; // 等待被触发 latch.await(); printBar.run(); latch = new CountDownLatch(1); // 触发foo线程和bar线程继续执行(进行下一次循环) barrier.await(); &#125; catch (Exception e) &#123;&#125; &#125; &#125;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#x79;&#109;&#x65;&#x73;&#115;&#x69;&#x40;&#x31;&#x36;&#51;&#x2e;&#99;&#x6f;&#109; 关于 数据结构与算法 的更多代码 请查看我的 GitHub仓库]]></content>
      <categories>
        <category>Java</category>
        <category>LeetCode-多线程题解</category>
      </categories>
      <tags>
        <tag>Java并发编程</tag>
        <tag>LeetCode题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 1188. 设计有限阻塞队列（Medium）Java语言题解]]></title>
    <url>%2F2020%2F03%2F01%2FLeetCode-1188-%E8%AE%BE%E8%AE%A1%E6%9C%89%E9%99%90%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.题目相关①题目及示例 ②相关标签 多线程 ③题目地址 1188. 设计有限阻塞队列 — 力扣网 2.解题方法 使用 LinkedList 集合模拟阻塞队列 存储当前队列元素个数的变量是 AtomicInteger 类型（来保证原子性） ①synchronized 关键字 + this 锁对象 使用 synchronized 关键字对入队和出队操作加锁 使用 Object 对象的 wait 方法 和 notify 方法控制两个线程的相互等待和唤醒操作 ②lock + condition 使用 lock 对入队和出队操作加锁 使用 condition 控制两个线程的相互等待和唤醒操作 3.代码详解①synchronized 关键字 + this 锁对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 1.synchronized关键字+this锁对象class BoundedBlockingQueue &#123; // 用线程安全的集合实现一个阻塞队列 private LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); // 存储当前队列元素个数 AtomicInteger size = new AtomicInteger(0); // 存储队列长度上限 private volatile int capacity; public BoundedBlockingQueue(int capacity) &#123; this.capacity = capacity; &#125; public void enqueue(int element) throws InterruptedException &#123; synchronized (this) &#123; // 如果队列满，调用线程被阻塞直到队列非满。 while (size.get() &gt;= capacity) &#123; // 线程阻塞时会释放锁 this.wait(); &#125; // 在队首增加一个element list.addFirst(element); // 当前队列元素个数加一 size.incrementAndGet(); // 通知消费者线程可以继续消费了 this.notify(); &#125; &#125; public int dequeue() throws InterruptedException &#123; synchronized (this) &#123; // 如果队列空，调用线程被阻塞直到队列非空。 while (size.get() == 0) &#123; // 线程阻塞时会释放锁 this.wait(); &#125; // 返回队尾元素并从队列中将其删除 int value = list.getLast(); list.removeLast(); // 当前队列元素个数减一 size.decrementAndGet(); // 通知生产者线程可以继续生产了 this.notify(); return value; &#125; &#125; public int size() &#123; return size.get(); &#125;&#125; ②lock + condition12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 2.lock+conditionclass BoundedBlockingQueue &#123; // 用线程安全的集合实现一个阻塞队列 private LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); // 存储当前队列元素个数 AtomicInteger size = new AtomicInteger(0); // 存储队列长度上限 private volatile int capacity; // 可重入锁 private Lock lock = new ReentrantLock(); Condition procuder = lock.newCondition(); Condition consumer = lock.newCondition(); public BoundedBlockingQueue(int capacity) &#123; this.capacity = capacity; &#125; public void enqueue(int element) throws InterruptedException &#123; try &#123; lock.lock(); // 如果队列满，调用线程被阻塞直到队列非满。 while (size.get() &gt;= capacity) &#123; // 线程阻塞时会释放锁 procuder.await(); &#125; // 在队首增加一个element list.addFirst(element); // 当前队列元素个数加一 size.incrementAndGet(); // 通知消费者线程可以继续消费了 consumer.signal(); &#125; finally &#123; lock.unlock(); &#125; &#125; public int dequeue() throws InterruptedException &#123; try &#123; lock.lock(); // 如果队列空，调用线程被阻塞直到队列非空。 while (size.get() == 0) &#123; // 线程阻塞时会释放锁 consumer.await(); &#125; // 返回队尾元素并从队列中将其删除 int value = list.getLast(); list.removeLast(); // 当前队列元素个数减一 size.decrementAndGet(); // 通知生产者线程可以继续生产了 procuder.signal(); return value; &#125; finally &#123; lock.unlock(); &#125; &#125; public int size() &#123; return size.get(); &#125;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#121;&#x6d;&#101;&#115;&#x73;&#x69;&#64;&#49;&#54;&#51;&#x2e;&#99;&#x6f;&#109; 关于 数据结构与算法 的更多代码 请查看我的 GitHub仓库]]></content>
      <categories>
        <category>Java</category>
        <category>LeetCode-多线程题解</category>
      </categories>
      <tags>
        <tag>Java并发编程</tag>
        <tag>LeetCode题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 1195. 交替打印字符串（Medium）Java语言题解]]></title>
    <url>%2F2020%2F03%2F01%2FLeetCode-1195-%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.题目相关①题目及示例 ②相关标签 多线程 ③题目地址 1195. 交替打印字符串 — 力扣网 2.解题方法①synchronized 关键字 + this 锁对象 原因：四个线程属于同一个实例，虽然四个线程访问的是一个类的不同的普通同步方法，但是四个普通同步方法默认都是以 this 对象作为同步方法的锁，所以它们会争抢同一把锁（对于同一个实例来讲，四个方法的 this 对象是同一个）。 结果：四个线程争抢同一把锁，同一时刻只能有一个线程执行该线程对应的同步方法，然后再使用 wait 方法和 notify 方法，使得四个线程交替运行。 ②lock + condition lock 代替 synchronized 关键字 condition 中的 await 方法和 release 方法代替 Object 对象的 wait 方法和 notify 方法 ③信号量 四个线程第一次执行时，因为只有 number 信号量的计数器初始值为 1，其余都为 0，所以 number 线程先执行，让它不断判断接下来该哪个线程执行，并释放对应线程的信号量，对应线程执行一次循环后，释放 number 信号量，以便 number 线程继续判断。 ④原子变量 使用一个原子变量控制，把并发调用变成按顺序调用。 ⑤volatile 关键字 使用 volatile 关键字保证变量的可见性，把并发调用变成按顺序调用。 3.代码详解①synchronized 关键字 + this 锁对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 1.synchronized关键字+this锁对象(四个不同的线程将会共用一个FizzBuzz实例)class FizzBuzz &#123; private int n; private int num = 1; public FizzBuzz(int n) &#123; this.n = n; &#125; public void fizz(Runnable printFizz) throws InterruptedException &#123; while (num &lt;= n) &#123; synchronized (this) &#123; // 是3的倍数且不是5的倍数 if (num % 3 == 0 &amp;&amp; num % 5 != 0) &#123; printFizz.run(); num++; &#125; // 唤醒所有线程 this.notifyAll(); // 防止线程在最后一次打印时睡眠，从而造成死锁。 if (num &lt;= n) &#123; // 自己陷入等待 this.wait(); &#125; &#125; &#125; &#125; public void buzz(Runnable printBuzz) throws InterruptedException &#123; while (num &lt;= n) &#123; synchronized (this) &#123; // 是5的倍数且不是3的倍数 if (num % 5 == 0 &amp;&amp; num % 3 != 0) &#123; printBuzz.run(); num++; &#125; // 唤醒所有线程 this.notifyAll(); // 防止线程在最后一次打印时睡眠，从而造成死锁。 if (num &lt;= n) &#123; // 自己陷入等待 this.wait(); &#125; &#125; &#125; &#125; public void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException &#123; while (num &lt;= n) &#123; synchronized (this) &#123; // 是3的倍数且是5的倍数 if (num % 3 == 0 &amp;&amp; num % 5 == 0) &#123; printFizzBuzz.run(); num++; &#125; // 唤醒所有线程 this.notifyAll(); // 防止线程在最后一次打印时睡眠，从而造成死锁。 if (num &lt;= n) &#123; // 自己陷入等待 this.wait(); &#125; &#125; &#125; &#125; public void number(IntConsumer printNumber) throws InterruptedException &#123; while (num &lt;= n) &#123; synchronized (this) &#123; // 不是3的倍数且不是5的倍数 if (num % 3 != 0 &amp;&amp; num % 5 != 0) &#123; printNumber.accept(num); num++; &#125; // 唤醒所有线程 this.notifyAll(); // 防止线程在最后一次打印时睡眠，从而造成死锁。 if (num &lt;= n) &#123; // 自己陷入等待 this.wait(); &#125; &#125; &#125; &#125;&#125; ②lock + condition123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// 2.lock+conditionclass FizzBuzz &#123; private int n; private int num = 1; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public FizzBuzz(int n) &#123; this.n = n; &#125; public void fizz(Runnable printFizz) throws InterruptedException &#123; while (num &lt;= n) &#123; lock.lock(); // 是3的倍数且不是5的倍数 if (num % 3 == 0 &amp;&amp; num % 5 != 0) &#123; printFizz.run(); num++; &#125; // 唤醒所有线程 condition.signalAll(); // 防止线程在最后一次打印时睡眠，从而造成死锁。 if (num &lt;= n) &#123; // 自己陷入等待 condition.await(); &#125; lock.unlock(); &#125; &#125; public void buzz(Runnable printBuzz) throws InterruptedException &#123; while (num &lt;= n) &#123; lock.lock(); // 是5的倍数且不是3的倍数 if (num % 5 == 0 &amp;&amp; num % 3 != 0) &#123; printBuzz.run(); num++; &#125; // 唤醒所有线程 condition.signalAll(); // 防止线程在最后一次打印时睡眠，从而造成死锁。 if (num &lt;= n) &#123; // 自己陷入等待 condition.await(); &#125; lock.unlock(); &#125; &#125; public void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException &#123; while (num &lt;= n) &#123; lock.lock(); // 是3的倍数且是5的倍数 if (num % 3 == 0 &amp;&amp; num % 5 == 0) &#123; printFizzBuzz.run(); num++; &#125; // 唤醒所有线程 condition.signalAll(); // 防止线程在最后一次打印时睡眠，从而造成死锁。 if (num &lt;= n) &#123; // 自己陷入等待 condition.await(); &#125; lock.unlock(); &#125; &#125; public void number(IntConsumer printNumber) throws InterruptedException &#123; while (num &lt;= n) &#123; lock.lock(); // 不是3的倍数且不是5的倍数 if (num % 3 != 0 &amp;&amp; num % 5 != 0) &#123; printNumber.accept(num); num++; &#125; // 唤醒所有线程 condition.signalAll(); // 防止线程在最后一次打印时睡眠，从而造成死锁。 if (num &lt;= n) &#123; // 自己陷入等待 condition.await(); &#125; lock.unlock(); &#125; &#125;&#125; ③信号量12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 3.信号量(Semaphore)class FizzBuzz &#123; private int n; private Semaphore fizz = new Semaphore(0); private Semaphore buzz = new Semaphore(0); private Semaphore fizzbuzz = new Semaphore(0); private Semaphore number = new Semaphore(1); public FizzBuzz(int n) &#123; this.n = n; &#125; public void fizz(Runnable printFizz) throws InterruptedException &#123; for (int i = 3; i &lt;= n; i += 3) &#123; if (i % 5 != 0) &#123; // 获取fizz信号量的一个许可 fizz.acquire(); printFizz.run(); // 释放number信号量的一个许可 number.release(); &#125; &#125; &#125; public void buzz(Runnable printBuzz) throws InterruptedException &#123; for (int i = 5; i &lt;= n; i += 5) &#123; if (i % 3 != 0) &#123; // 获取buzz信号量的一个许可 buzz.acquire(); printBuzz.run(); // 释放number信号量的一个许可 number.release(); &#125; &#125; &#125; public void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException &#123; for (int i = 15; i &lt;= n; i += 15) &#123; // 获取fizzbuzz信号量的一个许可 fizzbuzz.acquire(); printFizzBuzz.run(); // 释放number信号量的一个许可 number.release(); &#125; &#125; public void number(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 1; i &lt;= n; i++) &#123; // 获取number信号量的一个许可 number.acquire(); if (i % 3 == 0 &amp;&amp; i % 5 == 0) &#123; // 释放fizzbuzz信号量的一个许可 fizzbuzz.release(); &#125; else if (i % 3 == 0) &#123; // 释放fizz信号量的一个许可 fizz.release(); &#125; else if (i % 5 == 0) &#123; // 释放buzz信号量的一个许可 buzz.release(); &#125; else &#123; printNumber.accept(i); // 释放number信号量的一个许可 number.release(); &#125; &#125; &#125;&#125; ④原子变量1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 4.原子变量class FizzBuzz &#123; private int n; private AtomicInteger num = new AtomicInteger(1); public FizzBuzz(int n) &#123; this.n = n; &#125; public void fizz(Runnable printFizz) throws InterruptedException &#123; while (num.get() &lt;= n) &#123; int temp = num.get(); // 是3的倍数且不是5的倍数 if (temp % 3 == 0 &amp;&amp; temp % 5 != 0) &#123; printFizz.run(); num.getAndIncrement(); &#125; &#125; &#125; public void buzz(Runnable printBuzz) throws InterruptedException &#123; while (num.get() &lt;= n) &#123; int temp = num.get(); // 不是3的倍数且是5的倍数 if (temp % 3 != 0 &amp;&amp; temp % 5 == 0) &#123; printBuzz.run(); num.getAndIncrement(); &#125; &#125; &#125; public void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException &#123; while (num.get() &lt;= n) &#123; int temp = num.get(); // 是3的倍数且是5的倍数 if (temp % 3 == 0 &amp;&amp; temp % 5 == 0) &#123; printFizzBuzz.run(); num.getAndIncrement(); &#125; &#125; &#125; public void number(IntConsumer printNumber) throws InterruptedException &#123; while (num.get() &lt;= n) &#123; int temp = num.get(); // 不是3的倍数且不是5的倍数 if (temp % 3 != 0 &amp;&amp; temp % 5 != 0) &#123; printNumber.accept(temp); num.getAndIncrement(); &#125; &#125; &#125;&#125; ⑤volatile 关键字123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 5.volatile关键字class FizzBuzz &#123; private int n; private volatile int flag = 0; public FizzBuzz(int n) &#123; this.n = n; &#125; public void fizz(Runnable printFizz) throws InterruptedException &#123; for (int i = 3; i &lt;= n; i += 3) &#123; // 是3的倍数且不是5的倍数 if (i % 5 != 0) &#123; while (flag != 1) &#123; Thread.sleep(1);&#125; printFizz.run(); // 将控制权交还给number()方法 flag = 0; &#125; &#125; &#125; public void buzz(Runnable printBuzz) throws InterruptedException &#123; for (int i = 5; i &lt;= n; i += 5) &#123; // 不是3的倍数且是5的倍数 if (i % 3 != 0) &#123; while (flag != 2) &#123; Thread.sleep(1);&#125; printBuzz.run(); // 控制权交还给number()方法 flag = 0; &#125; &#125; &#125; public void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException &#123; for (int i = 15; i &lt;= n; i += 15) &#123; // 是3的倍数且是5的倍数 while (flag != 3) &#123; Thread.sleep(1);&#125; printFizzBuzz.run(); // 控制权交还给number()方法 flag = 0; &#125; &#125; public void number(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 1; i &lt;= n; i++) &#123; while (flag != 0) &#123; Thread.sleep(1);&#125; if (i % 3 == 0 &amp;&amp; i % 5 == 0) &#123; flag = 3; &#125; else if (i % 5 == 0) &#123; flag = 2; &#125; else if (i % 3 == 0) &#123; flag = 1; &#125; // 不是3的倍数且不是5的倍数 else &#123; printNumber.accept(i); flag = 0; &#125; &#125; &#125;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#106;&#121;&#109;&#101;&#x73;&#x73;&#x69;&#64;&#x31;&#x36;&#51;&#x2e;&#99;&#x6f;&#109; 关于 数据结构与算法 的更多代码 请查看我的 GitHub仓库]]></content>
      <categories>
        <category>Java</category>
        <category>LeetCode-多线程题解</category>
      </categories>
      <tags>
        <tag>Java并发编程</tag>
        <tag>LeetCode题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 1116. 打印零与奇偶数（Medium）Java语言题解]]></title>
    <url>%2F2020%2F03%2F01%2FLeetCode-1116-%E6%89%93%E5%8D%B0%E9%9B%B6%E4%B8%8E%E5%A5%87%E5%81%B6%E6%95%B0%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.题目相关①题目及示例 ②相关标签 多线程 ③题目地址 1116. 打印零与奇偶数 — 力扣网 2.解题方法①synchronized 关键字 + this 锁对象 原因：三个线程属于同一个实例，虽然三个线程访问的是一个类的不同的普通同步方法，但是三个普通同步方法默认都是以 this 对象作为同步方法的锁，所以它们会争抢同一把锁（对于同一个实例来讲，三个方法的 this 对象是同一个）。 结果：三个线程争抢同一把锁，同一时刻只能有一个线程执行该线程对应的同步方法，然后再使用 wait 方法和 notify 方法，使得三个线程按题意顺序运行。 ②lock + condition lock 代替 synchronized 关键字 condition 中的 await 方法和 release 方法代替 Object 对象的 wait 方法和 notify 方法 ③信号量 三个线程第一次执行时，因为只有 zero 信号量的计数器初始值为 1，其余都为 0，所以 zero 线程先执行，让它不断判断接下来该哪个线程执行，并释放对应线程的信号量，对应线程执行一次循环后，释放 zero 信号量，以便 zero 线程继续判断。 ④volatile 关键字 直接使用 volatile 关键字控制三个线程的执行顺序 具体实现见代码 3.代码详解①synchronized 关键字 + this 锁对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 1.synchronized关键字+this锁对象(三个不同的线程将会共用一个ZeroEvenOdd实例)class ZeroEvenOdd &#123; private int n; private volatile int flag = 0; public ZeroEvenOdd(int n) &#123; this.n = n; &#125; public void zero(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 1; i &lt;= n; i++) &#123; synchronized(this) &#123; while (flag != 0) &#123; // 自己陷入等待 this.wait(); &#125; printNumber.accept(0); if (i % 2 != 0) &#123; flag = 1; &#125; else &#123; flag = 2; &#125; // 唤醒所有线程 this.notifyAll(); &#125; &#125; &#125; public void even(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 2; i &lt;= n; i += 2) &#123; synchronized(this) &#123; while (flag != 2) &#123; // 自己陷入等待 this.wait(); &#125; printNumber.accept(i); flag = 0; // 唤醒所有线程 this.notifyAll(); &#125; &#125; &#125; public void odd(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 1; i &lt;= n; i += 2) &#123; synchronized(this) &#123; while (flag != 1) &#123; // 自己陷入等待 this.wait(); &#125; printNumber.accept(i); flag = 0; // 唤醒所有线程 this.notifyAll(); &#125; &#125; &#125;&#125; ②lock + condition12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 2.lock+conditionclass ZeroEvenOdd &#123; private int n; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); private volatile int flag = 0; public ZeroEvenOdd(int n) &#123; this.n = n; &#125; public void zero(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 1; i &lt;= n; i++) &#123; lock.lock(); while (flag != 0) &#123; // 自己陷入等待 condition.await(); &#125; printNumber.accept(0); if (i % 2 != 0) &#123; flag = 1; &#125; else &#123; flag = 2; &#125; // 唤醒所有线程 condition.signalAll(); lock.unlock(); &#125; &#125; public void even(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 2; i &lt;= n; i += 2) &#123; lock.lock(); while (flag != 2) &#123; // 自己陷入等待 condition.await(); &#125; printNumber.accept(i); flag = 0; // 唤醒所有线程 condition.signalAll(); lock.unlock(); &#125; &#125; public void odd(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 1; i &lt;= n; i += 2) &#123; lock.lock(); while (flag != 1) &#123; // 自己陷入等待 condition.await(); &#125; printNumber.accept(i); flag = 0; // 唤醒所有线程 condition.signalAll(); lock.unlock(); &#125; &#125;&#125; ③信号量1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 3.信号量(Semaphore)class ZeroEvenOdd &#123; private int n; private Semaphore zero = new Semaphore(1); private Semaphore even = new Semaphore(0); private Semaphore odd = new Semaphore(0); public ZeroEvenOdd(int n) &#123; this.n = n; &#125; public void zero(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 1; i &lt;= n; i++) &#123; // 获取zero信号量的一个许可 zero.acquire(); printNumber.accept(0); if (i % 2 != 0) &#123; // 释放odd信号量的一个许可 odd.release(); &#125; else &#123; // 释放even信号量的一个许可 even.release(); &#125; &#125; &#125; public void even(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 2; i &lt;= n; i += 2) &#123; // 获取even信号量的一个许可 even.acquire(); printNumber.accept(i); // 释放zero信号量的一个许可 zero.release(); &#125; &#125; public void odd(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 1; i &lt;= n; i += 2) &#123; // 获取odd信号量的一个许可 odd.acquire(); printNumber.accept(i); // 释放zero信号量的一个许可 zero.release(); &#125; &#125;&#125; ④volatile 关键字1234567891011121314151617181920212223242526272829303132333435363738394041424344// 4.volatileclass ZeroEvenOdd &#123; private int n; private volatile int flag = 0; public ZeroEvenOdd(int n) &#123; this.n = n; &#125; public void zero(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 1; i &lt;= n; i++) &#123; while (flag != 0) &#123; Thread.sleep(1); &#125; printNumber.accept(0); if (i % 2 != 0) &#123; flag = 1; &#125; else &#123; flag = 2; &#125; &#125; &#125; public void even(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 2; i &lt;= n; i += 2) &#123; while (flag != 2) &#123; Thread.sleep(1); &#125; printNumber.accept(i); flag = 0; &#125; &#125; public void odd(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 1; i &lt;= n; i += 2) &#123; while (flag != 1) &#123; Thread.sleep(1); &#125; printNumber.accept(i); flag = 0; &#125; &#125;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#x79;&#x6d;&#101;&#115;&#115;&#x69;&#64;&#x31;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d; 关于 数据结构与算法 的更多代码 请查看我的 GitHub仓库]]></content>
      <categories>
        <category>Java</category>
        <category>LeetCode-多线程题解</category>
      </categories>
      <tags>
        <tag>Java并发编程</tag>
        <tag>LeetCode题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 1226. 哲学家进餐（Medium）Java语言题解]]></title>
    <url>%2F2020%2F03%2F01%2FLeetCode-1226-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.题目相关①题目及示例 ②相关标签 多线程 ③题目地址 1226. 哲学家进餐 — 力扣网 2.解题方法 哲学家进餐问题有死锁和资源耗尽的风险：每个哲学家同时拿着左边的筷子，永远都在等右边的筷子。 所以本题的重点在于如何避免死锁，我们采用两种常用的解决方法： 改变一个哲学家拿叉子的顺序 餐票策略 ①synchronized 关键字 + 改变一个哲学家拿叉子的顺序 改变一个哲学家拿叉子的顺序：要想发生死锁，必须所有人同时拿起左边的筷子，但是如果这时有一个哲学家先拿右边再拿左边，就不会发生死锁。即避免发生环路，属于避免策略。 使用 synchronized 关键字对拿起的筷子加锁 ②lock + 改变一个哲学家拿叉子的顺序 改变一个哲学家拿叉子的顺序：要想发生死锁，必须所有人同时拿起左边的筷子，但是如果这时有一个哲学家先拿右边再拿左边，就不会发生死锁。即避免发生环路，属于避免策略。 使用 lock 对拿起的筷子加锁 ③synchronized 关键字 + 信号量 + 餐票策略 餐票策略：要求必须拿到餐票才能吃饭，而我们为了避免死锁，总共只发三张餐票，这样可以避免五个人同时准备吃饭的情况，也属于避免策略。 使用 synchronized 关键字对拿起的筷子加锁 使用信号量模拟餐票 ④lock + 信号量 + 餐票策略 餐票策略：要求必须拿到餐票才能吃饭，而我们为了避免死锁，总共只发三张餐票，这样可以避免五个人同时准备吃饭的情况，也属于避免策略。 使用 lock 对拿起的筷子加锁 使用信号量模拟餐票 3.代码详解①synchronized 关键字 + 改变一个哲学家拿叉子的顺序123456789101112131415161718192021222324252627282930// 1.synchronized+改变一个哲学家拿叉子的顺序来避免死锁class DiningPhilosophers &#123; private Object[] locks = new Object[5]; public DiningPhilosophers() &#123; for (int i = 0; i &lt; 5; i++) &#123; locks[i] = new Object(); &#125; &#125; public void wantsToEat(int philosopher, Runnable pickLeftFork, Runnable pickRightFork, Runnable eat, Runnable putLeftFork, Runnable putRightFork) throws InterruptedException &#123; // 改变0号哲学家拿叉子的顺序 int leftForkNumber = philosopher == 0? (philosopher + 1) % 5: philosopher; int rightForkNumber = philosopher == 0? philosopher: (philosopher + 1) % 5; synchronized (locks[leftForkNumber]) &#123; synchronized (locks[rightForkNumber]) &#123; pickLeftFork.run(); pickRightFork.run(); eat.run(); putLeftFork.run(); putRightFork.run(); &#125; &#125; &#125;&#125; ②lock + 改变一个哲学家拿叉子的顺序123456789101112131415161718192021222324252627// 2.lock+改变一个哲学家拿叉子的顺序来避免死锁class DiningPhilosophers &#123; private Lock[] locks = &#123;new ReentrantLock(), new ReentrantLock(), new ReentrantLock(), new ReentrantLock(), new ReentrantLock()&#125;; public DiningPhilosophers() &#123; &#125; public void wantsToEat(int philosopher, Runnable pickLeftFork, Runnable pickRightFork, Runnable eat, Runnable putLeftFork, Runnable putRightFork) throws InterruptedException &#123; // 改变0号哲学家拿叉子的顺序 int leftForkNumber = philosopher == 0? (philosopher + 1) % 5: philosopher; int rightForkNumber = philosopher == 0? philosopher: (philosopher + 1) % 5; locks[leftForkNumber].lock(); locks[rightForkNumber].lock(); pickLeftFork.run(); pickRightFork.run(); eat.run(); putLeftFork.run(); putRightFork.run(); locks[rightForkNumber].unlock(); locks[leftForkNumber].unlock(); &#125;&#125; ③synchronized 关键字 + 信号量 + 餐票策略123456789101112131415161718192021222324252627282930313233// 3.synchronized+信号量+餐票策略来避免死锁class DiningPhilosophers &#123; private Object[] locks = new Object[5]; private Semaphore limit = new Semaphore(3); public DiningPhilosophers() &#123; for (int i = 0; i &lt; 5; i++) &#123; locks[i] = new Object(); &#125; &#125; public void wantsToEat(int philosopher, Runnable pickLeftFork, Runnable pickRightFork, Runnable eat, Runnable putLeftFork, Runnable putRightFork) throws InterruptedException &#123; int leftForkNumber = philosopher; int rightForkNumber = (philosopher + 1) % 5; // 规定最多有三个哲学家同时拿起叉子 limit.acquire(); synchronized (locks[leftForkNumber]) &#123; synchronized (locks[rightForkNumber]) &#123; pickLeftFork.run(); pickRightFork.run(); eat.run(); putLeftFork.run(); putRightFork.run(); &#125; &#125; limit.release(); &#125;&#125; ④lock + 信号量 + 餐票策略123456789101112131415161718192021222324252627282930// 4.lock+信号量+餐票策略来避免死锁class DiningPhilosophers &#123; private Lock[] locks = &#123;new ReentrantLock(), new ReentrantLock(), new ReentrantLock(), new ReentrantLock(), new ReentrantLock()&#125;; private Semaphore limit = new Semaphore(3); public DiningPhilosophers() &#123; &#125; public void wantsToEat(int philosopher, Runnable pickLeftFork, Runnable pickRightFork, Runnable eat, Runnable putLeftFork, Runnable putRightFork) throws InterruptedException &#123; int leftForkNumber = philosopher; int rightForkNumber = (philosopher + 1) % 5; // 规定最多有三个哲学家同时拿起叉子 limit.acquire(); locks[leftForkNumber].lock(); locks[rightForkNumber].lock(); pickLeftFork.run(); pickRightFork.run(); eat.run(); putLeftFork.run(); putRightFork.run(); locks[rightForkNumber].unlock(); locks[leftForkNumber].unlock(); limit.release(); &#125;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#x6a;&#121;&#x6d;&#101;&#115;&#x73;&#x69;&#x40;&#49;&#x36;&#51;&#46;&#x63;&#111;&#x6d; 关于 数据结构与算法 的更多代码 请查看我的 GitHub仓库]]></content>
      <categories>
        <category>Java</category>
        <category>LeetCode-多线程题解</category>
      </categories>
      <tags>
        <tag>Java并发编程</tag>
        <tag>LeetCode题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 1114. 按序打印（Easy）Java语言题解]]></title>
    <url>%2F2020%2F03%2F01%2FLeetCode-1114-%E6%8C%89%E5%BA%8F%E6%89%93%E5%8D%B0%EF%BC%88Easy%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.题目相关①题目及示例 ②相关标签 多线程 ③题目地址 1114. 按序打印 — 力扣网 2.解题方法①原子变量 使用一个原子变量控制，把并发调用变成按顺序调用。 ②volatile 关键字 使用 volatile 关键字保证变量的可见性，把并发调用变成按顺序调用。 ③信号量 三个线程第一次执行时，因为 flag1 信号量和 flag2 信号量的计数器初始值都为 0，所以需要等 first 线程中释放了 flag1 信号量，second 线程才能开始执行，需要等 second 线程中释放了 flag2 信号量，third 线程才能开始执行。 ④CountDownLatch 两个 CountDownLatch 实例可以控制三个线程执行的先后顺序 具体实现见代码 ⑤CyclicBarrier 两个 CyclicBarrier 实例可以控制三个线程执行的先后顺序 具体实现见代码 3.代码详解①原子变量123456789101112131415161718192021222324252627// 1.使用一个原子变量控制，把并发调用变成按顺序调用。class Foo &#123; private AtomicInteger n = new AtomicInteger(0); public Foo() &#123; &#125; public void first(Runnable printFirst) throws InterruptedException &#123; printFirst.run(); n.incrementAndGet(); &#125; public void second(Runnable printSecond) throws InterruptedException &#123; // 等待第一个线程执行完毕 while (n.get() != 1) &#123; &#125; printSecond.run(); n.incrementAndGet(); &#125; public void third(Runnable printThird) throws InterruptedException &#123; // 等待第二个线程执行完毕 while (n.get() != 2) &#123; &#125; printThird.run(); &#125;&#125; ②volatile 关键字12345678910111213141516171819202122232425// 2.volatile关键字class Foo &#123; private volatile int flag = 0; public Foo() &#123; &#125; public void first(Runnable printFirst) throws InterruptedException &#123; printFirst.run(); flag = 1; &#125; public void second(Runnable printSecond) throws InterruptedException &#123; // 等待第一个线程执行完毕 while (flag != 1) &#123;&#125; printSecond.run(); flag = 2; &#125; public void third(Runnable printThird) throws InterruptedException &#123; // 等待第二个线程执行完毕 while (flag != 2) &#123;&#125; printThird.run(); &#125;&#125; ③信号量12345678910111213141516171819202122232425262728// 3.信号量(Semaphore)class Foo &#123; private Semaphore flag1 = new Semaphore(0); private Semaphore flag2 = new Semaphore(0); public Foo() &#123; &#125; public void first(Runnable printFirst) throws InterruptedException &#123; printFirst.run(); // 释放flag1信号量的一个许可 flag1.release(); &#125; public void second(Runnable printSecond) throws InterruptedException &#123; // 获取flag1信号量的一个许可 flag1.acquire(); printSecond.run(); // 释放flag2信号量的一个许可 flag2.release(); &#125; public void third(Runnable printThird) throws InterruptedException &#123; // 获取flag2信号量的一个许可 flag2.acquire(); printThird.run(); &#125;&#125; ④CountDownLatch12345678910111213141516171819202122232425262728// 4.CountDownLatchclass Foo &#123; private CountDownLatch latch1 = new CountDownLatch(1); private CountDownLatch latch2 = new CountDownLatch(1); public Foo() &#123; &#125; public void first(Runnable printFirst) throws InterruptedException &#123; printFirst.run(); // 触发second线程执行 latch1.countDown(); &#125; public void second(Runnable printSecond) throws InterruptedException &#123; // 等待被触发 latch1.await(); printSecond.run(); // 触发third线程执行 latch2.countDown(); &#125; public void third(Runnable printThird) throws InterruptedException &#123; // 等待被触发 latch2.await(); printThird.run(); &#125;&#125; ⑤CyclicBarrier1234567891011121314151617181920212223242526272829303132// 5.CyclicBarrierclass Foo &#123; private CyclicBarrier barrier1 = new CyclicBarrier(2); private CyclicBarrier barrier2 = new CyclicBarrier(2); public Foo() &#123; &#125; public void first(Runnable printFirst) throws InterruptedException &#123; try &#123; printFirst.run(); barrier1.await(); &#125; catch (BrokenBarrierException e) &#123;&#125; &#125; public void second(Runnable printSecond) throws InterruptedException &#123; try &#123; // 等待fisrt线程执行完printFirst.run(); barrier1.await(); printSecond.run(); barrier2.await(); &#125; catch (BrokenBarrierException e) &#123;&#125; &#125; public void third(Runnable printThird) throws InterruptedException &#123; try &#123; // 等待second线程执行完printSecond.run(); barrier2.await(); printThird.run(); &#125; catch (BrokenBarrierException e) &#123;&#125; &#125;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#121;&#x6d;&#101;&#x73;&#115;&#105;&#64;&#x31;&#54;&#51;&#x2e;&#99;&#111;&#109; 关于 数据结构与算法 的更多代码 请查看我的 GitHub仓库]]></content>
      <categories>
        <category>Java</category>
        <category>LeetCode-多线程题解</category>
      </categories>
      <tags>
        <tag>Java并发编程</tag>
        <tag>LeetCode题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程之基础概念]]></title>
    <url>%2F2020%2F02%2F25%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[1.进程和线程①与操作系统的关系 一个操作系统可以拥有多个进程（process） 一个进程可以拥有多个线程（thread） 即操作系统是包含多个进程的容器，而每个进程又都是容纳多个线程的容器。 ②进程定义 Oracle 的官方定义： 进程：使用 fork 系统调用创建的 UNIX 环境（包括文件描述符、用户 ID 、CPU 使用时间、存储器、IO 设备、内存等），它被设置为运行程序。 线程：在进程上下文中执行的一系列指令 通俗理解进程： 进程指的是程序的一次执行。在用户下达运行程序的命令后，就会产生进程。没有运行的程序占用的空间大部分是磁盘空间，将程序运行起来时就变成了一个进程。 比喻：进程是对代码的实例化 在任务管理器中可以查看正在运行的进程： 总结进程：进程是程序的真正运行实例，是资源分配的基本单位。内存、CPU 等资源都是以进程为单位进行分配的。 ③线程定义123456789101112131415161718192021222324/** * @author: wjy * @date: 2020/2/18 * @description: 创建100个线程，用任务管理器可以看到Java线程数量的变化。 */public class Create100Threads &#123; public static void main(String[] args) &#123; // 新建100个线程 for (int i = 0; i &lt; 100; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; // 睡眠10s try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; &#125;&#125; 程序运行前： 程序运行过程： 程序运行结束： 通俗理解线程： 线程是 CPU 的基本调度单位，每个线程执行的都是进程代码的某个片段。 进程是线程的容器，让线程利用进程中的资源执行代码。进程的线程数量若是大于 1，则是多线程的情况，多个线程帮助同一进程执行代码。 ④两者的异同 起源不同 回顾操作系统的历史，先有进程后有线程。 由于处理器的速度往往比外设（键盘、硬盘等）快，所以为了提高 CPU 的利用率，才诞生了线程，目的是提高程序的执行效率。 概念不同 进程是具有独立功能的程序运行起来的一个活动，是一个实例，也是系统分配资源和调度的独立单位。 线程是 CPU 的基本调度单位 内存共享方式不同 对于进程而言，每个进程都会被操作系统分配到一定的内存，不同进程之间的内存通常是不共享的。例如：浏览器无法访问正在播放的 qq 音乐，它们之间想要通讯的话，需要使用进程间通讯 RPC。 线程与线程之间服务于同一个进程，需要合作，所以两个线程之间通讯很容易，可以共享由操作系统分配给其父进程的相同内存块。 拥有的资源不用 线程本身是进程的一部分，拥有的资源一定少于进程。 不同的线程之间共享的内容：①进程代码段（重点）、②进程的公有数据（利用这些共享的数据，线程很容易实现互相通讯）、③进程打开的文件描述符、④信号的处理器、⑤进程的当前目录、⑥进程用户 ID 与进程组 ID 不同的线程之间独有的内容：①线程 ID、②寄存器组的值、③线程的堆栈（重点）、④错误返回码、⑤线程的信号屏蔽码 进程和线程的数量不同 进程只有一个，线程可以有多个。 一个进程至少拥有一个线程，否则没有办法执行。 开销不同 因为进程和线程本身不是一个数量级的东西，所以线程始终比进程更轻量级。 线程的创建、终止时间比进程短。 同一进程内的线程切换时间比进程切换时间短 同一进程的各个线程间共享内存和文件资源，可以不通过内核进行通信。而进程间想要通信，需要借助内核帮忙。 相同点：从生命周期 / 状态上来看，进程和线程从创建到结束都有就绪、等待、运行等状态。 ⑤Java 语言和多线程的关系 Java 语言的显著优势：在设计之初就支持多线程（当时大部分编程语言不支持多线程）。 Java 语言可以将我们创建的线程一对一映射到操作系统的内核线程中。而有些语言的线程是虚拟线程，不会在操作系统中对应的建立线程。 JVM 自动启动线程：即使在代码中不显式的创建线程，在运行 main 函数时，JVM 也会自动地启动其他线程，这些线程都有特定的含义。 123456789101112/** * @author: wjy * @date: 2020/2/18 * @description: 即使在代码中不显式的创建线程，在运行main函数时，JVM也会自动地启动其他线程。 * 并且这些线程都有特定的含义和作用。 */public class JavaAndThreads &#123; public static void main(String[] args) &#123; System.out.println("Hello Threads!"); &#125;&#125; Signal Dispatcher：把操作系统发来的信号分发给适当的处理程序，用于连接操作系统和应用程序。 Finalizer：负责对象的 finalize() 方法。在每个对象结束的时候，可能会实现 finalize() 方法，主要是为了处理该方法。但是随着 Java 语言的发展，不再推荐使用该方法。 Reference Handler：和 GC、引用相关的线程。将每一个对象的引用记录在案，以便配合 GC 进行垃圾回收。 main：主线程，用户程序的主入口，编写的代码从这里开始执行。 以上线程都是 JVM 自动创建的，由此可以看出 Java 语言和多线程息息相关。 2.多线程①定义 多线程：在单个进程中运行多个线程 多线程程序：如果一个程序允许运行两个或两个以上的线程，那么它就是多线程程序。 现在绝大部分的程序都是多线程程序。例如：在浏览器中可以同时打开几个网页、同时下载几个文件，以及服务端可以同时处理多个请求。 每个线程拥有自己的独立资源（ID、堆栈等），进程的内存空间对每个线程敞开，每个线程都可以到进程的内存空间中获取想要的资源并且互相通信。 相互独立的任务：没必要使用多线程 数据和资源共享的任务：需要使用多线程，并且要考虑线程的同步，确保线程的安全。 ②多线程实例 多线程实例：抢火车票 最开始在火车站买火车票，是全国统一进行放票。假设全国使用同一个服务器（类比为一个进程）进行放票，而多个售票窗口就可以类比为多个线程。不同的线程之间互相配合或竞争。 不断迭代后： 增加放票时间段（分散压力），不同的车次有自己的放票时间。 增加候补功能 增加买票限制 以上都是为了减少服务器的并发压力 ③为什么需要多线程？ 提高 CPU 的利用率（最主要的目的） 目前大部分 CPU 都是两核或者两核以上，如果不发挥多线程的优势，始终使用单线程，就会浪费计算资源。多线程程序可以充分发挥多核 CPU 的优势，提高计算机的运行效率。 ①提高了处理速度（CPU 的运行效率远远超过内存、磁盘、外设等） ②避免了无效等待（在读取磁盘 IO 的时候，CPU 没有必要等待，而应该去做其他的事情。） ③提高了用户体验：避免卡顿、缩短等待时间（并行处理，提高性能，例如 Tomcat 服务器用多个线程去接收 HTTP 请求，可以同时服务于多个用户。） 便于编程建模（简化任务） 将大任务拆解为 A、B、C、D 并建立模型，类似的任务都可以使用模型处理。然后用多线程分别执行这 4 个任务，就简单很多。因为每个子任务的目的明确、功能单一。 计算机性能定律：摩尔定律失效，阿姆达尔定律登上舞台。 摩尔定律：当价格不变时，集成电路上可容纳的晶体管数目约每隔 18 个月便会增加一倍，意味着 CPU 的性能可以提高一倍。这个定律告诉我们长期以来 CPU 的性能都是以指数型快速增长的。但是，近年来陷入了瓶颈。 阿姆达尔定律：处理器（CPU）越多，程序的执行速度就越快。但是执行速度也有上限，取决于程序中串行部分的比例，并行的比例越高，多处理器的效果越明显。对于串行任务，无论有多少 CPU 资源，都没有办法提高速度。 并行比例与提升速度的关系： 在未来，CPU 的性能的提升速度放缓了，这就要求我们把程序中更多可并行的部分并行化，以提高程序的性能。 ④什么场景中会用到多线程？ 执行耗时任务（IO、磁盘读写、网络通信等）新开线程，不但不会影响主程序的运行，也不会因为耗时任务执行时间过慢而影响其他任务的运行。 为了同时做多件不同的事：①使用浏览器的同时听音乐、②后台定时任务等 提高工作效率、处理能力 ①Tomcat 可以同时并行处理多个线程进来的请求 ②下载文件时可以选择线程数，多线程并行下载（每个线程都去和服务器通信，都去做独立的下载任务，并且把下载的任务进行分割，最后再把下载到的文件拼接起来），以提高下载效率。 ③NIO：将 IO 操作升级为多线程操作，提高了 IO 的处理能力。 需要同时有很大并发量的时候（比如进行服务器承受压力的能力的测试时，需要多线程并行请求） ⑤多线程的局限 性能问题：上下文切换带来的消耗 线程之间切换时会有上下文切换，会保存一些 CPU 所需要的数据，如当前运行到哪一行代码等。 异构化任务很难高效并行 每个任务之间的结构都不一样，很难总结为多个任务的拆解。 带来线程安全问题：包括数据安全问题（例如 i++ 总数不一致）以及线程带来的活跃性问题（线程饥饿、死锁等） 线程饥饿：某个线程想要执行任务，但是被其他线程强先，这个线程始终没有事干。 死锁：两个线程相互拥有对方所需要的资源但都不肯放手，于是陷入无穷等待。 3.串行、并行、并发①串行、并行、并发 串行：大家排队一个个来 左图：线程 A -&gt; B -&gt; C 依次执行 右图：将数据一位一位发送 并行：大家一起来 左图：线程 A / B / C 同时执行 右图：将 8 个数据一次性发送出去 并发（Concurrency）：单核就能实现并发、属于逻辑上的同时运行（由于处理器的处理速度很快，所以线程之间的切换肉眼是感知不到的，感觉它是在同时执行多个程序，实际某一时间只有一个程序执行（单处理器））。 在物理层面并发就是串行，只不过是在多个程序上快速的来回切换而不是一个个依次执行，所以在用户看来相当于三个程序同时执行。 并行（Parallelism）：多核处理器，物理上的同时运行，多个处理器都在同时执行任务。 并行是真正的 “同时” 运行：在同一时刻，有多个任务同时执行。 单核处理器是无法实现并行的，因为单核处理器无法在同一时刻执行多个任务。 并发可以对应到两个不同的概念 ①形容多个任务的执行状态： 两个或多个任务可以在重叠的时间段（不是指真正重叠的同一时刻，而是一段时间内交替运行）内启动，运行和完成。 并行（两个线程同时执行）一定是并发，两者是包含关系。 并发 + 多核 + 同一时刻执行同一段代码 = 并行 并发：不同的线程交替给一个 CPU 执行（蓝色竖线：CPU 的时间片） 并行：多个线程同时被多个 CPU 执行 ②对 “并发性” 的简称： 如果一个程序具有并发性，指的是程序不同的部分可以无序或同时执行，且不影响最终的执行结果。 在不同核心数的计算机上的表现不同： 在多核 CPU 上，可以并行执行并发性程序。 在单核 CPU 上，可以并发执行并发性程序，串行执行非并发性程序。 此时，并行和并发的概念并不在同一维度上。并发指的是并发性，并行指的是多个程序在同一时刻同时执行。一个程序如果想要并发 / 并行执行，前提条件是它具有并发性。并发性是并发执行和并行执行的前提条件和必要条件。如果一个程序可以并行执行，就代表它一定具有并发性。 ②是什么让并发和并行成为可能？ CPU 升级 CPU 之前一直遵循摩尔定律，性能提升的很快，它的处理速度远远比其他部件快。但是每个 CPU 同一时刻只能执行一个指令，出于这个原因，操作系统开发出了新的技术，可以让用户同时运行多个进程或者多个线程。 操作系统的升级 升级之后将 CPU 完美的调度了起来，即便是单核 CPU，也能让不同的进程使用时间片的方式（抢占式的方式）不停地切换。 抢占式多任务处理：现代 CPU 最主要的一种处理方式，即操作系统有权利中断正在执行的任务。 诞生多核处理器后，操作系统可以自动检测 CPU 核心的数量，为每个核心分配不同的任务，以实现真正地同一时刻运行多个程序。 编程语言的升级 Java 语言诞生之前，很多编程语言不支持多线程。随着 Java 的诞生，多线程编程开始逐渐火热并且发展成熟。 4.高并发①定义 高并发：同时有很多个请求发送给服务器系统，服务器会并行处理。 高并发场景：天猫双十一、春晚微信摇一摇、12306 卖火车票 一般将系统的承受能力设计为目前系统访问量的十倍比较合适 ②高并发和多线程的异同？ 高并发：指大量的请求同时到达服务器所带来的结果（结果指服务器需要同时处理很多请求），它是一种状态。系统需要应对高并发这种状态所带来的后果，如果处理不当，会导致请求的响应速度慢、无响应甚至服务器死机。 多线程并不意味着高并发，多线程编程是一种编程方式，是一种解决方案，不仅可以解决高并发所带来的线程安全问题 / 性能问题，还可以提高硬件的利用率，以便获取到更多的资源，从而解决高并发带来的服务器死机、响应慢等问题。 多线程编程是我们应对高并发场景的一种重要的解决方案。 高并发并不一定要通过多线程的方式解决 例如：解决数据库的高并发问题可以利用 Redis 缓存层（可能带来缓存不一致的问题，但不会带来线程安全问题） 总结：高并发并不意味着多线程（例如：Redis 底层是用单线程处理的）。高并发是一种状态，作为服务器开发者，最好用多线程的方式解决，这样可以提高 CPU 等资源的利用率，加快用户的响应速度。但是在场景不同，资源不同的情况下，也可以选择其他的解决方案。 ③高并发有哪些指标？ QPS（Queries Per Second）：每秒钟的查询（请求）数 PV（Page View）：24 小时内的页面点击量（综合浏览量） UV（Unique Visitor）：24 小时内访问的用户数量（根据 Cookie）、UV &lt;= PV 并发连接数：某个时刻服务器所接受的请求的数目。 对于同一个用户而言，可以同时产生很多个会话 / 连接，所以数目 &gt; 同时在线的用户数量。 对服务器来说，这个连接有一个上限 服务器平均请求等待时间：服务器处理一个请求所花费的时间 5.同步与异步、阻塞与非阻塞①同步与异步 同步与异步：被调用方是否主动告诉调用方结果。 同步与异步是被调用方（即服务端）的行为，而不是调用方的行为。 同步：在没有得到结果之前，服务端不返回任何结果。 异步：调用在发出之后，服务端会立刻返回，告诉调用方 “我收到你的请求了，我会马上处理的”，等服务器处理完成以后，会再次告诉调用方 “我已经处理完了”。 ②阻塞与非阻塞 站在线程状态的角度：阻塞指当前线程不能继续执行，需要等待一段时间或者被唤醒。 站在线程发出请求的角度：我是调用方，我调用一个东西后，在返回结果前是否还能做其他事情。 阻塞与非阻塞是调用方的行为，而不是被调用方的行为。 阻塞：调用一个东西后，返回结果前什么也不做。 非阻塞：调用一个东西后，返回结果前做其他事情。 ③同步阻塞、同步非阻塞、异步阻塞、异步非阻塞 同步不一定是阻塞，阻塞也不一定是同步。 异步不一定是非阻塞，非阻塞也不一定是异步。 同步阻塞：（被调用方）执行完成后才返回结果、（调用方）在返回结果前什么也不做。 同步非阻塞：（被调用方）执行完成后才返回结果、（调用方）在返回结果前做其他事情，不时地检查一下被调用方是否返回结果。 异步阻塞：调用方在发出请求之后，被调用方会立刻告诉调用方已经收到请求，当被调用方处理完成以后，会再次告诉调用方已经处理完了、但是（调用方）在返回结果前什么也不做。 异步非阻塞：调用方在发出请求之后，被调用方会立刻告诉调用方已经收到请求，当被调用方处理完成以后，会再次告诉调用方已经处理完了、（调用方）在返回结果前做其他事情，等待被调用方主动返回结果。 6.常见面试问题①进程和线程的异同？ 不同：起源、概念、内存共享方式、拥有的资源、数量、开销 相同：生命周期（状态） 具体见 1.进程和线程——④两者的异同 ②并行和并发的异同？ 都在形容一个程序的运行状态时：并行一定是并发。 并发也可以形容一个程序的属性，即程序是否具有并发性。若是程序没有并发性，表示程序只能串行执行。 ③多线程就是高并发吗？有什么反例？ 高并发指服务器同时接受很多请求，受到极大压力。 多线程是针对高并发的一个解决方案，可以使用多线程将这个压力迅速化解。 反例：Redis 本身是单线程的，但是同样可以支持高并发的场景。 应对高并发时，不仅可以通过多线程的方式解决，也可以从整体架构、缓存层的设计、MQ 队列等地方着手解决。 ④多线程可以提高程序的执行效率，你知不知道有哪些弊端？ 性能问题（上下文切换、保存 CPU cache） 异构化任务或不能并行执行的任务用多线程反而不如用单线程合适 线程安全问题 ⑤什么是同步？什么是异步？什么是阻塞？什么是非阻塞？ 同步、异步指的是被调用方在调用结束后是否主动返回结果 阻塞、非阻塞指的是调用方在调用后是否可以去做其他事情 具体见 5.同步与异步、阻塞与非阻塞 ⑥在单核 CPU 上运行多线程程序有意义吗？ 有意义，虽然在单核 CPU 上执行真正的并行是不可能的，因为只有一个处理器，但是对于应用程序而言，我们不知道它未来会运行在单核 CPU 还是多核 CPU 上，所以在编写时肯定以多核 CPU 为准。其次，对于多线程程序，当其中一个线程执行缓慢或者被阻塞时，其他线程可以利用这些时间（如读取磁盘的时间）做其他事情，让程序保持高效运转。 如果 CPU 被挤满，并不是说在单核 CPU 上运行多线程程序没有意义，而是说线程的数量设置不合理，应该减少线程的数量。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#121;&#109;&#101;&#x73;&#115;&#105;&#x40;&#49;&#54;&#x33;&#x2e;&#x63;&#111;&#109;]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Synchronized关键字]]></title>
    <url>%2F2020%2F02%2F20%2FSynchronized%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[1.简介①作用 Oracle 的官方解释：synchronized 关键字的同步方法支持一种简单的策略来防止线程干扰和内存一致性错误。 如果一个对象对多个线程可见，则对该对象变量的所有读取或写入都是通过同步方法完成的。 一句话总结 synchronized 的作用：能够保证在同一时刻最多只有一个线程执行该段代码，以达到保证并发安全的效果。 被 synchronized 关键字修饰的代码会以原子的方式执行，即多个线程不会同时执行这段代码，同一时刻最多只有一个线程执行该段代码。 如何控制同一时刻只有一个线程执行该段代码？有一把锁，当第一个线程执行这段代码时拿到这把锁，直到方法执行结束或一定条件后才会释放这把锁。在这把锁释放前，其他线程想要执行这段代码，只能等待或者阻塞。直到锁释放后，其他线程才能执行这段代码。 ②地位 synchronized 是 Java 的关键字，被 Java 语言原生支持。 volatile 也是 Java 的关键字（它们都是 Java 并发编程中的重要关键字） 它是最基本的互斥同步手段 互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。 同步：指程序用于控制不同线程之间操作发生相对顺序的机制。 它是并发编程中的元老级角色，是并发编程的必学内容。 ③不使用并发（同步方法）的后果 代码实战：两个线程同时执行 a++，最后结果会被预计的少。 12345678910111213141516171819202122232425262728293031/** * @author: wjy * @date: 2020/2/19 * @description: 不使用并发手段，建立两个线程一起执行a++。 */public class NoUseConcurrency implements Runnable &#123; // 创建类的实例 static NoUseConcurrency instance = new NoUseConcurrency(); // 初始化a的值 static int a = 0; public static void main(String[] args) throws InterruptedException &#123; // 建立两个线程，利用同一个实例，共用实例中的方法。 Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); // 启动两个线程 t1.start(); t2.start(); // 让主线程等待两个子线程都执行完成 t1.join(); t2.join(); System.out.println(a); &#125; @Override public void run() &#123; for (int i = 0; i &lt; 100000; i++) &#123; a++; &#125; &#125;&#125; 连续运行三次程序，打印的结果各不相同。 原因：a++ 看上去只是一个操作，实际上包含了三个步骤： ①读取 a ②将 a 的值加 1 ③将 a 的值写入到内存中 而在多线程的情况下任何一步执行完成后都有可能被打断，都有可能轮到另一个线程去执行，即线程不安全。 ④使用并发（同步方法）12345678910111213141516171819202122232425262728293031/** * @author: wjy * @date: 2020/2/20 * @description: 使用并发手段，建立两个线程一起执行a++。 */public class UseConcurrency implements Runnable &#123; static UseConcurrency instance = new UseConcurrency(); static int a = 0; public static void main(String[] args) throws InterruptedException &#123; // 建立两个线程，利用同一个实例，共用实例中的方法。 Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); // 启动两个线程 t1.start(); t2.start(); // 让主线程等待两个子线程都执行完成 t1.join(); t2.join(); System.out.println(a); &#125; // 对象锁-方法锁 // 将关键字加在普通方法上 @Override public synchronized void run() &#123; for (int i = 0; i &lt; 100000; i++) &#123; a++; &#125; &#125;&#125; 重复运行多次程序，打印结果都是 a = 200000。 2.用法 synchronized 关键字也叫做同步修饰符音标：[ˈsɪŋkrənaɪzd] ①对象锁 对象锁的两种形式： 同步代码块锁 手动指定锁对象（this 或自定义对象） 方法锁 synchronized 修饰普通方法（不能修饰静态方法），锁对象默认为 this。 12345678910111213141516171819202122232425262728293031323334353637/** * @author: wjy * @date: 2020/2/19 * @description: 对象锁实例1之同步代码块形式 */public class SynchronizedObjectLock1 implements Runnable &#123; static SynchronizedObjectLock1 instance = new SynchronizedObjectLock1(); @Override public void run() &#123; // 默认用this(当前对象)作为锁对象 // 保护以下代码块串行执行 synchronized (this) &#123; System.out.println(Thread.currentThread().getName() + "开始执行"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "执行结束"); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; // 建立两个线程，利用同一个实例，共用实例中的方法。 Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); // 启动两个线程 t1.start(); t2.start(); // 让主线程等待两个子线程都执行完成 while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("finished"); &#125;&#125; 以上代码线程 0 先执行，执行完成后线程 1 再执行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @author: wjy * @date: 2020/2/19 * @description: 对象锁实例1之同步代码块形式 */public class SynchronizedObjectLock1 implements Runnable &#123; static SynchronizedObjectLock1 instance = new SynchronizedObjectLock1(); // 创建自定义锁对象，lock1和lock2保护的时机不相同。 Object lock1 = new Object(); Object lock2 = new Object(); @Override public void run() &#123; // 自定义锁对象 synchronized (lock1) &#123; System.out.println(Thread.currentThread().getName() + "开始执行(lock1)"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "执行结束(lock1)"); &#125; synchronized (lock2) &#123; System.out.println(Thread.currentThread().getName() + "开始执行(lock2)"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "执行结束(lock2)"); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; // 建立两个线程，利用同一个实例，共用实例中的方法。 Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); // 启动两个线程 t1.start(); t2.start(); // 让主线程等待两个子线程都执行完成 while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("finished"); &#125;&#125; 以上代码线程 0 拿到第 2 把锁的同时，线程 1 拿到第 1 把锁，并行执行（第一把锁和第二把锁不相同，互不影响）。 1234567891011121314151617181920212223242526272829303132333435363738/** * @author: wjy * @date: 2020/2/19 * @description: 对象锁示例2之方法锁形式 */public class SynchronizedObjectLock2 implements Runnable &#123; static SynchronizedObjectLock2 instance = new SynchronizedObjectLock2(); @Override public void run() &#123; method(); &#125; // 对普通方法加上synchronized修饰符，保护以下代码块串行执行。 public synchronized void method() &#123; System.out.println(Thread.currentThread().getName() + "对象锁的方法修饰符形式"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "执行结束"); &#125; public static void main(String[] args) throws InterruptedException &#123; // 建立两个线程，利用同一个实例，共用实例中的方法。 Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); // 启动两个线程 t1.start(); t2.start(); // 让主线程等待两个子线程都执行完成 while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("finished"); &#125;&#125; 以上代码线程 0 先执行，执行完成后线程 1 再执行。 ②类锁 Java 类可能有很多个对象，但是只有 1 个 Class 对象。 本质：所谓的类锁，就是 Class 对象的锁。 效果：类锁在同一时刻只能被一个对象拥有 类锁的两种形式： 静态锁 synchronized 加在 static 方法上 Class 对象 synchronized 代码块（锁对象默认为 Class 对象） 指定锁为 Class 对象 12345678910111213141516171819202122232425262728293031323334353637383940/** * @author: wjy * @date: 2020/2/19 * @description: 类锁示例1之静态锁 */public class SynchronizedClassLock1 implements Runnable &#123; static SynchronizedClassLock1 instance1 = new SynchronizedClassLock1(); static SynchronizedClassLock1 instance2 = new SynchronizedClassLock1(); @Override public void run() &#123; method(); &#125; // synchronized修饰符修饰静态方法 // 在全局情况下保护以下代码块串行执行(不是对象的层面) public static synchronized void method() &#123; System.out.println(Thread.currentThread().getName() + "开始运行"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "结束运行"); &#125; public static void main(String[] args) throws InterruptedException &#123; // 建立两个线程，两个线程分别引用同一个类的不同实例。 Thread t1 = new Thread(instance1); Thread t2 = new Thread(instance2); // 启动两个线程 t1.start(); t2.start(); // 让主线程等待两个子线程都执行完成 while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("finished"); &#125;&#125; 以上代码线程 0 先执行，执行完成后线程 1 再执行。 若是将 method() 方法变为非静态方法，此时就算加了 synchronized 关键字，线程 0 和线程 1 也会同时执行。 123456789101112131415161718192021222324252627282930313233343536373839/** * @author: wjy * @date: 2020/2/19 * @description: 类锁示例1之静态锁 */public class SynchronizedClassLock1 implements Runnable &#123; static SynchronizedClassLock1 instance1 = new SynchronizedClassLock1(); static SynchronizedClassLock1 instance2 = new SynchronizedClassLock1(); @Override public void run() &#123; method(); &#125; // synchronized修饰符修饰非静态方法 public synchronized void method() &#123; System.out.println(Thread.currentThread().getName() + "开始运行"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "结束运行"); &#125; public static void main(String[] args) throws InterruptedException &#123; // 建立两个线程，两个线程分别引用同一个类的不同实例 Thread t1 = new Thread(instance1); Thread t2 = new Thread(instance2); // 启动两个线程 t1.start(); t2.start(); // 让主线程等待两个子线程都执行完成 while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("finished"); &#125;&#125; 因为静态方法属于整个类，当多个线程（类的不同实例）访问这个类的静态方法时，实际访问的是同一个方法。所以给这个静态方法上锁之后，同一时刻只能由一个线程执行该方法。 而非静态方法属于调用它的实例对象，当两个线程分别调用其实例对象的非静态方法时，相当于各自执行自己的方法，这时加或不加锁都不影响各自方法的执行。 所以类锁适用于在全局情况下同步方法，而不仅仅在对象层面。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @author: wjy * @date: 2020/2/19 * @description: 类锁示例2之Class对象 */public class SynchronizedClassLock2 implements Runnable &#123; static SynchronizedClassLock2 instance1 = new SynchronizedClassLock2(); static SynchronizedClassLock2 instance2 = new SynchronizedClassLock2(); @Override public void run() &#123; method(); &#125; private void method() &#123; // 锁对象是SynchronizedClassLock2.class // 无论是类的哪个实例用的都是同一个锁对象(串行执行) synchronized (SynchronizedClassLock2.class) &#123; System.out.println(Thread.currentThread().getName() + "开始运行"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "结束运行"); &#125; &#125; public static void main(String[] args) &#123; // 建立两个线程，两个线程分别引用同一个类的不同实例 Thread t1 = new Thread(instance1); Thread t2 = new Thread(instance2); // 启动两个线程 t1.start(); t2.start(); // 让主线程等待两个子线程都执行完成 while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("finished"); &#125;&#125; 以上代码线程 0 先执行，执行完成后线程 1 再执行。 若是将 synchronized 代码块中的 SynchronizedClassLock2.class 改为 this，此时就算是加了 synchronized 关键字，线程 0 和线程 1 也会同时执行。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @author: wjy * @date: 2020/2/19 * @description: 类锁示例2之Class对象 */public class SynchronizedClassLock2 implements Runnable &#123; static SynchronizedClassLock2 instance1 = new SynchronizedClassLock2(); static SynchronizedClassLock2 instance2 = new SynchronizedClassLock2(); @Override public void run() &#123; method(); &#125; private void method() &#123; // 锁对象是this // 不同实例的锁对象不同，多个线程并行执行。 synchronized (this) &#123; System.out.println(Thread.currentThread().getName() + "开始运行"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "结束运行"); &#125; &#125; public static void main(String[] args) &#123; // 建立两个线程，两个线程分别引用同一个类的不同实例 Thread t1 = new Thread(instance1); Thread t2 = new Thread(instance2); // 启动两个线程 t1.start(); t2.start(); // 让主线程等待两个子线程都执行完成 while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("finished"); &#125;&#125; 原因：不同实例的锁对象不同，多个线程并行执行。 3.多线程访问同步方法的 7 种情况（面试常考） 同步方法：被 synchronized 关键字所修饰的方法非同步方法：没有被 synchronized 关键字所修饰的方法普通方法：指非静态方法 ①两个线程同时访问一个对象的同步方法 原因：两个线程属于同一个实例，所以两个线程访问的是同一个方法，而这个方法被 synchronized 关键字修饰后默认以 this 对象作为同步方法的锁，所以它们会争抢同一把锁。 结果：两个线程争抢同一把锁，同一时刻只能有一个线程执行该同步方法。 12345678910111213141516171819202122232425262728293031323334/** * @author: wjy * @date: 2020/2/20 * @description: 两个线程同时访问一个对象的同步方法 */public class Situation1 implements Runnable &#123; static Situation1 instance = new Situation1(); @Override public void run() &#123; method(); &#125; private synchronized void method() &#123; System.out.println(Thread.currentThread().getName() + "开始运行"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "结束运行"); &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); t1.start(); t2.start(); while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("Situation1.class finished"); &#125;&#125; ②两个线程访问的是两个对象的同步方法 原因：两个线程属于不同的实例，所以两个线程访问的是不同的方法，而每个方法被 synchronized 关键字修饰后默认以 this 对象作为同步方法的锁，所以它们的锁对象不是同一个。 结果：两个线程的锁对象不是同一个，并行执行，互不干扰。 1234567891011121314151617181920212223242526272829303132333435/** * @author: wjy * @date: 2020/2/20 * @description: 两个线程访问的是两个对象的同步方法 */public class Situation2 implements Runnable &#123; static Situation2 instance1 = new Situation2(); static Situation2 instance2 = new Situation2(); @Override public void run() &#123; method(); &#125; private synchronized void method() &#123; System.out.println(Thread.currentThread().getName() + "开始运行"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "结束运行"); &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(instance1); Thread t2 = new Thread(instance2); t1.start(); t2.start(); while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("Situation2.class finished"); &#125;&#125; ③两个线程访问的是 synchronized 的静态方法 原因：虽然两个线程属于类的不同实例，但是两个线程访问的方法是类的静态方法，即它们实际访问的是同一个方法。给这个静态方法上锁之后，同一时刻只能有一个线程执行该方法。 结果：两个线程争抢同一把锁，同一时刻只能有一个线程执行该同步方法。 1234567891011121314151617181920212223242526272829303132333435/** * @author: wjy * @date: 2020/2/20 * @description: 两个线程访问的是synchronized的静态方法 */public class Situation3 implements Runnable &#123; static Situation3 instance1 = new Situation3(); static Situation3 instance2 = new Situation3(); @Override public void run() &#123; method(); &#125; private static synchronized void method() &#123; System.out.println(Thread.currentThread().getName() + "开始运行"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "结束运行"); &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(instance1); Thread t2 = new Thread(instance2); t1.start(); t2.start(); while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("Situation3.class finished"); &#125;&#125; ④同时访问同步方法与非同步方法 原因：synchronized 关键字只作用于其指定的方法中，其他非同步方法不受到影响。 结果：当线程 0 访问同步方法，线程 1 访问非同步方法时，两个线程并行执行，互不干扰。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * @author: wjy * @date: 2020/2/20 * @description: 同时访问同步和非同步方法 */public class Situation4 implements Runnable &#123; static Situation4 instance = new Situation4(); @Override public void run() &#123; // 让线程0运行method1()方法，线程1运行method2()方法。 // 线程的默认名是从Thread-0(Thread-1、Thread-2、...)开始。 if (Thread.currentThread().getName().equals("Thread-0")) &#123; method1(); &#125; else &#123; method2(); &#125; &#125; public synchronized void method1() &#123; System.out.println(Thread.currentThread().getName() + "开始运行(加锁的方法)"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "结束运行(加锁的方法)"); &#125; public void method2() &#123; System.out.println(Thread.currentThread().getName() + "开始运行(没加锁的方法)"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "结束运行(没加锁的方法)"); &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); t1.start(); t2.start(); while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("Situation4.class finished"); &#125;&#125; ⑤同时访问一个类的不同的普通同步方法 原因：两个线程属于同一个实例，虽然两个线程访问的是一个类的不同的普通同步方法，但是被 synchronized 关键字修饰的普通方法默认都是以 this 对象作为同步方法的锁，所以它们会争抢同一把锁（对于同一个实例来讲，两个方法的 this 对象是同一个）。 结果：两个线程争抢同一把锁，同一时刻只能有一个线程执行该线程对应的同步方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @author: wjy * @date: 2020/2/20 * @description: 同时访问一个类的不同的普通同步方法 */public class Situation5 implements Runnable &#123; static Situation5 instance = new Situation5(); @Override public void run() &#123; if (Thread.currentThread().getName().equals("Thread-0")) &#123; method1(); &#125; else &#123; method2(); &#125; &#125; public synchronized void method1() &#123; System.out.println(Thread.currentThread().getName() + "开始运行(加锁的方法)"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "结束运行(加锁的方法)"); &#125; public synchronized void method2() &#123; System.out.println(Thread.currentThread().getName() + "开始运行(加锁的方法)"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "结束运行(加锁的方法)"); &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); t1.start(); t2.start(); while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("Situation5.class finished"); &#125;&#125; ⑥同时访问静态 synchronized 和非静态 synchronized 方法 原因： synchronized 关键字修饰静态方法：类锁，锁住的是 .class 对象。 synchronized 关键字修饰非静态方法：方法锁，锁住的是实例本身 this。 两个线程的锁对象不是同一个，所以两个线程可以同时运行。 结果：两个线程的锁对象不是同一个，并行执行，互不干扰。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @author: wjy * @date: 2020/2/20 * @description: 同时访问静态synchronized和非静态synchronized方法 */public class Situation6 implements Runnable &#123; static Situation6 instance = new Situation6(); @Override public void run() &#123; if (Thread.currentThread().getName().equals("Thread-0")) &#123; method1(); &#125; else &#123; method2(); &#125; &#125; public static synchronized void method1() &#123; System.out.println(Thread.currentThread().getName() + "开始运行(静态加锁的方法)"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "结束运行(静态加锁的方法)"); &#125; public synchronized void method2() &#123; System.out.println(Thread.currentThread().getName() + "开始运行(非静态加锁的方法)"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "结束运行(非静态加锁的方法)"); &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); t1.start(); t2.start(); while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("Situation6.class finished"); &#125;&#125; ⑦方法抛出异常后会释放锁 synchronized：方法抛出异常后会主动释放锁。 Lock 类：方法抛出异常后不会主动释放锁，必须显式地释放锁。 12345678910111213141516171819202122232425262728293031323334353637/** * @author: wjy * @date: 2020/2/20 * @description: 方法抛出异常后会释放锁 * 展示不抛出异常前和抛出异常后的对比: 一旦第一个线程抛出异常，第二个线程会立刻进入同步方法，意味着锁已经释放。 */public class Situation7 implements Runnable &#123; static Situation7 instance = new Situation7(); @Override public void run() &#123; method(); &#125; public synchronized void method() &#123; System.out.println(Thread.currentThread().getName() + "开始运行"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 方法抛出异常后，JVM帮我们释放了锁，不需要手动释放锁。 // 抛出运行时异常，不强制要求捕获。 throw new RuntimeException(); &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); t1.start(); t2.start(); while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("Situation7.class finished"); &#125;&#125; ⑧总结 一把锁只能同时被一个线程获取，没有拿到锁的线程必须等待（对应①、⑤）。 每个实例都对应有自己的一把锁，不同的实例之间对应不同的锁，所以不同的实例之间互不影响。 例外：锁对象是 .class 以及 synchronized 修饰的是 static 方法的时候，所有对象共用同一把类锁（对应②、③、④、⑥） 。 无论是方法正常执行完毕或者方法抛出异常，都会释放锁（对应⑦）。 在被 synchronized 修饰的方法中调用没有被 synchronized 修饰的方法时，不是线程安全的，因为没有被 synchronized 修饰的方法是可以被多个线程同时访问的。 4.性质①可重入性（递归锁） 这是它区别于其他锁的关键特点 可重入性：指的是同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁。 ReentrantLock 也是可重入锁 好处： 避免死锁（假设方法 1 和方法 2 都被 synchronized 关键字修饰，此时某线程执行方法 1 和方法 2 时都需要同一把锁。假如线程 A 执行了方法 1 并且获得了这把锁，此时方法 1 要想访问方法 2，假设 synchronized 关键字没有可重入性，相当于线程 A 没有方法 2 的锁，不能直接使用本身已经获得的锁。既想要拿到方法 2 的锁又不释放方法 1 的锁（方法 1 和方法 2 是同一把锁），就开始了永久等待，变成了死锁。） 提升封装性（避免一次次解锁、加锁，提高了封装性，简化了并发编程的难度。） 粒度：即范围，默认加锁的范围是线程而非调用。 情况1：访问同一个方法是可重入的 情况2：可重入不要求是同一个方法（即证明在一个同步方法中调用另一个同步方法是可行的） 情况3：可重入不要求是同一个类中的 以上三种情况证明了可重入的粒度不是调用范围的，而是线程范围的。所以在同一个线程中，如果已经拿到了一把锁，又想继续使用这把锁访问其他（类的）方法时，只要锁是同一把锁，就可以访问。 证明情况1：访问同一个方法是可重入的 12345678910111213141516171819202122/** * @author: wjy * @date: 2020/2/20 * @description: 可重入粒度测试1——递归调用本方法 */public class ReentrantGranularityTest1 &#123; int a = 0; private synchronized void method() &#123; System.out.println("a = " + a); if (a == 0) &#123; a++; // 调用方法本身 method(); &#125; &#125; public static void main(String[] args) &#123; ReentrantGranularityTest1 test1 = new ReentrantGranularityTest1(); test1.method(); &#125; &#125; 证明情况2：可重入不要求是同一个方法 1234567891011121314151617181920/** * @author: wjy * @date: 2020/2/20 * @description: 可重入粒度测试2——调用类内其他的方法 */public class ReentrantGranularityTest2 &#123; private synchronized void method1() &#123; System.out.println("我是方法一"); method2(); &#125; private synchronized void method2() &#123; System.out.println("我是方法二"); &#125; public static void main(String[] args) &#123; ReentrantGranularityTest2 test2 = new ReentrantGranularityTest2(); test2.method1(); &#125;&#125; 证明情况3：可重入不要求是同一个类中的 123456789101112131415161718192021222324252627282930313233343536373839/** * @author: wjy * @date: 2020/2/20 * @description: 可重入粒度测试3——父类 */public class ReentrantGranularityTest &#123; public synchronized void doSomething() &#123; System.out.println("我是父类方法"); &#125;&#125;/** * @author: wjy * @date: 2020/2/20 * @description: 可重入粒度测试3——调用父类的方法 */public class ReentrantGranularityTest3 extends ReentrantGranularityTest &#123; /** * 功能描述: 重写父类方法 * * @param: [] * @return: void * @auther: wjy * @date: 2020/2/20 22:30 */ @Override public synchronized void doSomething() &#123; System.out.println("我是子类方法"); // 调用父类方法 super.doSomething(); &#125; public static void main(String[] args) &#123; ReentrantGranularityTest3 test3 = new ReentrantGranularityTest3(); // 执行子类方法 test3.doSomething(); &#125;&#125; ②不可中断性 这个性质是 synchronized 关键字的劣势 不可中断性：一旦这个锁已经被别人获得了，如果我还想获取，我只能选择等待或者阻塞，直到别的线程释放这个锁。如果别人永远不释放锁，那么我只能永远等待下去。 而 Lock 类拥有可以中断的能力 如果我觉得我等待的时间太长了，有权中断现在已经获取到锁的那个线程的执行。 如果我觉得我等待的时间太长了不想再等了，也可以直接退出。 5.原理①加锁和释放锁的原理 每一个类的实例对应着一把锁，而每一个被 synchronized 关键字修饰的方法都必须首先获得调用该方法的类的实例的锁才能执行，否则线程就会阻塞。而方法一旦执行，就会独占这把锁，直到该方法返回或者抛出异常，才会将锁释放。释放之后，其他被阻塞的线程就能获得这把锁，重新进入到可执行的状态。 即当一个对象中有 synchronized 关键字修饰的方法或者代码块时，要想执行这段代码，就必须先获得对象锁。如果此对象的对象锁已经被其他调用者占用了，就必须等待它被释放。所有的 Java 对象都含有一个互斥锁，这个锁由 JVM 自动去获取和释放，我们只需要指定这个对象就可以了。 获取和释放锁的时机：内置锁 每个 Java 对象都可以用作一个实现同步的锁，这个锁被称为内置锁或监视器锁。线程在进入到同步代码块之前，会自动获得这个锁，并且在退出同步代码块的时候，会自动释放。 获得内置锁的唯一途径，就是进入到锁所保护的同步代码块或方法中。 下面用 Lock 模拟 synchronized 加锁和释放锁的时机： 1234567891011121314151617181920212223242526272829303132333435363738import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * @author: wjy * @date: 2020/2/23 * @description: 用lock模拟synchronized加锁和释放锁的时机 */public class LockAndUnlock &#123; Lock lock = new ReentrantLock(); public synchronized void method1() &#123; // 进入方法时隐形地获取一把锁 System.out.println("我是synchronized形式的锁"); // 退出方法时隐形地释放一把锁 &#125; public void method2() &#123; // 加锁 lock.lock(); try &#123; System.out.println("我是lock形式的锁"); &#125; finally &#123; // 释放锁 lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; // synchronized和lock在底层可以相互类比和配合 // method1方法和method2方法等价 // 将method1中synchronized锁住和解锁的时机用method2中拆分的形式表达 LockAndUnlock l = new LockAndUnlock(); l.method1(); l.method2(); &#125;&#125; ③反编译看 monitor 指令 synchronized 是如何工作的 synchronized 用的锁是 Java 对象头里的一个字段（每一个对象都有一个对象头，对象头可以存储很多信息，其中有一个部分就是用来存储 synchronize 关键字的锁的，表明是否被锁住。） 细节：当线程访问一个同步代码块时，必须要得到这把锁，退出整个代码块或者抛出异常的时候必须释放锁，而锁存储在 Java 对象头中。在 JVM 规范中对于 synchronized 的实现原理已经有了说明，它的进入锁和释放锁是基于 Moniter 对象来实现同步方法和同步代码块的。Monditor 对象主要有两个指令：Monditorenter（插入到同步代码块开始的位置）和 Monditorexit（插入到方法结束的时候和退出的时候）。JVM 规范保证每一个 enter 之后必须要有 exit 和它对应，但是可能有多个 exit 和同一个 enter 对应，因为退出的时机包括方法结束和抛出异常。每一个对象都有一个 Monditor 和它关联，并且一旦一个 Monditor 被持有后，就会处于锁定状态，当线程执行到 Monditorenter 指令时，会尝试获取这个对象对应的 Monditor 的所有权，也就是尝试获取这个对象锁。 编译：javac 类名.java 将 Java 类编译为 .class 文件 反编译：javap -verbose class文件名.class 将 .class 文件反编译为字节码文件 反编译结果： 详细解读 Monditorenter 和 Monditorexit 指令：Monditorenter 和 Monditorexit 指令在执行的时候会使对象的锁计数加 1 或者减 1。每一个对象都和一个 Monditor 相关联，一个 Moditor 的 lock 锁只能被一个线程在同一时间获得，一个线程在尝试获得与这个对象关联的 Monditor 的所有权的时候，只会发生以下三种情况之一（即 Monditorenter 指令的三种情况）： 成功获得锁：Monditor 计数器为 0，意味着目前还没有被获得，这个线程就会立刻获得，然后把计数器加 1，之后别人再想进来就会看到信号，知道它已经被其他线程所持有，所以加 1 意味着当前线程是这个 Moditor 的持有者。 已经拿到这把锁的所有权再次重入时：计数器随着重入次数的增加而增加（每次加 1）。 Monditor 已经被其他线程所持有了：当前线程再次获取就会得到现在无法获取的信号，就会进入阻塞状态，直到 Moditor 的计数器变为0，才会再次尝试获取这个锁。 Monditorexit：释放 Monditor 的所有权（可以将 Monditor 理解为锁） 前提是已经拥有了锁的所有权 释放的过程：将 Monditor 的计数器减 1，如果减完之后变成 0 就意味着当前线程不再拥有对 Monditor 的所有权，即解锁。如果减完之后不是 0，意味着刚才是可重入进来的，所以还是继续持有这把锁。最终计数器减到 0 之后，不仅意味着释放锁了，还意味着刚才被阻塞的线程会再次尝试获取对这把锁的所有权。 ③可重入原理 可重入性：一个线程拿到一把锁之后，如果还想再次进入由这把锁所控制的方法，可以直接进入。 可重入原理：利用加锁次数计数器 每个对象自动地含有一把锁，JVM 负责跟踪对象被加锁的次数。 线程第一次给对象加锁的时候，计数变为 1。每当这个相同的线程在此对象上再次获得锁时，计数递增。每当任务结束离开时，计数递减，当计数为 0 的时候，锁被完全释放。 ④可见性原理 保证可见性的原理：Java 内存模型 共享变量的副本：将主内存的变量复制一份，放在自己的本地内存。原因：加速程序的运行，因为线程所使用的内存速度比主存中的速度快。 两个线程要想互相通信-要怎么做：线程 A 将共享变量的副本写到主内存中，因为主内存是它们相互沟通的桥梁，然后线程 B 再去主内存中读取。 这个过程是 JMM（Java 内存模型的缩写）控制的，JMM 通过控制主内存与每个线程的本地内存的交互来提供内存可见性的保证。 synchronized 是如何做到可见性的实现的？ 一旦代码块或者方法被 synchronized 关键字所修饰，那么它在执行完毕之后，被锁住的对象所做的任何修改，都要在释放锁之前，从线程内存写回到主内存中（不会存在线程内存和主内存不一致的情况）。 同样，在进入代码块获得锁之后，被锁定对象的数据也是直接从主内存中读取出来的。 6.缺陷 效率低 锁的释放情况少：当一个线程获取到锁并在执行过程中，其他线程也想要获得该锁时，只能等待当前线程释放。而当前线程只有在两种情况下才会释放锁：①线程执行完该段代码、②执行过程中发生异常（JVM 将锁释放）。如果要等待 IO 这种耗时操作或者线程 sleep 时，不会主动释放锁，其他线程只能等待，非常影响程序执行的效率。这时需要一种机制，遏制这些情况。（Lock 类可以做到） 试图获得锁时不能设定超时时间，只能等待。（Lock 类可以做到） 不能中断一个正在试图获得锁的线程（Lock 类可以做到） 不够灵活（读写锁更灵活） 加锁和释放锁的时机单一，每个锁仅有单一的条件（某个对象）。锁住某个对象，某个对象就是这把锁。释放这个对象，才意味着解了这把锁。 无法知道是否成功获取到锁（Lock 类可以做到） 1234567891011121314151617181920212223242526272829import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * @author: wjy * @date: 2020/2/23 * @description: 展示Lock的方法 */public class LockExample &#123; public static void main(String[] args) &#123; Lock lock = new ReentrantLock(); // 通过这两个方法灵活得控制这把锁，且可以配置自定义的锁。 // 锁住 lock.lock(); // 释放锁 lock.unlock(); // 在规定的超时时间内等待获得锁。 try &#123; // 不设置超时时间的tryLock() lock.tryLock(); // 若是10s拿不到锁，会主动放弃。 lock.tryLock(10, TimeUnit.SECONDS); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 7.常见面试问题①synchronized 关键字有哪些使用注意点？ 锁对象不能为空 指定一个对象作为锁对象时，必须是一个实例对象被 new 过，或者使用其他方法创建好的，而不是空对象。这是因为锁的信息保存在对象头中的，如果对象都没有，就没有对象头，所以这个锁是不能工作的。 作用域不宜过大 将尽可能多的代码使用 synchronized 包裹，虽然会降低出并发问题的可能性（大部分线程都是串行工作），但是没有达到多线程编程的目的，影响程序执行的效率。 避免死锁 ②如何选择 Lock 和 synchronized 关键字？ 如果可以的话，两者都不要使用，应该使用 JUC 中的各种类（更方便，不容易出错）。 如果 synchronized 关键字在程序中适用，那么就优先使用（可以减少所需要编写的代码，也就减少了出错的几率）。 如果需要使用到 Lock 类独有的特性（如灵活的加解锁机制），再使用 Lock。 ③多线程访问同步方法的各种具体情况 具体见 3.多线程访问同步方法的 7 种情况 8.思考 多个线程等待同一个 synchronized 锁的时候，JVM 如何选择下一个获取锁的是哪个线程？ 有内部锁调度机制有关 持有锁的线程在运行完成或抛出异常后，就会释放这把锁。线程释放锁之后，竞争锁的对象有：等待中的线程、刚刚申请这把锁的线程。内部锁调度机制实现细节和 JVM 的版本、具体实现相关，不能依赖算法。 目前是处于随机的，不公平的状态。 synchronized 是非公平锁，ReentrantLock 可以设置是否是公平锁。 synchronized 使得同时只有一个线程可以执行，性能较差，有什么方法可以提升性能？ 优化使用范围（临界区在符合要求的情况下尽可能得小） 使用其他类型的锁（如读写锁） 自己实现 Lock 接口，自由设定锁持有时间 想灵活的控制锁的获取和释放怎么办（现在释放锁的时机都被规定死了）？ 自己实现一个锁 什么是锁的升级和降级？什么是 JVM 里的偏斜锁、轻量级锁、重量级锁？ 9.总结 一句话介绍 synchronized：JVM 会自动通过使用 monitor 来自动加锁和解锁，保证了同时只有一个线程可以执行指定代码，从而保证了线程安全，同时具有可重入和不可中断的性质。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#121;&#x6d;&#x65;&#x73;&#x73;&#x69;&#x40;&#x31;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#x6d;]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb相关软件安装包分享]]></title>
    <url>%2F2020%2F02%2F18%2FJavaWeb%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8C%85%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[1.Linux 版本（JavaWeb 程序） 链接：https://pan.baidu.com/s/1BHFbs0_sMzfBdQGIOCrQ-w 提取码：wvtt jdk-8u201-linux-x64.tar.gz apache-tomcat-8.5.39.tar.gz apache-maven-3.6.0-bin.tar.gz nginx-1.8.0.tar.gz redis-5.0.4.tar.gz thrift-0.13.0.tar.gz 2.Windows 版本（JavaWeb 程序） 链接：https://pan.baidu.com/s/1H4o8uCxwYVn_x0wn7aNvpg 提取码：9h05 jdk-8u65-windows-x64.zip mysql-5.7.24-winx64.zip Redis-x64-3.0.504.msi gradle-5.2.1-all.zip elasticsearch-7.1.1-windows-x86_64.zip elasticsearch-head-master.zip Docker Community Edition 18.06.1-ce-win73 2018-08-29.exe 3.其他工具（Windows） 链接：https://pan.baidu.com/s/1LnO1znY4nlDuu8QvC957bQ 提取码：ihaf 谷歌访问助手_v2.3.0.crx（翻墙） Git-2.19.1-64-bit.exe GitHubDesktopSetup.exe redis-desktop-manager-0.8.8.384.exe Xftp.6.0.0105.v2.7z（Xftp.exe） Xshell.6.0.0111.v2.7z（Xshell.exe） notepad++.exe VMware-workstation-full-15.0.0-10134415.exe CentOS-7-x86_64-Minimal-1908.iso（CentOS 镜像 在 VMware 中使用） 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#121;&#109;&#x65;&#x73;&#115;&#105;&#x40;&#49;&#x36;&#x33;&#46;&#99;&#x6f;&#109;]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>总结&amp;其他</category>
      </categories>
      <tags>
        <tag>资源分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八种排序算法的总结及性能分析]]></title>
    <url>%2F2020%2F02%2F12%2F%E5%85%AB%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1.排序基础①基础知识 稳定性：任意两个相等的数据，排序前后的相对位置不发生改变。 内排序：在排序期间数据对象全部存放在内存中的排序。 原地排序：在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序。 非原地排序：需要利用额外的空间来辅助排序。 逆序对：对于下标 i &lt; j，如果 A[i] &gt; A[j]，则称 (i, j) 是一对逆序对。 交换 2 个相邻元素正好可以消去 1 个逆序对。 讨论规则： 只讨论升序的整数排序 只讨论基于比较的排序 只讨论内部排序 排序算法一览（图片来源于网络）： ②自定义辅助函数 排序接口（所有排序类都会实现这个接口） 12345678910111213141516171819package sort;/** * @author: wjy * @date: 2020/2/11 * @description: 排序接口 */public interface Sort &#123; /** * 功能描述: 对长度为n的数组中的元素进行升序排序 * * @param: [arr, n] * @return: void * @auther: wjy * @date: 2020/2/12 20:24 */ void ascendSort(int[] arr, int n);&#125; 构造待排序的数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package sort.util;/** * @author: wjy * @date: 2020/2/11 * @description: 构造待排序的数组 */public class RandomArray &#123; /** * 功能描述: 生成长度为n的数组，并且数组元素的范围在rangeL~rangeR之间。 * * @param: [n, rangeL, rangeR] * @return: int[] * @auther: wjy * @date: 2020/2/12 20:27 */ public static int[] generateRandomArray(int n, int rangeL, int rangeR) &#123; int[] arr = new int[n]; if (rangeL &lt;= rangeR) &#123; for (int i = 0; i &lt; n; i++) &#123; arr[i] = (int) (Math.random() * (rangeR - rangeL + 1) + rangeL); &#125; &#125; else &#123; System.out.println("rangeL &gt; rangeR"); &#125; return arr; &#125; /** * 功能描述: 生成近乎有序的长度为n的数组，并且可以自定义逆序对个数。 * * @param: [n, swapTimes] * @return: int[] * @auther: wjy * @date: 2020/2/12 20:28 */ public static int[] generateNearlyRandomArray(int n, int swapTimes) &#123; int[] arr = new int[n]; for (int i = 0; i &lt; n; i++) &#123; arr[i] = i; &#125; for (int i = 0; i &lt; swapTimes; i++) &#123; int x = (int) (Math.random() * n); int y = (int) (Math.random() * n); SortHelper.swap(arr, x, y); &#125; return arr; &#125;&#125; 排序辅助函数 方法一：验证数组是否有序（升序） 方法二：打印数组 方法三：交换数组中的元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package sort.util;/** * @author: wjy * @date: 2020/2/12 * @description: 排序辅助函数 */public class SortHelper &#123; /** * 功能描述: 验证数组是否有序(升序) * * @param: [arr, n] * @return: boolean * @auther: wjy * @date: 2020/2/12 22:31 */ public static boolean isAscendingOrder(int arr[], int n) &#123; for (int i = 0; i &lt; n - 1; i++) &#123; if (arr[i] &gt; arr[i + 1]) &#123; return false; &#125; &#125; return true; &#125; /** * 功能描述: 打印数组 * * @param: [arr, n] * @return: void * @auther: wjy * @date: 2020/2/12 22:30 */ public static void printArray(int[] arr, int n) &#123; for (int i = 0; i &lt; n; i++) &#123; System.out.print(arr[i] + " "); &#125; System.out.println(); &#125; /** * 功能描述: 交换数组中的元素 * * @param: [arr, i, j] * @return: void * @auther: wjy * @date: 2020/2/12 22:31 */ public static void swap(int[] arr, int i, int j) &#123; if (i != j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125;&#125; 测试排序算法的性能 函数入参：排序算法的名称、排序算法的实例、待排数组、待排数组的长度 方法内部：调用对应的排序算法，并打印执行用时及排序算法的正确性。 1234567891011121314151617181920212223242526272829package sort;import sort.util.SortHelper;import java.time.Instant;/** * @author: wjy * @date: 2020/2/11 * @description: 测试排序算法的性能 */public class TestSort &#123; /** * 功能描述: 测试排序算法的性能，打印执行用时及排序的正确性。 * * @param: [name, sort, arr, n] * @return: void * @auther: wjy * @date: 2020/2/12 20:41 */ public static void testSort(String name, Sort sort, int[] arr, int n) &#123; long start = Instant.now().toEpochMilli(); sort.ascendSort(arr, n); long end = Instant.now().toEpochMilli(); System.out.println(name + "用时: " + (end - start) + "ms"); System.out.println("排序后数组是否升序: " + SortHelper.isAscendingOrder(arr, n)); &#125;&#125; ③为什么要学习 O（n^2） 的排序算法？ O（n^2） 的排序算法：所消耗的时间和数据之间成平方关系。 基础。先用最简单的方法解决问题，能加深对问题本身的理解，进而优化或者衍生出更复杂的解法（希尔排序就是通过插入排序的思想进行优化衍生而来的）。 并不是所有场合都需要写 O（n*logn） 复杂度的排序算法。O（n^2） 复杂度的排序算法编码简单，易于实现，是一些简单情景的首选。 在一些特殊情况下，简单的排序算法更有效。 作为子过程，可以改进更复杂的排序算法。 2.交换排序类 — 简单交换排序①排序思路 方法：每一个位置的关键字与其后的所有关键字依次做比较，大则交换。 结果：执行第 i 次外层 for 循环后，第 i - 1 个位置上的关键字一定小于其后的所有关键字，并且其后的其他关键字还保持着未排序前的相对顺序。 缺点：每执行一次外层 for 循环，虽然进行了很多次的交换操作，但是只能消除一个逆序对。 ②代码演示123456789101112131415161718192021222324package sort.swapsort;import sort.Sort;import sort.util.SortHelper;/** * @author: wjy * @date: 2020/2/11 * @description: 交换排序类-简单交换排序 */public class SimpleSwapSort implements Sort &#123; @Override public void ascendSort(int[] arr, int n) &#123; for (int i = 0; i &lt; n - 1; i++) &#123; // 将索引i处的元素与其后的元素依次比较，若大于其后的元素就交换位置。 for (int j = i + 1; j &lt; n; j++) &#123; if (arr[i] &gt; arr[j]) &#123; SortHelper.swap(arr, i, j); &#125; &#125; &#125; &#125;&#125; ③性能分析 稳定性：不稳定 是否是原地排序：是 平均时间复杂度：O（n^2） 最好的情况：O（n^2）（顺序） 最坏的情况：O（n^2）（逆序） 空间复杂度：O（1） 3.交换排序类 — 冒泡排序①排序思路 方法：（从后向前）依次比较两个相邻的元素，前一个元素大则交换位置，这样较小的元素就如同气泡般慢慢浮到上面，所以称之为冒泡排序法。 传统的冒泡排序 方法：依次两两比较（从后向前）并交换位置后，arr[i] 变为 [i, n-1] 区间里的最小值。若某次循环全程无交换，表明数组已经有序，提前退出循环。 改进的冒泡排序 方法： 记录最后一次的交换位置，在此之前的元素（已经有序）在下一轮扫描中均不考虑。 优点：排序链表较为方便 ②代码演示 传统的冒泡排序 12345678910111213141516171819202122232425262728293031package sort.swapsort;import sort.Sort;import sort.util.SortHelper;/** * @author: wjy * @date: 2020/2/11 * @description: 交换排序类-传统的冒泡排序 */public class BubbleSort implements Sort &#123; @Override public void ascendSort(int[] arr, int n) &#123; for (int i = 0; i &lt; n; i++) &#123; int flag = 0; // 依次两两比较并交换位置后，arr[i]变为[i, n-1]区间里的最小值。 for (int j = n - 1; j &gt; i; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; SortHelper.swap(arr, j, j - 1); // 标识一趟冒泡排序中发生了交换。 flag = 1; &#125; &#125; // 全程无交换，表明数组已经有序。 if (flag == 0) &#123; break; &#125; &#125; &#125;&#125; 改进的冒泡排序 123456789101112131415161718192021222324252627package sort.swapsort;import sort.Sort;import sort.util.SortHelper;/** * @author: wjy * @date: 2020/2/11 * @description: 交换排序类-改进的冒泡排序 */public class AdvancedBubbleSort implements Sort &#123; @Override public void ascendSort(int[] arr, int n) &#123; int index = -1; for (int i = index + 1; i &lt; n; i++) &#123; // 依次两两比较并交换位置后，arr[i]变为[i, n-1]区间里的最小值。 for (int j = n - 1; j &gt; i; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; SortHelper.swap(arr, j, j - 1); // 记录最后一次的交换位置，在此之前的元素(已经有序)在下一轮扫描中均不考虑。 index = j - 1; &#125; &#125; &#125; &#125;&#125; ③性能分析 稳定性：稳定 是否是原地排序：是 平均时间复杂度：O（n^2） 最好情况：O（n）（顺序） 最坏情况：O（n^2）（逆序） 空间复杂度：O（1） 冒泡排序在各种情况下的性能都没有插入排序好 4.选择排序类 — 简单选择排序①排序思路 方法：首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后再从剩余未排序序列中继续寻找最小元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 优点：所需移动元素的次数比较少 可以看做是简单交换排序的优化（每次找到最小值再交换） ②代码演示1234567891011121314151617181920212223242526package sort.selectsort;import sort.Sort;import sort.util.SortHelper;/** * @author: wjy * @date: 2020/2/11 * @description: 选择排序类-简单选择排序 */public class SimpleSelectSort implements Sort &#123; @Override public void ascendSort(int[] arr, int n) &#123; for (int i = 0; i &lt; n; i++) &#123; // 寻找[i, n)区间里的最小值，其索引为minIndex。 int minIndex = i; for (int j = i + 1; j &lt; n; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j; &#125; &#125; SortHelper.swap(arr, i, minIndex); &#125; &#125;&#125; ③性能分析 稳定性：不稳定 是否是原地排序：是 平均时间复杂度：O（n^2） 最好情况：O（n^2）（顺序） 最坏情况：O（n^2）（逆序） 空间复杂度：O（1） 5.插入排序类 — 直接插入排序①排序思路 方法：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。（类比整理扑克牌的思想）。 特点： 在数组基本有序的情况下性能会非常高，远远优于选择排序，甚至比 O（n*logn） 级别的排序算法还要快，有重要的实际意义。 可以在更加复杂的排序算法中作为子过程来进行优化 插入排序和选择排序的最大区别：对于内层循环，当找到插入位置时，插入排序可以提前结束。 插入排序和冒泡排序都需要消除逆序对，交换次数是一样的。 ②代码演示1234567891011121314151617181920212223242526package sort.insertsort;import sort.Sort;/** * @author: wjy * @date: 2020/2/12 * @description: 插入排序类-直接插入排序 */public class DirectInsertSort implements Sort &#123; @Override public void ascendSort(int[] arr, int n) &#123; // 第1个元素(索引为0)默认有序 for (int i = 1; i &lt; n; i++) &#123; // 寻找元素e合适的插入位置 int e = arr[i], j = i; for (; j &gt; 0 &amp;&amp; arr[j - 1] &gt; e; j--) &#123; // 向后移出空位 arr[j] = arr[j - 1]; &#125; // 找到了合适的插入位置 arr[j] = e; &#125; &#125;&#125; ③性能分析 稳定性：稳定 是否是原地排序：是 平均时间复杂度：O（n^2） 最好情况：O（n）（顺序） 最坏情况：O（n^2）（逆序） 空间复杂度：O（1） 6.插入排序类 — 希尔排序①排序思路 定理 1：任意 n 个不同元素组成的序列平均具有 n * (n - 1) / 4 个逆序对。 定理 2：任何仅以交换相邻两个元素进行排序的算法（每次只能消去一个逆序对），其平均时间复杂度都为 O（n^2）。 这意味着想要提高排序算法的效率，我们每次必须消去不止一个逆序对，所以我们需要每次交换相隔较远的两个元素，此时就可以一次消去多个逆序对（希尔排序的思想）。 方法：先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。 步骤： 定义增量序列（递减到 1） 对每个增量进行增量间隔的直接插入排序 注意： &quot;Dk-间隔&quot; 有序的序列，在执行 &quot;Dk-1-间隔&quot; 排序后，其 &quot;Dk-间隔&quot; 仍然是有序的。 为了保证结果有序，最后必须进行一次 1 间隔的排序（在进行 1 间隔的排序前，整个数组已经基本有序）。 Hibbard 增量：Dk = 2 ^ k - 1 增量元素不互质，则小增量可能根本不起作用。 递推公式为：D1 = 1、D2 = 3、D3 = 7、Dk = 2 * D(k − 1) + 1、D (k - 1) = (Dk - 1) / 2 特点： 是插入排序的改进版本，克服了插入排序每次只交换相邻两个元素的缺点。 实现起来比 O（n*logn） 级别的排序算法简单 ②代码演示12345678910111213141516171819202122232425262728293031323334353637383940package sort.insertsort;import sort.Sort;/** * @author: wjy * @date: 2020/2/11 * @description: 插入排序类-希尔排序 */public class ShellSort implements Sort &#123; @Override public void ascendSort(int[] arr, int n) &#123; // Hibbard增量: Dk=2^k-1 // 递推公式为: D1=1、D2=3、D3=7、Dk=2D(k−1)+1、D(k-1)=(Dk-1)/2 // k 1 2 3 5 6 // Dk(d) 1 3 7 15 31 int d = 1; while (d &lt; n / 3) &#123; // D(k-1)-&gt;D(k) d = d * 2 + 1; &#125; while (d &gt;= 1) &#123; // d间隔的插入排序 // 第1个元素(索引为0)默认有序 for (int i = d; i &lt; n; i++) &#123; // 寻找元素e合适的插入位置 int e = arr[i], j = i; for (; j &gt;= d &amp;&amp; arr[j - d] &gt; e; j -= d) &#123; // 向后移出空位 arr[j] = arr[j - d]; &#125; // 找到了合适的插入位置 arr[j] = e; &#125; // D(k)-&gt;D(k-1) d = (d - 1) / 2; &#125; &#125;&#125; ③性能分析 稳定性：不稳定 是否是原地排序：是 平均时间复杂度：O（n^5/4） 最好情况：O（n^5/4）（顺序） 最坏情况：O（n^3/2）（逆序） 空间复杂度：O（1） 7.归并排序类 — 归并排序①排序思路 方法： 归并排序（递归） 归并层数：logn 层（二分法），每层要处理的元素个数是一样的。 每层的归并过程的时间复杂度为 O（n） 改进的归并排序（递归） 优化 1：当 n 小到一定程度的时候，插入排序比归并排序快，此时用插入排序代替归并排序（元素很少时，数组近乎有序的可能性变大，插入排序有优势，排序的高级算法都可如此优化）。 优化 2：如果两部分各自有序，就不需要继续归并了。 自底向上的归并排序（迭代） 改进的自底向上的归并排序（迭代） 优化方法同 改进的归并排序（递归） 优点： 适用于排序链表 优化后的归并排序在排序近乎有序的数组时，速度也很快。 缺点：空间复杂度为 O（n） 现代计算机中时间效率比空间效率重要的多，设计算法优先考虑时间复杂度，除非数据存储的空间是算法的重要瓶颈。 ②代码演示 归并排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package sort.mergesort;import sort.Sort;/** * @author: wjy * @date: 2020/2/11 * @description: 归并排序 */public class MergeSort implements Sort &#123; /** * 功能描述: 归并两个有序部分(arr[l...mid]和arr[mid+1...r]) * * @param: [arr, l, mid, r] * @return: void * @auther: wjy * @date: 2020/2/13 3:10 */ public static void merge(int[] arr, int l, int mid, int r) &#123; // 使用临时空间辅助我们完成归并过程 int[] aux = new int[r - l + 1]; for (int i = l; i &lt;= r; i++) &#123; aux[i - l] = arr[i]; &#125; // i和j分别指向两个有序部分的元素，k指向两个元素比较后小的那个元素的存储位置。 int i = l, j = mid + 1; for (int k = l; k &lt;= r; k++) &#123; // 第一个有序部分已经遍历完成 if (i &gt; mid) &#123; arr[k] = aux[j++ - l]; &#125; // 第二个有序部分已经遍历完成 else if (j &gt; r) &#123; arr[k] = aux[i++ - l]; &#125; else if (aux[i - l] &gt; aux[j - l]) &#123; arr[k] = aux[j++ - l]; &#125; else &#123; arr[k] = aux[i++ - l]; &#125; &#125; &#125; /** * 功能描述: 对arr[l...r]部分进行归并排序 * * @param: [arr, l, r] * @return: void * @auther: wjy * @date: 2020/2/13 3:10 */ public void recursion(int[] arr, int l, int r) &#123; if (l &gt;= r) &#123; return; &#125; // 避免发生溢出，使用位运算。 int mid = (l + r) &gt;&gt;&gt; 1; recursion(arr, l, mid); recursion(arr, mid + 1, r); // 归并两个有序部分(arr[l...mid]和arr[mid+1...r]) merge(arr, l, mid, r); &#125; @Override public void ascendSort(int[] arr, int n) &#123; recursion(arr, 0, n - 1); &#125;&#125; 改进的归并排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package sort.mergesort;import sort.Sort;/** * @author: wjy * @date: 2020/2/12 * @description: 归并排序-改进的归并排序 */public class AdvancedMergeSort implements Sort &#123; /** * 功能描述: 对arr[l...r]部分进行插入排序 * * @param: [arr, l, r] * @return: void * @auther: wjy * @date: 2020/2/13 0:10 */ public static void sort(int[] arr, int l, int r) &#123; // 第1个元素(索引为l)默认有序 for (int i = l + 1; i &lt;= r; i++) &#123; // 寻找元素e合适的插入位置 int e = arr[i], j = i; for (; j &gt; l &amp;&amp; arr[j - 1] &gt; e; j--) &#123; // 向后移出空位 arr[j] = arr[j - 1]; &#125; // 找到了合适的插入位置 arr[j] = e; &#125; &#125; /** * 功能描述: 归并两个有序部分(arr[l...mid]和arr[mid+1...r]) * * @param: [arr, l, mid, r] * @return: void * @auther: wjy * @date: 2020/2/13 3:10 */ public static void merge(int[] arr, int l, int mid, int r) &#123; // 使用临时空间辅助我们完成归并过程 int[] aux = new int[r - l + 1]; for (int i = l; i &lt;= r; i++) &#123; aux[i - l] = arr[i]; &#125; // i和j分别指向两个有序部分的元素，k指向两个元素比较后小的那个元素的存储位置。 int i = l, j = mid + 1; for (int k = l; k &lt;= r; k++) &#123; // 第一个有序部分已经遍历完成 if (i &gt; mid) &#123; arr[k] = aux[j++ - l]; &#125; // 第二个有序部分已经遍历完成 else if (j &gt; r) &#123; arr[k] = aux[i++ - l]; &#125; else if (aux[i - l] &gt; aux[j - l]) &#123; arr[k] = aux[j++ - l]; &#125; else &#123; arr[k] = aux[i++ - l]; &#125; &#125; &#125; /** * 功能描述: 对arr[l...r]部分进行归并排序 * * @param: [arr, l, r] * @return: void * @auther: wjy * @date: 2020/2/13 10:16 */ public void recursion(int[] arr, int l, int r) &#123; if (l &gt;= r) &#123; return; &#125; // 优化1: 当n小到一定程度时，插入排序比归并排序快，此时用插入排序代替归并排序。 if (r - l &lt;= 15) &#123; sort(arr, l, r); &#125; // 避免发生溢出，使用位运算。 int mid = (l + r) &gt;&gt;&gt; 1; recursion(arr, l, mid); recursion(arr, mid + 1, r); // 优化2: 如果两部分各自有序，就不需要继续归并了。 if (arr[mid + 1] &lt; arr[mid]) &#123; merge(arr, l, mid, r); &#125; &#125; @Override public void ascendSort(int[] arr, int n) &#123; recursion(arr, 0, n - 1); &#125;&#125; 自底向上的归并排序 12345678910111213141516171819202122package sort.mergesort;import sort.Sort;/** * @author: wjy * @date: 2020/2/13 * @description: 归并排序-自底向上的归并排序 */public class IterationMergeSort implements Sort &#123; @Override public void ascendSort(int[] arr, int n) &#123; // i: 1、2、4、8... for (int i = 1; i &lt;= n; i += i) &#123; for (int j = 0; j + i &lt; n; j += i + i) &#123; // 对arr[j...j+i-1]和arr[j+i...j+i+i-1]进行归并 AdvancedMergeSort.merge(arr, j, j + i - 1, Math.min(j + i + i - 1, n - 1)); &#125; &#125; &#125;&#125; 改进的自底向上的归并排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package sort.mergesort;import sort.Sort;/** * @author: wjy * @date: 2020/3/13 * @description: 归并排序-改进的自底向上的归并排序 */public class AdvancedIterationMergeSort implements Sort &#123; /** * 功能描述: 对arr[l...r]部分进行插入排序 * * @param: [arr, l, r] * @return: void * @auther: wjy * @date: 2020/2/13 0:10 */ public static void sort(int[] arr, int l, int r) &#123; // 第1个元素(索引为l)默认有序 for (int i = l + 1; i &lt;= r; i++) &#123; // 寻找元素e合适的插入位置 int e = arr[i], j = i; for (; j &gt; l &amp;&amp; arr[j - 1] &gt; e; j--) &#123; // 向后移出空位 arr[j] = arr[j - 1]; &#125; // 找到了合适的插入位置 arr[j] = e; &#125; &#125; @Override public void ascendSort(int[] arr, int n) &#123; // 优化1: 当n小到一定程度时，插入排序比归并排序快，此时用插入排序代替归并排序。 for (int i = 0; i &lt; n; i += 16) &#123; sort(arr, i, Math.min(i + 15, n - 1)); &#125; // i: 16、32、64... for (int i = 16; i &lt;= n; i += i) &#123; for (int j = 0; j + i &lt; n; j += i + i) &#123; // 优化2: 如果两部分各自有序，就不需要继续归并了。 if (arr[j + i - 1] &gt; arr[j + i]) &#123; AdvancedMergeSort.merge(arr, j, j + i - 1, Math.min(j + i + i - 1, n - 1)); &#125; &#125; &#125; &#125;&#125; ③性能分析 稳定性：稳定 是否是原地排序：否 平均时间复杂度：O（n*logn） 最好情况：O（n*logn）（顺序） 最坏情况：O（n*logn）（逆序） 空间复杂度：O（n） ④衍生问题 — 求一个数组中逆序对的数量 我们再来复习一下什么是逆序对：对于下标 i &lt; j，如果 A[i] &gt; A[j]，则称 (i, j) 是一个逆序对。 数组中逆序对的数量可以衡量一个数组的有序程度。 方法一（O（n^2））：使用双重循环考察每一个数对，暴力解法。 方法二（O（n*logn））：归并排序的思路求逆序对的个数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package sort.derivedquestion;import sort.util.RandomArray;/** * @author: wjy * @date: 2020/2/13 * @description: 归并排序的思路求逆序对的个数 */public class ReversePairsNumber &#123; /** * 功能描述: 求出在arr[l...mid]和arr[mid+1...r]有序的基础上，arr[l...r]的逆序数对个数。 * * @param: [arr, l, mid, r] * @return: long * @auther: wjy * @date: 2020/2/13 11:42 */ public long merge(int[] arr, int l, int mid, int r) &#123; // 初始化逆序对个数 long number = 0; // 使用临时空间辅助我们完成归并过程 int[] aux = new int[r - l + 1]; for (int i = l; i &lt;= r; i++) &#123; aux[i - l] = arr[i]; &#125; // i和j分别指向两个有序部分的元素，k指向两个元素比较后小的那个元素的存储位置。 int i = l, j = mid + 1; for (int k = l; k &lt;= r; k++) &#123; // 第一个有序部分已经遍历完成 if (i &gt; mid) &#123; arr[k] = aux[j++ - l]; &#125; // 第二个有序部分已经遍历完成 else if (j &gt; r) &#123; arr[k] = aux[i++ - l]; &#125; else if (aux[i - l] &gt; aux[j - l]) &#123; // aux[j-l]&lt;aux[i-l]，说明aux[i-l...mid]之间的所有元素都与aux[j-1]构成了逆序对。 arr[k] = aux[j++ - l]; number += (long) (mid - i + 1); &#125; else &#123; arr[k] = aux[i++ - l]; &#125; &#125; return number; &#125; /** * 功能描述: 对arr[l...r]部分进行归并排序 * * @param: [arr, l, r] * @return: long * @auther: wjy * @date: 2020/2/13 11:14 */ public long recursion(int[] arr, int l, int r) &#123; if (l &gt;= r) &#123; return 0L; &#125; // 避免发生溢出，使用位运算。 int mid = (l + r) &gt;&gt;&gt; 1; long number1 = recursion(arr, l, mid); long number2 = recursion(arr, mid + 1, r); return number1 + number2 + merge(arr, l, mid, r); &#125; public long ascendSort(int[] arr, int n) &#123; return recursion(arr, 0, n - 1); &#125; public static void main(String[] args) &#123; int n = 1000; // 1.测试完全有序的数组 int[] arr = RandomArray.generateNearlyRandomArray(n, 0); System.out.println("测试完全有序的数组: " + new ReversePairsNumber().ascendSort(arr, n)); // 2.测试逆序的数组(正确答案: n*(n-1)/2) for (int i = 0; i &lt; n; i++) &#123; arr[n - i - 1] = i; &#125; System.out.println("测试逆序的数组: " + new ReversePairsNumber().ascendSort(arr, n)); // 3.测试随机数组 arr = RandomArray.generateNearlyRandomArray(n, 10); System.out.println("测试随机数组: " + new ReversePairsNumber().ascendSort(arr, n)); &#125;&#125; 8.交换排序类 — 快速排序①排序思路 快速排序 20 世纪对世界影响最大的算法之一 方法： 普通快速排序 所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的元素可以放到任何一边） 基准值如何选取：选择数列中的第一个元素 未优化的快速排序在排序随机数组时就已经快于归并排序，但是在排序近乎有序的数组时会非常慢。 改进的快速排序 优化 1：当 n 小到一定程度时，插入排序比快速排序快，此时用插入排序代替快速排序。 优化 2：每次随机选择数列中的一个元素作为基准。此时快速排序的最坏情况的时间复杂度依然是 O（n^2） ，但是退化到 O（n^2） 的概率极低。优化后，针对数字范围很小的数组，依然会非常慢（递归树不平衡，当数组有大量重复键值时，很大概率会将数组分成极不平衡的两部分）。 双路快速排序 方法：将与基准值相等的元素分散到左右两部分 优化后在排序近乎有序的数组时也会比归并排序快 三路快速排序 方法：将与基准值相等的元素放在中间，下次递归时直接不用处理等于基准值的元素（它们已经在正确的位置上了）。 在存在大量重复键值的情况下，远远快于其他排序，其他情况稍微慢于二路快速排序。 归并排序与快速排序的比较 都使用了分治算法的基本思想（分治算法：顾名思义，分而治之，就是将原问题分割成同等结构的子问题，再将子问题逐一解决后，原问题也就得到了解决。） 归并排序的重点在于治，快速排序的重点在于分。 归并排序可以保证每次都将数组平均一分为二，快速排序则无法保证。所以快速排序调用递归的过程所生成的递归树比归并排序的差，且不能完全保证递归树的高度是 logn，最坏情况下递归树的高度是 O（n）（当数组近乎有序时）。 nlogn 级别的排序算法也有常数上的差异，快速排序相对占优。 归并排序与快速排序的选择 一般系统级别的排序，都是使用快速排序实现的。 如果一个系统对空间相对敏感，归并排序就不适合。 在系统级别的类库中，若想实现稳定的排序，通常选择的是归并排序。但是也可以通过自定义比较函数，使排序算法不存在稳定性的问题。 缺点：空间复杂度为 O（logn），有 logn 层栈空间来保存每一层递归过程中的临时变量，以供递归返回时调用。 ②代码演示 快速排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package sort.swapsort;import sort.Sort;import sort.util.SortHelper;/** * @author: wjy * @date: 2020/2/11 * @description: 交换排序类-快速排序 */public class QuickSort implements Sort &#123; /** * 功能描述: 对arr[l...r]部分进行partition操作 * 返回index，使得arr[l...index-1] &lt; arr[index]、arr[index+1...r] &gt;= arr[index]。 * * @param: [arr, l, r] * @return: int * @auther: wjy * @date: 2020/2/13 11:10 */ public int partition(int[] arr, int l, int r) &#123; // 使用数组的第一个元素作为分界的标志点 int value = arr[l], j = l; for (int i = l + 1; i &lt;= r; i++) &#123; if (arr[i] &lt; value) &#123; SortHelper.swap(arr, i, ++j); &#125; &#125; // 将value移到分界处 SortHelper.swap(arr, l, j); return j; &#125; /** * 功能描述: 对arr[l...r]部分进行快速排序 * * @param: [arr, l, r] * @return: void * @auther: wjy * @date: 2020/2/13 11:10 */ public void recursion(int[] arr, int l, int r) &#123; if (l &gt;= r) &#123; return; &#125; int index = partition(arr, l, r); recursion(arr, l, index - 1); recursion(arr, index + 1, r); &#125; @Override public void ascendSort(int[] arr, int n) &#123; recursion(arr, 0, n - 1); &#125;&#125; 改进的快速排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package sort.swapsort;import sort.Sort;import sort.util.SortHelper;/** * @author: wjy * @date: 2020/2/13 * @description: 交换排序类-改进的快速排序 */public class AdvancedQuickSort implements Sort &#123; /** * 功能描述: 对arr[l...r]部分进行插入排序 * * @param: [arr, l, r] * @return: void * @auther: wjy * @date: 2020/2/13 0:10 */ public static void sort(int[] arr, int l, int r) &#123; // 第1个元素(索引为l)默认有序 for (int i = l + 1; i &lt;= r; i++) &#123; // 寻找元素e合适的插入位置 int e = arr[i], j = i; for (; j &gt; l &amp;&amp; arr[j - 1] &gt; e; j--) &#123; // 向后移出空位 arr[j] = arr[j - 1]; &#125; // 找到了合适的插入位置 arr[j] = e; &#125; &#125; /** * 功能描述: 对arr[l...r]部分进行partition操作 * 返回index，使得arr[l...index-1] &lt; arr[index]、arr[index+1...r] &gt;= arr[index]。 * @param: [arr, l, r] * @return: int * @auther: wjy * @date: 2020/2/13 11:05 */ public int partition(int[] arr, int l, int r) &#123; // 优化2: 使用数组中的随机元素作为分界的标志点 SortHelper.swap(arr, l, (int) (Math.random() * (r - l + 1) + l)); int value = arr[l], j = l; for (int i = l + 1; i &lt;= r; i++) &#123; if (arr[i] &lt; value) &#123; SortHelper.swap(arr, i, ++j); &#125; &#125; // 将value移到分界处 SortHelper.swap(arr, l, j); return j; &#125; /** * 功能描述: 对arr[l...r]部分进行快速排序 * * @param: [arr, l, r] * @return: void * @auther: wjy * @date: 2020/2/13 11:04 */ public void recursion(int[] arr, int l, int r) &#123; if (l &gt;= r) &#123; return; &#125; // 优化1: 当n小到一定程度时，插入排序比快速排序快，此时用插入排序代替快速排序。 if (r - l &lt;= 15) &#123; sort(arr, l, r); &#125; int index = partition(arr, l, r); recursion(arr, l, index - 1); recursion(arr, index + 1, r); &#125; @Override public void ascendSort(int[] arr, int n) &#123; recursion(arr, 0, n - 1); &#125;&#125; 双路快速排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package sort.swapsort;import sort.Sort;import sort.util.SortHelper;/** * @author: wjy * @date: 2020/2/13 * @description: 交换排序类-双路快速排序 */public class QuickSort2Ways implements Sort &#123; /** * 功能描述: 对arr[l...r]部分进行插入排序 * * @param: [arr, l, r] * @return: void * @auther: wjy * @date: 2020/2/13 0:10 */ public static void sort(int[] arr, int l, int r) &#123; // 第1个元素(索引为l)默认有序 for (int i = l + 1; i &lt;= r; i++) &#123; // 寻找元素e合适的插入位置 int e = arr[i], j = i; for (; j &gt; l &amp;&amp; arr[j - 1] &gt; e; j--) &#123; // 向后移出空位 arr[j] = arr[j - 1]; &#125; // 找到了合适的插入位置 arr[j] = e; &#125; &#125; /** * 功能描述: 返回index，使得arr[l...index-1] &lt;= arr[index]、arr[index+1...r] &gt;= arr[index]。 * * @param: [arr, l, r] * @return: int * @auther: wjy * @date: 2020/2/13 22:34 */ public int partition(int[] arr, int l, int r) &#123; SortHelper.swap(arr, l, (int) (Math.random() * (r - l + 1) + l)); int value = arr[l]; // arr[l...i) &lt;= v、arr[j...r] &gt;= v int i = l + 1, j = r; while (true) &#123; while (i &lt;= r &amp;&amp; arr[i] &lt; value) &#123; i++; &#125; while (j &gt; l &amp;&amp; arr[j] &gt; value) &#123; j--; &#125; if (i &gt; j) &#123; break; &#125; else &#123; // 此时arr[i] &gt; value &amp;&amp; arr[j] &lt; value，所以直接交换它们的位置。 SortHelper.swap(arr, i++, j--); &#125; &#125; // 将value移到分界处 SortHelper.swap(arr, l, j); return j; &#125; /** * 功能描述: 对arr[l...r]部分进行双路快速排序 * * @param: [arr, l, r] * @return: void * @auther: wjy * @date: 2020/2/13 11:08 */ public void recursion(int[] arr, int l, int r) &#123; if (r - l &lt;= 15) &#123; sort(arr, l, r); return; &#125; int index = partition(arr, l, r); recursion(arr, l, index - 1); recursion(arr, index + 1, r); &#125; @Override public void ascendSort(int[] arr, int n) &#123; recursion(arr, 0, n - 1); &#125;&#125; 三路快速排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package sort.swapsort;import sort.Sort;import sort.util.SortHelper;/** * @author: wjy * @date: 2020/2/13 * @description: 交换排序类-三路快速排序 */public class QuickSort3Ways implements Sort &#123; /** * 功能描述: 对arr[l...r]部分进行插入排序 * * @param: [arr, l, r] * @return: void * @auther: wjy * @date: 2020/2/13 0:10 */ public static void sort(int[] arr, int l, int r) &#123; // 第1个元素(索引为l)默认有序 for (int i = l + 1; i &lt;= r; i++) &#123; // 寻找元素e合适的插入位置 int e = arr[i], j = i; for (; j &gt; l &amp;&amp; arr[j - 1] &gt; e; j--) &#123; // 向后移出空位 arr[j] = arr[j - 1]; &#125; // 找到了合适的插入位置 arr[j] = e; &#125; &#125; /** * 功能描述: 对arr[l...r]部分进行三路快速排序 * 将arr[l...r]分为 &lt; value、== value、&gt; value 三部分。 * @param: [arr, l, r] * @return: void * @auther: wjy * @date: 2020/2/13 11:09 */ public void recursion(int[] arr, int l, int r) &#123; if (r - l &lt;= 15) &#123; sort(arr, l, r); return; &#125; // partition SortHelper.swap(arr, l, (int) (Math.random() * (r - l + 1) + l)); // arr[l+1...lt] &lt; v、arr[lt+1...gt-1] == v、arr[gt...r] &gt; v。 int value = arr[l], lt = l, gt = r + 1, i = l + 1; while (i &lt; gt) &#123; if (arr[i] &lt; value) &#123; // 交换过来的arr[++lt]已经处理过，需要i++。 SortHelper.swap(arr, i++, ++lt); &#125; else if (arr[i] &gt; value) &#123; // 交换过来的arr[--gt]没有处理过，不需要i++。 SortHelper.swap(arr, i, --gt); &#125; else &#123; i++; &#125; &#125; // 将value移到分界处 SortHelper.swap(arr, l, lt); recursion(arr, l, lt - 1); recursion(arr, gt, r); &#125; @Override public void ascendSort(int[] arr, int n) &#123; recursion(arr, 0, n - 1); &#125;&#125; ③性能分析 稳定性：不稳定 是否是原地排序：否 平均时间复杂度：O（n*logn） 最好情况：O（n*logn）（顺序） 最坏情况：O（n^2）（逆序） 空间复杂度：O（logn）（递归） ④衍生问题 — 取数组中第 N 小的元素方法一（O（n^2））：排序后求解方法二（O（n*logn））：快速排序的思路求解数组中第 N 小的元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package sort.derivedquestion;import sort.util.RandomArray;import sort.util.SortHelper;/** * @author: wjy * @date: 2020/2/13 * @description: 求解数组中第N小的元素 */public class TopNByQuickSort &#123; /** * 功能描述: 对arr[l...r]部分进行partition操作 * * @param: [arr, l, r] * @return: int * @auther: wjy * @date: 2020/2/13 23:30 */ public static int partition(int[] arr, int l, int r) &#123; SortHelper.swap(arr, l, (int) (Math.random() * (r - l + 1) + l)); int value = arr[l], j = l; for (int i = l + 1; i &lt;= r; i++) &#123; if (arr[i] &lt; value) &#123; SortHelper.swap(arr, i, ++j); &#125; &#125; // 将value移到分界处 SortHelper.swap(arr, l, j); return j; &#125; /** * 功能描述: 对arr[l...r]部分进行快速排序，并寻找数组中第N小的元素。 * * @param: [arr, l, r, N] * @return: int * @auther: wjy * @date: 2020/2/13 23:31 */ public static int recursion(int[] arr, int l, int r, int N) &#123; if (l &gt;= r) &#123; return 0; &#125; int index = partition(arr, l, r), number = 0; if (index == N) &#123; number = arr[index]; &#125; else if (index &gt; N) &#123; number = recursion(arr, l, index - 1, N); &#125; else &#123; number = recursion(arr, index + 1, r, N); &#125; return number; &#125; public static void main(String[] args) &#123; int n = 5, N = (int) (Math.random() * n) + 1; int[] arr = RandomArray.generateRandomArray(n, 0, n); SortHelper.printArray(arr, n); System.out.println("数组中第" + N + "小的元素是: " + recursion(arr, 0, n - 1, N - 1)); &#125;&#125; 9.选择排序类 — 堆排序 基础的最大堆的构建和使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126package heap;import sort.util.SortHelper;/** * @author: wjy * @date: 2020/2/14 * @description: 最大堆(arr[1]处存储最大堆的第一个元素) */public class MaxHeap &#123; private int[] arr; private int count; private int capacity; public MaxHeap(int n) &#123; arr = new int[n + 1]; count = 0; this.capacity = n; &#125; /** * 功能描述: 向上调整最大堆(入队时调用) * * @param: [index] * @return: void * @auther: wjy * @date: 2020/2/14 7:44 */ public void shiftUp(int index) &#123; // 防止越界 while (index &gt; 1 &amp;&amp; arr[index / 2] &lt; arr[index]) &#123; SortHelper.swap(arr, index / 2, index); index /= 2; &#125; &#125; /** * 功能描述: 向下调整最大堆(出队时调用) * * @param: [index] * @return: void * @auther: wjy * @date: 2020/2/14 7:44 */ public void shiftDown(int index) &#123; // 判断是否有左孩子 while (index * 2 &lt;= count) &#123; // 哪个孩子大，就和哪个孩子交换。 int lc = index * 2, rc = lc + 1, res = lc; if (rc &lt;= count &amp;&amp; arr[rc] &gt; arr[lc]) &#123; res = rc; &#125; if (arr[index] &gt;= arr[res]) &#123; break; &#125; SortHelper.swap(arr, index, res); index = res; &#125; &#125; /** * 功能描述: 判断最大堆是否为空 * * @param: [] * @return: boolean * @auther: wjy * @date: 2020/2/14 7:49 */ public boolean isEmpty() &#123; return count == 0; &#125; /** * 功能描述: 打印最大堆 * * @param: [] * @return: void * @auther: wjy * @date: 2020/2/14 7:50 */ public void printArr() &#123; for (int i = 1; i &lt;= count; i++) &#123; System.out.print(arr[i] + " "); &#125; System.out.println(); &#125; /** * 功能描述: 入队 * * @param: [e] * @return: void * @auther: wjy * @date: 2020/2/14 10:14 */ public void insert(int e) &#123; if (count + 1 &gt; capacity) &#123; return; &#125; arr[++count] = e; shiftUp(count); &#125; /** * 功能描述: 出队 * 最大堆中只能取出根节点 * 为了维持完全二叉树的性质，将堆中最后一个元素移到根节点的位置，然后向下调整最大堆。 * * @param: [] * @return: int * @auther: wjy * @date: 2020/2/14 7:44 */ public int removeMax() &#123; if (count &lt; 1 ) &#123; return 0; &#125; // 取出根节点 int e = arr[1]; // 将堆中最后一个元素移到根节点的位置 SortHelper.swap(arr, 1, count--); shiftDown(1); return e; &#125;&#125; 改进的最大堆的构建和使用 1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132package heap;import sort.util.SortHelper;/** * @author: wjy * @date: 2020/2/14 * @description: 改进的最大堆1(arr[1]处存储最大堆的第一个元素) */public class AdvancedMaxHeap1 &#123; private int[] arr; private int count; private int capacity; public AdvancedMaxHeap1(int n) &#123; arr = new int[n + 1]; count = 0; this.capacity = n; &#125; /** * 功能描述: 向上调整最大堆(入队时调用) * * @param: [index] * @return: void * @auther: wjy * @date: 2020/2/14 7:44 */ public void shiftUp(int index) &#123; int e = arr[index]; // 防止越界 while (index &gt; 1 &amp;&amp; arr[index / 2] &lt; e) &#123; // 优化1: 使用赋值操作代替交换操作 arr[index] = arr[index / 2]; index /= 2; &#125; arr[index] = e; &#125; /** * 功能描述: 向下调整最大堆(出队时调用) * * @param: [index] * @return: void * @auther: wjy * @date: 2020/2/14 7:44 */ public void shiftDown(int index) &#123; int e = arr[index]; // 判断是否有左孩子 while (index * 2 &lt;= count) &#123; // 哪个孩子大，就和哪个孩子交换。 int lc = index * 2, rc = lc + 1, res = lc; if (rc &lt;= count &amp;&amp; arr[rc] &gt; arr[lc]) &#123; res = rc; &#125; if (e &gt;= arr[res]) &#123; break; &#125; // 优化1: 使用赋值操作代替交换操作 arr[index] = arr[res]; index = res; &#125; arr[index] = e; &#125; /** * 功能描述: 判断最大堆是否为空 * * @param: [] * @return: boolean * @auther: wjy * @date: 2020/2/14 7:49 */ public boolean isEmpty() &#123; return count == 0; &#125; /** * 功能描述: 打印最大堆 * * @param: [] * @return: void * @auther: wjy * @date: 2020/2/14 7:50 */ public void printArr() &#123; for (int i = 1; i &lt;= count; i++) &#123; System.out.print(arr[i] + " "); &#125; System.out.println(); &#125; /** * 功能描述: 入队 * * @param: [e] * @return: void * @auther: wjy * @date: 2020/2/14 10:14 */ public void insert(int e) &#123; if (count + 1 &gt; capacity) &#123; return; &#125; arr[++count] = e; shiftUp(count); &#125; /** * 功能描述: 出队 * 最大堆中只能取出根节点 * 为了维持完全二叉树的性质，将堆中最后一个元素移到根节点的位置，然后向下调整最大堆。 * * @param: [] * @return: int * @auther: wjy * @date: 2020/2/14 7:44 */ public int removeMax() &#123; if (count &lt; 1 ) &#123; return 0; &#125; // 取出根节点 int e = arr[1]; // 将堆中最后一个元素移到根节点的位置 SortHelper.swap(arr, 1, count--); shiftDown(1); return e; &#125;&#125; 改进的最大堆的构建和使用 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package heap;import sort.util.SortHelper;/** * @author: wjy * @date: 2020/2/14 * @description: 改进的最大堆2(arr[1]处存储最大堆的第一个元素) */public class AdvancedMaxHeap2 &#123; private int[] arr; private int count; // 优化2: 修改构造函数，直接向下调整最大堆。 public AdvancedMaxHeap2(int[] data, int n) &#123; arr = new int[n + 1]; for (int i = 0; i &lt; n; i++) &#123; arr[i + 1] = data[i]; &#125; count = n; // heapify: 将数组原地构建成最大堆 // 所有的叶子节点本身就是一个最大堆，所以我们从第一个不是叶子节点的节点开始调整堆。 // 对于一颗完全二叉树来说，第一个非叶子节点的索引: count/2。 for (int i = count / 2; i &gt; 0; i--) &#123; shiftDown(i); &#125; &#125; /** * 功能描述: 向下调整最大堆(出队时调用) * * @param: [index] * @return: void * @auther: wjy * @date: 2020/2/14 7:44 */ public void shiftDown(int index) &#123; int e = arr[index]; // 判断是否有左孩子 while (index * 2 &lt;= count) &#123; // 哪个孩子大，就和哪个孩子交换。 int lc = index * 2, rc = lc + 1, res = lc; if (rc &lt;= count &amp;&amp; arr[rc] &gt; arr[lc]) &#123; res = rc; &#125; if (e &gt;= arr[res]) &#123; break; &#125; // 优化1: 使用赋值操作代替交换操作 arr[index] = arr[res]; index = res; &#125; arr[index] = e; &#125; /** * 功能描述: 判断最大堆是否为空 * * @param: [] * @return: boolean * @auther: wjy * @date: 2020/2/14 7:49 */ public boolean isEmpty() &#123; return count == 0; &#125; /** * 功能描述: 打印最大堆 * * @param: [] * @return: void * @auther: wjy * @date: 2020/2/14 7:50 */ public void printArr() &#123; for (int i = 1; i &lt;= count; i++) &#123; System.out.print(arr[i] + " "); &#125; System.out.println(); &#125; /** * 功能描述: 出队 * 最大堆中只能取出根节点 * 为了维持完全二叉树的性质，将堆中最后一个元素移到根节点的位置，然后向下调整最大堆。 * * @param: [] * @return: int * @auther: wjy * @date: 2020/2/14 7:44 */ public int removeMax() &#123; if (count &lt; 1 ) &#123; return 0; &#125; // 取出根节点 int e = arr[1]; // 将堆中最后一个元素移到根节点的位置 SortHelper.swap(arr, 1, count--); shiftDown(1); return e; &#125;&#125; 测试最大堆的构建和使用 12345678910111213141516171819202122232425262728293031323334353637383940414243package heap;/** * @author: wjy * @date: 2020/2/14 * @description: 测试最大堆的构建和使用 */public class TestMaxHeap &#123; public static void main(String[] args) &#123; int n = 10; System.out.println("----------测试MaxHeap类----------"); MaxHeap maxHeap = new MaxHeap(n); for (int i = 0; i &lt; n; i++) &#123; maxHeap.insert((int) (Math.random() * 20)); &#125; while (!maxHeap.isEmpty()) &#123; System.out.print(maxHeap.removeMax() + " "); &#125; System.out.println(); System.out.println("----------测试AdvancedMaxHeap1类----------"); AdvancedMaxHeap1 advancedMaxHeap1 = new AdvancedMaxHeap1(n); for (int i = 0; i &lt; n; i++) &#123; advancedMaxHeap1.insert((int) (Math.random() * 20)); &#125; while (!advancedMaxHeap1.isEmpty()) &#123; System.out.print(advancedMaxHeap1.removeMax() + " "); &#125; System.out.println(); System.out.println("----------测试AdvancedMaxHeap2类----------"); int[] arr = new int[n]; for (int i = 0; i &lt; n; i++) &#123; arr[i] = ((int) (Math.random() * 20)); &#125; AdvancedMaxHeap2 advancedMaxHeap2 = new AdvancedMaxHeap2(arr, n); while (!advancedMaxHeap2.isEmpty()) &#123; System.out.print(advancedMaxHeap2.removeMax() + " "); &#125; System.out.println(); &#125;&#125; ①排序思路 堆最重要的应用是对动态数据的维护 方法： 堆排序： 方法：将 n 个元素逐个插入到一个空堆（最大堆，arr[1] 处存储最大堆的第一个元素）中，算法的时间复杂度是 O（n*logn），然后将堆中的元素逐个移出，使用额外的空间从后向前存放取出的元素。 未优化的堆排序慢于快速排序和归并排序 缺点：空间复杂度为 O（n） 改进的堆排序 1： 优化 1：使用赋值操作代替交换操作 优化 2：将数组原地构建成最大堆（只需要处理 n / 2 个元素） 优化建堆的堆排序整体速度慢于快速排序和归并排序。 改进的堆排序 2： 原地堆排序，arr[0] 处存储最大堆的第一个元素。 不占用额外空间的堆排序比占用额外空间的堆排序快一点 ②代码演示 堆排序 12345678910111213141516171819202122232425package sort.selectsort;import heap.AdvancedMaxHeap1;import sort.Sort;/** * @author: wjy * @date: 2020/2/11 * @description: 选择排序类-堆排序 */public class HeapSort implements Sort &#123; @Override public void ascendSort(int[] arr, int n) &#123; AdvancedMaxHeap1 advancedMaxHeap1 = new AdvancedMaxHeap1(n); // 构建最大堆 for (int i = 0; i &lt; n; i++) &#123; advancedMaxHeap1.insert(arr[i]); &#125; // 堆排序 for (int i = n - 1; i &gt;= 0; i--) &#123; arr[i] = advancedMaxHeap1.removeMax(); &#125; &#125;&#125; 改进的堆排序 1 1234567891011121314151617181920package sort.selectsort;import heap.AdvancedMaxHeap2;import sort.Sort;/** * @author: wjy * @date: 2020/2/14 * @description: 选择排序类-改进的堆排序1 */public class AdvancedHeapSort1 implements Sort &#123; @Override public void ascendSort(int[] arr, int n) &#123; AdvancedMaxHeap2 advancedMaxHeap2 = new AdvancedMaxHeap2(arr, n); for (int i = n - 1; i &gt;= 0; i--) &#123; arr[i] = advancedMaxHeap2.removeMax(); &#125; &#125;&#125; 改进的堆排序 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package sort.selectsort;import sort.Sort;import sort.util.SortHelper;/** * @author: wjy * @date: 2020/2/14 * @description: 选择排序类-改进的堆排序2(原地堆排序、arr[0]处存储最大堆的第一个元素) */public class AdvancedHeapSort2 implements Sort &#123; /** * 功能描述: 向下调整最大堆(出队时调用) * * @param: [arr, n, index] * @return: void * @auther: wjy * @date: 2020/2/14 11:17 */ public void shiftDown(int[] arr, int n, int index) &#123; int e = arr[index]; // 判断是否有左孩子 while (index * 2 + 1 &lt; n) &#123; // 哪个孩子大，就和哪个孩子交换。 int lc = index * 2 + 1, rc = lc + 1, res = lc; if (rc &lt; n &amp;&amp; arr[rc] &gt; arr[lc]) &#123; res = rc; &#125; if (e &gt;= arr[res]) &#123; break; &#125; arr[index] = arr[res]; index = res; &#125; arr[index] = e; &#125; @Override public void ascendSort(int[] arr, int n) &#123; // heapify: 将数组原地构建成最大堆 // 最后一个非叶子节点的索引计算: (最后一个元素索引值-1)/2 for (int i = (n - 1 - 1) / 2; i &gt;= 0; i--) &#123; shiftDown(arr, n, i); &#125; // 最大堆中第一个元素即是数组中的最大值，每次将堆中第一个元素与数组末尾的元素交换，再动态维护堆(数组长度-1)。 for (int i = n - 1; i &gt; 0; i--) &#123; // 将当前最大堆中的最大值移到数组末尾 SortHelper.swap(arr, 0, i); // 重新构建最大堆 shiftDown(arr, i, 0); &#125; &#125;&#125; ③性能分析 稳定性：不稳定 是否是原地排序：是 平均时间复杂度：O（n*logn） 最好的情况：O（n*logn）（顺序） 最坏的情况：O（n*logn）（逆序） 空间复杂度：O（1） 10.性能比较①排序随机数组 测试各个排序算法针对随机数组的排序性能 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package sort;import sort.insertsort.DirectInsertSort;import sort.insertsort.ShellSort;import sort.mergesort.AdvancedIterationMergeSort;import sort.mergesort.AdvancedMergeSort;import sort.mergesort.IterationMergeSort;import sort.mergesort.MergeSort;import sort.selectsort.AdvancedHeapSort1;import sort.selectsort.AdvancedHeapSort2;import sort.selectsort.HeapSort;import sort.selectsort.SimpleSelectSort;import sort.swapsort.*;import sort.util.RandomArray;import java.util.Arrays;/** * @author: wjy * @date: 2020/2/11 * @description: 测试各个排序算法针对随机数组的排序性能 */public class TestRandomArray &#123; public static void main(String[] args) &#123; System.out.println("----------随机数组的长度是1000，范围是0~1000。----------"); int n = 1000; // 随机数组的长度是1000，范围是0~1000。 int[] arr = RandomArray.generateRandomArray(n, 0, 1000); TestSort.testSort("简单交换排序", new SimpleSwapSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("传统的冒泡排序", new BubbleSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("改进的冒泡排序", new AdvancedBubbleSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("简单选择排序", new SimpleSelectSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("直接插入排序", new DirectInsertSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("希尔排序", new ShellSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("归并排序", new MergeSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("改进的归并排序", new AdvancedMergeSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("自底向上的归并排序", new IterationMergeSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("改进的自底向上的归并排序", new AdvancedIterationMergeSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("快速排序", new QuickSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("改进的快速排序", new AdvancedQuickSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("双路快速排序", new QuickSort2Ways(), Arrays.copyOf(arr, n), n); TestSort.testSort("三路快速排序", new QuickSort3Ways(), Arrays.copyOf(arr, n), n); TestSort.testSort("堆排序", new HeapSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("改进的堆排序1", new AdvancedHeapSort1(), Arrays.copyOf(arr, n), n); TestSort.testSort("改进的堆排序2", new AdvancedHeapSort2(), Arrays.copyOf(arr, n), n); System.out.println("----------随机数组的长度是100000，范围是0~100000。----------"); n = 100000; // 随机数组的长度是100000，范围是0~100000。 arr = RandomArray.generateRandomArray(n, 0, 100000); TestSort.testSort("简单交换排序", new SimpleSwapSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("传统的冒泡排序", new BubbleSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("改进的冒泡排序", new AdvancedBubbleSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("简单选择排序", new SimpleSelectSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("直接插入排序", new DirectInsertSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("希尔排序", new ShellSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("归并排序", new MergeSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("改进的归并排序", new AdvancedMergeSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("自底向上的归并排序", new IterationMergeSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("改进的自底向上的归并排序", new AdvancedIterationMergeSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("快速排序", new QuickSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("改进的快速排序", new AdvancedQuickSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("双路快速排序", new QuickSort2Ways(), Arrays.copyOf(arr, n), n); TestSort.testSort("三路快速排序", new QuickSort3Ways(), Arrays.copyOf(arr, n), n); TestSort.testSort("堆排序", new HeapSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("改进的堆排序1", new AdvancedHeapSort1(), Arrays.copyOf(arr, n), n); TestSort.testSort("改进的堆排序2", new AdvancedHeapSort2(), Arrays.copyOf(arr, n), n); &#125;&#125; ②排序近乎有序的数组 测试各个排序算法针对近乎有序的数组的排序性能 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package sort;import sort.insertsort.DirectInsertSort;import sort.insertsort.ShellSort;import sort.mergesort.AdvancedIterationMergeSort;import sort.mergesort.AdvancedMergeSort;import sort.mergesort.IterationMergeSort;import sort.mergesort.MergeSort;import sort.selectsort.AdvancedHeapSort1;import sort.selectsort.AdvancedHeapSort2;import sort.selectsort.HeapSort;import sort.selectsort.SimpleSelectSort;import sort.swapsort.*;import sort.util.RandomArray;import java.util.Arrays;/** * @author: wjy * @date: 2020/2/11 * @description: 测试各个排序算法针对近乎有序的数组的排序性能 */public class TestNearlyRandomArray &#123; public static void main(String[] args) &#123; System.out.println("----------随机数组的长度是1000，并且定义逆序对个数为10。----------"); int n = 1000; // 随机数组的长度是1000，并且定义逆序对个数为10。 int[] arr = RandomArray.generateNearlyRandomArray(n, 10); TestSort.testSort("简单交换排序", new SimpleSwapSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("传统的冒泡排序", new BubbleSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("改进的冒泡排序", new AdvancedBubbleSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("简单选择排序", new SimpleSelectSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("直接插入排序", new DirectInsertSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("希尔排序", new ShellSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("归并排序", new MergeSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("改进的归并排序", new AdvancedMergeSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("自底向上的归并排序", new IterationMergeSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("改进的自底向上的归并排序", new AdvancedIterationMergeSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("快速排序", new QuickSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("改进的快速排序", new AdvancedQuickSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("双路快速排序", new QuickSort2Ways(), Arrays.copyOf(arr, n), n); TestSort.testSort("三路快速排序", new QuickSort3Ways(), Arrays.copyOf(arr, n), n); TestSort.testSort("堆排序", new HeapSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("改进的堆排序1", new AdvancedHeapSort1(), Arrays.copyOf(arr, n), n); TestSort.testSort("改进的堆排序2", new AdvancedHeapSort2(), Arrays.copyOf(arr, n), n); System.out.println("----------随机数组的长度是100000，并且定义逆序对个数为1000。----------"); n = 100000; // 随机数组的长度是100000，并且定义逆序对个数为1000。 arr = RandomArray.generateNearlyRandomArray(n, 1000); TestSort.testSort("简单交换排序", new SimpleSwapSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("传统的冒泡排序", new BubbleSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("改进的冒泡排序", new AdvancedBubbleSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("简单选择排序", new SimpleSelectSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("直接插入排序", new DirectInsertSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("希尔排序", new ShellSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("归并排序", new MergeSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("改进的归并排序", new AdvancedMergeSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("自底向上的归并排序", new IterationMergeSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("改进的自底向上的归并排序", new AdvancedIterationMergeSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("快速排序", new QuickSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("改进的快速排序", new AdvancedQuickSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("双路快速排序", new QuickSort2Ways(), Arrays.copyOf(arr, n), n); TestSort.testSort("三路快速排序", new QuickSort3Ways(), Arrays.copyOf(arr, n), n); TestSort.testSort("堆排序", new HeapSort(), Arrays.copyOf(arr, n), n); TestSort.testSort("改进的堆排序1", new AdvancedHeapSort1(), Arrays.copyOf(arr, n), n); TestSort.testSort("改进的堆排序2", new AdvancedHeapSort2(), Arrays.copyOf(arr, n), n); &#125;&#125; ③总结 每一种排序算法都有它存在的理由，没有一种排序算法在任何情况下的表现都是最好的，排序算法的具体性能依赖于待排数据的特点。 排序算法对比（图片来源于网络）： 排序算法的应用场景（图片来源于网络）： 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#121;&#109;&#x65;&#x73;&#x73;&#x69;&#64;&#49;&#x36;&#x33;&#x2e;&#99;&#x6f;&#109; 关于 数据结构与算法 的更多代码 请查看我的 GitHub仓库]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络之HTTP协议]]></title>
    <url>%2F2019%2F10%2F12%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"></content>
      <categories>
        <category>计算机网络</category>
        <category>协议</category>
      </categories>
      <tags>
        <tag>计算机网络—协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat+Nginx配置HTTPS]]></title>
    <url>%2F2019%2F09%2F13%2FTomcat-Nginx%E9%85%8D%E7%BD%AEHTTPS%2F</url>
    <content type="text"><![CDATA[ps：每次修改配置后，需要重启 Nginx。命令：systemctl restart nginx。Nginx 的配置文件：/etc/nginx/nginx.conf。 1.相关博客 阿里云CentOS7安装Nginx Nginx之访问服务器静态资源 Nginx之rewrite配置域名跳转 2.准备SSL证书 在域名备案的前提下，我们需要购买 SSL 证书。一般情况下，购买免费版即可。 ①什么是SSL证书 ②准备过程 进入阿里云控制台 购买免费版 SSL 证书 然后在签发后下载 Nginx 服务器类型的证书并上传到服务器 3.具体配置①强制HTTPS（可选） 把 HTTP 的域名请求转成 HTTPS 123456server &#123; listen 80; server_name a.com; # 使用证书绑定的域名替换localhost return 301 https://$server_name$request_uri; # 返回301状态码进行跳转被Google认为是将网站地址由HTTP迁移到HTTPS的最佳方法&#125; ②开启HTTPS 12345678910111213141516171819202122server &#123; listen 443 ssl; # 监听433端口 server_name a.com; # 证书绑定的域名 ssl on; ssl_certificate /usr/local/javaweb/cert/2557101_a.com.pem; # 证书的文件名 ssl_certificate_key /usr/local/javaweb/cert/2557101_a.com.key; # 证书的密钥文件名 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; proxy_pass http://127.0.0.1:8080; # 对应tomcat的端口号 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Forwarded-Proto https; proxy_redirect off; proxy_connect_timeout 240; proxy_send_timeout 240; proxy_read_timeout 240; &#125;&#125; 配置成功 4.工作原理 浏览器发送的请求是发送到 Nginx 的，Nginx 作为代理服务器再转发到 Tomcat，浏览器和 Nginx 之间以 HTTPS 协议传输数据，而 Nginx 和 Tomcat 之间通过 proxy_pass 以 HTTP 协议传输数据。Nginx 是中间的代理服务器。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#x79;&#x6d;&#x65;&#115;&#x73;&#105;&#x40;&#49;&#54;&#51;&#x2e;&#99;&#x6f;&#x6d;]]></content>
      <categories>
        <category>操作系统</category>
        <category>服务器相关</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx之rewrite配置域名跳转]]></title>
    <url>%2F2019%2F09%2F12%2FNginx%E4%B9%8Brewrite%E9%85%8D%E7%BD%AE%E5%9F%9F%E5%90%8D%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[ps：每次修改配置后，需要重启 Nginx。命令：systemctl restart nginx。Nginx 的配置文件：/etc/nginx/nginx.conf。 1.相关博客 阿里云CentOS7安装Nginx Nginx之访问服务器静态资源 Tomcat+Nginx配置HTTPS 2.语法格式 rewrite 作用：将某个 URL 重写为特定的 URL 语法格式：rewrite（关键字） &lt;regex&gt;（正则表达式） &lt;replacement&gt;（替代内容） 根据 正则表达式 重定向到 replacement 3.对a域名的访问全部redirect到b域名 配置前 server 中不允许存在 location / { ... } 配置示例 123location / &#123; rewrite ^/(.*) http://1000.xidian.edu.cn/$1;&#125; 跳转前：http://a.com/index.php/Request/… 跳转后： 通过 location / 匹配所有以 / 开头的请求（即所有请求） rewrite 为固定关键字 regex 部分表示匹配完整的域名和之后的路径 replacement 部分中的 $1 取自 regex 部分 ( ) 中的内容 即 nginx 将 a.com/ 之后的路径拼接到了 http://1000.xidian.edu.cn/ 后 4.对a域名的不同访问redirect到不同域名①应用场景 同一个域名下的不同 URL 需要跳转到不同的域名下 ②示例一123location /xiaoyuan/ &#123; rewrite ^/xiaoyuan(.*) http://ehall.xidian.edu.cn$1;&#125; 跳转前：http://a.com/xiaoyuan/jwapp/sys/cjcx 跳转后： 通过 location /xiaoyuan/ 匹配所有以 /xiaoyuan/ 开头的请求 rewrite 为固定关键字 regex 部分表示匹配完整的域名和之后的路径 replacement 部分中的 $1 取自 regex 部分 ( ) 中的内容 即 nginx 将 a.com/xiaoyuan 之后的路径拼接到了 http://ehall.xidian.edu.cn 后 ③示例二123location /houqin/ &#123; rewrite ^/houqin(.*) http://1000.xidian.edu.cn$1;&#125; 跳转前：http://a.com/houqin/index.php/Request/... 跳转后： 通过 location /houqin/ 匹配所有以 /houqin/ 开头的请求 rewrite 为固定关键字 regex 部分表示匹配完整的域名和之后的路径 replacement 部分中的 $1 取自 regex 部分 ( ) 中的内容 即 nginx 将 a.com/houqin 之后的路径拼接到了 http://1000.xidian.edu.cn 后 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#121;&#x6d;&#101;&#x73;&#115;&#105;&#64;&#x31;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;]]></content>
      <categories>
        <category>操作系统</category>
        <category>服务器相关</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx之访问服务器静态资源]]></title>
    <url>%2F2019%2F09%2F12%2FNginx%E4%B9%8B%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[ps：每次修改配置后，需要重启 Nginx。命令：systemctl restart nginx。Nginx 的配置文件：/etc/nginx/nginx.conf。 1.相关博客 阿里云CentOS7安装Nginx Tomcat+Nginx配置HTTPS Nginx之rewrite配置域名跳转 2.通过域名/文件名.文件类型的URL格式访问 应用场景：小程序业务域名的验证。 ①方法一 当 server 的配置中不存在 location / { ... } 时 配置示例 123456server &#123; listen 80 default_server; # 监听80端口 server_name localhost; # 可自定义域名 root /usr; # 注意：/usr为文件所在目录,可任意设置 # root /; # 当文件在根目录时如此配置&#125; ②方法二 当 server 的配置中存在 location / { ... } 时 配置示例 1234567在server中添加：location /文件名.文件类型 &#123; root /usr; # 注意：/usr为文件所在目录,可任意设置 # root /; # 当文件在根目录时如此配置 expires 30d; access_log off;&#125; 通过 /文件名.文件类型 匹配以 /文件名.文件类型 开头的请求 ③验证配置 3.通过域名/自定义/文件名.文件类型的URL格式访问 应用场景：搭建 Nginx 图片服务器。 配置示例 12345location /images/ &#123; root /usr/local/javaweb/xdxlb/; # 将/images/映射到/usr/local/javaweb/xdxlb/images/ autoindex on; # 打开浏览功能&#125; 通过 location /images/ 匹配所有以 /images/ 开头的请求 验证配置： 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#x79;&#x6d;&#x65;&#x73;&#x73;&#105;&#x40;&#x31;&#54;&#51;&#x2e;&#99;&#x6f;&#x6d;]]></content>
      <categories>
        <category>操作系统</category>
        <category>服务器相关</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java发起HTTP请求的工具类]]></title>
    <url>%2F2019%2F08%2F15%2FJava%E5%8F%91%E8%B5%B7HTTP%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[ps：CloseableHttpClient 是 HttpClient 接口的实现类 1.发起GET请求①无参数的GET请求123456789101112/** * 功能描述: 无参数的GET请求 * * @param: [url] * @return: java.lang.String * @auther: wjy * @date: 2019/5/31 22:06 */public static String doGet(String url) &#123; return doGet(url, null);&#125; ②有参数的GET请求12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 功能描述: 有参数的GET请求 * * @param: [url, param] * @return: java.lang.String * @auther: wjy * @date: 2019/5/31 22:05 */ public static String doGet(String url, LinkedHashMap&lt;String, String&gt; param) &#123; // 创建HttpClient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); CloseableHttpResponse response = null; // GET请求的返回内容 String resultString = ""; try &#123; URIBuilder builder = new URIBuilder(url); // 设置请求参数 if (param != null) &#123; for (String key : param.keySet()) &#123; builder.addParameter(key, param.get(key)); &#125; &#125; // 构建一个URI对象 URI uri = builder.build(); // 创建GET请求 HttpGet httpGet = new HttpGet(uri); // 执行GET请求 response = httpClient.execute(httpGet); // 获取响应状态码 if (response.getStatusLine().getStatusCode() == 200) &#123; resultString = EntityUtils.toString(response.getEntity(), "UTF-8"); &#125; &#125; catch (URISyntaxException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; log.error("GET Method Catch Unexception Hanlder:&#123;&#125;, message:&#123;&#125;", e, e.getMessage()); throw new ServiceException(e.getMessage()); &#125; finally &#123; try &#123; if (response != null) &#123; response.close(); &#125; httpClient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return resultString; &#125; 2.发起POST请求①参数为Map对象的POST请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 功能描述: 有参数(Map对象)的POST请求 * * @param: [url, param] * @return: java.lang.String * @auther: wjy * @date: 2019/5/31 22:06 */ public static String doPost(String url, Map&lt;String, String&gt; param) &#123; // 创建HttpClient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); CloseableHttpResponse response = null; // POST请求的返回内容 String resultString = ""; try &#123; // 创建POST请求 HttpPost httpPost = new HttpPost(url); // 创建请求参数列表 if (param != null) &#123; List&lt;NameValuePair&gt; paramList = new ArrayList&lt;&gt;(); for (String key : param.keySet()) &#123; paramList.add(new BasicNameValuePair(key, param.get(key))); &#125; // 构造form表单式的实体 UrlEncodedFormEntity entity = new UrlEncodedFormEntity(paramList); httpPost.setEntity(entity); &#125; // 执行POST请求 response = httpClient.execute(httpPost); // 获取响应状态码 if (response.getStatusLine().getStatusCode() == 200) &#123; resultString = EntityUtils.toString(response.getEntity(), "UTF-8"); &#125; &#125; catch (IOException e) &#123; log.error("POST Method Catch Unexception Hanlder:&#123;&#125;, message:&#123;&#125;", e, e.getMessage()); throw new ServiceException(e.getMessage()); &#125; finally &#123; try &#123; if (response != null) &#123; response.close(); &#125; httpClient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return resultString; &#125; ②参数为JSON字符串的POST请求12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 功能描述: 有参数(Json字符串)的POST请求 * * @param: [url, jsonData] * @return: java.lang.String * @author: wjy * @date: 2019/6/25 17:39 */public static String doPost(String url, String jsonData) &#123; // 创建HttpClient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); CloseableHttpResponse response = null; // POST请求的返回内容 String resultString = ""; try &#123; // 创建POST请求 HttpPost httpPost = new HttpPost(url); // 解析Json数据并构造实体 StringEntity stringEntity = new StringEntity(jsonData, ContentType.APPLICATION_JSON); httpPost.setEntity(stringEntity); // 执行POST请求 response = httpClient.execute(httpPost); // 获取响应状态码 if (response.getStatusLine().getStatusCode() == 200) &#123; resultString = EntityUtils.toString(response.getEntity(), "UTF-8"); &#125; &#125; catch (IOException e) &#123; log.error("POST Method Catch Exception Handler:&#123;&#125;, message:&#123;&#125;", e, e.getMessage()); &#125; finally &#123; try &#123; if (response != null) &#123; response.close(); &#125; httpClient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return resultString;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#x6a;&#121;&#x6d;&#x65;&#x73;&#x73;&#x69;&#x40;&#x31;&#x36;&#x33;&#46;&#x63;&#111;&#109;]]></content>
      <categories>
        <category>Java</category>
        <category>进阶内容</category>
      </categories>
      <tags>
        <tag>Java进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb开发总结]]></title>
    <url>%2F2019%2F08%2F12%2FJavaWeb%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1.开发环境①开发必备 Java 版本：JDK8 Web 服务器：Tomcat9（运行后端）、Nginx（前端请求转发和搭建图片服务器） 工程框架：Spring Boot 2.0 操作数据库：Spring Boot Jpa（优先） / Mybatis 其他：Lombok 插件、JSON（fastjson / jackson） ②数据库 MySQL（主 db） Redis（处理缓存） MongoDB （特殊需求使用） ③编译器&amp;构建工具&amp;测试工具 IDEA maven（优先） / gradle Postman 2.框架分层①总览 common（公共包） enums（枚举类） exception（全局异常处理） interceptor（拦截器） jpa（jpa 配置） log（AOP 方式的日志埋点） utils（工具类） controller（控制层） model（DAO 层） dto（数据传输对象） entity（数据库实体类） repository / mapper（数据库操作层） service（服务层) base（基础服务） impl（业务服务实现类） resources（资源目录） application.yml（切换配置文件） application-dev.yml（本地配置文件） application-pro.yml （服务器配置文件） ②common层 ResultEnum 类：用于存放前端请求的响应 / 执行结果 注意枚举类定义格式 私有变量名不能定义为 name ③controller层 调用 service 层方法 提供对外暴露的接口 ④model层 ResultDTO 类：统一使用此类将数据封装好返回给前端 关于使用 DTO：从数据库中查出的是一个完整的对象，而大多数时候只会用到某些字段，这时候需要 DTO。 3.代码规范①注释 类注释（配置模板） 123456/** * @功能名称: HttpClient(举例) * @文件名称: HttpUtil.java(举例) * @Date: $date$ $time$ * @Author: 自定义 */ 方法注释（配置模板） 12345678/** * 功能描述: * * @param: $param$ * @return: $return$ * @auther: 自定义 * @date: $date$ $time$ */ 变量注释 123/** * 文字 */ 方法内注释 1// 文字 ②注解 自动装配用 @Autowired 注解 其 byType 注入 注解在字段上 @component：泛指组件 把普通 POJO 实例化到 spring 容器中 @Service：用于标注业务层组件 @RestController：用于标注控制层组件 @Repository：用于标注数据访问组件 即 DAO 组件 @RequestMapping(value = “/URI”)：标注控制层组件中的方法 @GetMapping(value = “/URI”)：标注控制层组件中的方法 @PostMapping(value = “/URI”)：标注控制层组件中的方法 @RequestParam：用于标注控制层组件的方法的参数 参数名与前端传来的必须吻合 若是不吻合 需要加 value = “…” 使参数名一一对应 ③配置文件 application.yml：总控制文件 可随时切换为本地 / 服务器的配置文件 便于开发 123spring: profiles: active: dev/pro application-dev.yml 12345678910111213141516171819202122232425262728293031323334353637383940server: port: 本地访问端口号spring: # MySQL数据库配置 datasource: driverClass: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/数据库名?characterEncoding=utf-8&amp;serverTimezone=GMT%2B8 username: root password: 自定义 # Redis配置 redis: database: 0 host: 127.0.0.1 port: 6379 password: 自定义 # MongoDB配置 data: mongodb: uri: mongodb://用户名:密码@localhost:27017/数据库名 # jpa配置 jpa: hibernate: # 在程序启动时更新实体类对应的表 ddl-auto: update # 在日志中打印出执行的SQL语句信息 show-sql: true naming: physical-strategy: org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy # mybatis配置 mybatis: type-aliases-package: 数据库实体类所在包 # 下划线自动转驼峰 configuration: map-underscore-to-camel-case: true use-generated-keys: true # jackson配置 jackson: serialization: indent-output: true application-pro.yml 123456789101112131415161718192021server: port: 服务器端口号spring: # MySQL数据库配置 datasource: driverClass: com.mysql.cj.jdbc.Driver url: jdbc:mysql://服务器公网ip:3306/数据库名?characterEncoding=utf-8&amp;serverTimezone=GMT%2B8&amp;useSSL=true username: root password: 自定义 # Redis配置 redis: database: 0 host: 服务器公网ip port: 6379 password: 自定义 # MongoDB配置 data: mongodb: uri: mongodb://用户名:密码@服务器ip:27017/数据库名 ...其他如上 ④pom.xml（maven）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MySQL --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- MongoDB --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- jpa --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- lombok插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- httpclient --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- maven插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- 解决项目启动bug --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; ⑤其他 将私有常量值单独定义在类的开头 公有常量值定义在公有枚举类中 工具类一般不需要被注入或构造 只包含普通的类方法 所有需要注入的类，都应该放到 Service 目录下 除 db 对象外 尽量使用全参构造对象 尽量消除魔法值 可使用枚举类封装 遵循《阿里巴巴Java代码开发规范》进行开发 4.安装插件 安装插件：Settings —&gt; Plugins —&gt; Marketplace —&gt; 查找所需插件 —&gt; Install 查看安装的所有插件： 安装后需要重启 IDEA ①Lombok 以简单的注解形式来简化 Java 代码，提高开发人员的开发效率。 @Getter：注解在类上 为类提供 get 方法 @Setter：注解在类上 为类提供 set 方法 @Data：注解在类上 为类提供读写属性 此外还提供了equals()、hashCode()、toString() 方法 @AllArgsConstructor：注解在类上 为类提供一个全参的构造方法 @NoArgsConstructor：注解在类上 为类提供一个无参的构造方法 @Slf4j：注解在类上 为类提供一个属性名为 log 的 log4j 日志对象 @Slf4j 相当于 private static final Logger log = LoggerFactory.getLogger(CategoryServiceImpl.class); ②Alibaba Java Coding Guidelines 阿里巴巴 Java 代码规约检测 使用插件： ③Grep Console 可以将不同级别的日志通过颜色区分，便于查看。 配置各级日志的颜色： 5.前后端交互①交互流程1.通过原型图确定产品功能（明确每个细节）2.后端撰写 API 文档及建表3.前后端按照 API 文档各自开发4.测试 ②API文档 ShowDoc 举例： ③RESTful API 后端撰写请求 URL 时 必须遵守 RESTful API 设计规范 举例： 6.关于团队协作（git） GitHub 客户端每次只能 commit 一个文件，不利于版本回滚和团队协作，所以尽量使用 git 命令行。 ①git同步流程 一般开发完成、但还没有测试的文件都会被提交到暂存区 将暂存区的文件（测试好的）提交到本地仓库 通过 git push 提交修改到远程仓库 ②git常用命令 git add 文件名：将本地某个文件添加到暂存区 git add *：将本地所有文件添加到暂存区 git commit -m “本次提交说明（自定义）”：将暂存区文件提交到本地仓库 git push -u origin master：使用本地 master 分支来更新远程 master 分支（远程仓库） git reset HEAD 文件名（将暂存区的内容还原为最后一次提交的内容） git checkout – 文件名（将工作区的内容还原为最后一次提交的内容） git tag -a name -m “comment”：新建标签并指定提交信息 git tag -d name：删除标签 git branch：查看当前所有分支 git branch name：创建分支 git checkout name：进入分支 通过两种方式克隆仓库： Clone with SSH：git clone git@github.com:messi1002/leetcode.git Clone with HTTPS：git clone https://github.com/messi1002/leetcode.git ③git高级操作 git stash save “注释”：将工作区和暂存区的新内容暂时保存在栈中 git stash list：显示缓存堆栈中的内容 git stash pop：将缓存堆栈中的第一个 stash 内容恢复到工作区后删除 git commit –amend：将缓存区的内容补充到上次 commit 并可以修改上次 commit 的描述（用来修复最近一次 commit） git rebase -i [startpoint] [endpoint]：每一个功能开发完成后 对多个 commit 进行合并处理（变基） 123[startpoint] 和 [endpoint] 指定了一个编辑区间，前开后闭。如果不指定 [endpoint]，则该区间的终点默认是当前分支 HEAD 所指向的 commit。进入编辑页面后，按照指令说明修改指令即可。 7.入门博客汇总 StringUtils用法+StringUtils详细介绍 Java 枚举类Enum的用法总结 Spring Boot 中 Redis 的使用 如何使用RedisTemplate访问Redis数据结构 Spring Boot中使用Redis数据库 Spring Boot中快速操作Mongodb Spring Boot 中 MongoDB 的使用 Spring Boot Jpa 的使用 如何优雅的使用 Mybatis MyBatis中Like语句使用方式 Java 开发工具–Lombok 介绍 Spring Boot中Jackson应用详解 JSON框架之阿里fastjson的介绍 RESTful API 设计规范 Git—版本控制工具 Git教程 上传图片到七牛云（前端和后端） 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#121;&#109;&#101;&#x73;&#115;&#105;&#64;&#49;&#54;&#x33;&#x2e;&#99;&#x6f;&#109;]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>总结&amp;其他</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker入门]]></title>
    <url>%2F2019%2F07%2F20%2FDocker%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1.什么是 Docker①作用 解决了大部分企业的痛点：快速的持续集成、服务的弹性伸缩、部署简单、解放运维、为企业节省了机器资源。 目前京东、阿里、腾讯等公司已经在生产环境中大规模的使用 Docker。 ②概念 概念：Docker 是一个用来装应用的容器，就像杯子可以放水，笔筒可以放笔，书包可以放书一样。你可以把 “Hello World！” 放到 Docker 中，也可以把网站放到 Docker 中，也可以把任何你想到的程序放到 Docker 中。 官网：www.docker.com 对 Docker 的介绍：Docker is the world’s leading software containerization platform.（Docker 是世界领先的软件容器化平台） 总结：Docker 是一个使用 Go 语言开发的开源的应用容器引擎，可以让开发者打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的机器上。 ③特点 Docker 是一个用来装应用的容器，由 Docker 公司开发。 开源的，托管在 github 上（docker/docker 已改名为 moby/moby）。 跨平台的，支持 Windows、Macos、Linux。 Docker 是在 ubuntu 系统上开发的，所以推荐在 Linux 上使用 Docker。 2.了解 Docker①Docker 思想 集装箱思想：把程序的运行环境和部署细节进行整体封装并密封，不容易丢失或损坏。 保证我们的程序放在任何地方运行时，都不会缺少东西。 标准化思想： 运输方式的标准化：Docker 有一个超级码头，任何一个地方需要货物时都由鲸鱼先将货物送到超级码头，再由鲸鱼从超级码头把货物送到目的地去。 例如：把台式机上的应用部署到笔记本上，可以在台式机上执行 docker 命令，让鲸鱼把程序送到超级码头，然后在笔记本上执行 docker 命令，让鲸鱼把程序从超级码头送到笔记本上。 即是执行固定命令发送代码到超级码头，执行固定命令将超级码头中的代码运送到部署地的标准化。 存储方式的标准化：程序员不需要关心应用存储在什么地方，docker 会自动进行标准化处理，我们只需要通过 docker 命令来启动或停止程序。 API 接口的标准化：提供了一系列的 RestAPI 接口包含了对应用的启动、停止、查看和删除等控制。 例如：能够实现执行同样的 docker 命令，来控制不同的 Web 应用服务器，例如 Tomcat、Nginx 等。 即提供了一系列的 RestAPI 接口，包含了对不同应用的统一控制的标准化。 隔离思想：使用虚拟机时，有独立的内存、CPU、硬盘，使得使用者完全感觉不到外面主机的存在。Docker 也是类似，但是 Docker 技术更加轻量，可以实现快速的创建和销毁。创建虚拟机可能需要几分钟，而创建 Docker 只需要 1 秒。 最底层的技术是 Linux 的一种内核限制机制 LXC。 LXC 是一种轻量级的容器虚拟化技术，最大效率的隔离了进程和资源，通过 cgroup 、namespace 等限制隔离进程组所使用的物理资源，如 CPU、I / O、Memory 等等。 这个机制早在多年前就已经加入到 Linux 内核了，直到 2013 年 Docker 出世的时候它才火起来。 Docker 也是随着云计算、敏捷开发、弹性服务等大环境的变迁而变火的，时势造英雄。 ②Docker 解决了什么问题 问题：程序在自己的环境中运行完全没有问题，而在其他人的环境中出问题。 Java Web 程序正常运行依赖于：操作系统、JDK、Tomcat、源代码、配置文件等。 在不同的环境下部署程序时，如果出现操作系统环境的改变、JDK 和 Tomcat 的版本差异、代码依赖于本地环境、配置文件丢失或者与本地系统相关等都可能会导致程序运行不起来。 解决方案：程序员运行 docker 命令，把操作系统、JDK、Tomcat、源代码、配置文件都封装在集装箱中，然后打包交给鲸鱼，由鲸鱼送到服务器上。 Docker 解决了运行环境不一致所带来的问题。 问题：系统好卡，谁又写死循环了，把资源都占用了。 当多个程序员共用一台服务器的时候，由于某一个人的程序失误，可能会导致其他人的程序内存耗尽、程序挂掉，或者程序运行越来越慢，甚至终端变卡顿。 解决方案：Docker 的隔离机制，在每个程序启动时都限制了最大可启用的 CPU、内存和硬盘等，如果超过这个限制，就会杀掉这个进程。 问题：客户数量激增（例如：双 11），原有的服务器撑不住了，需要扩展服务器数量。 一到某些节日，运维需要对每一台服务器进行安装软件、部署应用、调试测试等工作，等高峰过了再将多余的节点下线（缺点：工作量太大）。 解决方案：只要在每台机器上执行几个 docker 命令，分分钟就可以扩展成千上万台，并且运行不会出现任何问题。 Docker 让快速扩展、弹性伸缩变得简单。 3.走进 Docker①核心技术 三个核心词汇：镜像（集装箱）、仓库（超级码头）和容器（运行程序的地方） 用 Docker 运行一个程序的过程：去仓库把镜像拉到本地（Ship），然后用一条命令把镜像运行（Build）起来变成容器（Run）。 Build：构建镜像 Ship：运输镜像（在仓库和主机之间运输） Run：运行的镜像就是一个容器 ②镜像 英文名：image 鲸鱼驮着的所有的集装箱就是一个镜像 从本质上来说，镜像就是一系列的文件（可以包括应用程序的文件，也可以包括应用的运行环境的文件）。Docker 利用 Linux 的联合文件系统（UnionFS）存储镜像文件，将之保存在本地。 联合文件系统是一种分层的文件系统，它可以将不同的目录挂载到同一个虚拟文件系统下面。可以在同一个文件夹下看到 test1 文件夹和 test2 文件夹的内容集合。通过这样一种方式，联合文件系统就可以实现文件的分层，比如 test1 可以看做是第一层，test2 可以看做是第二层，每一层有每一层自己的文件，Docker 镜像就是利用了这种分层的概念来实现了镜像存储。 暂且忽视 writable 层，Docker 镜像的每一层文件系统都是只读的，把每一层加载完成之后，这些文件都会被看成是同一个目录，相对于只有一个文件系统，Docker 的这种文件系统就被称为镜像。 Image 层：相关软件（JDK、Tomcat、应用代码等），每一层都是我们自己可以控制的。 Debian 层：具体的一个 Linux 操作系统 最底层：操作系统的引导 镜像的存储格式（可以看成是一个个集装箱摞在一起）： ③容器 容器的本质就是一个进程，可以将它想象成是一个虚拟机，但是这个 “虚拟机” 的文件系统是一层一层的，并且只有最上面一层是可写的，其他层都是只读的。 为什么有可写层：大部分程序在运行起来后，都会有写日志、修改文件等需求，所以容器在最高层创建了一个可读可写的文件系统。如果想对镜像文件进行修改操作，那么可读层内容会拷贝到最顶层（可写层），然后再进行修改操作。当我们的应用读取镜像文件时，会从最顶层（可写层）查找，如果没有相应文件，才会去可读层查找。 即容器是可以修改的，而镜像是不能修改的。这样保证同一个镜像可以生成多个容器，它们之间独立运行，互不干扰。 ④仓库 构建镜像的目的：为了在其他的环境中运行我们的程序。 为了在其他的环境中运行程序，我们需要将构建的镜像传递到目的地，Docker 仓库可以帮助我们传输。 镜像的传输过程：先将构建的镜像传到 Docker 仓库中，再由目的地去 Docker 仓库将镜像拉取到本地。 Docker 提供了 Docker 仓库（一个中央服务器，地址是 http://hub.docker.com） 如果自己的镜像比较私密，不想让别人看到，Docker 也支持自己（在内网中）搭建一个镜像中心。 4.Docker 初体验①安装 Docker Docker 下载地址： win10 专业版：官网下载（Docker 对 win 10 做了原生的支持） windows 其他版本：官网下载（在 windows 上虚拟了一个 Linux 的运行环境） 国内下载地址：http://get.daocloud.io boot2docker.iso 下载地址：http://pan.baidu.com/s/1qYyc0ag 安装教程： Win10家庭版安装Docker 配置镜像加速器为阿里云加速器 CentOS7上安装Docker [docker][win10]安装的坑 ②第一个 Docker 镜像 docker pull [OPTIONS] NAME[:TAG]：从 Docker 的远程仓库拉取镜像到本地 NAME 表示要拉取的镜像的名称 默认拉取地址为 Docker 官方提供的默认仓库（http://hub.docker.com） TAG 表示要拉取的镜像的版本，默认版本为 :latest，表示为最新版本。 docker images [OPTIONS] [REPOSITORY[:TAG]]：查看本机所有的镜像列表 可以用于验证 docker pull 命令是否执行成功 REPOSITORY：镜像名称 TAG：镜像版本 IMAGE ID：64 位字符串，用于唯一标识镜像。 其他操作 Docker删除本地镜像 Error response from daemon: conflict: unable to delete fd2aef058105 (must be ③第一个 Docker 容器 docker run [OPTIONS] IMAGE[:TAG] [COMMAND] [ARG…]：运行镜像 command：镜像在运行起来时需要执行什么命令 ARG：command 命令所依赖的参数 Client：本机执行命令的客户端 DOCKER_HOST：本机的 Docker 服务 Registry：Docker 的远程仓库 docker pull 流程：Docker Client 向 Docker daemon 发送 docker pull 命令，Docker daemon 会先在本机中寻找是否有相应的镜像，如果存在且版本一致则不做任何操作，如果不存在则会从 Docker 的远程仓库中将相应的镜像拉取到本地。 docker run 流程：Docker Client 向 Docker daemon 发送 docker run 命令，Docker daemon 会先在本机中寻找是否有相应的镜像，如果不存在则会从 Docker 的远程仓库中将相应的镜像拉取到本地（相当于执行 docker pull 命令），然后将镜像通过一定方式运行起来变成 Docker 的容器。 5.Docker 运行 Nginx 服务器①运行 nginx 镜像 Nginx（web 服务器）镜像特点：持久运行的容器 前台运行镜像：docker run NAME（Ctrl + C 结束进程） 后台运行镜像：docker run -d NAME （返回容器 id） docker ps：查看正在运行的容器 docker run –help：查看 docker run 命令的相关参数 docker exec [OPTIONS] CONTAINER COMMAND [ARG…]：在一个运行的容器中运行一个命令 CONTAINER：容器名称 / 容器 id（不需要写全 id，写到能够唯一确定一个容器即可） -i：保证输入有效 -t：分配一个伪终端 docker exec -it id / name bash：进入容器 其实就是一个Linux，因为 Nginx 要运行在 Linux 容器上。 ps -ef：查看当前运行的进程 exit：退出容器 ②Docker 网络 Docker 使用了 Linux 的 Namespace （命名空间）技术来进行资源的隔离，如 PID Namespace -&gt; 隔离进程，Mount Namespace -&gt; 隔离文件系统，Network Namespace -&gt; 隔离网络等。每一个 Network Namespace 都提供了一份独立的网络环境（网卡、路由、iptable 规则等都与其他的 Network Namespace 隔离）。 Docker 的网络类型 bridge 模式（桥接）：Docker 默认的网络设置，此模式会为每一个容器分配一个独立的 Network Namespace、设置 IP 和端口等。一个虚拟网桥（docker0）与主机的网卡（eth0）相连，在启动容器时，容器中会虚拟一个容器的虚拟网卡，与网桥相连，然后通过网桥与主机进行通讯。 host 模式：容器不会获得一个独立的 Network Namespace，而是和主机共同使用一个。这时容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是会使用宿主机上的 IP 和端口。即在 Docker 中使用网络和在主机上使用网络是一样的（容器直接连在主机的网卡上，与主机使用同一块网卡）。 none 模式：Docker 将不会和外界进行通讯 Docker 的端口映射：在使用 bridge 模式的时候，因为 bridge 模式所使用的网络有独立的 Namespace，这就需要一种技术使容器内的端口可以在主机上访问到，这种技术就是端口映射。Docker 可以将容器内的某一个端口与容器所在主机上的某一个端口之间做一个映射，当你在访问主机上的端口时，其实就是在访问容器内的端口，虚拟网桥会进行请求转发（端口映射）并将响应按原路返回。 docker stop id：停止容器 docker restart id：重启容器 docker run -d -p 主机端口:容器端口 容器名称：开放容器的一个端口到主机上的一个端口 docker run -d -P 容器名称：开放容器的所有监听端口到主机上的随机端口（批量端口的映射方式） netstat -na | grep 8080：查看 8080 端口的状态 注意：使用云服务器操作时，记得让安全组开放对应的端口号，否则会访问失败。 6.Docker 化的 JavaWeb 应用①制作自己的镜像 我们之前所下载的镜像都是由其他人做好后传到镜像仓库中的，我们也可以制作自己的镜像。 Dockerfile：告诉 Docker 要怎么制作自己的镜像 docker build：执行 Dockerfile 中所描述的每一件事情，最终把 Docker 镜像构建出来。 下面演示使用 jpress 来制作自己的镜像： 下载 jpress-web-newest.war 并上传到服务器链接：https://pan.baidu.com/s/1j8gBluzagoOIl1Th_ntXqA提取码：fcqd 编写 Dockerfile 文件 123from tomcat # 继承自tomcat这个基础镜像MAINTAINER wjy wjymessi@163.com # 镜像所有者的个人信息COPY /usr/local/javaweb/jpress-web-newest.war /usr/local/tomcat/webapps # 将本地的web应用放在tomcat镜像中，让web应用随着tomcat一起启动。 下载基础镜像 构建镜像：docker build Dokerfile文件所在的目录（若是当前目录则默认为 .） docker build -t REPOSITORY:TAG Dokerfile文件所在的目录：给镜像指定名称和版本 ②运行自己的容器 下面我们开始运行自己创建的镜像： 如果出现下图问题，可以尝试此 解决方法。 成功运行镜像 7.总结 Docker 思想：集装箱思想、标准化思想、隔离思想（网络隔离、磁盘隔离、进程隔离） Docker 核心内容：镜像（Build：构建镜像）、容器（Run：运行容器）、仓库（SHIP：镜像通过仓库传输） Docker 命令：pull（下拉镜像）、build（构建镜像）、run（运行容器）、stop（停止容器）、restart（重启容器）、exec（进入容器内部）… 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#106;&#121;&#x6d;&#101;&#115;&#115;&#105;&#64;&#x31;&#54;&#x33;&#x2e;&#99;&#x6f;&#x6d;]]></content>
      <categories>
        <category>项目</category>
        <category>微服务基础</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用GoLand创建go工程]]></title>
    <url>%2F2019%2F07%2F12%2F%E4%BD%BF%E7%94%A8GoLand%E5%88%9B%E5%BB%BAgo%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1.准备工作 下载 JetBrains GoLand 配置 go 的开发环境 2.hello go 代码1234567package mainimport "fmt"func main() &#123; fmt.Println("你好")&#125; 3.创建 go 工程 新建工程、选择 GOROOT 路径 创建目录结构、创建 hello.go 文件 bin：包含生成的执行文件 pkg：包含编译的中间文件 src：包含程序的代码文件 配置全局路径和项目路径 配置并运行 hello.go 文件 4.命令行中运行 go 文件(windows) go run 文件名.go：编译一个或多个以 .go 结尾的源文件，链接库文件并运行最终生成的可执行文件 go build 文件名.go：生成一个可执行的二进制文件 文件名.exe：运行生成的文件 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#106;&#x79;&#109;&#101;&#x73;&#115;&#x69;&#64;&#x31;&#54;&#x33;&#x2e;&#x63;&#111;&#x6d;]]></content>
      <categories>
        <category>C &amp; Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为春招面经2020届JavaWeb]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%8D%8E%E4%B8%BA%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F2020%E5%B1%8AJavaWeb%2F</url>
    <content type="text"><![CDATA[1.投递职位 华为 2020 届勇敢星实习—通用软件开发工程师 年龄：大二(非大三) 时间：2019 年 地点：华为西研所 华为校招官网 2.我的招聘流程3.29 投递简历 ——&gt; 4.2 性格测试 ——&gt; 4.3 线上笔试 ——&gt; 4.20 面试 ——&gt; 4.25 收到 offer ——&gt; 5.6 签约 3.性格测试 华为比较重视这个，最好认真做完。可以在网上查查技巧，反正我是挂了(⊙o⊙)…。 4.笔试①题目分析 华为的笔试题都是基础的编程题，比较简单。总共有三道题，分值分别为 100、200、300，难度递增。第一题重点考察输入与输出， 第二题重点考察对语言类库的运用，第三题重点考察数据结构与算法。注意：最好在笔试后仔细研究研究未 AC 的题，面试官可能会问。 ②练习网址 牛客网：https://www.nowcoder.com/ta/huawei ③我的笔试 当时我 AC 了第一题和第二题(300 分)，由于第三题涉及到的算法还没有学习过，故放弃。不过只要拿 100 分，就能得到面试机会。 5.一面(35min)①面试问题 自我介绍 对华为的了解 为什么来华为实习 笔试中未做出的题 三道算法题 [LeetCode] 172. 阶乘后的零（Easy）C语言题解 [LeetCode] 172. 阶乘后的零（Easy）Java语言题解 104二叉树的最大深度 1123. 最深叶节点的最近公共祖先 做项目遇到的困难 对软件工程的了解 对”好代码”的理解 ②面试技巧 面试前最好了解一下企业文化及其业务方向。 面试官很看重应聘者解决问题的能力，即面对一个完全陌生的问题，应聘者能将之快速理解并想出求解方法。 在解决算法题的时候，最好先从最基础的求解方法开始分析，逐步优化并且分析每种解法的复杂度和优缺点(系统原理、安全漏洞等)。 如果实在想不出求解方法，也要尽可能地想出一个大概思路，最好别卡壳。如果面试时很紧张，会非常非常影响思路！所以一定要放松！！ 底层知识一定要重视！要将学过的知识点充分理解！ 注意：思考面试官问你的题目之间是否有关联，也许这是一个很好的解题突破点。 6.二面(20min)①面试问题 自我介绍 对 996 的看法 为什么跨专业学习 职业规划 关于读研 想在华为学到什么 项目介绍 英语能力及课内成绩 瞎聊… ②面试体验 一面结束后，排队等待二面，二面相对比较轻松。因为我是跨专业自学 CS，所以面试官一直逮着这点问，emmm。然后就会和你聊聊家庭情况、未来规划、学习情况等。 7.等待结果 面试完成后官网会更新 应聘进展 我的状态码： 状态码：6、1 性格测试貌似挂了 但没有被安排重测 面试考核 下无小字： but 5 天后就收到 offer 啦 纪念收到的第一个 offer！ 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#x6a;&#121;&#x6d;&#x65;&#x73;&#115;&#x69;&#64;&#x31;&#54;&#x33;&#x2e;&#x63;&#111;&#x6d;]]></content>
      <categories>
        <category>2020秋招</category>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 172. 阶乘后的零（Easy）C语言题解]]></title>
    <url>%2F2019%2F05%2F05%2FLeetCode-172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6%EF%BC%88Easy%EF%BC%89C%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.题目相关①题目及示例 ②相关标签 数学 ③题目地址 172. 阶乘后的零 — 力扣网 2.解题方法①暴力解法（超时） 思路：已知 2 * 5 = 10，所以尾数中零的数量只与 2 和 5 有关 。由此可知，我们只需要关注 N! 中作为乘法因子的 2 的数量和 5 的数量，最后计算 count(2) &lt; count(5)? count(2): count(5) 即可。 深入分析 1：2 的数量一定比 5 的数量多，所以只需要考虑 5 的数量（即统计小于或等于 N 的 5 的倍数们能拆分成多少个 5）。 ②数学规律 深入分析 2：通过观察 5 的倍数（5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 105 110 115 120 125 ……），可以发现对于 N! 的乘积因子来说，每隔 5 个数出现一个 5，每隔 25 个数出现两个 5，每隔 125 个数出现三个 5，以此类推，每隔 5^i 个数出现 i 个 5，最终 5 的个数就是 N / 5 + N / 25 + N / 125 + ...。 时间复杂度：O(log n) 空间复杂度：O(1) 3.代码详解①暴力解法（超时）123456789101112int trailingZeroes(int n)&#123; int count = 0; // 计算i的乘法因子中有几个5 for (int i = 5; i &lt;= n; i += 5) &#123; int j = i; while (j % 5 == 0) &#123; j /= 5; count += 1; &#125; &#125; return count;&#125; ②数学规律12345678int trailingZeroes(int n)&#123; int count = 0; while (n &gt; 0) &#123; count += n / 5; n /= 5; &#125; return count;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#121;&#x6d;&#x65;&#x73;&#x73;&#105;&#x40;&#x31;&#x36;&#51;&#46;&#99;&#111;&#x6d; 关于 数据结构与算法 的更多代码 请查看我的 GitHub仓库]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>LeetCode-C</category>
      </categories>
      <tags>
        <tag>LeetCode题解</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 172. 阶乘后的零（Easy）Java语言题解]]></title>
    <url>%2F2019%2F05%2F05%2FLeetCode-172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6%EF%BC%88Easy%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.题目相关①题目及示例 ②相关标签 数学 ③题目地址 172. 阶乘后的零 — 力扣网 2.解题方法①暴力解法（超时） 思路：已知 2 * 5 = 10，所以尾数中零的数量只与 2 和 5 有关 。由此可知，我们只需要关注 N! 中作为乘法因子的 2 的数量和 5 的数量，最后计算 Math.min(count(2), count(5)) 即可。 深入分析 1：2 的数量一定比 5 的数量多，所以只需要考虑 5 的数量（即统计小于或等于 N 的 5 的倍数们能拆分成多少个 5）。 ②数学规律 深入分析 2：通过观察 5 的倍数（5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 105 110 115 120 125 ……），可以发现对于 N! 的乘积因子来说，每隔 5 个数出现一个 5，每隔 25 个数出现两个 5，每隔 125 个数出现三个 5，以此类推，每隔 5^i 个数出现 i 个 5，最终 5 的个数就是 N / 5 + N / 25 + N / 125 + ...。 时间复杂度：O(log n) 空间复杂度：O(1) 3.代码详解①暴力解法（超时）123456789101112public int trailingZeroes(int n) &#123; int count = 0; // 计算i的乘法因子中有几个5 for (int i = 5; i &lt;= n; i += 5) &#123; int j = i; while (j % 5 == 0) &#123; j /= 5; count += 1; &#125; &#125; return count;&#125; ②数学规律12345678public int trailingZeroes(int n) &#123; int count = 0; while (n &gt; 0) &#123; count += n / 5; n /= 5; &#125; return count;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#121;&#109;&#x65;&#115;&#115;&#105;&#x40;&#x31;&#54;&#x33;&#46;&#x63;&#111;&#109; 关于 数据结构与算法 的更多代码 请查看我的 GitHub仓库]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>LeetCode-Java</category>
      </categories>
      <tags>
        <tag>LeetCode题解</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云CentOS7安装Nginx]]></title>
    <url>%2F2019%2F05%2F01%2F%E9%98%BF%E9%87%8C%E4%BA%91CentOS7%E5%AE%89%E8%A3%85Nginx%2F</url>
    <content type="text"><![CDATA[1.准备工作①添加安全组规则 服务器的安全组默认未设置任何自定义放行规则，这将会导致无法访问实例端口，若需访问需要添加安全组规则放行对应的端口。 放行 80 端口 ②设置防火墙 防火墙是系统的第一道防线，其作用是防止非法用户的进入。服务器的防火墙默认未设置任何自定义放行规则，这将会导致无法访问实例端口，若需访问需要防火墙放行对应的端口。注意：CentOS7 默认使用 firewalld 作为防火墙。 firewalld 默认是关闭 http 服务的。 1234567891011firewall-cmd --state # 查看防火墙状态systemctl start firewalld.service # 开启防火墙systemctl stop firewalld.service # 关闭防火墙systemctl enable firewalld.service # 打开防火墙的开机自启systemctl disable firewalld.service # 关闭防火墙的开机自启firewall-cmd --permanent --zone=public --add-port=80/tcp # 让防火墙永久开放80端口firewall-cmd --reload # 加载配置 使得修改有效firewall-cmd --permanent --zone=public --list-ports # 查看开放的端口号firewall-cmd --permanent --zone=public --add-service=http # 让防火墙永久打开http服务firewall-cmd --reload # 加载配置 使得修改有效firewall-cmd --permanent --zone=public --list-service # 查看开放的服务 2.yum安装Nginx Nginx 是一个高性能的 HTTP 和反向代理服务器。 ①下载和安装123rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm # 将nginx添加到yum源的repo中yum repolist # 查看yum源的repoyum install nginx # yum源安装nginx ②启动1234systemctl enable nginx # 设置开机启动systemctl start nginx # 启动nginxsystemctl reload nginx # 重新加载nginxsystemctl status nginx # 查看nginx启动状态 ③验证配置 访问 公网ip:80 如果出现上图内容 说明配置成功 ④安装后的目录结构1234567查看刚安装的所有目录：rpm -ql nginx启动nginx：/usr/sbin/nginx主配置文件：/etc/nginx/nginx.conf 首页的html网页所在路径：/usr/share/nginx/html缓存目录：/var/cache/nginx/fastcgi_temp代理目录：/var/cache/nginx/proxy_temp... 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#121;&#109;&#101;&#115;&#x73;&#x69;&#x40;&#49;&#x36;&#x33;&#46;&#x63;&#111;&#x6d;]]></content>
      <categories>
        <category>操作系统</category>
        <category>服务器相关</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云CentOS7安装 jdk8+tomcat8+maven+MySQL5.7+redis5]]></title>
    <url>%2F2019%2F04%2F27%2F%E9%98%BF%E9%87%8C%E4%BA%91CentOS7%E5%AE%89%E8%A3%85-jdk8-tomcat8-maven-MySQL5-7-redis5%2F</url>
    <content type="text"><![CDATA[1.我的服务器配置 2.准备工作①下载压缩包 下载 jdk8：https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 下载 tomcat8：https://tomcat.apache.org/download-80.cgi 下载 maven：http://maven.apache.org/download.cgi 下载 redis5：https://redis.io/download ②下载 Xftp6 Xftp6 是一款功能强大，主要用于 SFTP、FTP 文件传输的软件，能够帮助用户安全地在 UNIX/Linux 和 Windows PC 之间传输文件。我们需要使用此软件，将压缩包上传至阿里云服务器。 请自行搜索安装包 下载并安装 ③添加安全组规则 服务器的安全组默认未设置任何自定义放行规则，这将会导致无法访问实例端口，若需访问需要添加安全组规则放行对应的端口。 我们需要放行常用的端口号：8080、3306、22、6379 等 添加安全组规则： ④上传压缩包至服务器 打开 Xftp6 工具 点击 文件 – 新建 按下图填写信息并连接服务器 然后在 /usr/local/ 目录下新建 javaweb 文件夹 将压缩包上传到此文件夹中 ⑤设置防火墙 防火墙是系统的第一道防线，其作用是防止非法用户的进入。服务器的防火墙默认未设置任何自定义放行规则，这将会导致无法访问实例端口，若需访问需要防火墙放行对应的端口。注意：CentOS7 默认使用 firewalld 作为防火墙。 1234567891011firewall-cmd --state # 查看防火墙状态systemctl start firewalld.service # 开启防火墙systemctl stop firewalld.service # 关闭防火墙systemctl enable firewalld.service # 打开防火墙的开机自启systemctl disable firewalld.service # 关闭防火墙的开机自启firewall-cmd --permanent --zone=public --add-port=8080/tcp # 让防火墙永久开放8080端口firewall-cmd --permanent --zone=public --add-port=3306/tcp # 让防火墙永久开放3306端口firewall-cmd --permanent --zone=public --add-port=22/tcp # 让防火墙永久开放22端口firewall-cmd --permanent --zone=public --add-port=6379/tcp # 让防火墙永久开放6379端口firewall-cmd --reload # 加载配置 使得修改有效firewall-cmd --permanent --zone=public --list-ports # 查看开放的端口号 3.安装 jdk8 注意：若服务器版本是 CentOS7 系列，尽量不要安装系统自带的 openJDK (会有坑)！ ①解压安装包123cd /usr/local/javaweb # 进入该目录tar -zxvf jdk-8u201-linux-x64.tar.gz # 解压压缩包mv jdk1.8.0_201 jdk8 # 重命名文件夹 ②配置环境 使用 vim 命令打开文件 1vim /etc/profile # 配置环境变量 然后按 i 进入编辑模式 插入以下文字 123export JAVA_HOME=/usr/local/javaweb/jdk8 # jdk所在位置的绝对路径export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin 最后按 Esc 并输入 :wq 回车退出 1source /etc/profile # 使脚本文件生效 ③验证配置12javacjava -version 如果出现上图内容 说明配置成功 4.安装 tomcat8①解压安装包123cd /usr/local/javaweb # 进入该目录tar -zxvf apache-tomcat-8.5.39.tar.gz # 解压压缩包mv apache-tomcat-8.5.39 tomcat8 # 重命名文件夹 ②启动 tomcat812cd /usr/local/javaweb/tomcat8/bin # 进入该目录./startup.sh # 启动tomcat ③验证配置 访问 公网ip:8080 如果出现上图内容 说明配置成功 5.安装 maven①解压安装包123cd /usr/local/javaweb # 进入该目录tar -zxvf apache-maven-3.6.0-bin.tar.gz # 解压压缩包mv apache-maven-3.6.0 maven3 # 重命名文件夹 ②配置环境 使用 vim 命令打开文件 1vim /etc/profile.d/maven.sh # 配置环境变量 然后按 i 进入编辑模式 插入以下内容 123#!/bin/bashexport M2_HOME=/usr/local/javaweb/maven3 # maven所在位置的绝对路径export PATH=$PATH:$M2_HOME/bin 最后按 Esc 并输入 :wq 回车退出 1source /etc/profile.d/maven.sh # 使脚本文件生效 ③验证配置1mvn -v # 查看maven版本 如果出现上图内容 说明配置成功 6.安装 MySQL5.7①下载和安装12345rpm -ivh http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm # 下载安装包yum install -y mysql-server # 安装MySQLsystemctl enable mysqld.service # 设置开机自启动MySQLsystemctl start mysqld.service # 启动MySQLgrep &apos;temporary password&apos; /var/log/mysqld.log # 查看MySQL默认密码 ②登录 MySQL123mysql -uroot -p # 登录MySQL 然后输入默认密码(系统自动生成)SET PASSWORD = PASSWORD(&apos;Zxcvbnm10!_&apos;); # 修改默认密码 新密码必须包含大小写字母、数字、下划线和感叹号eixt # 退出MySQL 用新密码重新登录 ps：如果觉得新密码太复杂，可以修改以下两个字段来降低默认的密码安全级别。 12set global validate_password_policy=0; 设置密码安全级别为LOWset global validate_password_length=6; 设置密码最短长度为6 ③远程连接12GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;新密码&apos; WITH GRANT OPTION; # 开启root用户的远程访问权限flush privileges; # 使命令执行生效 使用 Navicat 远程访问数据库 连接后可以通过 Navicat 管理远程数据库 7.安装 redis5①解压安装包123cd /usr/local/javaweb # 进入该目录tar -zxvf redis-5.0.4.tar.gz # 解压压缩包mv redis-5.0.4 redis5 # 重命名文件夹 ②配置环境1234567cd /usr/local/javaweb/redis5 # 进入解压后的目录make # 编译mkdir -p /usr/local/javaweb/redis # 新创建目录存储rediscp /usr/local/javaweb/redis5/src/redis-server /usr/local/javaweb/redis/ # 复制redis-server到新目录cp /usr/local/javaweb/redis5/src/redis-cli /usr/local/javaweb/redis/ # 复制redis-cli到新目录cp /usr/local/javaweb/redis5/redis.conf /usr/local/javaweb/redis/ # 复制redis.conf到新目录cd /usr/local/javaweb/redis/ # 进入新目录 使用 vim 命令打开文件 1vim /usr/local/javaweb/redis/redis.conf # 编辑配置文件 然后按 i 进入编辑模式 编辑以下字段 1234bind 127.0.0.1 ——&gt; # bind 127.0.0.1 # 将此行注释掉protected-mode yes ——&gt; protected-mode nodaemonize no ——&gt; daemonize yes# requirepass foobared ——&gt; requirepass 123456 # 设置密码为123456 最后按 Esc 并输入 :wq 回车退出 使用 vim 命令打开文件 1vim /etc/init.d/redis #编辑redis开机启动脚本 然后按 i 进入编辑模式 插入以下文字 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/bin/sh # chkconfig: 2345 80 90 # description: Start and Stop redis #PATH=/usr/local/bin:/sbin:/usr/bin:/bin REDISPORT=6379 EXEC=/usr/local/javaweb/redis/redis-server REDIS_CLI=/usr/local/javaweb/redis/redis-cli PIDFILE=/var/run/redis_6379.pid CONF=&quot;/usr/local/javaweb/redis/redis.conf&quot; AUTH=&quot;123456&quot;case &quot;$1&quot; in start) if [ -f $PIDFILE ] then echo &quot;$PIDFILE exists, process is already running or crashed&quot; else echo &quot;Starting Redis server...&quot; $EXEC $CONF fi if [ &quot;$?&quot;=&quot;0&quot; ] then echo &quot;Redis is running...&quot; fi ;; stop) if [ ! -f $PIDFILE ] then echo &quot;$PIDFILE does not exist, process is not running&quot; else PID=$(cat $PIDFILE) echo &quot;Stopping ...&quot; $REDIS_CLI -p $REDISPORT SHUTDOWN while [ -x $&#123;PIDFILE&#125; ] do echo &quot;Waiting for Redis to shutdown ...&quot; sleep 1 done echo &quot;Redis stopped&quot; fi ;; restart|force-reload) $&#123;0&#125; stop $&#123;0&#125; start ;; *) echo &quot;Usage: /etc/init.d/redis &#123;start|stop|restart|force-reload&#125;&quot; &gt;&amp;2 exit 1esac 最后按 Esc 并输入 :wq 回车退出 使用 vim 命令打开文件 1vim /etc/rc.local # 添加开机启动服务 然后按 i 进入编辑模式 插入以下文字 1service redis start 最后按 Esc 并输入 :wq 回车退出 ③登录 redis12345678910chmod 755 /etc/init.d/redis # 设置权限chkconfig --add redis # 注册系统服务service redis start # 启动redis服务ps -ef|grep redis # 查看当前状态ln -s /usr/local/javaweb/redis/redis-cli /usr/bin/redis # 创建redis命令软连接cd /redis # 进入redisauth 123456 # 密码验证set name wiy # 增加用户get name ④验证配置 如果上图命令没有报错 说明配置成功 ⑤远程连接 使用 Redis Desktop Manager 远程访问数据库 连接后可以通过 Redis Desktop Manager 管理远程数据库 ⑥参考博客 https://blog.csdn.net/lc1010078424/article/details/78295482 8.部署 Springboot 项目①打包项目123本地命令行中: cd 项目根目录 # 进入该目录mvn package # 将项目打包 ②上传 jar 包 使用 Xftp6 工具上传 jar 包至服务器 ③运行 jar 包 方式一：在当前窗口运行 12cd /usr/local/javaweb/springboot # 进入该目录java -jar luckymoney-0.0.1-SNAPSHOT.jar # 运行此jar包 方式二：使 jar 包一直处于后台运行 123cd /usr/local/javaweb/springboot # 进入该目录nohup java -jar luckymoney-0.0.1-SNAPSHOT.jar &amp; # 运行此jar包cat nohup.out # 此文件存放控制台的实时输出内容 ④验证配置 如上图内容 我们成功地访问了这个 springboot 项目 间接说明了配置的正确性！ Ctrl + v：停止运行项目 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#x6a;&#121;&#109;&#101;&#x73;&#x73;&#x69;&#64;&#49;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;]]></content>
      <categories>
        <category>操作系统</category>
        <category>服务器相关</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在命令行中使用SSH免密登录服务器]]></title>
    <url>%2F2019%2F04%2F25%2F%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E4%BD%BF%E7%94%A8SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1.生成公钥和私钥 打开命令行 输入 ssh-keygen -t rsa 然后连续按三个回车(第一个回车表示不重命名文件 第二、三个回车表示不设置密码) 最后在 C 盘找到生成的公钥和私钥 2.将公钥写入服务器 ps：需要服务器的防火墙放行 22 端口。 在命令行使用密码登录服务器 将生成的公匙内容粘贴到 authorized_keys 文件中 退出服务器 重新连接时 不用输入密码即可登录！ 3.解决WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! 重置服务器之后再配置 SSH 连接时 会报这个错误：远程主机标识已更改！ 这时需要将电脑上的旧连接信息删除（根据服务器IP） 删除后重新连接即可 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#121;&#109;&#101;&#x73;&#115;&#x69;&#64;&#x31;&#54;&#51;&#x2e;&#x63;&#x6f;&#x6d;]]></content>
      <categories>
        <category>操作系统</category>
        <category>服务器相关</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[域名解析到服务器]]></title>
    <url>%2F2019%2F04%2F14%2F%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1.域名与服务器 域名是网站的入口，是 IP 的别名，便于记忆而存在，域名最终会通过 DNS 解析成 IP 地址。所以将域名解析到服务器后，域名 == 服务器 IP(一样的作用)！ 2.域名解析到服务器①域名解析 登录阿里云 打开 控制台-域名 选择域名 点击 解析 点击 添加记录 解析类型为 A-将域名解析到服务器 ②验证解析 验证网址：17CE 选择 Dns 并输入域名 如果画圈处的 IP 地址正确 说明解析成功 ps：解析成功后，使用 www.域名/域名 均可代替服务器 IP。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#121;&#x6d;&#101;&#115;&#x73;&#x69;&#64;&#49;&#54;&#x33;&#46;&#99;&#x6f;&#x6d;]]></content>
      <categories>
        <category>操作系统</category>
        <category>服务器相关</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10 + Ubuntu 18.04 双系统安装]]></title>
    <url>%2F2019%2F04%2F06%2Fwin10-Ubuntu-18-04-%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[1.准备工作①下载 Ubuntu 18.04.2 LTS 官网地址：https://www.ubuntu.com/download/desktop ②下载 Rufus Rufus 是 Ubuntu 官网推荐的 USB 启动盘制作工具。 官网地址：https://rufus.ie/ 或者我的网盘分享：https://pan.baidu.com/s/1uWUmyNQuupPJIp2YDhKDgg，提取码：fwea。 ③制作 Ubuntu 18.04 U盘启动 打开下载好的 Rufus 并将空U盘插入电脑，点击 选择，添加 Ubuntu 18.04.2 LTS。 其他设置如图所示，点击 开始 后，一直选择 OK 即可。 按照上图设置后，软件会把 ubuntu-18.04.2-desktop-amd64.iso 文件写入U盘，制作系统启动盘。 写入完成，点击 关闭。 刻录完成后的U盘内部： ④关闭 win10 的快速启动 关闭快速启动：https://jingyan.baidu.com/article/ca00d56c7a40e6e99febcf4f.html#!/article/ca00d56c7a40e6e99febcf4f ⑤磁盘分区 使用快捷键 win + x + Ctrl + k 打开 win10 的 磁盘管理 选择剩余空间较大的可分配磁盘，点击 右键 并选择 压缩卷，压缩 50~80 G。 压缩成功： 2.安装过程①BIOS 设置 重启电脑，按 F12。 进入 BIOS 设置后，如下图操作。 然后插入U盘，保存设置并退出，电脑会自动重启。 继续按 F12，选择如何启动电脑。 ②进入 Ubuntu 每次选择空闲设备中内存最大的设备——用于设置分区(四个分区)。| /：存储系统文件。| swap：交换分区。| /boot：包含系统内核和系统启动文件。| /home：存放文件。 然后将剩余空间全部用于创建 home 分区| 类型：逻辑分区。| 用于：Ext4 日志文件系统。| 挂载点：/home。 分区效果图： 最后设置时区、注册账号、重启电脑，即可完成安装。 3.问题总结①系统时间不同步 修改 Linux 系统时间： 123456# 安装ntpdate。sudo apt-get install ntpdate# 校准时间。sudo ntpdate time.windows.com# 将时间更新到硬件上。sudo hwclock --localtime --systohc 修改 win 系统时间：https://jingyan.baidu.com/article/60ccbcebbb041b64cab19730.html ②WIFI 无法开启 如图：优先级较前的 ideapad_wlan 的 Hard blocked 默认为 yes，说明 Ubuntu 默认关闭了硬件 wifi 开关，我们需要将这个模块移除，以便使用序号 3 模块(wifi 开关是打开的)。 注意：每次重启 Ubuntu 系统都要重新将第一个模块移除。 ③Linux 无法关机/重启 进入 软件和更新，选择 附加驱动，安装 NVDIA 专用驱动即可。 ④分区详解 https://blog.csdn.net/cl_cjh/article/details/69396906 ⑤误删 win10 引导 用快启动 pe 修复 win10 系统引导：https://blog.csdn.net/jessical1020/article/details/72933056 4.参考博客 安装教程：https://blog.csdn.net/lipengfei0427/article/details/83116527http://tieba.baidu.com/p/5276785632 更改系统时间：https://blog.csdn.net/hansion3333/article/details/60469583 WIFI 无法开启：https://www.linuxidc.com/Linux/2015-04/116077.htm 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#121;&#x6d;&#x65;&#115;&#115;&#x69;&#64;&#49;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#x6d;]]></content>
      <categories>
        <category>操作系统</category>
        <category>系统安装</category>
      </categories>
      <tags>
        <tag>系统安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树的常用操作]]></title>
    <url>%2F2019%2F02%2F15%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1.相关博客 二分查找法代码实现 二叉树的定义及性质 树的遍历（递归加迭代） 红黑树详解 B树和B+树详解 注意：示例代码中的 TreeNode 对象和结构体定义如下： 123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 12345struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right;&#125; 2.简介 二叉搜索树 不仅可以查找数据，还可以高效地插入、删除数据（即动态维护数据）。 堆的二叉树一定是完全二叉树，所以用数组表示很方便。而二叉搜索树不一定是完全二叉树，所以不好用数组表示，通常使用引用的方式表示二叉搜索树节点间的关系。 二叉搜索树中的问题：求最小值、最大值、查找一个节点的前驱节点和后继节点，实现 floor、ceil 和 rank 函数、以及支持插入重复节点值的二叉搜索树该如何实现。 二叉搜索树的局限性：可能退化成链表，此时二叉搜索树的高度为 n ，时间复杂度退化为 O(n)，还不如顺序查找表（原因：顺序查找表不用递归实现且不需要每次访问两个指针）。它不能像堆一样保证所有的操作一定是 O(logn) 级别的。 平衡二叉树：改进二叉树的实现，使之不能退化成链表。 平衡二叉树最著名的实现：红黑树 其他平衡二叉树的实现：SBT 树、AVL 树、Splay 树 平衡二叉树和堆的结合：Treap 树形问题：归并排序、快速排序、搜索树（八皇后） 3.查找最大值或最小值 返回以 root 为根节点的二叉搜索树中的最大（小）节点 Java 12345678910111213141516171819public TreeNode findMax(TreeNode root) &#123; if (root == null) &#123; return null; &#125; if (root.right == null) &#123; return root; &#125; return findMax(root.right);&#125;public TreeNode findMin(TreeNode root) &#123; if (root == null) &#123; return null; &#125; if (root.left == null) &#123; return root; &#125; return findMin(root.left);&#125; 返回以 root 为根节点的二叉搜索树中的最大 （小）节点的节点值 C 12345678910111213int findMax(struct TreeNode* root) &#123; if (!root-&gt;right) &#123; return root-&gt;val; &#125; return findMax(root-&gt;right);&#125;int findMin(struct TreeNode* root) &#123; if (!root-&gt;left) &#123; return root-&gt;val; &#125; return findMin(root-&gt;left);&#125; 4.删除最大值或最小值 删除以 root 为根节点的二叉搜索树中的最大（小）节点，返回删除最大（小）节点后新的二叉搜索树的根。 删除最大值：向右走到头，若它是叶子节点则直接删除，若它有左子树，则将左子树赋给其父亲节点（最大值所在的节点只可能有左孩子） 删除最小值：向左走到头，若它是叶子节点则直接删除，若它有右子树，则将右子树赋给其父亲节点（最小值所在的节点只可能有右孩子） Java 123456789101112131415public TreeNode removeMax(TreeNode root) &#123; if (root.right == null) &#123; return root.left; &#125; root.right = removeMax(root.right); return root;&#125;public TreeNode removeMin(TreeNode root) &#123; if (root.left == null) &#123; return root.right; &#125; root.left = removeMin(root.left); return root;&#125; C 123456789101112131415struct TreeNode* removeMax(struct TreeNode* root) &#123; if (!root-&gt;right) &#123; return root-&gt;left; &#125; root-&gt;right = removeMax(root-&gt;right); return root;&#125;struct TreeNode* removeMin(struct TreeNode* root) &#123; if (!root-&gt;left) &#123; return root-&gt;right; &#125; root-&gt;left = removeMin(root-&gt;left); return root;&#125; 5.二叉搜索树中的搜索 查找节点的过程： 和当前节点值相等，则直接返回 小于当前节点值，在左子树中查找 大于当前节点值，在右子树中查找 Java 12345678910111213141516171819202122232425262728293031// 1.尾递归public TreeNode searchBST(TreeNode root, int val) &#123; if (root == null) &#123; return null; &#125; if (val == root.val) &#123; return root; &#125; else if (val &lt; root.val) &#123; return searchBST(root.left, val); &#125; else &#123; return searchBST(root.right, val); &#125;&#125;// 2.迭代public TreeNode searchBST(TreeNode root, int val) &#123; while (root != null) &#123; if (val == root.val) &#123; return root; &#125; else if (val &lt; root.val) &#123; root = root.left; &#125; else &#123; root = root.right; &#125; &#125; return null;&#125; C 12345678910111213141516171819202122232425262728293031// 1.尾递归struct TreeNode* searchBST(struct TreeNode* root, int val) &#123; if (!root) &#123; return NULL; &#125; if (val == root-&gt;val) &#123; return root; &#125; else if (val &lt; root-&gt;val) &#123; return searchBST(root-&gt;left, val); &#125; else &#123; return searchBST(root-&gt;right, val); &#125;&#125;// 2.迭代struct TreeNode* searchBST(struct TreeNode* root, int val) &#123; while (root) &#123; if (val == root-&gt;val) &#123; return root; &#125; else if (val &lt; root-&gt;val) &#123; root = root-&gt;left; &#125; else &#123; root = root-&gt;right; &#125; &#125; return NULL;&#125; 6.二叉搜索树中的遍历操作 因为二叉搜索树也是一种二叉树，所以它的遍历操作与二叉树的遍历操作相同。 具体见：树的遍历（递归加迭代） 7.二叉搜索树中的插入操作 插入新节点的过程： 和当前节点值相等，则直接返回（假设这种情况不存在） 小于当前节点值，在左子树中插入 大于当前节点值，在右子树中插入 Java 1234567891011121314151617181920212223242526272829303132333435363738// 1.尾递归public TreeNode insertIntoBST(TreeNode root, int val) &#123; // 找到插入位置 if (root == null) &#123; return new TreeNode(val); &#125; if (val &lt; root.val) &#123; root.left = insertIntoBST(root.left, val); &#125; else &#123; root.right = insertIntoBST(root.right, val); &#125; return root;&#125;// 2.迭代public TreeNode insertIntoBST(TreeNode root, int val) &#123; TreeNode node = root; while (node != null) &#123; if (val &lt; node.val) &#123; // 找到插入位置 if (node.left == null) &#123; node.left = new TreeNode(val); break; &#125; node = node.left; &#125; else &#123; // 找到插入位置 if (node.right == null) &#123; node.right = new TreeNode(val); break; &#125; node = node.right; &#125; &#125; return root;&#125; C 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 1.尾递归struct TreeNode* insertIntoBST(struct TreeNode* root, int val) &#123; // 找到插入位置 if (!root) &#123; struct TreeNode* node = malloc(sizeof(struct TreeNode)); node-&gt;val = val; node-&gt;left = NULL; node-&gt;right = NULL; return node; &#125; if (val &lt; root-&gt;val) &#123; root-&gt;left = insertIntoBST(root-&gt;left, val); &#125; else &#123; root-&gt;right = insertIntoBST(root-&gt;right, val); &#125; return root;&#125;// 2.迭代struct TreeNode* insertIntoBST(struct TreeNode* root, int val) &#123; struct TreeNode* t = root; while (t) &#123; if (val &lt; t-&gt;val) &#123; // 找到插入位置 if (!t-&gt;left) &#123; struct TreeNode* node = malloc(sizeof(struct TreeNode)); node-&gt;val = val; node-&gt;left = NULL; node-&gt;right = NULL; t-&gt;left = node; break; &#125; t = t-&gt;left; &#125; else &#123; // 找到插入位置 if (!t-&gt;right) &#123; struct TreeNode* node = malloc(sizeof(struct TreeNode)); node-&gt;val = val; node-&gt;left = NULL; node-&gt;right = NULL; t-&gt;right = node; break; &#125; t = t-&gt;right; &#125; &#125; return root;&#125; 8.删除二叉搜索树中的节点 分析： 删除只有一个孩子的节点：直接将孩子赋给其父节点 删除有两个孩子的节点：找到其右子树中的最小值代替该节点（即该节点的后继节点）或找到其左子树中的最大值代替该节点（即该节点的前驱节点）。 具体做法：先创建一个新节点（值是其后继节点或前驱节点的节点值），再把被删除节点的后继节点或前驱节点在原位置删除，最后将被删除节点的左右子树分别赋值给该新节点。 删除二叉搜索树中任意一个节点的时间复杂度为 O(logn) Java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// 1.用被删除节点的前驱节点(是其左子树中的最大值所在的节点)替换被删除的节点// 返回以root为根节点的二分搜索树中的最大节点public TreeNode findMax(TreeNode root) &#123; if (root == null) &#123; return null; &#125; if (root.right == null) &#123; return root; &#125; return findMax(root.right);&#125;public TreeNode deleteNode(TreeNode root, int key) &#123; if (root == null) &#123; return null; &#125; if (key &lt; root.val) &#123; root.left = deleteNode(root.left, key); &#125; else if (key &gt; root.val) &#123; root.right = deleteNode(root.right, key); &#125; else &#123; if (root.left == null) &#123; return root.right; &#125; else if (root.right == null) &#123; return root.left; &#125; else &#123; // 此时root是被删除的节点 // maxNode(node)是被删除节点的前驱节点 TreeNode maxNode = findMax(root.left); // 将被删除节点的前驱节点放在被删除节点的位置 TreeNode node = new TreeNode(maxNode.val); // 删除原来的前驱节点 node.left = deleteNode(root.left, maxNode.val); node.right = root.right; return node; &#125; &#125; return root;&#125;// 2.用被删除节点的后继节点(是其右子树中的最小值所在的节点)替换被删除的节点// 返回以root为根节点的二分搜索树中的最小节点public TreeNode findMin(TreeNode root) &#123; if (root == null) &#123; return null; &#125; if (root.left == null) &#123; return root; &#125; return findMin(root.left);&#125;public TreeNode deleteNode(TreeNode root, int key) &#123; if (root == null) &#123; return null; &#125; if (key &lt; root.val) &#123; root.left = deleteNode(root.left, key); &#125; else if (key &gt; root.val) &#123; root.right = deleteNode(root.right, key); &#125; else &#123; if (root.left == null) &#123; return root.right; &#125; else if (root.right == null) &#123; return root.left; &#125; else &#123; // 此时root是被删除的节点 // minNode(node)是被删除节点的后继节点 TreeNode minNode = findMin(root.right); // 将被删除节点的后继节点放在被删除节点的位置 TreeNode node = new TreeNode(minNode.val); node.left = root.left; // 删除原来的后继节点 node.right = deleteNode(root.right, minNode.val); return node; &#125; &#125; return root;&#125; 具体做法：先将被删除节点的节点值改为其后继节点或前驱节点的节点值，再把被删除节点的后继节点或前驱节点在原位置删除。 C 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 1.用被删除节点的前驱节点(是其左子树中的最大值所在的节点)替换被删除的节点// 返回以root为根节点的二分搜索树中的最大节点int findMax(struct TreeNode* root) &#123; if (!root-&gt;right) &#123; return root-&gt;val; &#125; return findMax(root-&gt;right);&#125;struct TreeNode* deleteNode(struct TreeNode* root, int key) &#123; if (!root) &#123; return NULL; &#125; if (key &lt; root-&gt;val) &#123; root-&gt;left = deleteNode(root-&gt;left, key); &#125; else if (key &gt; root-&gt;val) &#123; root-&gt;right = deleteNode(root-&gt;right, key); &#125; else &#123; if (!root-&gt;left) &#123; return root-&gt;right; &#125; else if (!root-&gt;right) &#123; return root-&gt;left; &#125; else &#123; // 此时root是被删除的节点 // max是被删除节点的前驱节点的值 int max = findMax(root-&gt;left); // 将被删除节点的前驱节点放在被删除节点的位置 root-&gt;val = max; // 删除原来的前驱节点 root-&gt;left = deleteNode(root-&gt;left, max); root-&gt;right = root-&gt;right; &#125; &#125; return root;&#125;// 2.用被删除节点的后继节点(是其右子树中的最小值所在的节点)替换被删除的节点// 返回以root为根节点的二分搜索树中的最小节点int findMin(struct TreeNode* root) &#123; if (!root-&gt;left) &#123; return root-&gt;val; &#125; return findMin(root-&gt;left);&#125;struct TreeNode* deleteNode(struct TreeNode* root, int key) &#123; if (!root) &#123; return NULL; &#125; if (key &lt; root-&gt;val) &#123; root-&gt;left = deleteNode(root-&gt;left, key); &#125; else if (key &gt; root-&gt;val) &#123; root-&gt;right = deleteNode(root-&gt;right, key); &#125; else &#123; if (!root-&gt;left) &#123; return root-&gt;right; &#125; else if (!root-&gt;right) &#123; return root-&gt;left; &#125; else &#123; // 此时root是被删除的节点 // min是被删除节点的后继节点的值 int min = findMin(root-&gt;right); // 将被删除节点的后继节点放在被删除节点的位置 root-&gt;val = min; // 删除原来的后继节点 root-&gt;left = root-&gt;left; root-&gt;right = deleteNode(root-&gt;right, min); &#125; &#125; return root;&#125; 9.二叉搜索树的第 k 大节点 Java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 1.中序遍历二叉搜索树得到升序数列，再找到第k大节点的值。private List&lt;Integer&gt; list;private void inorderTraversal(TreeNode root) &#123; if (root == null) &#123; return; &#125; inorderTraversal(root.left); list.add(root.val); inorderTraversal(root.right);&#125;public int kthLargest(TreeNode root, int k) &#123; list = new ArrayList&lt;&gt;(); inorderTraversal(root); return list.get(list.size() - k);&#125;// 2.优化: 对于升序数组来说，第k小节点值易求，第k大节点值不易求。// 所以逆中序遍历二叉搜索树得到降序数列，当遍历到第k个值时，即得第k大节点值，结束递归。private int k;private int k_number;private void inorderTraversal(TreeNode root) &#123; if (root == null) &#123; return; &#125; inorderTraversal(root.right); if (--k == 0) &#123; k_number = root.val; return; &#125; inorderTraversal(root.left);&#125;public int kthLargest(TreeNode root, int k) &#123; this.k = k; inorderTraversal(root); return k_number;&#125;// 3.迭代(逆中序遍历)public int kthLargest(TreeNode root, int k) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); int count = 0; while (!stack.isEmpty() || root != null) &#123; // 遇到一个节点，就把它压入栈中，并去遍历它的右子树。 while (root != null) &#123; stack.push(root); root = root.right; &#125; // 当右子树遍历结束后，弹出栈顶元素并访问它。 if (!stack.isEmpty()) &#123; root = stack.pop(); if (++count == k) &#123; return root.val; &#125; // 再去中序遍历该节点的左子树 root = root.left; &#125; &#125; return -1;&#125; C 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// 1.中序遍历二叉搜索树得到升序数列，再找到第k大节点的值。void orderTraversal(struct TreeNode* root, int* returnSize, int* arr) &#123; if (!root) &#123; return; &#125; orderTraversal(root-&gt;left, returnSize, arr); arr[(*returnSize)++] = root-&gt;val; orderTraversal(root-&gt;right, returnSize, arr); &#125;// 统计结点数int makeSize(struct TreeNode* root) &#123; if (!root) &#123; return 0; &#125; return makeSize(root-&gt;left) + makeSize(root-&gt;right) + 1;&#125;int kthLargest(struct TreeNode* root, int k)&#123; int size = makeSize(root); int* arr = (int*)malloc(sizeof(int) * size); int* returnSize = (int*)malloc(sizeof(int)); *returnSize = 0; orderTraversal(root, returnSize, arr); return arr[size - k];&#125;// 2.优化: 对于升序数组来说，第k小节点值易求，第k大节点值不易求。// 所以逆中序遍历二叉搜索树得到降序数列，当遍历到第k个值时，即得第k大节点值，结束递归。void orderTraversal(struct TreeNode* root, int* returnSize, int* arr, int k, int* k_number) &#123; if (!root) &#123; return; &#125; orderTraversal(root-&gt;right, returnSize, arr, k, k_number); if (++(*returnSize) == k) &#123; *k_number = root-&gt;val; &#125; orderTraversal(root-&gt;left, returnSize, arr, k, k_number);&#125;// 统计结点数int makeSize(struct TreeNode* root) &#123; if (!root) &#123; return 0; &#125; return makeSize(root-&gt;left) + makeSize(root-&gt;right) + 1;&#125;int kthLargest(struct TreeNode* root, int k)&#123; int size = makeSize(root); int* arr = (int*)malloc(sizeof(int) * size); int* returnSize = (int*)malloc(sizeof(int)); int* k_number = (int*)malloc(sizeof(int)); *returnSize = 0; *k_number = 0; orderTraversal(root, returnSize, arr, k, k_number); return *k_number;&#125;// 3.迭代(逆中序遍历)// 统计结点数int makeSize(struct TreeNode* root) &#123; if (!root) return 0; return makeSize(root-&gt;left) + makeSize(root-&gt;right) + 1;&#125;typedef struct &#123; struct TreeNode** array; int top;&#125; Stack;int kthLargest(struct TreeNode* root, int k)&#123; int size = makeSize(root); int* arr = (int*)malloc(sizeof(int) * size); Stack* s = (Stack*)malloc(sizeof(Stack)); s-&gt;array = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * size); s-&gt;top = -1; int count = 0; while (s-&gt;top != -1 || root) &#123; // 遇到一个节点，就把它压入栈中，并去遍历它的右子树。 while (root) &#123; s-&gt;array[++s-&gt;top] = root; root = root-&gt;right; &#125; // 当右子树遍历结束后，弹出栈顶元素并访问它。 if (s-&gt;top != -1) &#123; root = s-&gt;array[s-&gt;top--]; if (++count == k) &#123; return root-&gt;val; &#125; // 再去中序遍历该节点的左子树 root = root-&gt;left; &#125; &#125; return -1;&#125; 10.二叉搜索树的范围和 Java 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 明确题意: 求出所有满足 节点值&gt;=L且节点值&lt;=R 的节点的值的和// 1.递归解法public int rangeSumBST(TreeNode root, int L, int R) &#123; if (root == null) &#123; return 0; &#125; if (root.val &lt; L) &#123; // root.val&lt;L，说明其左子树所有的值都小于L，排除这些节点。 return rangeSumBST(root.right, L, R); &#125; else if (root.val &gt; R) &#123; // root.val&gt;R，说明其右子树所有的值都大于R，排除这些节点。 return rangeSumBST(root.left, L, R); &#125; else &#123; return root.val + rangeSumBST(root.right, L, R) + rangeSumBST(root.left, L, R); &#125;&#125;// 2.迭代public int rangeSumBST(TreeNode root, int L, int R) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); int sum = 0; stack.push(root); while (!stack.isEmpty()) &#123; TreeNode node = stack.pop(); if (node != null) &#123; // root.val&lt;L，说明其左子树所有的值都小于L，排除这些节点。 if (node.val &lt; L) &#123; stack.push(node.right); &#125; // root.val&gt;R，说明其右子树所有的值都大于R，排除这些节点。 else if (node.val &gt; R) &#123; stack.push(node.left); &#125; else &#123; sum += node.val; stack.push(node.left); stack.push(node.right); &#125; &#125; &#125; return sum;&#125; C 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 明确题意: 求出所有满足 节点值&gt;=L且节点值&lt;=R 的节点的值的和// 1.递归解法int rangeSumBST(struct TreeNode* root, int L, int R) &#123; if (!root) &#123; return 0; &#125; if (root-&gt;val &lt; L) &#123; // root.val&lt;L，说明其左子树所有的值都小于L，排除这些节点。 return rangeSumBST(root-&gt;right, L, R); &#125; else if (root-&gt;val &gt; R) &#123; // root.val&gt;R，说明其右子树所有的值都大于R，排除这些节点。 return rangeSumBST(root-&gt;left, L, R); &#125; else &#123; return root-&gt;val + rangeSumBST(root-&gt;left, L, R) + rangeSumBST(root-&gt;right, L, R); &#125;&#125;// 2.迭代// 统计结点数int makeSize(struct TreeNode* root) &#123; if (!root) return 0; return makeSize(root-&gt;left) + makeSize(root-&gt;right) + 1;&#125;typedef struct &#123; struct TreeNode** array; int top;&#125; Stack;int rangeSumBST(struct TreeNode* root, int L, int R) &#123; int size = makeSize(root), sum = 0; Stack* s = (Stack*)malloc(sizeof(Stack)); s-&gt;array = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * size); s-&gt;top = -1; s-&gt;array[++s-&gt;top] = root; while (s-&gt;top != -1) &#123; struct TreeNode* node = s-&gt;array[s-&gt;top--]; if (node) &#123; // root.val&lt;L，说明其左子树所有的值都小于L，排除这些节点。 if (node-&gt;val &lt; L) &#123; s-&gt;array[++s-&gt;top] = node-&gt;right; &#125; // root.val&gt;R，说明其右子树所有的值都大于R，排除这些节点。 else if (node-&gt;val &gt; R) &#123; s-&gt;array[++s-&gt;top] = node-&gt;left; &#125; else &#123; sum += node-&gt;val; s-&gt;array[++s-&gt;top] = node-&gt;left; s-&gt;array[++s-&gt;top] = node-&gt;right; &#125; &#125; &#125; return sum;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#x79;&#109;&#x65;&#115;&#x73;&#105;&#64;&#49;&#x36;&#x33;&#x2e;&#99;&#111;&#109; 关于 数据结构与算法 的更多代码 请查看我的 GitHub仓库]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的遍历(递归+迭代)]]></title>
    <url>%2F2019%2F02%2F11%2F%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E9%80%92%E5%BD%92-%E8%BF%AD%E4%BB%A3%2F</url>
    <content type="text"><![CDATA[1.相关博客因为二叉树这种数据结构本身天然的就具有递归的结构，所以面对二叉树问题，使用递归方法解决通常比较简单。 二叉树的定义及性质 二叉搜索树的常用操作 红黑树详解 B树和B+树详解 注意：示例代码中的 TreeNode 对象、Node 对象和结构体定义如下： 123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112131415public class Node &#123; public int val; public List&lt;Node&gt; children; public Node() &#123;&#125; public Node(int _val) &#123; val = _val; &#125; public Node(int _val, List&lt;Node&gt; _children) &#123; val = _val; children = _children; &#125;&#125;; 12345struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right;&#125; 2.树的前序遍历 前序遍历也称为先序遍历 遍历过程为： ①访问根结点 ②先序遍历其左子树 ③先序遍历其右子树 举例： 下图的先序遍历结果为：1、2、3、4、5、6、7、8、9。 ①二叉树-递归 Java 12345678910111213141516171819202122class Solution &#123; // 递归函数定义: 前序遍历以root节点为根节点的二叉树 private void traversal(TreeNode root, List list) &#123; // 递归终止条件 if (root == null) &#123; return; &#125; // 递归过程 // 处理当前节点 list.add(root.val); // 前序遍历root节点的左子树 traversal(root.left, list); // 前序遍历root节点的右子树 traversal(root.right, list); &#125; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); traversal(root, list); return list; &#125;&#125; C 12345678910111213141516171819202122232425262728293031// 递归函数，returnSize、arr是指针，动态修改。// 递归函数定义: 前序遍历以root节点为根节点的二叉树void orderTraversal(struct TreeNode* root, int* returnSize, int* arr) &#123; // 递归终止条件 if (!root) &#123; return; &#125; // 递归过程 // 处理当前节点 arr[(*returnSize)++] = root-&gt;val; // 前序遍历root节点的左子树 orderTraversal(root-&gt;left, returnSize, arr); // 前序遍历root节点的右子树 orderTraversal(root-&gt;right, returnSize, arr); &#125;// 统计结点数int makeSize(struct TreeNode* root) &#123; if (!root) &#123; return 0; &#125; return makeSize(root-&gt;left) + makeSize(root-&gt;right) + 1;&#125;int* preorderTraversal(struct TreeNode* root, int* returnSize) &#123; int size = makeSize(root); int* arr = (int*)malloc(sizeof(int) * size); *returnSize = 0; orderTraversal(root, returnSize, arr); return arr;&#125; ②二叉树-迭代 遇到一个节点就访问它，然后把它压入栈中，并去遍历它的左子树。当左子树遍历结束后，弹出栈顶元素，再去先序遍历该节点的右子树。 Java 123456789101112131415161718192021class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (!stack.isEmpty() || root != null) &#123; // 遇到一个节点就访问它，然后把它压入栈中，并去遍历它的左子树。 while (root != null) &#123; list.add(root.val); stack.push(root); root = root.left; &#125; // 当左子树遍历结束后，弹出栈顶元素。 if (!stack.isEmpty()) &#123; root = stack.pop(); // 再去先序遍历该节点的右子树 root = root.right; &#125; &#125; return list; &#125;&#125; C 123456789101112131415161718192021222324252627282930313233343536// 统计结点数int makeSize(struct TreeNode* root) &#123; if (!root) return 0; return makeSize(root-&gt;left) + makeSize(root-&gt;right) + 1;&#125;typedef struct &#123; struct TreeNode** array; int top;&#125; Stack;int* preorderTraversal(struct TreeNode* root, int* returnSize) &#123; int size = makeSize(root); int* arr = (int*)malloc(sizeof(int) * size); *returnSize = 0; Stack* s = (Stack*)malloc(sizeof(Stack)); s-&gt;array = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * size); s-&gt;top = -1; while (s-&gt;top != -1 || root) &#123; // 遇到一个节点就访问它，然后把它压入栈中，并去遍历它的左子树。 while (root) &#123; arr[(*returnSize)++] = root-&gt;val; s-&gt;array[++s-&gt;top] = root; root = root-&gt;left; &#125; // 当左子树遍历结束后，弹出栈顶元素。 if (s-&gt;top != -1) &#123; root = s-&gt;array[s-&gt;top--]; // 再去先序遍历该节点的右子树 root = root-&gt;right; &#125; &#125; return arr;&#125; ③N叉树-递归 Java 123456789101112131415161718192021class Solution &#123; // 递归函数定义: 前序遍历以root节点为根节点的N叉树 private void traversal(Node root, List list) &#123; // 递归终止条件 if (root == null) &#123; return; &#125; // 递归过程 // 处理当前节点 list.add(root.val); // 前序遍历root节点的每个子树 for (Node node: root.children) &#123; traversal(node, list); &#125; &#125; public List&lt;Integer&gt; preorder(Node root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); traversal(root, list); return list; &#125;&#125; ④N叉树-迭代 Java 1234567891011121314151617181920class Solution &#123; public List&lt;Integer&gt; preorder(Node root) &#123; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (root == null) &#123; return list; &#125; stack.push(root); while (!stack.isEmpty()) &#123; root = stack.pop(); list.add(root.val); // 将N叉树的子树从右向左推入栈中，这样子树出栈的顺序是从左到右。 Collections.reverse(root.children); for (Node n: root.children) &#123; stack.push(n); &#125; &#125; return list; &#125;&#125; 3.树的中序遍历 遍历过程为： ①中序遍历其左子树 ②访问根结点 ③中序遍历其右子树 对于二分搜索树来说，中序遍历使得元素从小到大排序。 举例： 下图的中序遍历结果为：1、2、3、4、5、6、7、8、9。 ①二叉树-递归 Java 12345678910111213141516171819202122class Solution &#123; // 递归函数定义: 中序遍历以root节点为根节点的二叉树 private void traversal(TreeNode root, List list) &#123; // 递归终止条件 if (root == null) &#123; return; &#125; // 递归过程 // 中序遍历root节点的左子树 traversal(root.left, list); // 处理当前节点 list.add(root.val); // 中序遍历root节点的右子树 traversal(root.right, list); &#125; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); traversal(root, list); return list; &#125;&#125; C 12345678910111213141516171819202122232425262728293031// 递归函数，returnSize、arr是指针，动态修改。// 递归函数定义: 中序遍历以root节点为根节点的二叉树void orderTraversal(struct TreeNode* root, int* returnSize, int* arr) &#123; // 递归终止条件 if (!root) &#123; return; &#125; // 递归过程 // 中序遍历root节点的左子树 orderTraversal(root-&gt;left, returnSize, arr); // 处理当前节点 arr[(*returnSize)++] = root-&gt;val; // 中序遍历root节点的右子树 orderTraversal(root-&gt;right, returnSize, arr); &#125;// 统计结点数int makeSize(struct TreeNode* root) &#123; if (!root) &#123; return 0; &#125; return makeSize(root-&gt;left) + makeSize(root-&gt;right) + 1;&#125;int* inorderTraversal(struct TreeNode* root, int* returnSize) &#123; int size = makeSize(root); int* arr = (int*)malloc(sizeof(int) * size); *returnSize = 0; orderTraversal(root, returnSize, arr); return arr;&#125; ②二叉树-迭代 遇到一个节点，就把它压入栈中，并去遍历它的左子树。当左子树遍历结束后，弹出栈顶元素并访问它，再去中序遍历该节点的右子树。 Java 123456789101112131415161718192021class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (!stack.isEmpty() || root != null) &#123; // 遇到一个节点，就把它压入栈中，并去遍历它的左子树。 while (root != null) &#123; stack.push(root); root = root.left; &#125; // 当左子树遍历结束后，弹出栈顶元素并访问它。 if (!stack.isEmpty()) &#123; root = stack.pop(); list.add(root.val); // 再去中序遍历该节点的右子树 root = root.right; &#125; &#125; return list; &#125;&#125; C 123456789101112131415161718192021222324252627282930313233343536// 统计结点数int makeSize(struct TreeNode* root) &#123; if (!root) return 0; return makeSize(root-&gt;left) + makeSize(root-&gt;right) + 1;&#125;typedef struct &#123; struct TreeNode** array; int top;&#125; Stack;int* inorderTraversal(struct TreeNode* root, int* returnSize) &#123; int size = makeSize(root); int* arr = (int*)malloc(sizeof(int) * size); *returnSize = 0; Stack* s = (Stack*)malloc(sizeof(Stack)); s-&gt;array = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * size); s-&gt;top = -1; while (s-&gt;top != -1 || root) &#123; // 遇到一个节点，就把它压入栈中，并去遍历它的左子树。 while (root) &#123; s-&gt;array[++s-&gt;top] = root; root = root-&gt;left; &#125; // 当左子树遍历结束后，弹出栈顶元素并访问它。 if (s-&gt;top != -1) &#123; root = s-&gt;array[s-&gt;top--]; arr[(*returnSize)++] = root-&gt;val; // 再去中序遍历该节点的右子树 root = root-&gt;right; &#125; &#125; return arr;&#125; 4.树的后序遍历 遍历过程为： ①后序遍历其左子树 ②后序遍历其右子树 ③访问根结点 举例： 下图的后序遍历结果为：1、2、3、4、5、6、7、8、9。 ①二叉树-递归 Java 12345678910111213141516171819202122class Solution &#123; // 递归函数定义: 后序遍历以root节点为根节点的二叉树 private void traversal(TreeNode root, List list) &#123; // 递归终止条件 if (root == null) &#123; return; &#125; // 递归过程 // 后序遍历root节点的左子树 traversal(root.left, list); // 后序遍历root节点的右子树 traversal(root.right, list); // 处理当前节点 list.add(root.val); &#125; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); traversal(root, list); return list; &#125;&#125; C 12345678910111213141516171819202122232425262728293031// 递归函数，returnSize、arr是指针，动态修改。// 递归函数定义: 后序遍历以root节点为根节点的二叉树void orderTraversal(struct TreeNode* root, int* returnSize, int* arr) &#123; // 递归终止条件 if (!root) &#123; return; &#125; // 递归过程 // 后序遍历root节点的左子树 orderTraversal(root-&gt;left, returnSize, arr); // 后序遍历root节点的右子树 orderTraversal(root-&gt;right, returnSize, arr); // 处理当前节点 arr[(*returnSize)++] = root-&gt;val;&#125;// 统计结点数int makeSize(struct TreeNode* root) &#123; if (!root) &#123; return 0; &#125; return makeSize(root-&gt;left) + makeSize(root-&gt;right) + 1;&#125;int* postorderTraversal(struct TreeNode* root, int* returnSize) &#123; int size = makeSize(root); int* arr = (int*)malloc(sizeof(int) * size); *returnSize = 0; orderTraversal(root, returnSize, arr); return arr;&#125; ②二叉树-迭代 后序遍历的顺序是：左右中 先序遍历的顺序是：中左右 所以我们可以先将先序遍历修改为：中右左，再将其遍历结果翻转存放，即可得到后序遍历的结果。 Java 123456789101112131415161718192021222324class Solution &#123; // 先将先序遍历的中左右改为中右左，再将遍历结果翻转，即可得到后序遍历的左右中。 public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (!stack.isEmpty() || root != null) &#123; // 遇到一个节点就访问它，然后把它压入栈中，并去遍历它的右子树。 while (root != null) &#123; list.add(root.val); stack.push(root); root = root.right; &#125; // 当右子树遍历结束后，弹出栈顶元素。 if (!stack.isEmpty()) &#123; root = stack.pop(); // 再去"改写的先序"遍历该节点的左子树 root = root.left; &#125; &#125; // 将遍历结果翻转 Collections.reverse(list); return list; &#125;&#125; C 123456789101112131415161718192021222324252627282930313233343536373839// 先将先序遍历的中左右改为中右左，再将遍历结果翻转，即可得到后序遍历的左右中。// 统计结点数int makeSize(struct TreeNode* root) &#123; if (!root) return 0; return makeSize(root-&gt;left) + makeSize(root-&gt;right) + 1;&#125;typedef struct &#123; struct TreeNode** array; int top;&#125; Stack;int* postorderTraversal(struct TreeNode* root, int* returnSize) &#123; int size = makeSize(root); int* arr = (int*)malloc(sizeof(int) * size); Stack* s = (Stack*)malloc(sizeof(Stack)); s-&gt;array = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * size); s-&gt;top = -1; *returnSize = size; int row = *returnSize-1; while (root || s-&gt;top != -1) &#123; // 遇到一个节点就访问它，然后把它压入栈中，并去遍历它的右子树。 while (root) &#123; // 反向存储遍历结果 arr[row--] = root-&gt;val; s-&gt;array[++s-&gt;top] = root; root = root-&gt;right; &#125; // 当右子树遍历结束后，弹出栈顶元素。 if (s-&gt;top != -1) &#123; root = s-&gt;array[s-&gt;top--]; // 再去"改写的先序"遍历该节点的左子树 root = root-&gt;left; &#125; &#125; return arr;&#125; ③N叉树-递归 Java 123456789101112131415161718192021class Solution &#123; // 递归函数定义: 后序遍历以root节点为根节点的N叉树 private void traversal(Node root, List list) &#123; // 递归终止条件 if (root == null) &#123; return; &#125; // 递归过程 // 后序遍历root节点的每个子树 for (Node node: root.children) &#123; traversal(node, list); &#125; // 处理当前节点 list.add(root.val); &#125; public List&lt;Integer&gt; postorder(Node root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); traversal(root, list); return list; &#125;&#125; ④N叉树-迭代 Java 12345678910111213141516171819202122class Solution &#123; // 与二叉树的后序遍历——迭代法同理 public List&lt;Integer&gt; postorder(Node root) &#123; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (root == null) &#123; return list; &#125; stack.push(root); while (!stack.isEmpty()) &#123; root = stack.pop(); list.add(root.val); // 将N叉树的子树从左向右推入栈中，这样子树出栈的顺序是从右到左。 for (Node n: root.children) &#123; stack.push(n); &#125; &#125; // 将遍历结果翻转 Collections.reverse(list); return list; &#125;&#125; 5.树的层序遍历 从根节点开始，首先将根节点入队，然后开始执行循环：节点出队、访问该节点、其左右孩子入队。 举例： 下图的层序遍历结果为：5、2、8、1、4、6、9、3、7。 注意：层序遍历的示例代码输出格式为下图所示格式。 ①二叉树-迭代 Java 12345678910111213141516171819202122232425262728293031class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (root == null) &#123; return res; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); // 将根节点入队 queue.add(root); while (!queue.isEmpty()) &#123; // 使用count分层 int count = queue.size(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (count-- &gt; 0) &#123; // 节点出队 TreeNode node = queue.poll(); // 访问该节点 list.add(node.val); // 其左右孩子入队 if (node.left != null) &#123; queue.add(node.left); &#125; if (node.right != null) &#123; queue.add(node.right); &#125; &#125; res.add(list); &#125; return res; &#125;&#125; ②N叉树-迭代 Java 12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (root == null) &#123; return res; &#125; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); // 将根节点入队 queue.add(root); while (!queue.isEmpty()) &#123; // 使用count分层 int count = queue.size(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (count-- &gt; 0) &#123; // 节点出队 Node node = queue.poll(); // 访问该节点 list.add(node.val); // 其所有孩子从左到右依次入队 for (Node n: node.children) &#123; queue.add(n); &#125; &#125; res.add(list); &#125; return res; &#125;&#125; 6.总结 前、中、后序遍历都属于 深度优先遍历。 即首先尝试走到最深，走不通之后再返回用回溯的方式将整棵树遍历结束。 三种遍历实际访问节点的顺序相同，只是执行打印的位置不同。 实现深度优先遍历：需要堆栈。 层序遍历属于 广度优先遍历。 一层一层地遍历，关注广度，将每层的所有结点遍历完再去下一层。 实现广度优先遍历：需要队列。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#x79;&#109;&#101;&#x73;&#x73;&#x69;&#x40;&#49;&#54;&#x33;&#46;&#99;&#111;&#109; 关于 数据结构与算法 的更多代码 请查看我的 GitHub仓库]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找法代码实现]]></title>
    <url>%2F2019%2F01%2F05%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1.概念 对于有序数列，才能使用二分查找法。 二分查找又称折半查找。 优点：比较次数少、查找速度快、平均性能好 缺点：要求待查表为有序表、插入和删除困难 因此二分查找适用于不经常变动且查找频繁的有序列表 2.代码实现 二分查找法：在有序数组 arr 中查找 target。 如果找到 target，返回相应的索引 index。 如果没有找到 target，返回 -1。 时间复杂度：O(log n) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * @author: wjy * @date: 2020/2/21 * @description: 二分查找法: 在有序数组arr中查找target。 * 如果找到target，返回相应的索引index。如果没有找到target，返回-1。 * 时间复杂度: O(log n) */public class BinarySearch &#123; /** * 功能描述: 使用迭代的方法实现二分查找法。 * * @param: [arr, target] * @return: int * @auther: wjy * @date: 2020/2/21 21:10 */ public static int binarySearch(int[] arr, int target) &#123; // 在arr[l...r]之中查找target int l = 0, r = arr.length - 1; while (l &lt;= r) &#123; // int mid = (l + r) / 2; // 防止极端情况下的整形溢出，用以下方法求mid。 // int mid = l + (r - l) / 2; // 模仿jdk源码中的写法，无符号右移一位。 int mid = (l + r) &gt;&gt;&gt; 1; if (arr[mid] == target) &#123; return mid; &#125; else if (target &lt; arr[mid]) &#123; // 在arr[l...mid-1]之中查找target r = mid - 1; &#125; else &#123; // 在arr[mid+1...r]之中查找target l = mid + 1; &#125; &#125; return -1; &#125; /** * 功能描述: 使用递归的方法实现二分查找法(性能上略差，但差异是常数级的)。 * * @param: [arr, l, r, target] * @return: int * @auther: wjy * @date: 2020/2/21 20:58 */ public static int binarySearchByRecursion(int[] arr, int l, int r, int target) &#123; // 在arr[l...r]之中查找target if (l &gt; r) &#123; return -1; &#125; // int mid = (l + r) / 2; // 防止极端情况下的整形溢出，用以下方法求mid。 // int mid = l + (r - l) / 2, index = -1; // 模仿jdk源码中的写法，无符号右移一位。 int mid = (l + r) &gt;&gt;&gt; 1, index = -1; if (arr[mid] == target) &#123; index = mid; &#125; else if (target &lt; arr[mid]) &#123; // 在arr[l...mid-1]之中查找target index = binarySearchByRecursion(arr, l, mid - 1, target); &#125; else &#123; // 在arr[mid+1...r]之中查找target index = binarySearchByRecursion(arr, mid + 1, r, target); &#125; return index; &#125; /** * 功能描述: 测试迭代方法和递归方法的正确性 * * @param: [args] * @return: void * @auther: wjy * @date: 2020/2/21 20:39 */ public static void main(String[] args) &#123; // 生成一个有序数组 int n = 100; int[] arr = new int[n]; for (int i = 0; i &lt; n; i++) &#123; arr[i] = i; &#125; int random = (int) (Math.random() * n); System.out.println("随机数: " + random + " 迭代方法执行结果: " + binarySearch(arr, random)); System.out.println("随机数: " + random + " 递归方法执行结果: " + binarySearchByRecursion(arr, 0, n - 1, random)); &#125;&#125; 3.Leetcode 题解举例 [LeetCode] 35.搜索插入位置（Easy）Java语言题解 [LeetCode] 35.搜索插入位置（Easy）C语言题解 优秀题解分享：用“排除法”（减治思想）写二分查找问题 4.扩展问题 如果有序数列中存在多个 target 值，我们应该返回什么呢？ 使用上述代码，并不能确定我们找到的索引具体对应哪一个 target。 为了解决这个问题，我们额外定义两个函数： ①floor() 函数: 返回 target 在数组中第一次出现的位置，若是元素不存在，返回数组中小于 target 的最大元素。 ②ceil() 函数: 返回 target 在数组中最后一次出现的位置，若是元素不存在，返回数组中大于 target 的最小元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * @author: wjy * @date: 2020/2/21 * @description: 二分查找法的扩展问题: 当数组中存在多个target值时，应该返回什么？ */public class BinarySearchExtend &#123; public static int floor(int[] arr, int target) &#123; int l = 0, r = arr.length - 1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt;&gt; 1; if (arr[mid] &lt; target) &#123; l = mid + 1; &#125; else &#123; r = mid - 1; &#125; &#125; // 所有元素都小于target if (l == arr.length) &#123; return l - 1; &#125; return arr[l] == target? l: l - 1; &#125; public static int ceil(int[] arr, int target) &#123; int l = 0, r = arr.length - 1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt;&gt; 1; if (arr[mid] &gt; target) &#123; r = mid - 1; &#125; else &#123; l = mid + 1; &#125; &#125; // 所有元素都大于target if (r &lt; 0) &#123; return 0; &#125; // 所有元素都小于target if (l == arr.length) &#123; return l - 1; &#125; return arr[r] == target? r: r + 1; &#125; /** * 功能描述: 测试floor()函数和ceil()函数 * * @param: [args] * @return: void * @auther: wjy * @date: 2020/2/21 20:39 */ public static void main(String[] args) &#123; int[] arr = &#123;0, 1, 3, 4, 4, 4, 4, 5, 6, 6&#125;; int random = (int) (Math.random() * arr.length); System.out.println("floor(arr, " + random + ") = " + floor(arr, random)); System.out.println("ceil(arr, " + random + ") = " + ceil(arr, random)); &#125;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#x79;&#109;&#x65;&#115;&#115;&#x69;&#x40;&#49;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d; 关于 数据结构与算法 的更多代码 请查看我的 GitHub仓库]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 35.搜索插入位置（Easy）Java语言题解]]></title>
    <url>%2F2019%2F01%2F04%2FLeetCode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%EF%BC%88Easy%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.题目相关①题目及示例 ②相关标签 数组 二分查找 ③题目地址 35. 搜索插入位置 — 力扣网 2.解题方法①顺序查找 根据题意可以看出，数组中第一个大于或等于 target 的元素对应的下标就是 target 将要插入的位置，若是数组中的元素都比 target 小，则返回数组长度。 时间复杂度：O(n) 空间复杂度：O(1) ②二分查找 结论： 每次判断 nums[mid] 和 target 之间的大小： 若 nums[mid] = target，则直接返回下标。 若 nums[mid] &lt; target，则 left = mid + 1。 若 nums[mid] &gt; target，则 right = mid - 1。 查找结束后返回 left，该值为插入位置。 这道题的难点是如果数组中不包含值和 target 相等的元素，那么我们要返回什么呢？上文的结论是返回 left，那么我们是如何得到的呢？ 此时我们可以想象程序在最后一次循环中会做什么： 已知程序结束循环的条件是 left &gt; right，所以我们可以确定在最后一次循环中有：right == left -&gt; mid == (right + left) / 2 == right == left，此时存在两种情况： 12345if (nums[mid] &lt; target) &#123; // left &gt; right，之后退出循环。 left = mid + 1;&#125;// 退出循环后，nums[left] = nums[right + 1] &gt; target。 12345if (nums[mid] &gt; target) &#123; // right &lt; left，之后退出循环。 right = mid - 1;&#125;// 退出循环后，nums[left] = nums[mid] &gt; target。 根据上述证明可知，返回 left 是正确的。 时间复杂度：O(log n) 空间复杂度：O(1) 注意：修改以上代码的返回结果，也可以用于求解其他题目。 返回 left，表示查找比 target 大的最小数的位置，适用于本题以及 278. 第一个错误的版本、744. 寻找比目标字母大的最小字母 等题。 返回 right，表示查找比 target 小的最大数的位置，适用于 441. 排列硬币、69. x 的平方根 等题。 返回 -1 或者 false，表示查找不到 target，适用于 704. 二分查找、367. 有效的完全平方数、74. 搜索二维矩阵 等题。 如果题目中说明一定能找到 target，这时返回哪个值都可以，适用于 852. 山脉数组的峰顶索引 等题。 3.代码详解①暴力解法123456789public int searchInsert(int[] nums, int target) &#123; int len = nums.length; for (int i = 0; i &lt; len; i++) &#123; if (nums[i] &gt;= target) &#123; return i; &#125; &#125; return len;&#125; ②二分查找123456789101112131415161718public int searchInsert(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; // int mid = (left + right) / 2; // int mid = left + (right - left) / 2; int mid = (left + right) &gt;&gt;&gt; 1; if (nums[mid] == target) &#123; return mid; &#125; else if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; return left;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#x6a;&#x79;&#x6d;&#x65;&#115;&#115;&#105;&#x40;&#49;&#54;&#x33;&#x2e;&#99;&#x6f;&#x6d; 关于 数据结构与算法 的更多代码 请查看我的 GitHub仓库]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>LeetCode-Java</category>
      </categories>
      <tags>
        <tag>LeetCode题解</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 35.搜索插入位置（Easy）C语言题解]]></title>
    <url>%2F2019%2F01%2F04%2FLeetCode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%EF%BC%88Easy%EF%BC%89C%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.题目相关①题目及示例 ②相关标签 数组 二分查找 ③题目地址 35. 搜索插入位置 — 力扣网 2.解题方法①顺序查找 根据题意可以看出，数组中第一个大于或等于 target 的元素对应的下标就是 target 将要插入的位置，若是数组中的元素都比 target 小，则返回数组长度。 时间复杂度：O(n) 空间复杂度：O(1) ②二分查找 结论： 每次判断 nums[mid] 和 target 之间的大小： 若 nums[mid] = target，则直接返回下标。 若 nums[mid] &lt; target，则 left = mid + 1。 若 nums[mid] &gt; target，则 right = mid - 1。 查找结束后返回 left，该值为插入位置。 这道题的难点是如果数组中不包含值和 target 相等的元素，那么我们要返回什么呢？上文的结论是返回 left，那么我们是如何得到的呢？ 此时我们可以想象程序在最后一次循环中会做什么： 已知程序结束循环的条件是 left &gt; right，所以我们可以确定在最后一次循环中有：right == left -&gt; mid == (right + left) / 2 == right == left，此时存在两种情况： 12345if (nums[mid] &lt; target) &#123; // left &gt; right，之后退出循环。 left = mid + 1;&#125;// 退出循环后，nums[left] = nums[right + 1] &gt; target。 12345if (nums[mid] &gt; target) &#123; // right &lt; left，之后退出循环。 right = mid - 1;&#125;// 退出循环后，nums[left] = nums[mid] &gt; target。 根据上述证明可知，返回 left 是正确的。 时间复杂度：O(log n) 空间复杂度：O(1) 注意：修改以上代码的返回结果，也可以用于求解其他题目。 返回 left，表示查找比 target 大的最小数的位置，适用于本题以及 278. 第一个错误的版本、744. 寻找比目标字母大的最小字母 等题。 返回 right，表示查找比 target 小的最大数的位置，适用于 441. 排列硬币、69. x 的平方根 等题。 返回 -1 或者 false，表示查找不到 target，适用于 704. 二分查找、367. 有效的完全平方数、74. 搜索二维矩阵 等题。 如果题目中说明一定能找到 target，这时返回哪个值都可以，适用于 852. 山脉数组的峰顶索引 等题。 3.代码详解①暴力解法12345678int searchInsert(int* nums, int numsSize, int target) &#123; for (int i = 0; i &lt; numsSize; i++) &#123; if (nums[i] &gt;= target) &#123; return i; &#125; &#125; return numsSize;&#125; ②二分查找123456789101112131415161718int searchInsert(int* nums, int numsSize, int target) &#123; int left = 0, right = numsSize - 1; while (left &lt;= right) &#123; // int mid = (left + right) / 2; // int mid = left + (right - left) / 2; int mid = (left + right) &gt;&gt;&gt; 1; if (nums[mid] == target) &#123; return mid; &#125; else if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; return left;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#106;&#121;&#109;&#101;&#115;&#x73;&#x69;&#64;&#x31;&#x36;&#51;&#46;&#99;&#111;&#109; 关于 数据结构与算法 的更多代码 请查看我的 GitHub仓库]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>LeetCode-C</category>
      </categories>
      <tags>
        <tag>LeetCode题解</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言常用库函数整理]]></title>
    <url>%2F2018%2F12%2F20%2FC%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[PS：include 称为文件包含命令，即它把 &lt; &gt; 或 &quot; &quot; 内指定的文件包含到程序中。被包含的(头)文件通常是由系统提供的，其扩展名为 .h。如下介绍了 stdio.h、stdlib.h、string.h、math.h 等系统提供的文件。 1.stdio.h 标准 I/O 库。 int scanf(char *format, args, …)：按 format 指定的格式将输入数据存入到 args，… 指定的内存中(读取到空格就停止)。 int printf(char *format, args, …)：将 args，… 的值以 format 指定的格式输出。 char *gets(char *str)：从标准输入中读取一行，并把它存储在 str 所指向的字符串中(读取到换行符或者到达文件末尾时停止，读取到空格不停止)。 int getchar(void)：从标准输入中读取下一个字符。| 如果没有错误发生，返回相同的字符，如果碰到文件结尾或者有错误发生，则返回 EOF。 int putchar(int character)：将字符输出到标准输出中。| 如果没有错误发生，返回相同的字符，如果有错误发生，则返回 EOF。 int sprintf(char *str, const char *format, …)：格式化输出到 str 所指向的字符串。 12345int a = 123;char* s1 = "abc";char* s2;sprintf(s2, "%d %s", a, s1);printf("%s", s2); // 123 abc。 宏 EOF 是一个负整数，通常在有函数调用错误或者碰到文件结尾时返回。 1234// 判断是否到达输入流末尾。if (scanf("%d", %num) != EOF) &#123; ...&#125; 2.stdlib.h①分配空间 void *calloc(unsigned n, unsigned size)：分配所需的内存空间，并返回一个指向它的指针。 void *malloc(unsigned size)：分配所需的内存空间，并返回一个指向它的指针。 1234// 如: 向系统申请分配100个int型的连续内存空间。// 并返回所分配的内存空间的首地址。int* array = malloc(sizeof(int)*100); int* array = calloc(100, sizeof(int)); void *realloc(void *ptr, unsigned size)：重新调整之前调用 malloc 或 calloc 所分配的内存块的大小(其中 ptr 为指向内存块的指针)。 void free(void *ptr)：释放调用 calloc、malloc 或 realloc 所分配的内存空间(即释放 ptr 指针所指向的内存空间)。 ②算法相关 执行快速排序： 12345678910// 主函数外声明一个compare函数，决定升序/降序。int compare(const void* a, const void* b) &#123; // 升序。 return (*(待排元素类型*)a) -/&gt; (*(待排元素类型*)b); // 降序。 return (*(待排元素类型*)b) -/&gt; (*(待排元素类型*)a);&#125;// 主函数内调用快排函数，进行快速排序。qsort(待排数组首地址, 待排元素总个数, sizeof(待排元素类型), compare(函数，决定升序/降序)); 执行二分查找： 1234567891011// 主函数外声明一个compare函数，决定升序/降序。int compare(const void* a, const void* b) &#123; // 升序。 return (*(待排元素类型*)a) -/&gt; (*(待排元素类型*)b); // 降序。 return (*(待排元素类型*)b) -/&gt; (*(待排元素类型*)a);&#125;// 主函数内调用二分查找函数，查找某个元素。int* ptr;ptr = (int*)bsearch(指向要查找元素的指针, 待查数组首地址, 待查数组的元素总个数, sizeof(待排元素类型), compare(函数，决定升序/降序)); 如果查找成功，则返回一个指向数组中匹配元素的指针，否则返回空指针。 ③其他 int rand(void)：返回一个范围在 0 - RAND_MAX(32767) 之间的伪随机数。 123456// 返回[0-10)之间的随机数。printf("%d", rand()%10);// 返回[20-30)之间的随机数。printf("%d", rand()%10+20);// 返回[m,n)范围内的随机数num，可用：prinrf("%d", rand()%(n-m)+m); int abs(int x)：求整数 x 的绝对值。 long int labs(long int x)：返回长整型 x 的绝对值。 int atoi(const char *str)：把参数 str 所指向的字符串转换为一个 int 型整数。 123char* s = "521 abc";int a = atoi(s);printf("%d", a); // 521。 double atof(const char *str)：把参数 str 所指向的字符串转换为一个 double 型浮点数。 long int atol(const char *str)：把参数 str 所指向的字符串转换为一个 long int 型长整数。 void exit(int status)：使一个程序正常终止(status 为 0)，或非正常终止(status 为 1)。 void abort(void)：使一个异常程序终止。 ④库宏RAND_MAX： rand 函数返回的最大值。NULL：是一个空指针常量的值。 NULL——stdio.h、string.h 头文件中也有此宏。 3.string.h string.h 头文件定义了各种操作字符数组的函数。 int strcmp(const char *str1, const char *str2)：把 str1 所指向的字符串和 str2 所指向的字符串进行比较。 12345678910111213/* strcmp()函数会按照ASCII码顺序比较两个字符串，并由函数返回值返回比较结果。 字符串1 ＝ 字符串2，返回值 ＝ 0。 字符串2 &gt; 字符串2，返回值 &gt; 0。 字符串1 &lt; 字符串2，返回值 &lt; 0。 */char* s1 = "asd";char* s2 = "asd";// 两字符串相等，返回1，否则，返回0。if (strcmp(s1, s2) == 0) return 1; else return 0; size_t strlen(const char *str)：计算字符串 str 的长度。 char *strcpy(char *dest, const char *src)：把 src 所指向的字符串复制到 dest。 char *strcat(char *dest, const char *src)：把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。 12345678910// 注意: 以下代码会出现错误。char* s = malloc(sizeof(char)*10);char arr[5] = "abcde";strcat(s, arr);// ×，必须给s赋初值，再使用此函数。// 正确操作。char s[5] = "aaaaa";char arr[5] = "bbbbb";strcat(s, arr);printf("%s", s);// aaaaabbbbb。 void *memcpy(void *str1, const void *str2, size_t n)：从存储区 str2 复制 n 个字符到存储区 str1。| 返回一个指向目标存储区 str1 的指针。 char *strtok(char *str, const char *delim)：分解字符串 str，其中 delim 为分隔符。| str — 要被分解的字符串。| delim — 包含分隔符的 C 字符串。 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main() &#123; char s[15] = "I am so cold"; char** arr = (char**)malloc(sizeof(char*)*4); int i = 0; arr[i] = (char*)malloc(sizeof(char)*5); arr[i] = strtok(s, " "); /* 输出: I am so cold */ while (arr[i] != NULL) &#123; printf("%s\n", arr[i]); i++; arr[i] = (char*)malloc(sizeof(char)*5); arr[i] = strtok(NULL, " "); &#125; return 0;&#125; 4.math.h math.h 头文件定义了各种数学函数，此库中所有函数都带有一个 double 类型的参数，且都返回 double 类型的结果。 ①普通数字处理 double fabs(double x)：求浮点数 x 的绝对值。 double sqrt(double x)：计算 x 的平方根。 double pow(double x, double y)：计算 x 的 y 次幂。 double fmod (double x, double y)：返回 x / y 的余数。 double exp(double x)：求 e 的 x 次幂，e = 2.718281828。 double log(double x)：计算 x 的自然对数，即 e 为底数，x 的值应大于零。 double log10(double x)：计算 x 的常用对数，即 10 为底数，x 的值应大于零。 double floor(double x)：求不大于 x 的最大整数。| 返回 x 的下限，如 74.12 的下限为 74，-74.12 的下限为 -75，返回值为 double 类型。 double ceil(double x)：求不小于 x 的最小整数。| 返回 x 的上限，如 74.12 的上限为 75，-74.12 的上限为 -74，返回值为 double 类型。 ②三角函数 double cos(double x)：求 x (弧度表示)的余弦值。 double sin(double x)：求 x (弧度表示)的正弦值。 double tan(double x)：求 x (弧度表示)的正切值。 ③其他 double hypot(double x, double y)：x、y 为直角三角形的两个直角边，返回其斜边的长度。 double modf(double x, double *ip)：将 x 的整数部分通过指针回传，返回其小数部分，并将整数部分保存在 *ip 中。 5.ctype.h 如果参数 c 满足函数条件，则如下函数返回非零值(即 true)。如果不满足，则如下函数返回零(即 false)。 int isalnum(int c)：检查所传的字符是否是字母和数字。 int isalpha(int c)：该函数检查所传的字符是否是字母。 int islower(int c)：检查所传的字符是否是小写字母。 int isupper(int c)：检查所传的字符是否是大写字母。 int isdigit(int c)：检查所传的字符是否是十进制数字。 int isxdigit(int c)：检查所传的字符是否是十六进制数字。 int tolower(int c)：把大写字母转换为小写字母。 int toupper(int c)：把小写字母转换为大写字母。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#x79;&#x6d;&#x65;&#115;&#115;&#x69;&#x40;&#x31;&#54;&#x33;&#46;&#99;&#111;&#109;]]></content>
      <categories>
        <category>C &amp; Go</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASC2码]]></title>
    <url>%2F2018%2F12%2F18%2FASC%E2%85%A1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[方便用时查看。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#121;&#x6d;&#101;&#x73;&#115;&#105;&#x40;&#49;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#109;]]></content>
      <categories>
        <category>C &amp; Go</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON快速入门(JAVA版)]]></title>
    <url>%2F2018%2F12%2F11%2FJSON%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-JAVA%E7%89%88%2F</url>
    <content type="text"><![CDATA[org.json、gson 等 jar 包的下载：链接：https://pan.baidu.com/s/1sjMDVajQgR-ihFvAZ54ymg提取码：dt84 1.了解 JSON 它的全称为 JavaScript Object Notation。 ①优点 JSON 是一种与开发语言无关的、轻量级的数据交换格式。| 它采用完全独立于编程语言的文本格式来存储和表示数据。| 最初来自 JS，后来几乎每种常用语言都有处理 JSON 的 API，它支持多种服务器端语言，便于服务器端的解析。 JSON 是行业内使用最为广泛的数据传输格式。| 调用服务端 API 时会使用 JSON 作为返回格式。 JSON 是数据存储的一种格式，格式简单、易于读写、占用带宽小。| 它易于易于程序的解析和生成，并能有效的提升网络传输效率。 ②缺点 要求字符集必须是 Unicode，受约束性强。 ③实例 { }：标识一个 JSON 对象(即结构体)。| { } 中包含键值对结构，key 必须是 String 类型，value 为任何基本类型、对象或数组，多个键值对之间用逗号分隔。 []：数组 Array，用逗号分隔元素。| 在 Java 中，可用集合、string[] 等定义。 元素基本类型：String、number、true、false、null。| JSON 中的数字没有浮点数、整数 … 之分。但在 Java 中，JSONObject 的 put 方法会自动区分不同的数字格式。这是一种 JSON 原生数据格式到 Java 数据格式的映射关系。| 标准 JSON 中不支持任何形式的注释。| JSON 中没有日期 / 时间数据格式。 2.org.json 包的使用①使用 JSONObject 构建 JSON 对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package json;import org.json.JSONException;import org.json.JSONObject;/** * @Auther: wjy * @Date: 2019/4/10 16:34 * @Description: 使用JSONObject构建JSON对象。 */public class jsonTest &#123; public static void main(String[] args) &#123; JSONObject messi = new JSONObject(); Object null1 = null; try &#123; messi.put("name", "messi"); // put方法具有替代性，第二次赋值会代替第一次赋值。 messi.put("name", "梅西"); messi.put("age", 31.8); // JSON中用String类型代替日期类型。 messi.put("birthday", "1987-06-24"); messi.put("home", "Barcelona"); // 可用集合、string[]等定义JSON数组。 messi.put("major", new String[]&#123;"player", "star"&#125;); messi.put("car", true); messi.put("house", true); // 直接使用null会产生二义性。 messi.put("daughter", null1); messi.put("girlfriend", "安东内拉"); // 此键值作为JSON数据的注释。 messi.put("comment", "love him!!"); // 打印JSON格式的数据。 /* * 自动去除空格 —— 压缩数据。 * 与键值的插入顺序不同。 * &#123;"birthday":"1987-06-24","girlfriend":"安东内拉","major":["player","star"],"car":true,"name":"梅西","comment":"love him!!","house":true,"age":31.8,"home":"Barcelona"&#125; */ System.out.println(messi.toString()); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ②使用 Map 构建 JSON 对象1234567891011121314151617181920212223242526272829303132333435363738394041424344package json;import org.json.JSONObject;import java.util.HashMap;/** * @Auther: wjy * @Date: 2019/4/10 16:34 * @Description: 使用Map构建JSON对象。 */public class jsonTest &#123; public static void main(String[] args) &#123; HashMap&lt;String, Object&gt; messi = new HashMap&lt;String, Object&gt;(); Object null1 = null; messi.put("name", "messi"); // put方法具有替代性，第二次赋值会代替第一次赋值。 messi.put("name", "梅西"); messi.put("age", 31.8); // JSON中用String类型代替日期类型。 messi.put("birthday", "1987-06-24"); messi.put("home", "Barcelona"); // 可用集合、string[]等定义JSON数组。 messi.put("major", new String[]&#123;"player", "star"&#125;); messi.put("car", true); messi.put("house", true); // 直接使用null会产生二义性。 messi.put("daughter", null1); messi.put("girlfriend", "安东内拉"); // 此键值作为JSON数据的注释。 messi.put("comment", "love him!!"); // 打印JSON格式的数据。 /* * 通过JSONObject的构造函数传入Map对象,来构建一个JSON对象。 * 自动去除空格 —— 压缩数据。 * 与键值的插入顺序不同。 * &#123;"birthday":"1987-06-24","girlfriend":"安东内拉","major":["player","star"],"car":true,"name":"梅西","comment":"love him!!","house":true,"age":31.8,"home":"Barcelona"&#125; */ System.out.println(new JSONObject(messi).toString()); &#125;&#125; ③使用 Javabean 构建 JSON 对象(推荐使用)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package json;/** * @Auther: wjy * @Date: 2019/4/10 17:21 * @Description: 封装数据的Javabean。 */public class lover &#123; private String name; private double age; // 日期类型需要用字符串类型代替。 private String birthday; private String home; private String[] major; private Boolean car; private Boolean house; private String girlfriend; private Object daugter; private String comment; public lover() &#123;&#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getAge() &#123; return age; &#125; public void setAge(double age) &#123; this.age = age; &#125; public String getBirthday() &#123; return birthday; &#125; public void setBirthday(String birthday) &#123; this.birthday = birthday; &#125; public String getHome() &#123; return home; &#125; public void setHome(String school) &#123; this.home = home; &#125; public String[] getMajor() &#123; return major; &#125; public void setMajor(String[] major) &#123; this.major = major; &#125; public Boolean getCar() &#123; return car; &#125; public void setCar(boolean car) &#123; this.car = car; &#125; public Boolean getHouse() &#123; return house; &#125; public void setHouse(boolean house) &#123; this.house = house; &#125; public String getGirlfriend() &#123; return girlfriend; &#125; public void setGirlfriend(String girlfriend) &#123; this.girlfriend = girlfriend; &#125; public Object getDaughter() &#123; return daugter; &#125; public void setDaughter(Object daugter) &#123; this.daugter = daugter; &#125; public String getComment() &#123; return comment; &#125; public void setComment(String comment) &#123; this.comment = comment; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637package json;import org.json.JSONObject;/** * @Auther: wjy * @Date: 2019/4/10 16:34 * @Description: 使用Javabean构建JSON对象。 */public class jsonTest &#123; public static void main(String[] args) &#123; // 声明一个bean的实例。 lover messi = new lover(); Object null1 = null; // 给bean的属性赋值。 messi.setName("梅西"); messi.setAge(31.8); messi.setBirthday("1987-06-24"); messi.setHome("Barcelona"); messi.setMajor(new String[]&#123;"player", "star"&#125;); messi.setCar(true); messi.setHouse(true); messi.setDaughter(null1); messi.setGirlfriend("安东内拉"); messi.setComment("love him!!"); /* * 通过JSONObject的构造函数传入Javabean实例，来构建一个JSON对象。 * 并不是直接对JSONObject进行操作，没有将属性直接put到JSONObject中。而是先创建一个Javabean对象，给此对象的属性赋值，便于重用Javabean。 * &#123;"birthday":"1987-06-24","girlfriend":"安东内拉","major":["player","star"],"car":true,"name":"梅西","comment":"love him!!","daughter":null,"house":true,"age":31.8,"home":null&#125; */ System.out.println(new JSONObject(messi).toString()); &#125;&#125; ④从文件中读取 JSON 需要将此 JSON 文件放在工程根目录下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package json;import java.io.File;import java.io.IOException;import org.apache.commons.io.FileUtils;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;/** * @Auther: wjy * @Date: 2019/4/10 18:31 * @Description: 从文件中读取JSON数据。 * 注意: JSONObject不支持将JSON数据反解析为Javabean。 */public class readJsonTest &#123; public static void main(String[] args) throws IOException, JSONException &#123; // 获取文件。 File file = new File(readJsonTest.class.getResource("../messi.json").getFile()); // 读取文件内容。 String content = FileUtils.readFileToString(file); // 将文件内容转换为JSON对象。 JSONObject json = new JSONObject(content); // 增加程序的健壮性。 if (!json.isNull("name")) System.out.println("name: " + json.getString("name")); // 解析JSON格式的数据。 System.out.println("age: " + json.getDouble("age")); System.out.println("birthday: " + json.getString("birthday")); System.out.println("home: " + json.getString("home")); System.out.println("car? " + json.getBoolean("car")); System.out.println("house? " + json.getBoolean("house")); System.out.println("comment: " + json.getString("comment")); // JSONObject对象不能解析JSON格式中的数组，需要JSONArray对象解析。 // 获取JSON格式中的数组。 JSONArray array = json.getJSONArray("major"); // 遍历获取到的数组。 /* * 专业-1: player * 专业-2: star */ for (int i = 0; i &lt; array.length(); i++) System.out.println("专业-" + (i+1) + ": " + array.getString(i)); &#125;&#125; 3.GSON 的使用 Google 提出的开源项目(第三方工具)，相比于 JSONObject，功能更强大、性能更出色、使用方式更简单。 ①使用 Javabean 构建 JSON 对象(推荐使用)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package gson;/** * @Auther: wjy * @Date: 2019/4/11 17:21 * @Description: 封装数据的JavaBean。 */public class lover1 &#123; private String name; private double age; private String birthday; private String home; private String[] major; private Boolean car; private Boolean house; private String girlfriend; private Object daughter; private String comment; public lover1() &#123;&#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getAge() &#123; return age; &#125; public void setAge(double age) &#123; this.age = age; &#125; public String getBirthday() &#123; return birthday; &#125; public void setBirthday(String birthday) &#123; this.birthday = birthday; &#125; public String getHome() &#123; return home; &#125; public void setHome(String home) &#123; this.home = home; &#125; public String[] getMajor() &#123; return major; &#125; public void setMajor(String[] major) &#123; this.major = major; &#125; public Boolean getCar() &#123; return car; &#125; public void setCar(boolean car) &#123; this.car = car; &#125; public Boolean getHouse() &#123; return house; &#125; public void setHouse(boolean house) &#123; this.house = house; &#125; public String getGirlfriend() &#123; return girlfriend; &#125; public void setGirlfriend(String girlfriend) &#123; this.girlfriend = girlfriend; &#125; public Object getDaughter() &#123; return daughter; &#125; public void setDaughter(Object daugter) &#123; this.daughter = daugter; &#125; public String getComment() &#123; return comment; &#125; public void setComment(String comment) &#123; this.comment = comment; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435package gson;import com.google.gson.Gson;/** * @Auther: wjy * @Date: 2019/4/11 10:13 * @Description: 使用Javabean构建JSON对象。 */public class gsonTest &#123; public static void main(String[] args) &#123; lover1 messi = new lover1(); Object null1 = null; Gson gson = new Gson(); messi.setName("messi"); messi.setAge(31.8); messi.setBirthday("1987-06-24"); messi.setHome("Barcelona"); messi.setMajor(new String[]&#123;"player", "star"&#125;); messi.setCar(true); messi.setHouse(true); messi.setDaughter(null1); messi.setGirlfriend("安东内拉"); messi.setComment("love him!!"); // 生成JSON格式的数据。 /* * &#123;"name":"messi","age":31.8,"birthday":"1987-06-24","home":"Barcelona","major":["player","star"],"car":true,"house":true,"girlfriend":"安东内拉","comment":"love him!!"&#125; */ System.out.println(gson.toJson(messi)); &#125;&#125; ②个性化定制 JSON123456789101112131415161718192021222324252627282930313233343536373839404142package gson;import com.google.gson.annotations.SerializedName;/** * @Auther: wjy * @Date: 2019/4/11 17:21 * @Description: 封装数据的JavaBean。 * GSON有更强的灵活性。 */public class lover2 &#123; // 通过添加注解的方式，标识生成JSON对象的一个key。 // 将name转换为NAME，相当于解析的时候重新命名key值。 @SerializedName("NAME") private String name; private double age; // 隐藏某个属性。 private transient String ignore; public lover2() &#123;&#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getAge() &#123; return age; &#125; public void setAge(double age) &#123; this.age = age; &#125; public String getIgnore() &#123; return ignore; &#125; public void setIgnore(String ignore) &#123; this.ignore = ignore; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package gson;import com.google.gson.Gson;import com.google.gson.GsonBuilder;/** * @Auther: wjy * @Date: 2019/4/11 10:13 * @Description: 使用Javabean构建JSON对象。 * 个性化构建JSON格式。 */public class gsonTest &#123; public static void main(String[] args) &#123; lover2 messi = new lover2(); GsonBuilder gb = new GsonBuilder(); // 通过Javabean类中的注解将name变为NAME，即在构建过程中将key个性化，一直有效。 messi.setName("messi"); messi.setAge(31.8); // 通过传入回调参数将age变为AGE，即在构建过程中将key个性化，仅在这个gb对象中有效。 gb.setFieldNamingStrategy(field -&gt; &#123; if (field.getName().equals("age")) return "AGE"; else return field.getName(); &#125;); // 生成JSON格式的数据。 /* * &#123;"NAME":"messi","AGE":31.8&#125; */ System.out.println(gb.create().toJson(messi)); // 美化JSON格式。 gb.setPrettyPrinting(); // 生成JSON格式的数据。 /* * &#123; * "NAME": "messi", * "AGE": 31.8 * &#125; */ System.out.println(gb.create().toJson(messi)); Gson gson = new Gson(); // 在JavaBean中构建JSON对象时隐藏某个属性(private transient String 属性名)。 messi.setIgnore("I love you!"); // 生成JSON格式的数据。 /* * 隐藏了ignore属性。 * &#123;"NAME":"messi","age":31.8&#125; */ System.out.println(gson.toJson(messi)); &#125;&#125; ③从文件中读取 JSON + 将 JSON 数据反解析为 Javabean 对象 将 JSON 数据反解析为 Javabean 对象时，GSON 支持将 String 类型的日期转换为日期类型。GSON 会将 JSON 数据中的数组自动转换为 Javabean 对象中的集合类型。 1234567891011121314151617181920212223242526272829303132333435363738394041package gson;import java.util.Date;import java.util.List;/** * @Auther: wjy * @Date: 2019/4/11 17:21 * @Description: 封装数据的Javabean。 * 将JSON数据反解析为Javabean对象。 */public class lover3 &#123; private double age; // 日期类型。 private Date birthday; // 集合类型。 private List&lt;String&gt; major; public lover3() &#123;&#125; public double getAge() &#123; return age; &#125; public void setAge(double age) &#123; this.age = age; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public List&lt;String&gt; getMajor() &#123; return major; &#125; public void setMajor(List&lt;String&gt; major) &#123; this.major = major; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243package gson;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import org.apache.commons.io.FileUtils;import java.io.File;import java.io.IOException;/** * @Auther: wjy * @Date: 2019/4/11 20:00 * @Description: 从文件中读取JSON。 * 将JSON数据反解析为Javabean对象。 */public class readJsonTest &#123; public static void main(String[] args) throws IOException &#123; // 从文件中读取JSON。 File file = new File(readJsonTest.class.getResource("../messi.json").getFile()); String content = FileUtils.readFileToString(file); // 使用GsonBuilder的setDateFormat("日期模板")方法可以将JSON对象中String类型的日期转换成Date类型。 Gson gson = new GsonBuilder().setDateFormat("yyyy-MM-dd").create(); // JSON对象中的key与Javabean的属性一一对应。 // 将JSON数据反解析为Javabean对象。 lover3 messi = gson.fromJson(content, lover3.class); /* * Wed Jun 24 00:00:00 CDT 1987 * 31.8 * gson.lover3@1e4a7dd4 * GSON会将JSON数据中的数组自动转换为Javabean对象中的集合类型。 * [player, star] * class java.util.ArrayList */ System.out.println(messi.getBirthday()); System.out.println(messi.getAge()); System.out.println(messi.toString()); System.out.println(messi.getMajor()); System.out.println(messi.getMajor().getClass()); &#125;&#125; org.json 是 Android SDK 的官方库。GSON 应用于服务端开发，功能更强大。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#x79;&#109;&#101;&#x73;&#x73;&#x69;&#64;&#x31;&#x36;&#51;&#46;&#x63;&#x6f;&#x6d;]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>入门内容</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git-版本控制工具]]></title>
    <url>%2F2018%2F11%2F25%2FGit-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[版本控制工具的发展： git 是分布式版本控制系统，能记录所有文件的所有版本，并有效地追踪文件的变化，也容易回滚到文件之前的状态。 1.安装与配置①下载 git 下载地址：https://git-scm.com/downloads 然后按默认选项安装即可 ②验证安装 打开命令行 输入 git 如果出现上图内容 说明安装成功 ③配置用户信息 安装好 git 后，需要配置用户信息(绑定 GitHub 用户名 和邮箱)。 2.Git 仓库 仓库又名版本库，英文名是 repository，可以将之理解为一个目录，目录中的所有文件都可被 git 管理。每个文件的修改、删除等操作都可以被 git 追踪。 git 仓库的相关操作： 12345678910111213141516171819202122pwd: 查看目前位置。cd 文件夹名: 进入该目录。cd ..: 进入上级目录。git init: 初始化版本库。git add: 添加文件到暂存区。git commit: 将文件从暂存区提交到仓库。git status: 查看仓库状态信息。ll: 展示当前目录的详细信息，等价于ls -l。ls -a: 展示隐藏和非隐藏文件。 一般点开头的文件都是隐藏文件。 创建仓库详情: mkdir test // 创建test目录。 cd test // 进入test目录。 git init // 初始化版本库。 ll // 目录为空。 ls -a // 展示.git隐藏目录。 echo &quot;......&quot; &gt;&gt; test.txt // 将&apos;......&apos;追加到test.txt文件中。 cat test.txt // 展示当前文件内容。 git add test.txt // 添加文件到版本库(即本地暂存区)。 git commit -m &quot;repo first commit&quot; // 提交到仓库中，&quot;repo first commit&quot;为本次提交的描述信息。 git status // 查看仓库状态。 3.Git 工作流 原理分析：当工作区使用 git add 命令将修改后的文件提交到暂存区时，暂存区中的文件将会被提交到 object 文件目录中，index 的指针也会指向 object 文件目录中的新文件 id。执行 git commit 命令后，master 分支更新，其中的指针也会指向 object 文件目录中的新文件 id。 ①暂存区到工作区的回滚 一般开发完成但还没有测试的文件都会被提交到暂存区 如果不想要暂存区的最新版本 可以直接丢弃| git reset HEAD 文件名(将暂存区的内容还原为最后一次提交的内容)| git checkout – 文件名(将工作区的内容还原为最后一次提交的内容) ②已提交版本的回滚 要找到以前的提交版本 需要回滚 我们先创建一次提交： 现在查看 commit 号：git log 此时代码需要回到过去 即将 hard 指针(当前环境的版本指针)修改到某次 commit 上：git reset –hard commit号 回到过去后 使用 git reflog 可以查看”未来”的版本号 ③清空仓库 清空本地仓库： git rm –cache 文件名：删除添加到暂存区的文件 git rm 文件名：同时删除工作区和暂存区的文件 注意：以上所有操作只是提交给本地仓库，并不是 Github。 4.远程仓库 本地仓库：在电脑上的仓库 远程仓库：在公网服务器上的仓库 通过 git push 提交修改到远程仓库时，需要 ssh 连接(连接后每次提交都不需要重新输入密码)。ssh 连接的具体步骤：https://blog.csdn.net/qq_41979043/article/details/83046278 —— 3.安装git 关联远程仓库： 每次可以使用 git push 命令 将本地仓库的 master 分支同步到远程仓库的 master 分支 5.克隆仓库 将远程仓库克隆到本地： 1.Clone with SSH：git clone git@github.com:messi1002/test.git 2.Clone with HTTPS：git clone https://github.com/messi1002/test.git 将远程仓库的文件更新到本地仓库：git pull origin master 6.标签管理 当需要发布新的版本时，需要在版本库中打一个标签(确定该标签对应的版本时刻)。以后想要回滚到某个版本时，可以直接通过标签(版本号)回滚。 新建标签并指定提交信息：git tag -a name -m “comment” 删除标签：git tag -d name 7.分支管理 当我们需要修改正在更新的项目的 bug 时，可以新建一个分支，以已经发布的项目代码为基础，修改 bug 后重新发布代码，最后再将此分支合并到正在开发的分支上。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#x6a;&#x79;&#x6d;&#x65;&#x73;&#115;&#105;&#x40;&#49;&#x36;&#51;&#x2e;&#x63;&#111;&#109;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用NATAPP进行微信本地开发调试]]></title>
    <url>%2F2018%2F11%2F14%2F%E7%94%A8NATAPP%E8%BF%9B%E8%A1%8C%E5%BE%AE%E4%BF%A1%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[开发环境下，要想与微信后台对接，需要在公网上访问本机服务器 URL 地址(只能使用 80 端口 / 443 端口)。因此，需要用映射工具将本机地址映射到公网上。 1.使用NATAPP①购买隧道 地址：https://natapp.cn/ 注册之后 点击 登录 然后购买隧道| 注意：免费隧道在每次启动窗口时都会更换映射地址。 &emsp;&emsp; 填写 80 端口 / 443 端口(微信仅支持这两个端口号) &emsp;&emsp; 然后进入刚刚购买的隧道 记住你的 authtoken ②映射 下载客户端 &emsp;&emsp; 新建一个 config.ini 文件 内容如下| 将 authtoken 字段的值修改为刚刚购买的隧道的 authtoken。 12345678#将本文件放置于natapp同级目录,程序将读取[default]段。#在命令行参数模式如 natapp -authtoken=xxx 等相同参数将会覆盖掉此配置。[default]authtoken=你的authtoken #对应一条隧道的authtoken。clienttoken= #对应客户端的clienttoken,将会忽略authtoken,若无请留空。log=none #log 日志文件,可指定本地文件,none=不做记录,stdout=直接屏幕输出,默认为none。loglevel=ERROR #日志等级DEBUG,INFO,WARNING,ERROR默认为DEBUG。http_proxy= #代理设置 如 http://10.123.10.10:3128 非代理上网用户,请务必留空。 将客户端程序和 config.ini 文件放入同一个文件夹中 启动命令行 进入该文件夹 输入 natapp -authtoken=你的authtoken 即可得到如下结果 &emsp;&emsp; 再注意！！对于免费隧道来说，每次启动 natapp.exe 进行映射时，其外网映射地址都会改变。 ③映射测试 将工程的 Tomcat 端口号改为 80 端口或 443 端口(对应隧道的端口号)| 在 Spring Boot 工程中，按照以下方式修改： &emsp;&emsp; &emsp;&emsp; | 其他工程的修改方式： &emsp;&emsp; 若此时访问 127.0.0.1:80(或localhost:80) 和访问 映射外网:80 是同一个效果，说明映射成功！ 2.微信开发者模式接入①填写服务器配置 服务器地址 URL：所映射的外网地址 / 工程校验代码的访问地址。| 如： http://qc95we.natappfree.cc/weixinA。 Token：开发者随意填写 在接入认证时生成一个签名。| 需要在校验代码中定义一个字符串名为 Token，此字符串值对应所填写内容，具体看下文。 ②验证服务器地址的有效性 开发者提交信息后，微信服务器会发送 GET 请求到填写的服务器地址 URL 上，GET 请求携带以下四个参数。 &emsp;&emsp; signature 微信加密签名 &emsp;&emsp; timestamp 时间戳 &emsp;&emsp; nonce 随机数 &emsp;&emsp; echostr 随机字符串 需要开发者将 token、timestamp、nonce 这三个参数进行排序，再拼接成字符串并对其进行 sha1 加密，再将加密后的字符串与微信加密签名( signature )进行对比，两个字符串相同时(可标识该 GET 请求来自微信服务器)返回 echostr 参数内容，此时开发者接入成功。 ③具体代码 我在 Spring Boot 工程中配置了 Servlet 校验代码。如果你不想在 Spring Boot 工程中测试，可以在其他 web 应用的 web.xml 文件中自行配置 Servlet。只是配置文件不同，校验代码都相同。 工程目录结构如下： &emsp;&emsp; 附上我的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package com.example.springbootdemo.config;import com.example.springbootdemo.util.CheckUtil;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * @Auther: wjy * @Date: 2018/12/4 20:56 * @Description: 获得参数。 */public class WeixinServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; request.setCharacterEncoding("UTF-8"); response.setCharacterEncoding("UTF-8"); PrintWriter out = response.getWriter(); String echostr = request.getParameter("echostr"); String signature = request.getParameter("signature"); String timestamp = request.getParameter("timestamp"); String nonce = request.getParameter("nonce"); if (CheckUtil.check(timestamp, nonce, signature) == true) out.print(echostr); &#125;&#125;--------------------------------------------------------------------------------package com.example.springbootdemo.util;import java.security.MessageDigest;import java.util.Arrays;/** * @Auther: wjy * @Date: 2018/12/4 21:57 * @Description: 开发者校验。 */public class CheckUtil &#123; public static String token = "weixinAAAA"; /* * 按照微信公众号平台要求校验。 */ public static boolean check(String timestamp, String nonce, String signature) &#123; String[] string = new String[]&#123;timestamp, nonce, token&#125;; String s = new String(); String encrypt = null; Arrays.sort(string); for (int i = 0; i &lt; string.length; i++) s += string[i]; encrypt = getSha1(s); System.out.println(encrypt); if (encrypt.equals(signature)) return true; else return false; &#125; /* * 加密。 */ public static String getSha1(String decript) &#123; if(decript == null | decript .length() == 0) return null; char hexDigits[] = &#123;'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'&#125;; try &#123; MessageDigest mdTemp = MessageDigest.getInstance("SHA1"); mdTemp.update(decript.getBytes("UTF-8")); byte[] md = mdTemp.digest(); int j = md.length, k = 0; char buf[] = new char[j*2]; for (int i = 0; i &lt; j; i++) &#123; byte byte0 = md[i]; buf[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf]; buf[k++] = hexDigits[byte0 &amp; 0xf]; &#125; return new String(buf); &#125; catch (Exception e) &#123; return null; &#125; &#125;&#125;--------------------------------------------------------------------------------package com.example.springbootdemo.servlet;import com.example.springbootdemo.config.WeixinServlet;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;import org.springframework.context.annotation.Bean;/** * @Auther: wjy * @Date: 2018/12/4 21:33 * @Description: SpringBoot中的Servlet配置。 */@SpringBootApplicationpublic class ServletConfig extends SpringBootServletInitializer &#123; public static void main(String[] args) &#123; SpringApplication.run(ServletConfig.class, args); &#125; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(ServletConfig.class); &#125; // 注册Servlet。 @Bean public ServletRegistrationBean wexinA() &#123; return new ServletRegistrationBean(new WeixinServlet(), "/weixinA"); &#125;&#125; ④映射调试 此时可通过 映射地址/wenxinA 或 localhost:80/weixinA 访问这个 Servlet| 注意：因为访问此校验代码需要传入四个参数，所以如下直接访问时，控制台报出的空指针异常，不是配置的问题！！ &emsp;&emsp; &emsp;&emsp; 将可以访问 Servlet 的 URL 配置到微信公共平台的服务器 URL 一栏 最后再填写 Token 对应的值| 我的校验代码中，Token 字符串的值为 wenxinAAAA。 &emsp; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#121;&#109;&#101;&#x73;&#115;&#105;&#x40;&#x31;&#54;&#51;&#46;&#x63;&#111;&#x6d;]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识微信公众号开发]]></title>
    <url>%2F2018%2F11%2F11%2F%E5%88%9D%E8%AF%86%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[1.了解微信公众号①明确概念 公众号与微信聊天的区别 公众号类型介绍| 企业号：消息出现在好友会话列表首层、每分钟最多群发 200 条消息、通讯录关注、支持保密消息。| 服务号：消息出现在好友会话列表首层、每周最多群发一条消息、查找关注。| 订阅号：支持个人申请、每天最多群发一条消息、查找关注、不支持高级接口权限。 以下内容，仅针对订阅号。 ②申请公众号 注册地址：微信公众平台 微信公众平台是腾讯为了让用户申请和管理微信公众账号而推出的一个 web 平台。 登记信息 填写账号名称和功能介绍 个性化公众号 ③功能模块 可群发文字、图片、语音、视频或图文消息(每天 1 条) 自动回复| 被添加自动回复| 固定自动回复(每小时提示一次)| 关键词自动回复(灵活) 自定义菜单| 最多三个 1 级菜单| 最多五个 2 级菜单 投票功能(文章中加入) … ④管理模块 消息管理(回复消息) 用户管理(管理已关注的用户) 素材管理(保存公众号的群发内容) ⑤编辑模式 微信公众号开发的模式之一——编辑模式。 所谓编辑模式 就是在官网网页上操作基本功能 添加被关注自动回复 &emsp; 根据服务功能设置关键字回复(关注中英文差异) &emsp; 素材管理| 单图文消息可显示摘要，多图文消息只显示标题。| 如下为多图文消息： &emsp; 自定义菜单| click 类型(发送消息)| view 类型(跳转到网页) &emsp; &emsp; 群发消息(每天 1 次) 2.开发前奏①开发准备 开发环境下，要想与微信后台对接，需要在公网上访问本机服务器 URL 地址(只能使用 80 端口 / 443 端口)。因此，需要用映射工具将本机地址映射到公网上。 一个微信公众号 外网映射工具(开发调试) ②映射工具 ngrok：服务器在国外、访问速度慢、每次映射地址不同(现在国内有很多使用它的方法)。 tunnel：部署在国内、支持 ngrok 的绝大数功能(现在不可用)。 正在使用 NATAPP.cn，教程见用NATAPP进行微信本地开发调试—1。 ③访问模式 映射成功后，使用以下格式进行公网访问。 本地访问：http://localhost:8080/Test/index.jsp 对应的公网访问：(映射公网)/Test/index.jsp 3.开发模式 微信公众号开发的模式之一——开发模式。注意：开发模式和编辑模式是互斥关系，两者的设置不共存。只能使用一种模式，选择之后公众号会应用该模式的所有设置。 ①数据交互原理 如下所示： &emsp; 其中，微信公众号服务器就是我们在开发模式下需要开发的内容。 ②开发模式接入 具体操作参见：用NATAPP进行微信本地开发调试—2 通过之前的操作 我们已经进入了开发模式 启用了开发模式 编辑模式的设置会自动失效| 此时编辑模式下的自动回复和菜单栏都跑了。 &emsp; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#x6a;&#x79;&#109;&#x65;&#x73;&#115;&#x69;&#64;&#x31;&#x36;&#x33;&#46;&#x63;&#111;&#x6d;]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目管理利器-maven]]></title>
    <url>%2F2018%2F11%2F01%2F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%88%A9%E5%99%A8-maven%2F</url>
    <content type="text"><![CDATA[maven 是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型(POM)的概念，它可以从一个中心资料片管理项目构建、报告和文件。它也是一套强大的自动化构建工具，覆盖了编译、测试、运行、清理、打包和部署等整个项目构建的周期。并且它提供了一个仓库的概念，可以统一地管理项目所依赖的第三方 jar 包。 1.安装 maven①下载 maven 下载地址：https://maven.apache.org/download.cgi 然后解压压缩包 ②安装目录介绍 ③配置环境变量12M2_HOME: D:\apache-maven-3.5.4(安装目录)path: %M2_HOME%\bin 注意：%环境变量% 相当于引用这个环境变量的路径。 配置完 path 环境变量后，需要重启命令行(重新加载环境变量)。 ④验证配置 mvn -v 命令：查看 maven 版本 如果出现上图文字 说明安装成功 2.第一个 maven 项目①目录结构 使用 maven 管理的 Java 项目都有着相同的项目结构(强制) ②编写代码 编写 “Hello Maven!” 类： 123456public class HelloMaven &#123; public String say() &#123; return "Hello Maven!"; &#125;&#125; 编写测试类： 123456789101112import org.junit.Assert.*;import org.junit.*;public class HelloMavenTest &#123; // 表明该方法为测试方法。 @Test public void test() &#123; // 检验new HelloMaven().say()的返回值是否为"Hello Maven!"。 Assert.assertEquals("Hello Maven!", new HelloMaven().say()); &#125;&#125; 目录结构如下： ③新建 pom.xml 文件 pom.xml：用于管理项目依赖和构建过程(维护当前项目的 jar 包)。 写完代码后 还需要 pom.xml 文件管理项目的依赖 新建 pom.xml 文件 并将之移至项目根目录 1234567891011121314151617181920212223242526272829&lt;!-- 以下文字:&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 组织名 --&gt; &lt;groupId&gt;wjy-maven1&lt;/groupId&gt; &lt;!-- 模块名 --&gt; &lt;artifactId&gt;maven1-model&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 导入junit依赖(测试框架) --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 增加jdk的设置 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt;&lt;/project&gt; !--&gt; ④编译运行(进入项目根目录) mvn compile：编译项目 mvn test：测试运行项目 编译运行后，项目根目录会自动生成一个 target 目录，里面存放着测试报告、编译生成的 class 文件等。 3.核心知识①常用构建命令 mvn -v：查看 maven 版本 mvn clean：清理上一次构建生成的所有文件 mvn compile：编译 mvn test：测试运行 mvn package：将项目打包 mvn install：安装 jar 包到本地仓库 若要在 a 包的类中导入 b 包类，一般需要把包含 b 包类的 jar 包加入到 classpath 路径中。而 maven 为我们提供了更方便的方法：在 b 包的根目录下，我们使用 mvn install 命令将包含其所有类的 jar 文件发布到本地仓库中，然后在 a 包的 pom.xml 文件中添加 b 包的坐标，之后 maven 会自动帮我们进行依赖管理操作。原理：在编译源代码时，若程序用到了其他的包，maven 会在 pom.xml 文件中查找程序是否引入了该包的坐标。若是已经引入，maven 会在本地仓库中查找其对应的 jar 包并添加到 classpath 路径中，若是没有找到 jar 包，maven 会上网在中央仓库中下载 jar 包并放入本地仓库。若是没有引入，则返回异常信息。 ②自动创建目录结构 archetype 插件：用于自动创建符合 maven 规定的目录结构| 目录结构详情见 2-① 创建目录结构的两种方式： 1.输入 mvn archetype:generate -DarchetypeCatalog=internal 后按照命令行提示进行创建： 2.一次性写入以下代码： 1234mvn archetype:generate -DarchetypeCatalog=internal -DgroupId=wjy-maven02 -DartifactId=maven02-model -Dversion=1.0-SNAPSHOT -Dpackage=maven02.model# groupId: 组织名，一般为公司网址的反写-项目名。# artifactId: 一般为项目名-模块名，它是maven项目在组织中的唯一标识。# package: 代码所存在的包名，应该和groupId名、artifactId名相吻合。 ③坐标 在 maven 中，任何一个依赖、插件、项目构件的输出都可被称为构件。所有构件都通过坐标作为其唯一标识。&lt;groupId&gt;、&lt;artifactId&gt;、&lt;version&gt; 组成了 maven 的基本坐标。 ④仓库 仓库：用来管理项目的依赖。 a.本地仓库 在本地仓库中找不到项目所需要的构件时 会自动到远程仓库中查找并下载 b.远程仓库 远程仓库：即全球中央仓库 地址为 https://repo.maven.apache.org/maven2 远程仓库中包含了绝大多数开源的 Java 项目 但访问速度较慢(访问量大、且在国外) c.镜像仓库 镜像仓库：与全球中央仓库的功能相同 可以将默认的远程仓库改为国内的镜像仓库(访问速度更快、更稳定) 修改方法(将下列内容添加到 settings.xml 文件中)： 12345678&lt;!--设置镜像仓库为阿里云--&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;!-- 为中央仓库配置镜像。 --&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;&lt;/mirror&gt; 修改后 访问远程仓库的操作会转为访问镜像仓库 d.更改仓库默认位置 maven 的本地仓库默认存放在 C 盘中(占用 C 盘内存！) 修改上文的 settings.xml 文件 可以更改本地仓库的位置 然后在 maven 项目下执行 mvn clean compile 命令 会更新本地仓库的位置 最后将 setting.xml 文件放入新仓库中 防止 maven 升级后需要重新配置此文件 4.项目构建过程①项目构建与插件 完整的项目构建过程包括：清理(clean)、编译(compile)、测试(test)、打包(package)、集成测试、验证、部署(deploy)等。maven 和插件是密不可分的，maven 抽象出一套项目构建的生命周期，而插件是对 maven 抽象的具体实现，即 maven 中的所有命令都是调用插件实现的。在 maven 官网中，提供了很多插件。插件地址：https://mvnrepository.com/open-source/maven-plugins ②生命周期 maven 定义了三套相互独立的生命周期(clean、default、site)，每套生命周期包含一些有顺序的阶段，后面的阶段依赖于前面的阶段。即执行某个阶段时，其之前同一周期的阶段会顺序执行，如执行 package 命令时，complie、test 命令会自动顺序执行。 在 IDEA 中 pom.xml 文件会自动导入与生命周期有关的插件 a.clean—清理项目 pre-clean：执行清理前的工作 clean：清理上一次构建生成的所有文件 post-clean：执行清理后的工作 b.default(最核心)—构建项目 compile：编译 test：测试 package：打包 install：安装 jar 包到本地仓库 c.site—生成项目站点 pre-site：在生成项目站点之前要完成的工作 site：生成项目的站点文档 post-site：在生成项目站点之后要完成的工作 site-deploy：将生成的站点发布到服务器上 5.pom.xml 详解①pom pom 是 maven 项目的核心管理文件，用于项目描述、组织管理、依赖管理和构建信息的管理。方便的第三方框架的管理和便捷的项目构建过程，大大提高了工作效率。 ②pom 常用元素1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!-- project是pom.xml文件的根元素，包含了一些约束信息。 --&gt;&lt;project&gt; &lt;!-- modelVersion为必须元素，指定了当前文件的版本。 --&gt; &lt;modelVersion&gt;&lt;/modelVersion&gt; &lt;!-- 坐标信息: --&gt; &lt;!-- maven项目与实际项目不同，maven项目体现了模块化的概念，一个实际项目往往被划分为多个模块。 --&gt; &lt;!-- groupId为主项目标识，一般为反写的公司网址+项目名。 --&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;!-- artifactId为实际项目中的一个模块，一般为项目名+模块名。 --&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;!-- version为当前项目的版本号。 第一个0是大版本号，第二个0是分支版本号，第三个0是小版本号，如0.0.1。 napshot: 快照版、alpha: 内测版、beta: 公测版、Release: 稳定版、GA: 正式版。 --&gt; &lt;version&gt;&lt;/version&gt; &lt;!-- package为maven项目的打包方式，默认打包为war，也可以是jar、zip、pom等。 --&gt; &lt;packaging&gt;&lt;/packaging&gt; &lt;!-- name为项目的描述名，产生项目文档时才会使用。 --&gt; &lt;name&gt;&lt;/name&gt; &lt;!-- url为项目地址。 --&gt; &lt;url&gt;&lt;/url&gt; &lt;!-- description为项目描述。 --&gt; &lt;description&gt;&lt;/description&gt; &lt;!-- developers为开发人员列表。 --&gt; &lt;developers&gt;&lt;/developers&gt; &lt;!-- licenses为许可证信息。 --&gt; &lt;licenses&gt;&lt;/licenses&gt; &lt;!-- organization为组织信息。 --&gt; &lt;organization&gt;&lt;/organization&gt; &lt;!-- dependencies为依赖列表，其下包含多个依赖项(dependency)，一个坐标唯一标识一个依赖项。 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;type&gt;&lt;/type&gt; &lt;!-- optional设置该依赖是否可选，默认为false。若为true，项目必须显式引入该依赖，若为false，项目默认继承该依赖。 --&gt; &lt;optional&gt;&lt;/optional&gt; &lt;!-- 依赖范围。 --&gt; &lt;scope&gt;&lt;/scope&gt; &lt;!-- exclusions是排除依赖传递的列表。 --&gt; &lt;exclusions&gt; &lt;exclusion&gt;&lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- dependencyManagement为依赖的管理，主要定义在父模块中，供子模块继承。 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!-- 对构建行为提供一个支持。 --&gt; &lt;build&gt; &lt;!-- 插件列表: --&gt; &lt;plugins&gt; &lt;!-- 一个坐标唯一标识一个插件。 --&gt; &lt;plugin&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!-- 用于子模块中，是对父模块的一个继承。 --&gt; &lt;parent&gt;&lt;/parent&gt; &lt;!-- 用来聚合多个maven项目，使多个maven模块可以一起编译并运行。 --&gt; &lt;modules&gt;&lt;/modules&gt;&lt;/project&gt; 6.依赖①依赖范围 关于 &lt;scope&gt;&lt;/scope&gt; 12345678910&lt;!-- 平时开发时，若使用某一框架，就要将该框架的jar包引入到项目的classpath路径中，这样项目就可以使用该框架为我们封装好的一些方法。而maven为我们提供了三种classpath，分别为编译、测试、运行(时有效)，依赖的范围就是用来控制依赖与三种classpath的关系的。 scope标签的值有六种，分别为: compile(测试、编译和运行时都有效，默认选项)、 provided(测试、编译时有效，适用于一些web容器中已经包含的jar(运行时不需要再引入)，如servlet)、 runtime(测试、运行时有效，适用于JDBC驱动，项目主代码的编译只需要jdk提供的JDBC的API，只有测试或运行时才需要具体驱动的API)、 test(测试时有效，如junit测试框架)、 system(测试、编译时有效，但具有不可移植性，需要与本地系统相关联)、 import(导入，它只使用在dependencyManagement标签中，表示从其它的pom中继承过来的依赖)。 --&gt; 将 A 中的依赖导入到 B 中 12345678910111213141516171819&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;WJY-Test&lt;/groupId&gt; &lt;artifactId&gt;Test-B&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;name&gt;B&lt;/name&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;WJY-Test&lt;/groupId&gt; &lt;artifactId&gt;Test-A&lt;/artifactId&gt; &lt;type&gt;pom&lt;/type&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; ②排除依赖传递123456789101112131415161718192021&lt;!-- exclusions是排除依赖传递的列表。 若模块C依赖模块B的jar，模块B依赖模块A的jar，模块A对模块C来说就是传递依赖，默认模块C也会依赖模块A的jar。 若模块C不想依赖模块A的jar，可以使用这个标签，在模块C的pom.xml文件中添加以下内容便可排除模块A的依赖。 --&gt; &lt;!-- 此时模块C只依赖模块B的jar。 --&gt; &lt;dependency&gt; &lt;groupId&gt;WJY-Maven&lt;/groupId&gt; &lt;artifactId&gt;Mavan-B&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 排除依赖。 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;WJY-Maven&lt;/groupId&gt; &lt;artifactId&gt;Maven-A&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- 注意: 先要将模块A的jar发布到本地仓库中，模块B才能通过坐标在本地仓库中找到模块A的jar，再将模块B的jar发布到本地仓库中，模块C才能通过坐标在本地仓库中找到模块B的jar。 --&gt; ③依赖冲突 如果 A 和 B 分别有不同版本的相同构件，而 C 同时依赖于 A 和 B，此时会发生依赖冲突。 解决依赖冲突的两个原则： 1.短路优先—优先解析路径短(依赖级数少)的版本 2.如果路径相同 则看依赖的先后(先声明依赖哪个 就选择哪个依赖的版本) ④聚合 聚合：在 maven 中，将多个项目(模块)放在一起运行。聚合时，需要新建一个 maven 项目(父模块)，新建项目的 pom 将作为其他 pom 的容器。 1234567891011121314151617&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 作为其他pom的容器。 --&gt; &lt;groupId&gt;WJY-Maven&lt;/groupId&gt; &lt;artifactId&gt;Maven-0&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;!-- 此pom项目里不执行任何代码，只是为了聚合或传递依赖。--&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;!-- 用来聚合多个maven项目，使多个maven模块可以一起编译并运行。 --&gt; &lt;!-- 聚合后，还需要引入这些maven项目的依赖！ --&gt; &lt;modules&gt; &lt;module&gt;../Maven-1&lt;/module&gt; &lt;module&gt;../Maven-2&lt;/module&gt; &lt;module&gt;../Maven-3&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; ⑤继承123456&lt;!-- dependencyManagement为依赖的管理，可以声明依赖列表，但不会被引入到实际依赖中。主要定义在父模块中，供子模块继承(继承版本号等信息)。 即若多个模块都包括同一个依赖，可以抽象出来一个父模块，在父模块中对其进行一个定义，其他子模块只需要继承即可。 注意: 子模块还是需要显式地声明依赖。 优点: 如果有多个子模块都需要引用同样的依赖，则此标签可以避免在每个子模块中重复声明版本号等信息，便于整体修改。如果某个子模块需要其他版本，只需要单独声明version。 --&gt; 父 pom.xml 中： 12345678910111213141516171819202122&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;WJY-Maven&lt;/groupId&gt; &lt;artifactId&gt;Maven-1&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;junit.version&gt;4.11&lt;/junit.version&gt; &lt;/peoperties&gt; &lt;!-- 要被继承的依赖: --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 子 pom.xml 中： 123456&lt;parent&gt; &lt;!-- 父坐标: --&gt; &lt;groupId&gt;WJY-Maven&lt;/groupId&gt; &lt;artifactId&gt;Maven-1&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; 7.IDEA 中使用 maven 构建 web 项目①新建工程 注意：模板 maven-archetype-quickstart 的目录结构如下图所示，应该根据需要选择合适的模板。 ②创建目录结构 在 src/main 目录下新建 java 目录 将 java 目录作为 Sources Root 在 src/main 目录下新建 resources 目录 将 resources 目录作为 Resources Root 在 src/test 目录下新建 java 目录 将 java 目录作为 Test Sources Root 在 src/test 目录下新建 resources 目录 将 resources 目录作为 Test Resources Root 目录结构如下： ③配置 tomcat 新建 tomcat： tomcat 热部署： ④运行 tomcat 如果出现上图内容 说明配置成功 ⑤IDEA 中管理 maven 的生命周期 修改以下部分 并新增工程入口类 使用 package 命令 可以将工程打包 ⑥运行 jar 包 用 360压缩 打开 jar 包 编辑 MANIFEST.MF 文件 添加划线部分 保存并退出 在命令行运行 jar 包 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#x6a;&#x79;&#x6d;&#101;&#x73;&#115;&#105;&#64;&#x31;&#54;&#51;&#46;&#x63;&#111;&#109;]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>入门内容</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录GitHub+Hexo搭建博客过程]]></title>
    <url>%2F2018%2F10%2F04%2F%E8%AE%B0%E5%BD%95GitHub-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1.next 主题使用文档 官方文档 2.使用基础①常用技巧 hexo 命令 出错时 可使用 hexo –debug 查看错误 安装插件命令是 install 卸载插件命令是 uninstall hexo clean：清除缓存文件和已生成的静态文件(public) 每次更新修改：| hexo g：重新生成缓存和静态文件。| hexo d/deploy：重新部署到服务器。 在博客文章中插入图片：点击查看| 注意：对于 next 主题，引入图片时使用 ![图片代替名](图片名.jpg) 的格式。 ②修改根目录下的 _config.yml 文件123456title: # 你的标题subtitle: # 副标题description: # 网站描述，便于搜索引擎用关键词检索。author: wjy # 作者language: # 语言timezone: Asia/Shanghai ③添加 about 等页面 使用此命令：hexo new page about| 会看到在 source 文件夹中生成了一个 about 文件夹，里面包含一个 index.md 文件。| 在这个 markdown 文件内，我们可以编写一些 about 页面的信息。 然后修改主题目录下的 _config.yml 文件 在 menu 中添加 about 页面的链接 添加其他页面同理，下列文字是为 next 主题配置页面链接。 12345678910menu: home: / || home archives: /archives/ || archive tags: /tags/ || tags categories: /categories/ || th 最爱: /love/ || soccer-ball-o 电影: /movies/ || film 书籍: /books/ || book 旅行: /photos/ || camera-retro about: /about/ || user 配置后会在页面菜单中生成一个关于 about 页面的链接 点击 about 就可跳转到 about 页面 ④写文章时添加分类、标签格式123456categories:- 分类1 - 分类2tags:- 标签1- 标签2 3.我的博客配置 我的博客：http://messi1002.top 语言：zh-Hans(中文) √ ①侧边栏 侧边栏排版(签名)及头像 √ 侧边栏作者头像旋转 √ 配置侧边栏中的社交账号及其图标 √ 侧边栏推荐阅读 √ DaoVoice 在线联系功能 √ 添加 RSS 订阅 √ ②网站主页 菜单栏优化及签名 √ 添加顶部加载条 √ 修改网页 icon √ 首页不显示全文 √ 添加 fork me on github √ 增加动态线段背景 √ 爆炸效果图 √ 增加宠物 √ 隐藏网页底部的 … By Hexo √ 文章添加阴影效果(好看) √ 修改网页底部的星星 √ 网站底部访问量统计 √ 网站底部字数统计 √ 博文置顶 √ 修改内容宽度 √ 添加博客背景 √ 设置站点图标 √ ③网站功能 添加本地搜索 √ 添加评论功能(来必力) √ 添加打赏功能 √ 添加 README.md 文件 √ 引入豆瓣电影和读书 √ 引入相册功能(两个) √| 最爱页—使用 GitHub 存放图片(简单)| 旅行页—使用阿里云存放图片(速度) ④文章细节 文章内容统计功能 √ 在文章底部增加版权信息 √ 修改文章内链接文本样式 √ 修改文章底部的带 # 号的标签 √ 添加热度 √ 代码高亮 √ 文章加密访问 √ 配置教程参考：Next主题配置博客 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#x6a;&#121;&#x6d;&#101;&#x73;&#x73;&#105;&#x40;&#49;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;]]></content>
      <categories>
        <category>博客相关</category>
      </categories>
      <tags>
        <tag>GitHub+Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java进制转换及位运算]]></title>
    <url>%2F2018%2F09%2F20%2FJava%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%8F%8A%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[1.进制①进制相关 在线进制转换工具：https://tool.lu/hexconvert/ 进位制是一种记数方式，亦称进位计数法或位值计数法。它是人们为计数和运算方便而约定的计数系统。 把一个数表示成 a 与 10 的 n 次幂相乘的形式（1 ≤ |a| &lt; 10，n 为整数），这种记数的方法叫做科学记数法。 使用的数字符号的数目称为这种进位制的基数或底数。 位权：一个数码在不同的位置上所代表的值不同、且不同的进位制，处于同一数位上的权也是不同的。 例如：十进制第 2 位的位权为 10，第 3 位的位权为 100、而二进制第 2 位的位权为 2，第 3 位的位权为 4。 ②进制转换 进位制 基本数字 进位规则 应用 标志的开头 二进制 0 ~ 1 二进一 计算机内部采用二进制，其运算简单，简化了计算机结构 0b / 0B 八进制 0 ~ 7 八进一 适用于12位和36位计算机系统 0 十进制 0 ~ 9 十进一 日常生活中使用 无 十六进制 0 ~ 9和A、B、C、D、E、F(15) 十六进一 长度短 0x / 0X 进制表： ​​​​ 十进制转换为 二 / 八 / 十六 进制 对于整数：采用重复相除权再倒看余数的方法 对于小数：采用重复相乘权再正看 “余数” 的方法 二 / 八 / 十六进制采用科学计数法按对应权展开可得十进制数： ③JDK 内置的进制转换 1234567891011121314151617181920212223242526272829303132333435363738394041424344package object.base;/** * @author: wjy * @date: 2018/10/08 * @description: JDK内置的进制转换 */public class javaSystem &#123; public static void main(String[] args) &#123; // 10进制转换为其他进制 // 10进制转换为2进制：1100 System.out.println(Integer.toBinaryString(12)); // 10进制转换为8进制：14 System.out.println(Integer.toOctalString(12)); // 10进制转换为16进制：14 System.out.println(Integer.toHexString(20)); // 其他进制转换为10进制 // 2进制转换为10进制：1*2^2+1*2^0=5 System.out.println(Integer.parseInt("0101",2)); System.out.println(Integer.valueOf("0101",2).toString()); // 8进制转换为10进制：1*8^2+2*8^1+3*8^0=83 System.out.println(Integer.parseInt("0123",8)); System.out.println(Integer.valueOf("0123",8).toString()); // 16进制转换为10进制：15*16^3+15*16^2+15*16^1+15*16^0=65535 System.out.println(Integer.parseInt("FFFF",16)); System.out.println(Integer.valueOf("FFFF",16).toString()); // 打印为十进制数字123 System.out.println(123); // 打印为十进制数字5(其中0101是2进制数字，0b标识0101为2进制) System.out.println(0b0101); // 打印为十进制数字5(其中0101是2进制数字，0B标识0101为2进制) System.out.println(0B0101); // 打印为十进制数字83(其中123是8进制数字，0标识123为8进制) System.out.println(0123); // 打印为十进制数字291(其中123是16进制数字，0x标识123为16进制) System.out.println(0x123); // 打印为十进制数字291(其中123是16进制数字，0X标识123为16进制) System.out.println(0X123); &#125;&#125; 2.二进制数据的表示方法 ps：Java 中整型（int型）是 32 位的。 ①原码 原码表示法：最高位为符号位，其余位表示数值的大小。 使用 0 表示正数、1 表示负数 [+1]原 = 0000 0001 [-1]原 = 1000 0001 优点：表达简单明了、易于理解 缺点： 有歧义（0 既可以用 00 表示，也可以用 10 表示） 当两个操作数的符号不同时，运算十分复杂 ②反码 正数的反码是其本身 [+1] = [00000001]原 = [00000001]反 负数的反码等于原码除符号位外按位取反 [-1] = [10000001]原 = [11111110]反 ③补码 正数的补码是其本身 [+1] = [00000001]原 = [00000001]反 = [00000001]补 负数的补码等于反码加 1 [-1] = [10000001]原 = [11111110]反 = [11111111]补 ④原码、补码和反码之间的关系 因为原码表示法对于零的表示有歧义且其减法运算复杂，所以引入了补码表示法。虽然补码表示法在一定程度上解决了这两个问题，但是其在计算补码的过程中引进了减法操作。 解决方法：引进反码表示法。先由原码计算出反码，再由反码计算出补码，即可消除直接通过原码求补码时引入的减法操作。 在计算机中，数据都是以补码的形式存储的。 0 的反码和补码都为零 3.位运算 ps：程序中所有的数在内存中都是以二进制的形式存储的，位运算是直接对二进制位进行的位操作。二进制位运算的优点：计算方便，速度快，被支持面广。 ①运算符 运算 功能 举例 应用/规律 按位与(&amp;) 两位全为1，结果才为1 6(00000110) &amp; 3(00000011) = 2(00000010) a.清零(若要将一个单元清零，只要与一个各位都为0的数值相与即可) b.取一个数中的指定位(找一个数，对应x要取的位，该数的对应位为1，其余位为0，此数与x进行与运算即可得到x中的指定位) 按位或(|) 只要有一个为1，结果就为1 6(00000110) | 3(00000011) = 7(00000111) 用来对一个数据的某些位置1(找一个数，对应x要置1的位，该数的对应位为1，其余位为0，此数与x进行或运算即可使x中的某些位置1) 异或运算(^) 两个相应位为”异”，则该位结果为1，否则为0 6(00000110) ^ 3(00000011) = 5(00000101) a.与0相异或，可保留原值 b.使特定位翻转(找一个数，对应x要翻转的位，该数的对应位为1，其余位为0，此数与x对应位异或即可) 取反运算(~) 对一个二进制数按位取反，0变1，1变0 ~6(00000110) = -7(11111001) 补码(11111001)-1 -&gt; 得到反码(11111000)，除符号位外各位取反 -&gt; 得到原码-7(10000111) 左移运算(&lt;&lt;) 将一个数的各二进制位全部左移指定的位数，右边补0 3(00000011) &lt;&lt; 2 = 12(00001100) 若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2 右移运算(&gt;&gt;) 将一个数的各二进制位全部右移指定的位数，正数左补0，负数左补1 3(00000011) &gt;&gt; 1 = 1(00000001) 若操作数为正数，则每右移一位，相当于该数除以2 无符号右移运算(&gt;&gt;&gt;) 将一个数的各二进制位全部右移指定的位数，左边补0 3(00000011) &gt;&gt;&gt; 1 = 1(00000001) 若操作数为正数，则每右移一位，相当于该数除以2 ②两个变量交换值的方法 利用临时变量来实现两个变量的交换 步骤：C = A、A = B、B = C 利用加减法来实现两个变量的交换 步骤：A = A + B、B = A - B、A = A - B 利用位异或运算来实现两个变量的交换（效率最高） 原理：利用一个数异或本身等于 0 、与 0 异或保留原值和异或运算符合交换律 步骤：A = A ^ B、B = A ^ B、A = A ^ B 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#x79;&#109;&#x65;&#x73;&#115;&#x69;&#x40;&#x31;&#54;&#x33;&#x2e;&#x63;&#111;&#x6d;]]></content>
      <categories>
        <category>Java</category>
        <category>基础内容</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Markdown]]></title>
    <url>%2F2018%2F09%2F17%2F%E5%85%B3%E4%BA%8EMarkdown%2F</url>
    <content type="text"><![CDATA[1.认识Markdown Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的 HTML 页面。 —— 维基百科 Markdown 的目标是实现易读易写。其语法全由一些符号组成，并且符号的作用一目了然。语法目标：成为一种适用于网络的书写语言。它的语法种类很少，只对应于 HTML 标记的一小部分。理念是能使文档更易读、写和随意更改。 一般 Markdown 编译器的左边是编辑区，右边显示的样式是转换为 HTML 后加上 CSS 样式显示的。 同理在 Hexo 博客中，Markdown 文章需要解析成 HTML 格式，再输出到网页中。 2.Markdown和HTML HTML 是一种发布的格式。 Markdown 是一种书写的格式，其格式语法只涵盖纯文本可以涵盖的范围。 不在 Markdown 涵盖范围之内的标签，都可以直接在文档里用 HTML 撰写。 3.特殊字符自动转换①HTML中 在 HTML 文件内，有些字符需要特殊处理(相当于”转义”)，才能使用。如 &lt; 符号用于起始标签，&amp; 符号用于标记 HTML实体 。要想单纯的显示这两个字符原型，必须要使用实体的形式，即避免它们被当成标签的一部分。 字符实体有三部分：一个 &amp;符号、一个 实体名称 或&emsp; # 和 实体编号 、一个 ; 。如： &lt; == &amp;lt; == &amp;#60; || &amp; == &amp;amp; == &amp;#38; 。链接内、网址名中的 &amp; 也是要转换成实体后，再放到 &lt;a&gt; 标签的 herf 属性中去。 ②Markdown中 而 Markdown 可以让我们自然地书写字符。你只需正常的写，Markdown 编译器会进行判断，然后在生成 HTML 代码时自动转换，无须编写者关注。 即如果使用的 &amp; 是 HTML 字符实体的一部分(即是标识实体的特殊字符时)，它会保留原状，*否则自动转换成 &amp;amp; *。 或如果把使用的 &lt; 作为 HTML 标签的定界符使用，它会保留原状，否则自动转换为其实体名。 4.区块元素①段落与换行 一个 Markdown 段落的前后要有一个以上的空行(即无文本行)。若一行只包含空格和制表符，则该行会被视为空行。 与 HTML 的空格和换行设定一样，不管换(空)多少行(格)，只一个符号有效。可以用 HTML 标签实现多个换行与空格功能。 ②标题 Markdown 支持两种标题的语法，类Setext 和 类atx 形式。 类setext 形式：用底线的形式，=表示一级标题，–表示二级标题。 类Atx 形式：在行首插入1-6个 # ，对应1到6级标题。 作为美观,可以在行尾使用 # 闭合 类atx 样式的标题。 ③区块引用 Markdown 文件中建立一个区块引用，每行的最前面加上 &gt; 。 区块引用可以嵌套(例如：引用内的引用)，只要根据层次加上不同数量的 &gt; 。引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等。 ④列表 Markdown 支持有序列表和无序列表。 无序列表使用 * 、+ 或 - 接一个 空格 作为列表标记。 有序列表则使用 数字 接 . 再接一个 空格 作为列表标记。 如果要在列表项目内放进引用,那就需要缩进：空格 + 两个 Tab 为宜。 1 2 3 1 2 3 ⑤分隔线 在一行中用三个以上的 * 、 - 、 _ 可建立一个分隔线，行内不能有其他东东。也可以在 * 或是 - 中间插入空格。 ps：使用 --- 必须上下行都是空行，防止它作用在文字底部加粗文字。 ⑥表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 5.区段元素①文字链接 123 ②强调 Markdown使用 * 和下划线 _ 作为标记强调文字的符号。 斜体：被一个 * 或 _ 包围的文字，会被转成用 &lt;em&gt; 标签包围。 加粗：用两个 * 或 _ 包围的文字，会被转成用 &lt;strong&gt; 标签包围。 加粗斜体：被三个 * / _ 包围。 删除线：被~~ 包围 / &lt;del&gt; 标签。 强调也可以直接插在文字中间。 但是如果你的 * 和 _ 两边都有空白的话，它们就会被当成普通的符号。 如果要在文字前后直接插入普通的星号或底线，你可以用反斜线。 ③代码 如果要标记一小段行内代码，你可以用 反引号 把它包起来。 如果要标记多行代码： 1**123** 在代码区段内，&amp; 和 &lt; 都会被自动地转成 HTML 实体，这使得插入 HTML 原始代码变得很容易。代码区段中的Markdown 语法不会被转换，它们只是有高亮的普通文本。 ④图片![图片的代替文字](URL) Markdown 没有办法指定图片的宽高。如果需要，可以使用普通的 &lt;img&gt; 标签。 ⑤网址/邮箱链接 用尖括号包起来，Markdown 就会自动把它转成链接。 &lt;http:messi1002.top&gt; ⑥反斜杠 Markdown 支持以下符号前面加上反斜杠来帮助插入普通的符号：即反斜杠可以转义 Markdown 中的特殊字符！ 123456789101112\：反斜线。`：反引号。*：星号。_：底线。。&#123;&#125;：花括号。[]：方括号。()：括弧。#：井字号。+：加号。-：减号。.：英文句点。!：惊叹号。 如果想在行首出现 数字.空格 ，而不生成列表样式，可以在句点前面加上反斜杠。 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#106;&#x79;&#109;&#x65;&#115;&#x73;&#105;&#64;&#49;&#54;&#51;&#x2e;&#x63;&#111;&#x6d;]]></content>
      <categories>
        <category>博客相关</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交换变量的三种方法]]></title>
    <url>%2F2018%2F09%2F15%2F%E4%BA%A4%E6%8D%A2%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.相关博客 Java进制转换及位运算 2.临时变量法 利用临时变量来实现两个变量的交换 步骤： C = A A = B B = C 3.算术法 利用加减法来实现两个变量的交换 步骤： A = A + B B = A - B A = A - B 4.位运算法 利用位异或运算来实现两个变量的交换（效率最高） 原理：利用一个数异或本身等于 0 、与 0 异或保留原值和异或运算符合交换律 步骤： A = A ^ B B = A ^ B A = A ^ B 5.代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package other;/** * @author: wjy * @date: 2018/9/15 * @description: 交换变量的三种方法 */public class SwapVariable &#123; public static int i = 102, j = 928; /** * 功能描述: 利用临时变量来实现两个变量的交换 * * @param: [] * @return: void * @auther: wjy * @date: 2018/9/15 20:16 */ public static void swapByTemp() &#123; int temp = i; i = j; j = temp; &#125; /** * 功能描述: 利用加减法来实现两个变量的交换 * * @param: [] * @return: void * @auther: wjy * @date: 2018/9/15 20:17 */ public static void swapByArithmetic() &#123; i = i + j; j = i - j; i = i - j; &#125; /** * 功能描述: 利用位异或运算来实现两个变量的交换（效率最高） * * @param: [] * @return: void * @auther: wjy * @date: 2018/9/15 20:17 */ public static void swapByBitOperation() &#123; i = i &amp; j; j = i &amp; j; i = i &amp; j; &#125; public static void main(String[] args) &#123; System.out.println("交换前: i = " + i + " j = " + j); swapByTemp(); System.out.println("交换前: i = " + i + " j = " + j); swapByArithmetic(); System.out.println("交换前: i = " + i + " j = " + j); swapByBitOperation(); &#125;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#106;&#121;&#109;&#x65;&#115;&#x73;&#x69;&#x40;&#x31;&#54;&#51;&#46;&#x63;&#111;&#x6d;]]></content>
      <categories>
        <category>Java</category>
        <category>基础内容</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java.math.BigDecimal类的使用]]></title>
    <url>%2F2018%2F09%2F12%2Fjava-math-BigDecimal%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.浮点数的运算 double、float 类型的浮点数在进行运算时会发生精度丢失。 12345678910111213141516171819/** * @Auther: wjy * @Date: 2018/4/15 20:16 * @Description: 浮点数的运算。 */public class BigDecimalTest1 &#123; public static void main(String[] args) &#123; /* * 0.05 + 0.01 = 0.060000000000000005 * 1.0 - 0.42 = 0.5800000000000001 * 4.015 * 100 = 401.49999999999994 * 123.3 / 100 = 1.2329999999999999 */ System.out.println("0.05 + 0.01 = " + (0.05 + 0.01)); System.out.println("1.0 - 0.42 = " + (1.0 - 0.42)); System.out.println("4.015 * 100 = " + (4.015 * 100)); System.out.println("123.3 / 100 = " + (123.3 / 100)); &#125;&#125; 2.BigDecimal[‘desɪm(ə)l] 对象 为了能精确表示和计算浮点数，Java 提供了 BigDecimal 类，该类提供了大量的构造器，可以将不同的基本数值型变量、数字字符串、数字字符数组等转换成一个 BigDecimal 对象。注意：对于浮点数，建议使用基于 String 的构造器 (new BigDecimal(“num”);) 或 BigDecimal.valueOf(double value) 静态方法，以便在不丢失精度的前提下转换成一个 BigDecimal 对象。 new BigDecimal(double value) 构造器也会发生精度丢失 1234567891011121314151617181920212223import java.math.BigDecimal;/** * @Auther: wjy * @Date: 2018/4/15 20:49 * @Description: new BigDecimal(double value)构造器的精度丢失。 */public class BigDecicalTest2 &#123; public static void main(String[] args) &#123; BigDecimal b1 = new BigDecimal("0.01"); // 直接使用new BigDecimal(double value)同样会发生精度丢失。 BigDecimal b2 = new BigDecimal(0.01); BigDecimal b3 = BigDecimal.valueOf(0.01); /* * 0.01 * 0.01000000000000000020816681711721685132943093776702880859375 * 0.01 */ System.out.println(b1); System.out.println(b2); System.out.println(b3); &#125;&#125; BigDecimal 类中的方法： 1234567891011121314151617181920212223242526272829303132333435import java.math.BigDecimal;/** * @Auther: wjy * @Date: 2018/4/15 21:05 * @Description: BigDecimal类中的方法。 */public class BigDecimalTest3 &#123; public static void main(String[] args) &#123; BigDecimal b1 = new BigDecimal("123.4"); BigDecimal b2 = BigDecimal.valueOf(0.4); /* * b1 + b2 = 123.8 * b1 - b2 = 123.0 * b1 * b2 = 49.36 * b1 / b2 = 308.5 * b1 &gt; b2? 1 * b2 &gt; b1? -1 * b1的平方 = 15227.56 * b1的绝对值 = 123.4 * b1和b2中的较小值 = 0.4 * b1和b2中的较大值 = 123.4 */ System.out.println("b1 + b2 = " + b1.add(b2)); System.out.println("b1 - b2 = " + b1.subtract(b2)); System.out.println("b1 * b2 = " + b1.multiply(b2)); System.out.println("b1 / b2 = " + b1.divide(b2)); System.out.println("b1 &gt; b2? " + b1.compareTo(b2)); System.out.println("b2 &gt; b1? " + b2.compareTo(b1)); System.out.println("b1的平方 = " + b1.pow(2)); System.out.println("b1的绝对值 = " + b1.abs()); System.out.println("b1和b2中的较小值 = " + b1.min(b2)); System.out.println("b1和b2中的较大值 = " + b1.max(b2)); &#125;&#125; 3.自定义 Arith 工具类 当程序进行浮点数的运算时，需要先将 double 类型数值包装成 BigDecimal 对象，再调用 BigDecimal 对象的方法执行运算，最后将结果转换为 double 变量。如果代码中需要频繁地进行浮点数的运算，可以将上述步骤封装起来，写成一个 Arith 工具类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.math.BigDecimal;import java.math.RoundingMode;/** * @Auther: wjy * @Date: 2018/4/15 21:37 * @Description: 浮点数运算工具类。 */class BigDecimalArith &#123; // 设置除法运算精度，防止除不尽。 public static final int DEF_DIV_SCALE = 10; // 构造器私有，防止类的实例化。 private BigDecimalArith() &#123;&#125; // 加法。 public static double add(double d1, double d2) &#123; BigDecimal b1 = BigDecimal.valueOf(d1); BigDecimal b2 = BigDecimal.valueOf(d2); return b1.add(b2).doubleValue(); &#125; // 减法。 public static double sub(double d1, double d2) &#123; BigDecimal b1 = BigDecimal.valueOf(d1); BigDecimal b2 = BigDecimal.valueOf(d2); return b1.subtract(b2).doubleValue(); &#125; // 乘法。 public static double mul(double d1, double d2) &#123; BigDecimal b1 = BigDecimal.valueOf(d1); BigDecimal b2 = BigDecimal.valueOf(d2); return b1.multiply(b2).doubleValue(); &#125; // 除法。 public static double div(double d1, double d2) &#123; BigDecimal b1 = BigDecimal.valueOf(d1); BigDecimal b2 = BigDecimal.valueOf(d2); return b1.divide(b2, DEF_DIV_SCALE, RoundingMode.HALF_UP).doubleValue(); &#125;&#125;public class BigDecimalArithTest &#123; public static void main(String[]args)&#123; /* * 1.2 + 2.3 = 3.5 * 1.2 - 2.3 = -1.1 * 1.2 * 2.3 = 2.76 * 1.2 / 2.3 = 0.5217391304 */ System.out.println("1.2 + 2.3 = " + BigDecimalArith.add(1.2, 2.3)); System.out.println("1.2 - 2.3 = " + BigDecimalArith.sub(1.2, 2.3)); System.out.println("1.2 * 2.3 = " + BigDecimalArith.mul(1.2, 2.3)); System.out.println("1.2 / 2.3 = " + BigDecimalArith.div(1.2, 2.3)); &#125;&#125; 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#119;&#x6a;&#x79;&#x6d;&#x65;&#x73;&#x73;&#105;&#x40;&#x31;&#x36;&#51;&#46;&#x63;&#111;&#109;]]></content>
      <categories>
        <category>Java</category>
        <category>基础内容</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写给阿根廷]]></title>
    <url>%2F2018%2F09%2F07%2F%E5%86%99%E7%BB%99%E9%98%BF%E6%A0%B9%E5%BB%B7%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 东南 再东南&emsp;&emsp; 穿过太平洋&emsp;&emsp; 五月的太阳&emsp;&emsp; 晴空的蓝 浮云的白 &emsp;&emsp; 耶稣山上的圣象&emsp;&emsp; 张开双臂俯视世间万物&emsp;&emsp; …&emsp;&emsp; … &emsp;&emsp; 雄鹰蓦地折断翅膀&emsp;&emsp; 蓝白色海洋陷入死寂&emsp;&emsp; 眼中闪着点点泪光&emsp;&emsp; 蓝白色是不变的信仰 &emsp;&emsp; 战车上的残翼&emsp;&emsp; 无法挫伤你的锐气&emsp;&emsp; 潘帕斯雄鹰&emsp;&emsp; 依旧是绿茵场上的传奇&emsp;&emsp;&emsp;&emsp; ——记2014年巴西世界杯 围巾一 &emsp;&emsp; 重新想起以前写的这首诗，有些片段忘记了，慢慢回忆吧。 致梅西：不管有没有世界杯冠军，你都是当之无愧的球王！ 附录 我的个人博客：messi1002.top 如有错误或疑惑之处 请联系 &#x77;&#106;&#121;&#x6d;&#101;&#115;&#x73;&#105;&#64;&#49;&#54;&#x33;&#46;&#99;&#111;&#x6d;]]></content>
      <categories>
        <category>随笔</category>
        <category>诗</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
