<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wjy&#39;s blog</title>
  
  <subtitle>行到水穷处，坐看云起时。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://messi1002.top/"/>
  <updated>2020-06-19T13:10:54.942Z</updated>
  <id>http://messi1002.top/</id>
  
  <author>
    <name>围巾一</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java并发编程之活跃性问题</title>
    <link href="http://messi1002.top/2020/06/16/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B4%BB%E8%B7%83%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <id>http://messi1002.top/2020/06/16/Java并发编程之活跃性问题/</id>
    <published>2020-06-16T14:50:37.000Z</published>
    <updated>2020-06-19T13:10:54.942Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>死锁是最常见的活跃性问题，除了死锁之外，活锁和饥饿也会导致程序无法顺利执行，一般将死锁、活锁和饥饿统称为活跃性问题（也称为活性故障）。</strong></p></blockquote><h3 id="1-死锁（DeadLock）"><a href="#1-死锁（DeadLock）" class="headerlink" title="1.死锁（DeadLock）"></a>1.死锁（DeadLock）</h3><ul><li><a href="https://messi1002.top/2020/04/03/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%AD%BB%E9%94%81%E7%9A%84%E5%89%8D%E7%94%9F%E4%BB%8A%E4%B8%96/">Java并发编程之死锁的前生今世</a></li></ul><hr><h3 id="2-活锁（LiveLock）"><a href="#2-活锁（LiveLock）" class="headerlink" title="2.活锁（LiveLock）"></a>2.活锁（LiveLock）</h3><h4 id="①什么是活锁"><a href="#①什么是活锁" class="headerlink" title="①什么是活锁"></a>①什么是活锁</h4><p><img src="./1592485590026.png" alt="Alt text"></p><ul><li>死锁：是指两个（或多个）线程（或进程）相互持有对方所需要的资源，又不主动释放，导致大家都无法继续前进，程序陷入无尽的阻塞。<ul><li>比喻 1：如上图所示，绅士 1 说：你先，先生。绅士 2 说：还是你先，先生。然后他们不再说话，一直等待。</li><li>比喻 2：在哲学家就餐问题中，每个哲学家都拿着左边的叉子，永远都在等右边的叉子（或者相反）。 </li><li>程序阻塞，不需要消耗 CPU 资源。</li></ul></li><li>活锁：（用两个线程举例）是指线程 1 可以使用资源，但它很礼貌，让线程 2 先使用资源。线程 2 也可以使用资源，但它很绅士，让线程 1 先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。<ul><li>比喻 1：如上图所示，绅士 1 说：你先，先生。绅士 2 说：还是你先，先生。绅士 1 继续说：还是你先，先生。绅士 2 继续说：…… 双方一直在互相谦让，但是都不会起来。  </li><li>比喻 2：在哲学家就餐问题中，每个哲学家同时拿起左边的叉子，等待五秒钟后（检测到发生死锁），同时放下手中的叉子，再等待五秒钟后，又同时拿起左边的叉子 …… 一直都吃不到饭。</li><li>程序一直在运转，需要消耗 CPU 资源。</li><li>虽然线程没有阻塞，也始终在运行（所以叫做 “活” 锁，线程是 “活” 的），但是程序却得不到进展，因为线程间始终在互相谦让。</li></ul></li><li>死锁和活锁的结果是一样的 -&gt; 都使得线程无法正常运行。</li></ul><h4 id="②代码演示"><a href="#②代码演示" class="headerlink" title="②代码演示"></a>②代码演示</h4><ul><li>具体代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> threadcoreknowledge.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 演示活锁问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 勺子类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Spoon</span> </span>&#123;</span><br><span class="line">        <span class="comment">// owner是勺子的拥有者，拥有勺子时才能吃饭。</span></span><br><span class="line">        <span class="keyword">private</span> Person owner;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Spoon</span><span class="params">(Person owner)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.owner = owner;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOwner</span><span class="params">(Person owner)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.owner = owner;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用synchronized关键字修饰方法，表示同时只能有一个人吃饭。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 格式化打印，方便统一处理变量。</span></span><br><span class="line">            System.out.printf(<span class="string">"%s has eaten!\n"</span>, owner.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 就餐者类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 就餐者的名字</span></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="comment">// 就餐者是否饥饿</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isHungry;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.isHungry = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 功能描述: 就餐方法</span></span><br><span class="line"><span class="comment">         * spoon: 勺子</span></span><br><span class="line"><span class="comment">         * spouse: 另一半的实例</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span>: [spoon, spouse]</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@date</span>: 2020/6/18 21:26</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatWith</span><span class="params">(Spoon spoon, Person spouse)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果饿了，才准备吃饭。</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">this</span>.isHungry) &#123;</span><br><span class="line">                <span class="comment">// 勺子不在自己手里时，等待1ms。</span></span><br><span class="line">                <span class="keyword">if</span> (spoon.owner != <span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 勺子在自己手里时，如果另一半饿了，就让另一半先吃饭。</span></span><br><span class="line">                <span class="keyword">if</span> (spouse.isHungry) &#123;</span><br><span class="line">                    System.out.println(name + <span class="string">": 亲爱的"</span> + spouse.name + <span class="string">"你先吃吧!"</span>);</span><br><span class="line">                    <span class="comment">// 初始状态两个人都是饥饿的，他们不断地互相谦让，变成了传勺子游戏。</span></span><br><span class="line">                    spoon.setOwner(spouse);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 勺子在自己手里时，如果另一半不饿，自己才开始吃饭。</span></span><br><span class="line">                    spoon.use();</span><br><span class="line">                    isHungry = <span class="keyword">false</span>;</span><br><span class="line">                    System.out.println(name + <span class="string">": 我吃完了!"</span>);</span><br><span class="line">                    <span class="comment">// 把勺子交给另一半</span></span><br><span class="line">                    spoon.setOwner(spouse);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person husband = <span class="keyword">new</span> Person(<span class="string">"牛郎"</span>);</span><br><span class="line">        Person wife = <span class="keyword">new</span> Person(<span class="string">"织女"</span>);</span><br><span class="line">        <span class="comment">// 先把勺子给牛郎</span></span><br><span class="line">        Spoon spoon = <span class="keyword">new</span> Spoon(husband);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                husband.eatWith(spoon, wife);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                wife.eatWith(spoon, husband);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1592365869582.png" alt="Alt text"></p><h4 id="③工程中的活锁实例：消息队列"><a href="#③工程中的活锁实例：消息队列" class="headerlink" title="③工程中的活锁实例：消息队列"></a>③工程中的活锁实例：消息队列</h4><p><img src="./1592475426998.png" alt="Alt text"></p><ul><li>上图为一个先进先出的消息队列</li><li>错误策略：某个消息如果处理失败，就放在队列开头重试。此时如果依赖服务出了问题，无法成功处理该消息，会导致程序不停地重试。</li><li>解决方法：</li></ul><ol><li>将处理失败的消息放在队列尾部<ul><li>将其他消息处理完成后，再重试之前处理失败的消息。此时即便该消息再次处理失败，也不会对其他消息造成影响。</li></ul></li><li>加上重试次数的限制（根据业务的不同选取合适的次数）<ul><li>达到重试次数上限后，我们可以认为该消息短时间内无法恢复了，此时可以将它写到数据库中。对于数据库来说，一旦发现写入了处理失败的消息，一方面会触发报警机制，另一方面会存在定时任务定时重试该消息。</li></ul></li></ol><h4 id="④如何解决活锁问题"><a href="#④如何解决活锁问题" class="headerlink" title="④如何解决活锁问题"></a>④如何解决活锁问题</h4><ul><li>发生活锁问题的原因：重试机制不变，导致程序一直重试（如消息队列始终重试、吃饭始终互相谦让等）。</li><li>解决活锁问题 1：在程序中加入一个随机因素，让重试策略更加多元化。<ul><li>解决 <strong>2.活锁 — ②代码演示</strong> 中的活锁问题：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> threadcoreknowledge.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 解决活锁问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 勺子类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Spoon</span> </span>&#123;</span><br><span class="line">        <span class="comment">// owner是勺子的拥有者，拥有勺子时才能吃饭。</span></span><br><span class="line">        <span class="keyword">private</span> Person owner;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Spoon</span><span class="params">(Person owner)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.owner = owner;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOwner</span><span class="params">(Person owner)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.owner = owner;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用synchronized关键字修饰方法，表示同时只能有一个人吃饭。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 格式化打印，方便统一处理变量。</span></span><br><span class="line">            System.out.printf(<span class="string">"%s has eaten!\n"</span>, owner.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 就餐者类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 就餐者的名字</span></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="comment">// 就餐者是否饥饿</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isHungry;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.isHungry = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 功能描述: 就餐方法</span></span><br><span class="line"><span class="comment">         * spoon: 勺子</span></span><br><span class="line"><span class="comment">         * spouse: 另一半的实例</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span>: [spoon, spouse]</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@date</span>: 2020/6/18 21:26</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatWith</span><span class="params">(Spoon spoon, Person spouse)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果饿了，才准备吃饭。</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">this</span>.isHungry) &#123;</span><br><span class="line">                <span class="comment">// 勺子不在自己手里时，等待1ms。</span></span><br><span class="line">                <span class="keyword">if</span> (spoon.owner != <span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 解决活锁问题</span></span><br><span class="line">                Random random = <span class="keyword">new</span> Random();</span><br><span class="line">                <span class="comment">// 勺子在自己手里时，如果另一半饿了，有90%的概率让另一半先吃饭。</span></span><br><span class="line">                <span class="keyword">if</span> (spouse.isHungry &amp;&amp; random.nextInt(<span class="number">10</span>) &lt; <span class="number">9</span>) &#123;</span><br><span class="line">                    System.out.println(name + <span class="string">": 亲爱的"</span> + spouse.name + <span class="string">"你先吃吧!"</span>);</span><br><span class="line">                    spoon.setOwner(spouse);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 自己开始吃饭</span></span><br><span class="line">                    spoon.use();</span><br><span class="line">                    isHungry = <span class="keyword">false</span>;</span><br><span class="line">                    System.out.println(name + <span class="string">": 我吃完了!"</span>);</span><br><span class="line">                    <span class="comment">// 把勺子交给另一半</span></span><br><span class="line">                    spoon.setOwner(spouse);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person husband = <span class="keyword">new</span> Person(<span class="string">"牛郎"</span>);</span><br><span class="line">        Person wife = <span class="keyword">new</span> Person(<span class="string">"织女"</span>);</span><br><span class="line">        <span class="comment">// 先把勺子给牛郎</span></span><br><span class="line">        Spoon spoon = <span class="keyword">new</span> Spoon(husband);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                husband.eatWith(spoon, wife);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                wife.eatWith(spoon, husband);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1592474944876.png" alt="Alt text"></p><ul><li>解决活锁问题 2：以太网的指数退避算法（如下图所示）<ul><li>解决哲学家就餐问题中的活锁问题：当陷入死锁时，让每个哲学家等待一段随机时间后放下叉子，而不是设置一个固定的等待时间。</li></ul></li></ul><p><img src="./1592558856167.png" alt="Alt text"></p><hr><h3 id="3-饥饿"><a href="#3-饥饿" class="headerlink" title="3.饥饿"></a>3.饥饿</h3><h4 id="①什么是饥饿"><a href="#①什么是饥饿" class="headerlink" title="①什么是饥饿"></a>①什么是饥饿</h4><ul><li>饥饿：线程需要某些资源（通常指 CPU），但是却始终得不到。</li><li>饥饿可能会导致响应性变差：比如，浏览器有一个线程负责处理前台响应，另外的后台线程负责下载图片和文件、计算渲染等。在这种情况下，如果后台线程把 CPU 资源都占了，那么前台线程将无法流畅地执行，这会使得用户的体验很差。</li></ul><h4 id="②导致饥饿的几种情况"><a href="#②导致饥饿的几种情况" class="headerlink" title="②导致饥饿的几种情况"></a>②导致饥饿的几种情况</h4><ol><li>线程的优先级设置得过于低（CPU 始终分配给优先级更高的线程）</li><li>有其他线程持有锁的同时又无限循环从而不释放锁</li><li>某程序始终占用某文件的写锁</li></ol><h4 id="③关于线程优先级"><a href="#③关于线程优先级" class="headerlink" title="③关于线程优先级"></a>③关于线程优先级</h4><ol><li>Java 中有 10 个级别，默认的线程优先级为 5，子线程默认继承父线程的优先级。</li><li>程序设计不应该依赖于优先级。因为不同的操作系统对优先级的理解不一样，Windows 只有 7 个优先级，而 Linux 可能会忽略优先级。如果程序在不同的操作系统上运行的效果不一样，是不符合预期的。</li><li>操作系统的权限很高，程序的优先级会被操作系统改变。</li><li>为了避免饥饿现象的发生，不应该在程序中设定优先级。</li></ol><hr><h3 id="4-面试常考问题"><a href="#4-面试常考问题" class="headerlink" title="4.面试常考问题"></a>4.面试常考问题</h3><h4 id="①什么是活跃性问题？活锁、饥饿和死锁有什么区别？"><a href="#①什么是活跃性问题？活锁、饥饿和死锁有什么区别？" class="headerlink" title="①什么是活跃性问题？活锁、饥饿和死锁有什么区别？"></a>①什么是活跃性问题？活锁、饥饿和死锁有什么区别？</h4><blockquote><p>具体见 <strong>上文</strong></p></blockquote><ul><li>活跃性问题：一般将死锁、活锁和饥饿统称为活跃性问题（也称为活性故障），它们都会导致程序无法顺利执行。</li><li>死锁：争来争去 谁也得不到</li><li>活锁：让来让去 谁都不拥有</li><li>饥饿：排多久 都轮不到自己</li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#106;&#x79;&#x6d;&#101;&#115;&#x73;&#105;&#x40;&#49;&#54;&#x33;&#x2e;&#99;&#x6f;&#109;" target="_blank" rel="noopener">&#x77;&#106;&#x79;&#x6d;&#101;&#115;&#x73;&#105;&#x40;&#49;&#54;&#x33;&#x2e;&#99;&#x6f;&#109;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;死锁是最常见的活跃性问题，除了死锁之外，活锁和饥饿也会导致程序无法顺利执行，一般将死锁、活锁和饥饿统称为活跃性问题（也称为活性故障）。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-死锁（DeadLock
      
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="并发编程" scheme="http://messi1002.top/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出并发编程底层原理</title>
    <link href="http://messi1002.top/2020/06/14/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <id>http://messi1002.top/2020/06/14/深入浅出并发编程底层原理/</id>
    <published>2020-06-14T13:33:40.000Z</published>
    <updated>2020-06-21T13:34:21.209Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="并发编程" scheme="http://messi1002.top/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://messi1002.top/2020/06/11/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://messi1002.top/2020/06/11/单例模式/</id>
    <published>2020-06-11T12:38:23.000Z</published>
    <updated>2020-06-20T12:45:44.978Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="单例模式" scheme="http://messi1002.top/categories/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="单例模式" scheme="http://messi1002.top/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="http://messi1002.top/2020/06/10/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://messi1002.top/2020/06/10/volatile关键字/</id>
    <published>2020-06-10T12:54:12.000Z</published>
    <updated>2020-06-20T12:26:18.102Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="并发编程" scheme="http://messi1002.top/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>2020秋招复习之数据结构与算法</title>
    <link href="http://messi1002.top/2020/06/08/2020%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://messi1002.top/2020/06/08/2020秋招复习之数据结构与算法/</id>
    <published>2020-06-08T09:01:28.000Z</published>
    <updated>2020-06-12T13:01:39.562Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-面经相关"><a href="#1-面经相关" class="headerlink" title="1.面经相关"></a>1.面经相关</h3><h4 id="①相关博客"><a href="#①相关博客" class="headerlink" title="①相关博客"></a>①相关博客</h4><ul><li><a href="https://canghaizanhua6.github.io/2020/05/01/%E5%85%AC%E5%8F%B8%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/" target="_blank" rel="noopener">大厂秋招笔试真题汇总</a></li><li><a href="https://canghaizanhua6.github.io/2020/05/03/%E7%AC%94%E8%AF%95%E9%A2%98%E5%88%86%E7%B1%BB%E7%BB%9F%E8%AE%A1/" target="_blank" rel="noopener">大厂秋招笔试真题分类统计</a></li></ul><h4 id="②分类优先级"><a href="#②分类优先级" class="headerlink" title="②分类优先级"></a>②分类优先级</h4><p>29.多线程 &gt; 15.设计 &gt; 23.线段树 &gt; 22.字典树 &gt; 19.堆 &gt; 20.分治算法 &gt; 4.动态规划 &gt; 14.回溯算法 &gt; 11.贪心算法 &gt; 8.图 &gt; 7.树 &gt; 13.栈 &gt; 24.队列 &gt; 16.位运算 &gt; 17.排序 &gt; 18.链表 &gt; 21.递归 &gt; 12.滑动窗口 &gt; 10.二分查找 &gt; 9.哈希表 &gt; 12.双指针 &gt; 6.数学 &gt; 5.字符串 &gt; 3.数组</p><hr><h3 id="2-算法复杂度"><a href="#2-算法复杂度" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h3><ul><li>什么是算法复杂度</li><li>时间 / 空间复杂度的含义</li><li>大 O 复杂度具体指的是什么？</li><li>有哪些常见的时间复杂度，分别举一个例子。</li><li>多举几个 O(1) 时间复杂度的例子</li></ul><hr><h3 id="3-数组"><a href="#3-数组" class="headerlink" title="3.数组"></a>3.数组</h3><h4 id="①知识点整理"><a href="#①知识点整理" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li>数组和链表的差别</li><li>标记数组</li></ul><h4 id="②LeetCode-必刷题目（49）"><a href="#②LeetCode-必刷题目（49）" class="headerlink" title="②LeetCode 必刷题目（49）"></a>②LeetCode 必刷题目（49）</h4><ul><li>剑指 Offer（3）<ul><li><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/" target="_blank" rel="noopener">面试题21. 调整数组顺序使奇数位于偶数前面</a></li><li><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">面试题29. 顺时针打印矩阵</a></li><li><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/" target="_blank" rel="noopener">面试题66. 构建乘积数组</a></li></ul></li><li>简单（34）<ul><li><a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener">66. 加一</a> </li><li><a href="https://leetcode-cn.com/problems/pascals-triangle/" target="_blank" rel="noopener">118. 杨辉三角</a></li><li><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/" target="_blank" rel="noopener">119. 杨辉三角 II</a></li><li><a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">189. 旋转数组</a></li><li><a href="https://leetcode-cn.com/problems/third-maximum-number/" target="_blank" rel="noopener">414. 第三大的数</a></li><li><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">448. 找到所有数组中消失的数字</a></li><li><a href="https://leetcode-cn.com/problems/max-consecutive-ones/" target="_blank" rel="noopener">485. 最大连续1的个数</a></li><li><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. 斐波那契数</a></li><li><a href="https://leetcode-cn.com/problems/array-partition-i/" target="_blank" rel="noopener">561. 数组拆分 I</a></li><li><a href="https://leetcode-cn.com/problems/reshape-the-matrix/" target="_blank" rel="noopener">566. 重塑矩阵</a></li><li><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">581. 最短无序连续子数组</a></li><li><a href="https://leetcode-cn.com/problems/image-smoother/" target="_blank" rel="noopener">661. 图片平滑器</a></li><li><a href="https://leetcode-cn.com/problems/non-decreasing-array/" target="_blank" rel="noopener">665. 非递减数列</a></li><li><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">674. 最长连续递增序列</a></li><li><a href="https://leetcode-cn.com/problems/degree-of-an-array/" target="_blank" rel="noopener">697. 数组的度</a></li><li><a href="https://leetcode-cn.com/problems/1-bit-and-2-bit-characters/" target="_blank" rel="noopener">717. 1比特与2比特字符</a></li><li><a href="https://leetcode-cn.com/problems/find-pivot-index/" target="_blank" rel="noopener">724. 寻找数组的中心索引</a></li><li><a href="https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others/" target="_blank" rel="noopener">747. 至少是其他数字两倍的最大数</a></li><li><a href="https://leetcode-cn.com/problems/toeplitz-matrix/" target="_blank" rel="noopener">766. 托普利茨矩阵</a></li><li><a href="https://leetcode-cn.com/problems/positions-of-large-groups/" target="_blank" rel="noopener">830. 较大分组的位置</a></li><li><a href="https://leetcode-cn.com/problems/flipping-an-image/" target="_blank" rel="noopener">832. 翻转图像</a></li><li><a href="https://leetcode-cn.com/problems/transpose-matrix/" target="_blank" rel="noopener">867. 转置矩阵</a></li><li><a href="https://leetcode-cn.com/problems/fair-candy-swap/" target="_blank" rel="noopener">888. 公平的糖果交换</a></li><li><a href="https://leetcode-cn.com/problems/monotonic-array/" target="_blank" rel="noopener">896. 单调数列</a></li><li><a href="https://leetcode-cn.com/problems/sort-array-by-parity/" target="_blank" rel="noopener">905. 按奇偶排序数组</a></li><li><a href="https://leetcode-cn.com/problems/valid-mountain-array/" target="_blank" rel="noopener">941. 有效的山脉数组</a></li><li><a href="https://leetcode-cn.com/problems/sum-of-even-numbers-after-queries/" target="_blank" rel="noopener">985. 查询后的偶数和</a></li><li><a href="https://leetcode-cn.com/problems/add-to-array-form-of-integer/" target="_blank" rel="noopener">989. 数组形式的整数加法</a></li><li><a href="https://leetcode-cn.com/problems/available-captures-for-rook/" target="_blank" rel="noopener">999. 可以被一步捕获的棋子数</a></li><li><a href="https://leetcode-cn.com/problems/height-checker/" target="_blank" rel="noopener">1051. 高度检查器</a></li><li><a href="https://leetcode-cn.com/problems/sum-of-digits-in-the-minimum-number/" target="_blank" rel="noopener">1085. 最小元素各数位之和</a></li><li><a href="https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits/" target="_blank" rel="noopener">1295. 统计位数为偶数的数字</a></li><li><a href="https://leetcode-cn.com/problems/find-n-unique-integers-sum-up-to-zero/" target="_blank" rel="noopener">1304. 和为零的N个唯一整数</a></li><li><a href="https://leetcode-cn.com/problems/decompress-run-length-encoded-list/" target="_blank" rel="noopener">1313. 解压缩编码列表</a></li></ul></li><li>中等（11）<ul><li><a href="https://leetcode-cn.com/problems/rotate-matrix-lcci/" target="_blank" rel="noopener">面试题 01.07. 旋转矩阵</a></li><li><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">31. 下一个排列</a></li><li><a href="https://leetcode-cn.com/problems/rotate-image/" target="_blank" rel="noopener">48. 旋转图像</a></li><li><a href="https://leetcode-cn.com/problems/spiral-matrix/" target="_blank" rel="noopener">54. 螺旋矩阵</a></li><li><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/" target="_blank" rel="noopener">59. 螺旋矩阵 II</a></li><li><a href="https://leetcode-cn.com/problems/set-matrix-zeroes/" target="_blank" rel="noopener">73. 矩阵置零</a></li><li><a href="https://leetcode-cn.com/problems/majority-element-ii/" target="_blank" rel="noopener">229. 求众数 II</a></li><li><a href="https://leetcode-cn.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">238. 除自身以外数组的乘积</a></li><li><a href="https://leetcode-cn.com/problems/game-of-life/" target="_blank" rel="noopener">289. 生命游戏</a></li><li><a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/" target="_blank" rel="noopener">442. 数组中重复的数据</a></li><li><a href="https://leetcode-cn.com/problems/my-calendar-i/" target="_blank" rel="noopener">729. 我的日程安排表 I</a></li></ul></li><li>困难（1）<ul><li><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">41. 缺失的第一个正数</a></li></ul></li></ul><h4 id="③相关博客"><a href="#③相关博客" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="4-动态规划"><a href="#4-动态规划" class="headerlink" title="4.动态规划"></a>4.动态规划</h3><hr><h3 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5.字符串"></a>5.字符串</h3><h4 id="①知识点整理-1"><a href="#①知识点整理-1" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li>KMP 算法</li><li>正则表达式</li></ul><h4 id="②LeetCode-必刷题目（40）"><a href="#②LeetCode-必刷题目（40）" class="headerlink" title="②LeetCode 必刷题目（40）"></a>②LeetCode 必刷题目（40）</h4><ul><li>剑指 Offer（3）<ul><li><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">面试题05. 替换空格</a></li><li><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/" target="_blank" rel="noopener">面试题58 - I. 翻转单词顺序</a> </li><li><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/" target="_blank" rel="noopener">面试题58 - II. 左旋转字符串</a></li></ul></li><li>简单（27）<ul><li><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14. 最长公共前缀</a></li><li><a href="https://leetcode-cn.com/problems/count-and-say/" target="_blank" rel="noopener">38. 外观数列</a></li><li><a href="https://leetcode-cn.com/problems/length-of-last-word/" target="_blank" rel="noopener">58. 最后一个单词的长度</a></li><li><a href="https://leetcode-cn.com/problems/read-n-characters-given-read4/" target="_blank" rel="noopener">157. 用 Read4 读取 N 个字符</a></li><li><a href="https://leetcode-cn.com/problems/ransom-note/" target="_blank" rel="noopener">383. 赎金信</a></li><li><a href="https://leetcode-cn.com/problems/add-strings/" target="_blank" rel="noopener">415. 字符串相加</a></li><li><a href="https://leetcode-cn.com/problems/number-of-segments-in-a-string/" target="_blank" rel="noopener">434. 字符串中的单词数</a></li><li><a href="https://leetcode-cn.com/problems/string-compression/" target="_blank" rel="noopener">443. 压缩字符串</a></li><li><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/" target="_blank" rel="noopener">459. 重复的子字符串</a></li><li><a href="https://leetcode-cn.com/problems/detect-capital/" target="_blank" rel="noopener">520. 检测大写字母</a></li><li><a href="https://leetcode-cn.com/problems/longest-uncommon-subsequence-i/" target="_blank" rel="noopener">521. 最长特殊序列 Ⅰ</a></li><li><a href="https://leetcode-cn.com/problems/reverse-string-ii/" target="_blank" rel="noopener">541. 反转字符串 II</a></li><li><a href="https://leetcode-cn.com/problems/student-attendance-record-i/" target="_blank" rel="noopener">551. 学生出勤记录 I</a></li><li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/" target="_blank" rel="noopener">557. 反转字符串中的单词 III</a></li><li><a href="https://leetcode-cn.com/problems/robot-return-to-origin/" target="_blank" rel="noopener">657. 机器人能否返回原点</a></li><li><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/" target="_blank" rel="noopener">680. 验证回文字符串 Ⅱ</a></li><li><a href="https://leetcode-cn.com/problems/repeated-string-match/" target="_blank" rel="noopener">686. 重复叠加字符串匹配</a></li><li><a href="https://leetcode-cn.com/problems/count-binary-substrings/" target="_blank" rel="noopener">696. 计数二进制子串</a></li><li><a href="https://leetcode-cn.com/problems/to-lower-case/" target="_blank" rel="noopener">709. 转换成小写字母</a></li><li><a href="https://leetcode-cn.com/problems/rotated-digits/" target="_blank" rel="noopener">788. 旋转数字</a></li><li><a href="https://leetcode-cn.com/problems/unique-morse-code-words/" target="_blank" rel="noopener">804. 唯一摩尔斯密码词</a></li><li><a href="https://leetcode-cn.com/problems/goat-latin/" target="_blank" rel="noopener">824. 山羊拉丁文</a></li><li><a href="https://leetcode-cn.com/problems/groups-of-special-equivalent-strings/" target="_blank" rel="noopener">893. 特殊等价字符串组</a></li><li><a href="https://leetcode-cn.com/problems/unique-email-addresses/" target="_blank" rel="noopener">929. 独特的电子邮件地址</a></li><li><a href="https://leetcode-cn.com/problems/defanging-an-ip-address/" target="_blank" rel="noopener">1108. IP 地址无效化</a></li><li><a href="https://leetcode-cn.com/problems/remove-vowels-from-a-string/" target="_blank" rel="noopener">1119. 删去字符串中的元音</a></li><li><a href="https://leetcode-cn.com/problems/single-row-keyboard/" target="_blank" rel="noopener">1165. 单行键盘</a></li></ul></li><li>中等（8）<ul><li><a href="https://leetcode-cn.com/problems/zigzag-conversion/" target="_blank" rel="noopener">6. Z 字形变换</a></li><li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">151. 翻转字符串里的单词</a></li><li><a href="https://leetcode-cn.com/problems/compare-version-numbers/" target="_blank" rel="noopener">165. 比较版本号</a></li><li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-ii/" target="_blank" rel="noopener">186. 翻转字符串里的单词 II</a></li><li><a href="https://leetcode-cn.com/problems/minimum-time-difference/" target="_blank" rel="noopener">539. 最小时间差</a></li><li><a href="https://leetcode-cn.com/problems/next-greater-element-iii/" target="_blank" rel="noopener">556. 下一个更大元素 II</a></li><li><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/" target="_blank" rel="noopener">583. 两个字符串的删除操作</a></li><li><a href="https://leetcode-cn.com/problems/valid-parenthesis-string/" target="_blank" rel="noopener">678. 有效的括号字符串</a></li></ul></li><li>困难（2）<ul><li><a href="https://leetcode-cn.com/problems/shortest-palindrome/" target="_blank" rel="noopener">214. 最短回文串</a></li><li><a href="https://leetcode-cn.com/problems/find-the-closest-palindrome/" target="_blank" rel="noopener">564. 寻找最近的回文数</a></li></ul></li></ul><h4 id="③相关博客-1"><a href="#③相关博客-1" class="headerlink" title="③相关博客"></a>③相关博客</h4><ul><li>Java 的字符串操作：</li></ul><p><img src="./1589428412427.png" alt="Alt text"><br><img src="./1589428362495.png" alt="Alt text"><br><img src="./1589428335234.png" alt="Alt text"></p><hr><h3 id="6-数学"><a href="#6-数学" class="headerlink" title="6.数学"></a>6.数学</h3><h4 id="①知识点整理-2"><a href="#①知识点整理-2" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li>约瑟夫环</li><li>牛顿迭代法</li><li>排列组合</li><li>前 n 项和</li><li>快速幂算法</li></ul><h4 id="②LeetCode-必刷题目（41）"><a href="#②LeetCode-必刷题目（41）" class="headerlink" title="②LeetCode 必刷题目（41）"></a>②LeetCode 必刷题目（41）</h4><ul><li>剑指 Offer（7）<ul><li><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/" target="_blank" rel="noopener">面试题17. 打印从1到最大的n位数</a></li><li><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank" rel="noopener">面试题20. 表示数值的字符串</a></li><li><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">面试题43. 1～n整数中1出现的次数</a></li><li><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题44. 数字序列中某一位的数字</a></li><li><a href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank" rel="noopener">面试题49. 丑数</a></li><li><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题62. 圆圈中最后剩下的数字</a></li><li><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/" target="_blank" rel="noopener">面试题67. 把字符串转换成整数</a></li></ul></li><li>简单（23）<ul><li><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">7. 整数反转</a></li><li><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">9. 回文数</a></li><li><a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">13. 罗马数字转整数</a></li><li><a href="https://leetcode-cn.com/problems/add-binary/" target="_blank" rel="noopener">67. 二进制求和</a></li><li><a href="https://leetcode-cn.com/problems/excel-sheet-column-title/" target="_blank" rel="noopener">168. Excel表列名称</a></li><li><a href="https://leetcode-cn.com/problems/excel-sheet-column-number/" target="_blank" rel="noopener">171. Excel表列序号</a></li><li><a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/" target="_blank" rel="noopener">172. 阶乘后的零</a></li><li><a href="https://leetcode-cn.com/problems/happy-number/" target="_blank" rel="noopener">202. 快乐数</a></li><li><a href="https://leetcode-cn.com/problems/add-digits/" target="_blank" rel="noopener">258. 各位相加</a></li><li><a href="https://leetcode-cn.com/problems/ugly-number/" target="_blank" rel="noopener">263. 丑数</a></li><li><a href="https://leetcode-cn.com/problems/power-of-three/" target="_blank" rel="noopener">326. 3的幂</a></li><li><a href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/" target="_blank" rel="noopener">453. 最小移动次数使数组元素相等</a></li><li><a href="https://leetcode-cn.com/problems/perfect-number/" target="_blank" rel="noopener">507. 完美数</a></li><li><a href="https://leetcode-cn.com/problems/range-addition-ii/" target="_blank" rel="noopener">598. 范围求和 II</a></li><li><a href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/" target="_blank" rel="noopener">628. 三个数的最大乘积</a></li><li><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/" target="_blank" rel="noopener">633. 平方数之和</a></li><li><a href="https://leetcode-cn.com/problems/self-dividing-numbers/" target="_blank" rel="noopener">728. 自除数</a></li><li><a href="https://leetcode-cn.com/problems/binary-gap/" target="_blank" rel="noopener">868. 二进制间距</a></li><li><a href="https://leetcode-cn.com/problems/smallest-range-i/" target="_blank" rel="noopener">908. 最小差值 I</a></li><li><a href="https://leetcode-cn.com/problems/di-string-match/" target="_blank" rel="noopener">942. 增减字符串匹配</a></li><li><a href="https://leetcode-cn.com/problems/confusing-number/" target="_blank" rel="noopener">1056. 易混淆数</a></li><li><a href="https://leetcode-cn.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/" target="_blank" rel="noopener">1281. 整数的各位积和之差</a></li><li><a href="https://leetcode-cn.com/problems/maximum-69-number/" target="_blank" rel="noopener">1323. 6 和 9 组成的最大数字</a></li></ul></li><li>中等（9）<ul><li><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">8. 字符串转换整数 (atoi)</a></li><li><a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank" rel="noopener">12. 整数转罗马数字</a></li><li><a href="https://leetcode-cn.com/problems/multiply-strings/" target="_blank" rel="noopener">43. 字符串相乘</a></li><li><a href="https://leetcode-cn.com/problems/ugly-number-ii/" target="_blank" rel="noopener">264. 丑数 II</a></li><li><a href="https://leetcode-cn.com/problems/super-pow/" target="_blank" rel="noopener">372. 超级次方</a></li><li><a href="https://leetcode-cn.com/problems/nth-digit/" target="_blank" rel="noopener">400. 第N个数字</a></li><li><a href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/" target="_blank" rel="noopener">462. 最少移动次数使数组元素相等 II</a></li><li><a href="https://leetcode-cn.com/problems/complex-number-multiplication/" target="_blank" rel="noopener">537. 复数乘法</a></li><li><a href="https://leetcode-cn.com/problems/reach-a-number/" target="_blank" rel="noopener">754. 到达终点数字</a></li></ul></li><li>困难（2）<ul><li><a href="https://leetcode-cn.com/problems/number-of-digit-one/" target="_blank" rel="noopener">233. 数字 1 的个数</a></li><li><a href="https://leetcode-cn.com/problems/poor-pigs/" target="_blank" rel="noopener">458. 可怜的小猪</a></li></ul></li></ul><h4 id="③相关博客-2"><a href="#③相关博客-2" class="headerlink" title="③相关博客"></a>③相关博客</h4><ul><li><a href="https://messi1002.top/2019/05/05/LeetCode-172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6%EF%BC%88Easy%EF%BC%89C%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/">172. 阶乘后的零（Easy）C语言题解</a></li><li><a href="https://messi1002.top/2019/05/05/LeetCode-172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6%EF%BC%88Easy%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/">172. 阶乘后的零（Easy）Java语言题解</a></li></ul><hr><h3 id="7-树"><a href="#7-树" class="headerlink" title="7.树"></a>7.树</h3><h4 id="①知识点整理-3"><a href="#①知识点整理-3" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li>树的概念<ul><li>二叉树有哪几种形式？</li><li>什么是平衡二叉树、满二叉树、完全二叉树</li><li>Trie 树和二叉树的区别</li><li>树和链表的区别？</li><li>讲讲树和图，它们有什么区别？</li></ul></li><li>树的遍历</li><li>递归求解树</li><li>路径相关</li><li>二叉搜索树 <ul><li>在含有 100 个节点的二叉搜索树中找到其中第 80 大的节点</li></ul></li></ul><h4 id="②LeetCode-必刷题目（78）"><a href="#②LeetCode-必刷题目（78）" class="headerlink" title="②LeetCode 必刷题目（78）"></a>②LeetCode 必刷题目（78）</h4><ul><li>剑指 Offer（14）<ul><li><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题07. 重建二叉树</a></li><li><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">面试题26. 树的子结构</a></li><li><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">面试题27. 二叉树的镜像</a></li><li><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题28. 对称的二叉树</a></li><li><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题32 - I. 从上到下打印二叉树</a></li><li><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">面试题32 - II. 从上到下打印二叉树 II</a></li><li><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">面试题32 - III. 从上到下打印二叉树 III</a></li><li><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">面试题33. 二叉搜索树的后序遍历序列</a></li><li><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">面试题34. 二叉树中和为某一值的路径</a></li><li><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" target="_blank" rel="noopener">面试题54. 二叉搜索树的第k大节点</a></li><li><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/" target="_blank" rel="noopener">面试题55 - I. 二叉树的深度</a></li><li><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题55 - II. 平衡二叉树</a></li><li><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">面试题68 - I. 二叉搜索树的最近公共祖先</a></li><li><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">面试题68 - II. 二叉树的最近公共祖先</a></li></ul></li><li>树的遍历（19）<ul><li><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. 二叉树的后序遍历</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">107. 二叉树的层次遍历 II</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">103. 二叉树的锯齿形层次遍历</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-vertical-order-traversal/" target="_blank" rel="noopener">314. 二叉树的垂直遍历</a></li><li><a href="https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/" target="_blank" rel="noopener">987. 二叉树的垂序遍历</a></li><li><a href="https://leetcode-cn.com/problems/increasing-order-search-tree/" target="_blank" rel="noopener">897. 递增顺序查找树</a></li><li><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener">637. 二叉树的层平均值</a></li><li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a></li><li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">106. 从中序与后序遍历序列构造二叉树</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">199. 二叉树的右视图</a></li><li><a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">337. 打家劫舍 III</a></li><li><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-bst/" target="_blank" rel="noopener">449. 序列化和反序列化二叉搜索树</a></li><li><a href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/" target="_blank" rel="noopener">863. 二叉树中所有距离为 K 的结点</a></li><li><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">429. N叉树的层序遍历</a></li><li><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="noopener">589. N叉树的前序遍历</a></li><li><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener">590. N叉树的后序遍历</a></li></ul></li><li>适合递归求解（21）<ul><li><a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">100. 相同的树</a></li><li><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. 对称二叉树</a></li><li><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. 二叉树的最大深度</a></li><li><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">110. 平衡二叉树</a></li><li><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. 二叉树的最小深度</a></li><li><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. 二叉树展开为链表</a></li><li><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">222. 完全二叉树的节点个数</a></li><li><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">226. 翻转二叉树</a></li><li><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">404. 左叶子之和</a></li><li><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/" target="_blank" rel="noopener">513. 找树左下角的值</a></li><li><a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/" target="_blank" rel="noopener">515. 在每个树行中找最大值</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-tilt/" target="_blank" rel="noopener">563. 二叉树的坡度</a></li><li><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener">572. 另一个树的子树</a></li><li><a href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/" target="_blank" rel="noopener">606. 根据二叉树创建字符串</a></li><li><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">617. 合并二叉树</a></li><li><a href="https://leetcode-cn.com/problems/maximum-binary-tree/" target="_blank" rel="noopener">654. 最大二叉树</a></li><li><a href="https://leetcode-cn.com/problems/print-binary-tree/" target="_blank" rel="noopener">655. 输出二叉树</a></li><li><a href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/" target="_blank" rel="noopener">671. 二叉树中第二小的节点</a></li><li><a href="https://leetcode-cn.com/problems/leaf-similar-trees/" target="_blank" rel="noopener">872. 叶子相似的树</a></li><li><a href="https://leetcode-cn.com/problems/flip-equivalent-binary-trees/" target="_blank" rel="noopener">951. 翻转等价二叉树</a></li><li><a href="https://leetcode-cn.com/problems/univalued-binary-tree/" target="_blank" rel="noopener">965. 单值二叉树</a></li></ul></li><li>路径相关（8）<ul><li><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">112. 路径总和</a></li><li><a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">113. 路径总和 II</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">124. 二叉树中的最大路径和</a></li><li><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. 二叉树的最近公共祖先</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-paths/" target="_blank" rel="noopener">257. 二叉树的所有路径</a></li><li><a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">437. 路径总和 III</a></li><li><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">543. 二叉树的直径</a></li><li><a href="https://leetcode-cn.com/problems/longest-univalue-path/" target="_blank" rel="noopener">687. 最长同值路径</a></li></ul></li><li>二叉搜索树（16）<ul><li><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a> </li><li><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener">99. 恢复二叉搜索树</a></li><li><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">108. 将有序数组转换为二叉搜索树</a></li><li><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">230. 二叉搜索树中第K小的元素</a></li><li><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">235. 二叉搜索树的最近公共祖先</a></li><li><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">450. 删除二叉搜索树中的节点</a></li><li><a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/" target="_blank" rel="noopener">501. 二叉搜索树中的众数</a></li><li><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener">530. 二叉搜索树的最小绝对差</a></li><li><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">538. 把二叉搜索树转换为累加树</a></li><li><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/" target="_blank" rel="noopener">653. 两数之和 IV - 输入 BST</a> </li><li><a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/" target="_blank" rel="noopener">669. 修剪二叉搜索树</a></li><li><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener">700. 二叉搜索树中的搜索</a></li><li><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">701. 二叉搜索树中的插入操作</a></li><li><a href="https://leetcode-cn.com/problems/split-bst/" target="_blank" rel="noopener">776. 拆分二叉搜索树</a></li><li><a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/" target="_blank" rel="noopener">783. 二叉搜索树节点最小距离</a></li><li><a href="https://leetcode-cn.com/problems/range-sum-of-bst/" target="_blank" rel="noopener">938. 二叉搜索树的范围和</a></li></ul></li></ul><h4 id="③相关博客-3"><a href="#③相关博客-3" class="headerlink" title="③相关博客"></a>③相关博客</h4><ul><li><a href="https://messi1002.top/2019/02/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%80%A7%E8%B4%A8/">二叉树的定义及性质</a></li><li><a href="https://messi1002.top/2019/02/11/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E9%80%92%E5%BD%92-%E8%BF%AD%E4%BB%A3/">树的遍历(递归+迭代)</a></li><li><a href="https://www.tamarous.com/morris_traversal_algorithm/" target="_blank" rel="noopener">二叉树的 Morris 遍历</a></li><li><a href="https://messi1002.top/2019/02/15/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/">二叉搜索树的常用操作</a></li></ul><hr><h3 id="8-图"><a href="#8-图" class="headerlink" title="8.图"></a>8.图</h3><h4 id="①知识点整理-4"><a href="#①知识点整理-4" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li>BFS（广度优先搜索）</li><li>DFS（深度优先搜索）</li><li>最短路径算法</li><li>说一下数据结构中的图如何存储</li><li>一个有向图用邻接矩阵表示，并且是有权图，怎么判断图中有没有环（有向图判断循环引用）</li></ul><h4 id="②LeetCode-必刷题目（11）"><a href="#②LeetCode-必刷题目（11）" class="headerlink" title="②LeetCode 必刷题目（11）"></a>②LeetCode 必刷题目（11）</h4><ul><li>剑指 Offer（1）<ul><li><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">面试题13. 机器人的运动范围</a></li></ul></li><li>中等（8）<ul><li><a href="https://leetcode-cn.com/problems/clone-graph/" target="_blank" rel="noopener">133. 克隆图</a></li><li><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></li><li><a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">207. 课程表</a></li><li><a href="https://leetcode-cn.com/problems/course-schedule-ii/" target="_blank" rel="noopener">210. 课程表 II</a></li><li><a href="https://leetcode-cn.com/problems/minimum-height-trees/" target="_blank" rel="noopener">310. 最小高度树</a></li><li><a href="https://leetcode-cn.com/problems/reconstruct-itinerary/" target="_blank" rel="noopener">332. 重新安排行程</a></li><li><a href="https://leetcode-cn.com/problems/evaluate-division/" target="_blank" rel="noopener">399. 除法求值</a></li><li><a href="https://leetcode-cn.com/problems/redundant-connection/" target="_blank" rel="noopener">684. 冗余连接</a></li></ul></li><li>困难（2）<ul><li><a href="https://leetcode-cn.com/problems/alien-dictionary/" target="_blank" rel="noopener">269. 火星词典</a></li><li><a href="https://leetcode-cn.com/problems/redundant-connection-ii/" target="_blank" rel="noopener">685. 冗余连接 II</a></li></ul></li></ul><h4 id="③相关博客-4"><a href="#③相关博客-4" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="9-哈希表"><a href="#9-哈希表" class="headerlink" title="9.哈希表"></a>9.哈希表</h3><h4 id="①知识点整理-5"><a href="#①知识点整理-5" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li>怎么防止 hash 碰撞</li><li>K—V</li></ul><h4 id="②LeetCode-必刷题目（47）"><a href="#②LeetCode-必刷题目（47）" class="headerlink" title="②LeetCode 必刷题目（47）"></a>②LeetCode 必刷题目（47）</h4><ul><li>剑指 Offer（2）<ul><li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题03. 数组中重复的数字</a></li><li><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/" target="_blank" rel="noopener">面试题50. 第一个只出现一次的字符</a></li></ul></li><li>简单（31）<ul><li><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></li><li><a href="https://leetcode-cn.com/problems/count-primes/" target="_blank" rel="noopener">204. 计数质数</a></li><li><a href="https://leetcode-cn.com/problems/isomorphic-strings/" target="_blank" rel="noopener">205. 同构字符串</a></li><li><a href="https://leetcode-cn.com/problems/contains-duplicate/" target="_blank" rel="noopener">217. 存在重复元素</a></li><li><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">219. 存在重复元素 II</a></li><li><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">242. 有效的字母异位词</a></li><li><a href="https://leetcode-cn.com/problems/word-pattern/" target="_blank" rel="noopener">290. 单词规律</a></li><li><a href="https://leetcode-cn.com/problems/bulls-and-cows/" target="_blank" rel="noopener">299. 猜数字游戏</a></li><li><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">349. 两个数组的交集</a></li><li><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">350. 两个数组的交集 II</a></li><li><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">387. 字符串中的第一个唯一字符</a></li><li><a href="https://leetcode-cn.com/problems/longest-palindrome/" target="_blank" rel="noopener">409. 最长回文串</a></li><li><a href="https://leetcode-cn.com/problems/number-of-boomerangs/" target="_blank" rel="noopener">447. 回旋镖的数量</a></li><li><a href="https://leetcode-cn.com/problems/island-perimeter/" target="_blank" rel="noopener">463. 岛屿的周长</a></li><li><a href="https://leetcode-cn.com/problems/keyboard-row/" target="_blank" rel="noopener">500. 键盘行</a></li><li><a href="https://leetcode-cn.com/problems/distribute-candies/" target="_blank" rel="noopener">575. 分糖果</a></li><li><a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/" target="_blank" rel="noopener">594. 最长和谐子序列</a></li><li><a href="https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/" target="_blank" rel="noopener">599. 两个列表的最小索引总和</a></li><li><a href="https://leetcode-cn.com/problems/set-mismatch/" target="_blank" rel="noopener">645. 错误的集合</a></li><li><a href="https://leetcode-cn.com/problems/shortest-completing-word/" target="_blank" rel="noopener">748. 最短完整词</a></li><li><a href="https://leetcode-cn.com/problems/find-anagram-mappings/" target="_blank" rel="noopener">760. 找出变位映射</a></li><li><a href="https://leetcode-cn.com/problems/jewels-and-stones/" target="_blank" rel="noopener">771. 宝石与石头</a></li><li><a href="https://leetcode-cn.com/problems/subdomain-visit-count/" target="_blank" rel="noopener">811. 子域名访问计数</a></li><li><a href="https://leetcode-cn.com/problems/uncommon-words-from-two-sentences/" target="_blank" rel="noopener">884. 两句话中的不常见单词</a></li><li><a href="https://leetcode-cn.com/problems/verifying-an-alien-dictionary/" target="_blank" rel="noopener">953. 验证外星语词典</a></li><li><a href="https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array/" target="_blank" rel="noopener">961. 重复 N 次的元素</a></li><li><a href="https://leetcode-cn.com/problems/find-common-characters/" target="_blank" rel="noopener">1002. 查找常用字符</a></li><li><a href="https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/" target="_blank" rel="noopener">1160. 拼写单词</a></li><li><a href="https://leetcode-cn.com/problems/maximum-number-of-balloons/" target="_blank" rel="noopener">1189. “气球” 的最大数量</a></li><li><a href="https://leetcode-cn.com/problems/unique-number-of-occurrences/" target="_blank" rel="noopener">1207. 独一无二的出现次数</a></li><li><a href="https://leetcode-cn.com/problems/intersection-of-three-sorted-arrays/" target="_blank" rel="noopener">1213. 三个有序数组的交集</a></li></ul></li><li>中等（9）<ul><li><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></li><li><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a></li><li><a href="https://leetcode-cn.com/problems/valid-sudoku/" target="_blank" rel="noopener">36. 有效的数独</a></li><li><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">49. 字母异位词分组</a></li><li><a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1/" target="_blank" rel="noopener">380. 常数时间插入、删除和获取随机元素</a></li><li><a href="https://leetcode-cn.com/problems/4sum-ii/" target="_blank" rel="noopener">454. 四数相加 II</a></li><li><a href="https://leetcode-cn.com/problems/contiguous-array/" target="_blank" rel="noopener">525. 连续数组</a></li><li><a href="https://leetcode-cn.com/problems/encode-and-decode-tinyurl/" target="_blank" rel="noopener">535. TinyURL 的加密与解密</a></li><li><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. 和为K的子数组</a></li></ul></li><li>困难（5）<ul><li><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/" target="_blank" rel="noopener">30. 串联所有单词的子串</a></li><li><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a></li><li><a href="https://leetcode-cn.com/problems/max-points-on-a-line/" target="_blank" rel="noopener">149. 直线上最多的点数</a></li><li><a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed/" target="_blank" rel="noopener">381. O(1) 时间插入、删除和获取随机元素 - 允许重复</a></li><li><a href="https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/" target="_blank" rel="noopener">632. 最小区间</a></li></ul></li></ul><h4 id="③相关博客-5"><a href="#③相关博客-5" class="headerlink" title="③相关博客"></a>③相关博客</h4><ul><li>Java 集合的用法</li></ul><hr><h3 id="10-二分查找"><a href="#10-二分查找" class="headerlink" title="10.二分查找"></a>10.二分查找</h3><h4 id="①知识点整理-6"><a href="#①知识点整理-6" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><h4 id="②LeetCode-必刷题目（31）"><a href="#②LeetCode-必刷题目（31）" class="headerlink" title="②LeetCode 必刷题目（31）"></a>②LeetCode 必刷题目（31）</h4><ul><li>剑指 Offer（4）<ul><li><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">面试题11. 旋转数组的最小数字</a></li><li><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">面试题16. 数值的整数次方</a></li><li><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank" rel="noopener">面试题53 - I. 在排序数组中查找数字 I</a></li><li><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题53 - II. 0～n-1中缺失的数字</a> </li></ul></li><li>简单（13）<ul><li><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a></li><li><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">69. x 的平方根</a></li><li><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a></li><li><a href="https://leetcode-cn.com/problems/first-bad-version/" target="_blank" rel="noopener">278. 第一个错误的版本</a></li><li><a href="https://leetcode-cn.com/problems/valid-perfect-square/" target="_blank" rel="noopener">367. 有效的完全平方数</a></li><li><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/" target="_blank" rel="noopener">374. 猜数字大小</a></li><li><a href="https://leetcode-cn.com/problems/arranging-coins/" target="_blank" rel="noopener">441. 排列硬币</a></li><li><a href="https://leetcode-cn.com/problems/heaters/" target="_blank" rel="noopener">475. 供暖器</a></li><li><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找</a></li><li><a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/" target="_blank" rel="noopener">744. 寻找比目标字母大的最小字母</a></li><li><a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/" target="_blank" rel="noopener">852. 山脉数组的峰顶索引</a></li><li><a href="https://leetcode-cn.com/problems/fixed-point/" target="_blank" rel="noopener">1064. 不动点</a></li><li><a href="https://leetcode-cn.com/problems/check-if-a-number-is-majority-element-in-a-sorted-array/" target="_blank" rel="noopener">1150. 检查一个数是否在数组中占绝大多数</a></li></ul></li><li>中等（12）<ul><li><a href="https://leetcode-cn.com/problems/divide-two-integers/" target="_blank" rel="noopener">29. 两数相除</a></li><li><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></li><li><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></li><li><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></li><li><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">74. 搜索二维矩阵</a></li><li><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. 搜索旋转排序数组 II</a></li><li><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></li><li><a href="https://leetcode-cn.com/problems/find-peak-element/" target="_blank" rel="noopener">162. 寻找峰值</a></li><li><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">209. 长度最小的子数组</a></li><li><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">287. 寻找重复数</a></li><li><a href="https://leetcode-cn.com/problems/find-right-interval/" target="_blank" rel="noopener">436. 寻找右区间</a></li><li><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener">718. 最长重复子数组</a></li></ul></li><li>困难（2）<ul><li><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. 寻找旋转排序数组中的最小值 II</a></li><li><a href="https://leetcode-cn.com/problems/kth-smallest-number-in-multiplication-table/" target="_blank" rel="noopener">668. 乘法表中第k小的数</a></li></ul></li></ul><h4 id="③相关博客-6"><a href="#③相关博客-6" class="headerlink" title="③相关博客"></a>③相关博客</h4><ul><li><a href="https://messi1002.top/2019/01/05/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/">二分查找法代码实现</a></li><li><a href="https://messi1002.top/2019/01/04/LeetCode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%EF%BC%88Easy%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/">35.搜索插入位置（Easy）Java语言题解</a></li><li><a href="https://messi1002.top/2019/01/04/LeetCode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%EF%BC%88Easy%EF%BC%89C%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/">35.搜索插入位置（Easy）C语言题解</a></li><li><a href="https://mp.weixin.qq.com/s/AlUZ8i6zqap6XIMvgTVO2w" target="_blank" rel="noopener">你真的会写二分查找吗？</a></li></ul><hr><h3 id="11-贪心算法"><a href="#11-贪心算法" class="headerlink" title="11.贪心算法"></a>11.贪心算法</h3><h4 id="①知识点整理-7"><a href="#①知识点整理-7" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><h4 id="②LeetCode-必刷题目（13）"><a href="#②LeetCode-必刷题目（13）" class="headerlink" title="②LeetCode 必刷题目（13）"></a>②LeetCode 必刷题目（13）</h4><ul><li>简单（2）<ul><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a></li><li><a href="https://leetcode-cn.com/problems/assign-cookies/" target="_blank" rel="noopener">455. 分发饼干</a></li></ul></li><li>中等（8）<ul><li><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></li><li><a href="https://leetcode-cn.com/problems/gas-station/" target="_blank" rel="noopener">134. 加油站</a></li><li><a href="https://leetcode-cn.com/problems/remove-k-digits/" target="_blank" rel="noopener">402. 移掉K位数字</a></li><li><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/" target="_blank" rel="noopener">406. 根据身高重建队列</a></li><li><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener">452. 用最少数量的箭引爆气球</a></li><li><a href="https://leetcode-cn.com/problems/task-scheduler/" target="_blank" rel="noopener">621. 任务调度器</a></li><li><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/" target="_blank" rel="noopener">738. 单调递增的数字</a></li><li><a href="https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/" target="_blank" rel="noopener">921. 使括号有效的最少添加</a></li></ul></li><li>困难（3）<ul><li><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II</a></li><li><a href="https://leetcode-cn.com/problems/candy/" target="_blank" rel="noopener">135. 分发糖果</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/" target="_blank" rel="noopener">316. 去除重复字母</a></li></ul></li></ul><h4 id="③相关博客-7"><a href="#③相关博客-7" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="12-双指针（滑动窗口）"><a href="#12-双指针（滑动窗口）" class="headerlink" title="12.双指针（滑动窗口）"></a>12.双指针（滑动窗口）</h3><h4 id="①知识点整理-8"><a href="#①知识点整理-8" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li>滑动窗口</li></ul><h4 id="②LeetCode-必刷题目（26）"><a href="#②LeetCode-必刷题目（26）" class="headerlink" title="②LeetCode 必刷题目（26）"></a>②LeetCode 必刷题目（26）</h4><ul><li>剑指 Offer（4）<ul><li><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">面试题04. 二维数组中的查找</a></li><li><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">面试题48. 最长不含重复字符的子字符串</a></li><li><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/" target="_blank" rel="noopener">面试题57. 和为s的两个数字</a></li><li><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" target="_blank" rel="noopener">面试题57 - II. 和为s的连续正数序列</a></li></ul></li><li>简单（13）<ul><li><a href="https://leetcode-cn.com/problems/sorted-merge-lcci/" target="_blank" rel="noopener">面试题 10.01. 合并排序的数组</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除排序数组中的重复项</a></li><li><a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="noopener">27. 移除元素</a></li><li><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">28. 实现 strStr()</a></li><li><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">88. 合并两个有序数组</a></li><li><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">125. 验证回文串</a></li><li><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">283. 移动零</a></li><li><a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">344. 反转字符串</a></li><li><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="noopener">345. 反转字符串中的元音字母</a></li><li><a href="https://leetcode-cn.com/problems/k-diff-pairs-in-an-array/" target="_blank" rel="noopener">532. 数组中的K-diff数对</a></li><li><a href="https://leetcode-cn.com/problems/long-pressed-name/" target="_blank" rel="noopener">925. 长按键入</a></li><li><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/" target="_blank" rel="noopener">977. 有序数组的平方</a></li><li><a href="https://leetcode-cn.com/problems/diet-plan-performance/" target="_blank" rel="noopener">1176. 健身计划评估</a></li></ul></li><li>中等（9）<ul><li><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a></li><li><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></li><li><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">16. 最接近的三数之和</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/" target="_blank" rel="noopener">80. 删除排序数组中的重复项 II</a></li><li><a href="https://leetcode-cn.com/problems/3sum-smaller/" target="_blank" rel="noopener">259. 较小的三数之和</a></li><li><a href="https://leetcode-cn.com/problems/sort-transformed-array/" target="_blank" rel="noopener">360. 有序转化数组</a></li><li><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/" target="_blank" rel="noopener">424. 替换后的最长重复字符</a></li><li><a href="https://leetcode-cn.com/problems/permutation-in-string/" target="_blank" rel="noopener">567. 字符串的排列</a></li><li><a href="https://leetcode-cn.com/problems/subarray-product-less-than-k/" target="_blank" rel="noopener">713. 乘积小于K的子数组</a></li></ul></li></ul><h4 id="③相关博客-8"><a href="#③相关博客-8" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="13-栈"><a href="#13-栈" class="headerlink" title="13.栈"></a>13.栈</h3><h4 id="①知识点整理-9"><a href="#①知识点整理-9" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li><a href="https://blog.csdn.net/K346K346/article/details/80849966" target="_blank" rel="noopener">堆与栈的区别</a></li><li>栈的时间复杂度、空间复杂度</li><li>栈的应用场景</li></ul><h4 id="②LeetCode-必刷题目（25）"><a href="#②LeetCode-必刷题目（25）" class="headerlink" title="②LeetCode 必刷题目（25）"></a>②LeetCode 必刷题目（25）</h4><ul><li>剑指 Offer（3）<ul><li><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">面试题09. 用两个栈实现队列</a></li><li><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank" rel="noopener">面试题30. 包含min函数的栈</a></li><li><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">面试题31. 栈的压入、弹出序列</a></li></ul></li><li>简单（9）<ul><li><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></li><li><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a> </li><li><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">225. 用队列实现栈</a></li><li><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232. 用栈实现队列</a></li><li><a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">496. 下一个更大元素 I</a></li><li><a href="https://leetcode-cn.com/problems/baseball-game/" target="_blank" rel="noopener">682. 棒球比赛</a></li><li><a href="https://leetcode-cn.com/problems/backspace-string-compare/" target="_blank" rel="noopener">844. 比较含退格的字符串</a></li><li><a href="https://leetcode-cn.com/problems/remove-outermost-parentheses/" target="_blank" rel="noopener">1021. 删除最外层的括号</a></li><li><a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/" target="_blank" rel="noopener">1047. 删除字符串中的所有相邻重复项</a></li></ul></li><li>中等（7）<ul><li><a href="https://leetcode-cn.com/problems/simplify-path/" target="_blank" rel="noopener">71. 简化路径</a></li><li><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">150. 逆波兰表达式求值</a></li><li><a href="https://leetcode-cn.com/problems/mini-parser/" target="_blank" rel="noopener">385. 迷你语法分析器</a></li><li><a href="https://leetcode-cn.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">503. 下一个更大元素 II</a></li><li><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">739. 每日温度</a></li><li><a href="https://leetcode-cn.com/problems/score-of-parentheses/" target="_blank" rel="noopener">856. 括号的分数</a></li><li><a href="https://leetcode-cn.com/problems/validate-stack-sequences/" target="_blank" rel="noopener">946. 验证栈序列</a></li></ul></li><li>困难（6）<ul><li><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水</a></li><li><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a> </li><li><a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">85. 最大矩形</a></li><li><a href="https://leetcode-cn.com/problems/basic-calculator/" target="_blank" rel="noopener">224. 基本计算器</a></li><li><a href="https://leetcode-cn.com/problems/tag-validator/" target="_blank" rel="noopener">591. 标签验证器</a></li><li><a href="https://leetcode-cn.com/problems/number-of-atoms/" target="_blank" rel="noopener">726. 原子的数量</a></li></ul></li></ul><h4 id="③相关博客-9"><a href="#③相关博客-9" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="14-回溯算法"><a href="#14-回溯算法" class="headerlink" title="14.回溯算法"></a>14.回溯算法</h3><h4 id="①知识点整理-10"><a href="#①知识点整理-10" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><h4 id="②LeetCode-必刷题目（23）"><a href="#②LeetCode-必刷题目（23）" class="headerlink" title="②LeetCode 必刷题目（23）"></a>②LeetCode 必刷题目（23）</h4><ul><li>剑指 Offer（1）<ul><li><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">面试题38. 字符串的排列</a> </li></ul></li><li>简单（2）<ul><li><a href="https://leetcode-cn.com/problems/binary-watch/" target="_blank" rel="noopener">401. 二进制手表</a></li><li><a href="https://leetcode-cn.com/problems/letter-case-permutation/" target="_blank" rel="noopener">784. 字母大小写全排列</a></li></ul></li><li>中等（17）<ul><li><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a></li><li><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a></li><li><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和</a></li><li><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II</a></li><li><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></li><li><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">47. 全排列 II</a></li><li><a href="https://leetcode-cn.com/problems/permutation-sequence/" target="_blank" rel="noopener">60. 第k个排列</a></li><li><a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">77. 组合</a></li><li><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a></li><li><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">79. 单词搜索</a></li><li><a href="https://leetcode-cn.com/problems/gray-code/" target="_blank" rel="noopener">89. 格雷编码</a></li><li><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">90. 子集 II</a></li><li><a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">93. 复原IP地址</a></li><li><a href="https://leetcode-cn.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">131. 分割回文串</a></li><li><a href="https://leetcode-cn.com/problems/combination-sum-iii/" target="_blank" rel="noopener">216. 组合总和 III</a></li><li><a href="https://leetcode-cn.com/problems/additive-number/" target="_blank" rel="noopener">306. 累加数</a></li><li><a href="https://leetcode-cn.com/problems/beautiful-arrangement/" target="_blank" rel="noopener">526. 优美的排列</a></li></ul></li><li>困难（3）<ul><li><a href="https://leetcode-cn.com/problems/sudoku-solver/" target="_blank" rel="noopener">37. 解数独</a></li><li><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">51. N皇后</a></li><li><a href="https://leetcode-cn.com/problems/n-queens-ii/" target="_blank" rel="noopener">52. N皇后 II</a></li></ul></li></ul><h4 id="③相关博客-10"><a href="#③相关博客-10" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="15-设计"><a href="#15-设计" class="headerlink" title="15.设计"></a>15.设计</h3><h4 id="①知识点整理-11"><a href="#①知识点整理-11" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><h4 id="②LeetCode-必刷题目（21）"><a href="#②LeetCode-必刷题目（21）" class="headerlink" title="②LeetCode 必刷题目（21）"></a>②LeetCode 必刷题目（21）</h4><ul><li>剑指 Offer（2）<ul><li><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题37. 序列化二叉树</a></li><li><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">面试题41. 数据流中的中位数</a></li></ul></li><li>简单（6）<ul><li><a href="https://leetcode-cn.com/problems/two-sum-iii-data-structure-design/" target="_blank" rel="noopener">170. 两数之和 III - 数据结构设计</a></li><li><a href="https://leetcode-cn.com/problems/logger-rate-limiter/" target="_blank" rel="noopener">359. 日志速率限制器</a></li><li><a href="https://leetcode-cn.com/problems/design-compressed-string-iterator/" target="_blank" rel="noopener">604. 迭代压缩字符串</a></li><li><a href="https://leetcode-cn.com/problems/design-hashset/" target="_blank" rel="noopener">705. 设计哈希集合</a></li><li><a href="https://leetcode-cn.com/problems/design-hashmap/" target="_blank" rel="noopener">706. 设计哈希映射</a></li><li><a href="https://leetcode-cn.com/problems/max-stack/" target="_blank" rel="noopener">716. 最大栈</a></li></ul></li><li>中等（9）<ul><li><a href="https://leetcode-cn.com/problems/lru-cache-lcci/" target="_blank" rel="noopener">面试题 16.25. LRU缓存</a></li><li><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU缓存机制</a></li><li><a href="https://leetcode-cn.com/problems/binary-search-tree-iterator/" target="_blank" rel="noopener">173. 二叉搜索树迭代器</a></li><li><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">208. 实现 Trie (前缀树)</a></li><li><a href="https://leetcode-cn.com/problems/add-and-search-word-data-structure-design/" target="_blank" rel="noopener">211. 添加与搜索单词 - 数据结构设计</a></li><li><a href="https://leetcode-cn.com/problems/peeking-iterator/" target="_blank" rel="noopener">284. 顶端迭代器</a></li><li><a href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/" target="_blank" rel="noopener">341. 扁平化嵌套列表迭代器</a></li><li><a href="https://leetcode-cn.com/problems/design-twitter/" target="_blank" rel="noopener">355. 设计推特</a></li><li><a href="https://leetcode-cn.com/problems/design-linked-list/" target="_blank" rel="noopener">707. 设计链表</a></li></ul></li><li>困难（4）<ul><li><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">295. 数据流的中位数</a></li><li><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">297. 二叉树的序列化与反序列化</a></li><li><a href="https://leetcode-cn.com/problems/all-oone-data-structure/" target="_blank" rel="noopener">432. 全 O(1) 的数据结构</a></li><li><a href="https://leetcode-cn.com/problems/lfu-cache/" target="_blank" rel="noopener">460. LFU缓存</a></li></ul></li></ul><h4 id="③相关博客-11"><a href="#③相关博客-11" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="16-位运算"><a href="#16-位运算" class="headerlink" title="16.位运算"></a>16.位运算</h3><h4 id="①知识点整理-12"><a href="#①知识点整理-12" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li>进制转换</li><li>运算符</li></ul><h4 id="②LeetCode-必刷题目（26）-1"><a href="#②LeetCode-必刷题目（26）-1" class="headerlink" title="②LeetCode 必刷题目（26）"></a>②LeetCode 必刷题目（26）</h4><ul><li>剑指 Offer（4）<ul><li><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">面试题15. 二进制中1的个数</a></li><li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">面试题56 - I. 数组中数字出现的次数</a></li><li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank" rel="noopener">面试题56 - II. 数组中数字出现的次数 II</a></li><li><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" target="_blank" rel="noopener">面试题65. 不用加减乘除做加法</a></li></ul></li><li>简单（14）<ul><li><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. 只出现一次的数字</a></li><li><a href="https://leetcode-cn.com/problems/reverse-bits/" target="_blank" rel="noopener">190. 颠倒二进制位</a></li><li><a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">191. 位1的个数</a></li><li><a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="noopener">231. 2的幂</a></li><li><a href="https://leetcode-cn.com/problems/missing-number/" target="_blank" rel="noopener">268. 缺失数字</a></li><li><a href="https://leetcode-cn.com/problems/power-of-four/" target="_blank" rel="noopener">342. 4的幂</a></li><li><a href="https://leetcode-cn.com/problems/sum-of-two-integers/" target="_blank" rel="noopener">371. 两整数之和</a></li><li><a href="https://leetcode-cn.com/problems/find-the-difference/" target="_blank" rel="noopener">389. 找不同</a></li><li><a href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/" target="_blank" rel="noopener">405. 数字转换为十六进制数</a></li><li><a href="https://leetcode-cn.com/problems/hamming-distance/" target="_blank" rel="noopener">461. 汉明距离</a></li><li><a href="https://leetcode-cn.com/problems/number-complement/" target="_blank" rel="noopener">476. 数字的补数</a></li><li><a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/" target="_blank" rel="noopener">693. 交替位二进制数</a></li><li><a href="https://leetcode-cn.com/problems/prime-number-of-set-bits-in-binary-representation/" target="_blank" rel="noopener">762. 二进制表示中质数个计算置位</a></li><li><a href="https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/" target="_blank" rel="noopener">1290. 二进制链表转整数</a></li></ul></li><li>中等（8）<ul><li><a href="https://leetcode-cn.com/problems/single-number-ii/" target="_blank" rel="noopener">137. 只出现一次的数字 II</a></li><li><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/" target="_blank" rel="noopener">187. 重复的DNA序列</a></li><li><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/" target="_blank" rel="noopener">201. 数字范围按位与</a></li><li><a href="https://leetcode-cn.com/problems/single-number-iii/" target="_blank" rel="noopener">260. 只出现一次的数字 III</a></li><li><a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/" target="_blank" rel="noopener">318. 最大单词长度乘积</a></li><li><a href="https://leetcode-cn.com/problems/utf-8-validation/" target="_blank" rel="noopener">393. UTF-8 编码验证</a></li><li><a href="https://leetcode-cn.com/problems/integer-replacement/" target="_blank" rel="noopener">397. 整数替换</a></li><li><a href="https://leetcode-cn.com/problems/total-hamming-distance/" target="_blank" rel="noopener">477. 汉明距离总和</a></li></ul></li></ul><h4 id="③相关博客-12"><a href="#③相关博客-12" class="headerlink" title="③相关博客"></a>③相关博客</h4><ul><li><a href="https://messi1002.top/2018/09/20/Java%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%8F%8A%E4%BD%8D%E8%BF%90%E7%AE%97/">Java进制转换及位运算</a></li></ul><hr><h3 id="17-排序"><a href="#17-排序" class="headerlink" title="17.排序"></a>17.排序</h3><h4 id="①知识点整理-13"><a href="#①知识点整理-13" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li>比较排序<ul><li>交换排序类：简单交换排序、冒泡排序、快速排序 </li><li>选择排序类：简单选择排序、堆排序 </li><li>插入排序类：直接插入排序、希尔排序 </li><li>归并排序类：归并排序 </li></ul></li><li>非比较排序<ul><li>计数排序</li><li>桶排序</li><li>基数排序 </li></ul></li></ul><h4 id="②LeetCode-必刷题目（21）-1"><a href="#②LeetCode-必刷题目（21）-1" class="headerlink" title="②LeetCode 必刷题目（21）"></a>②LeetCode 必刷题目（21）</h4><ul><li>剑指 Offer（3）<ul><li><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener">面试题45. 把数组排成最小的数</a></li><li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">面试题51. 数组中的逆序对</a></li><li><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/" target="_blank" rel="noopener">面试题61. 扑克牌中的顺子</a></li></ul></li><li>简单（3）<ul><li><a href="https://leetcode-cn.com/problems/meeting-rooms/" target="_blank" rel="noopener">252. 会议室</a></li><li><a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/" target="_blank" rel="noopener">922. 按奇偶排序数组 II</a></li><li><a href="https://leetcode-cn.com/problems/largest-perimeter-triangle/" target="_blank" rel="noopener">976. 三角形的最大周长</a></li></ul></li><li>中等（11）<ul><li><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56. 合并区间</a></li><li><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">75. 颜色分类</a></li><li><a href="https://leetcode-cn.com/problems/insertion-sort-list/" target="_blank" rel="noopener">147. 对链表进行插入排序</a></li><li><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">148. 排序链表</a></li><li><a href="https://leetcode-cn.com/problems/largest-number/" target="_blank" rel="noopener">179. 最大数</a></li><li><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">220. 存在重复元素 III</a></li><li><a href="https://leetcode-cn.com/problems/h-index/" target="_blank" rel="noopener">274. H 指数</a></li><li><a href="https://leetcode-cn.com/problems/wiggle-sort/" target="_blank" rel="noopener">280. 摆动排序</a></li><li><a href="https://leetcode-cn.com/problems/wiggle-sort-ii/" target="_blank" rel="noopener">324. 摆动排序 II</a></li><li><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/" target="_blank" rel="noopener">524. 通过删除字母匹配到字典里最长单词</a></li><li><a href="https://leetcode-cn.com/problems/pancake-sorting/" target="_blank" rel="noopener">969. 煎饼排序</a></li></ul></li><li>困难（4）<ul><li><a href="https://leetcode-cn.com/problems/insert-interval/" target="_blank" rel="noopener">57. 插入区间</a></li><li><a href="https://leetcode-cn.com/problems/maximum-gap/" target="_blank" rel="noopener">164. 最大间距</a></li><li><a href="https://leetcode-cn.com/problems/best-meeting-point/" target="_blank" rel="noopener">296. 最佳的碰头地点</a></li><li><a href="https://leetcode-cn.com/problems/word-abbreviation/" target="_blank" rel="noopener">527. 单词缩写</a></li></ul></li></ul><h4 id="③相关博客-13"><a href="#③相关博客-13" class="headerlink" title="③相关博客"></a>③相关博客</h4><ul><li><a href="https://messi1002.top/2020/02/12/%E5%85%AB%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">八种排序算法的总结及性能分析</a></li><li><a href="https://mp.weixin.qq.com/s/teOGQlslb6aP4AQrx7TTzA" target="_blank" rel="noopener">漫画：“排序算法” 大总结</a></li><li><a href="https://mp.weixin.qq.com/s/l13mNfGZgCaUKLDgh3Jddw" target="_blank" rel="noopener">面试时写不出排序算法？看这篇就够了</a></li></ul><hr><h3 id="18-链表"><a href="#18-链表" class="headerlink" title="18.链表"></a>18.链表</h3><h4 id="①知识点整理-14"><a href="#①知识点整理-14" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li>单链表和双链表的区别及应用场景</li><li>链表和数组的区别</li><li>用数组实现循环链表</li></ul><h4 id="②LeetCode-必刷题目（31）-1"><a href="#②LeetCode-必刷题目（31）-1" class="headerlink" title="②LeetCode 必刷题目（31）"></a>②LeetCode 必刷题目（31）</h4><ul><li>剑指 Offer（7）<ul><li><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">面试题06. 从尾到头打印链表</a></li><li><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/" target="_blank" rel="noopener">面试题18. 删除链表的节点</a></li><li><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">面试题22. 链表中倒数第k个节点</a></li><li><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">面试题24. 反转链表</a></li><li><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/" target="_blank" rel="noopener">面试题25. 合并两个排序的链表</a></li><li><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">面试题35. 复杂链表的复制</a></li><li><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" target="_blank" rel="noopener">面试题52. 两个链表的第一个公共节点</a></li></ul></li><li>简单（9）<ul><li><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">83. 删除排序链表中的重复元素</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表</a></li><li><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160. 相交链表</a></li><li><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">203. 移除链表元素</a></li><li><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></li><li><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. 回文链表</a></li><li><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">237. 删除链表中的节点</a></li><li><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">876. 链表的中间结点</a></li></ul></li><li>中等（14）<ul><li><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">2. 两数相加</a></li><li><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. 删除链表的倒数第N个节点</a></li><li><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. 两两交换链表中的节点</a></li><li><a href="https://leetcode-cn.com/problems/rotate-list/" target="_blank" rel="noopener">61. 旋转链表</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">82. 删除排序链表中的重复元素 II</a></li><li><a href="https://leetcode-cn.com/problems/partition-list/" target="_blank" rel="noopener">86. 分隔链表</a></li><li><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. 反转链表 II</a></li><li><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">138. 复制带随机指针的链表</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II</a></li><li><a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">143. 重排链表</a></li><li><a href="https://leetcode-cn.com/problems/odd-even-linked-list/" target="_blank" rel="noopener">328. 奇偶链表</a></li><li><a href="https://leetcode-cn.com/problems/plus-one-linked-list/" target="_blank" rel="noopener">369. 给单链表加一</a></li><li><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener">445. 两数相加 II</a></li><li><a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/" target="_blank" rel="noopener">725. 分隔链表</a></li></ul></li><li>困难（1）<ul><li><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25. K 个一组翻转链表</a></li></ul></li></ul><h4 id="③相关博客-14"><a href="#③相关博客-14" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="19-堆"><a href="#19-堆" class="headerlink" title="19.堆"></a>19.堆</h3><h4 id="①知识点整理-15"><a href="#①知识点整理-15" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><h4 id="②LeetCode-必刷题目（11）-1"><a href="#②LeetCode-必刷题目（11）-1" class="headerlink" title="②LeetCode 必刷题目（11）"></a>②LeetCode 必刷题目（11）</h4><ul><li>剑指 Offer（1）<ul><li><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">面试题40. 最小的k个数</a></li></ul></li><li>简单（1）<ul><li><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/" target="_blank" rel="noopener">703. 数据流中的第K大元素</a></li></ul></li><li>中等（7）<ul><li><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">215. 数组中的第K个最大元素</a></li><li><a href="https://leetcode-cn.com/problems/ugly-number-ii/" target="_blank" rel="noopener">264. 丑数 II</a></li><li><a href="https://leetcode-cn.com/problems/super-ugly-number/" target="_blank" rel="noopener">313. 超级丑数</a></li><li><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">347. 前 K 个高频元素</a></li><li><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/" target="_blank" rel="noopener">378. 有序矩阵中第K小的元素</a></li><li><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/" target="_blank" rel="noopener">451. 根据字符出现频率排序</a></li><li><a href="https://leetcode-cn.com/problems/k-closest-points-to-origin/" target="_blank" rel="noopener">973. 最接近原点的 K 个点</a></li></ul></li><li>困难（2）<ul><li><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并K个排序链表</a></li><li><a href="https://leetcode-cn.com/problems/trapping-rain-water-ii/" target="_blank" rel="noopener">407. 接雨水 II</a></li></ul></li></ul><h4 id="③相关博客-15"><a href="#③相关博客-15" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="20-分治算法"><a href="#20-分治算法" class="headerlink" title="20.分治算法"></a>20.分治算法</h3><h4 id="①知识点整理-16"><a href="#①知识点整理-16" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><h4 id="②LeetCode-必刷题目（11）-2"><a href="#②LeetCode-必刷题目（11）-2" class="headerlink" title="②LeetCode 必刷题目（11）"></a>②LeetCode 必刷题目（11）</h4><ul><li>剑指 Offer（3）<ul><li><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">面试题36. 二叉搜索树与双向链表</a></li><li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题39. 数组中出现次数超过一半的数字</a></li><li><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">面试题42. 连续子数组的最大和</a></li></ul></li><li>简单（2）<ul><li><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></li><li><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">169. 多数元素</a></li></ul></li><li>中等（2）<ul><li><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">240. 搜索二维矩阵 II</a></li><li><a href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/" target="_blank" rel="noopener">241. 为运算表达式设计优先级</a></li></ul></li><li>困难（4）<ul><li><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个正序数组的中位数</a></li><li><a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">312. 戳气球</a></li><li><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">315. 计算右侧小于当前元素的个数</a></li><li><a href="https://leetcode-cn.com/problems/count-of-range-sum/" target="_blank" rel="noopener">327. 区间和的个数</a></li></ul></li></ul><h4 id="③相关博客-16"><a href="#③相关博客-16" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="21-递归"><a href="#21-递归" class="headerlink" title="21.递归"></a>21.递归</h3><h4 id="①知识点整理-17"><a href="#①知识点整理-17" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li><a href="https://juejin.im/post/5c14c08ce51d4570e5715581" target="_blank" rel="noopener">常见递归算法的时间复杂度分析</a></li></ul><h4 id="②LeetCode-必刷题目（7）"><a href="#②LeetCode-必刷题目（7）" class="headerlink" title="②LeetCode 必刷题目（7）"></a>②LeetCode 必刷题目（7）</h4><ul><li>剑指 Offer（2）<ul><li><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">面试题10- I. 斐波那契数列</a></li><li><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/comments/" target="_blank" rel="noopener">面试题64. 求1+2+…+n</a></li></ul></li><li>简单（1）<ul><li><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/" target="_blank" rel="noopener">1137. 第 N 个泰波那契数</a></li></ul></li><li>中等（3）<ul><li><a href="https://leetcode-cn.com/problems/strobogrammatic-number-ii/" target="_blank" rel="noopener">247. 中心对称数 II</a></li><li><a href="https://leetcode-cn.com/problems/output-contest-matches/" target="_blank" rel="noopener">544. 输出比赛匹配对</a></li><li><a href="https://leetcode-cn.com/problems/minimum-factorization/" target="_blank" rel="noopener">625. 最小因式分解</a></li></ul></li><li>困难（1）<ul><li><a href="https://leetcode-cn.com/problems/strobogrammatic-number-iii/" target="_blank" rel="noopener">248. 中心对称数 III</a></li></ul></li></ul><h4 id="③相关博客-17"><a href="#③相关博客-17" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="22-字典树"><a href="#22-字典树" class="headerlink" title="22.字典树"></a>22.字典树</h3><h4 id="①知识点整理-18"><a href="#①知识点整理-18" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><h4 id="②LeetCode-必刷题目（8）"><a href="#②LeetCode-必刷题目（8）" class="headerlink" title="②LeetCode 必刷题目（8）"></a>②LeetCode 必刷题目（8）</h4><ul><li>简单（1）<ul><li><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/" target="_blank" rel="noopener">720. 词典中最长的单词</a></li></ul></li><li>中等（5）<ul><li><a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/" target="_blank" rel="noopener">421. 数组中两个数的最大异或值</a></li><li><a href="https://leetcode-cn.com/problems/replace-words/" target="_blank" rel="noopener">648. 单词替换</a></li><li><a href="https://leetcode-cn.com/problems/implement-magic-dictionary/" target="_blank" rel="noopener">676. 实现一个魔法字典</a></li><li><a href="https://leetcode-cn.com/problems/map-sum-pairs/" target="_blank" rel="noopener">677. 键值映射</a></li><li><a href="https://leetcode-cn.com/problems/top-k-frequent-words/" target="_blank" rel="noopener">692. 前K个高频单词</a></li></ul></li><li>困难（2）<ul><li><a href="https://leetcode-cn.com/problems/word-search-ii/" target="_blank" rel="noopener">212. 单词搜索 II</a></li><li><a href="https://leetcode-cn.com/problems/palindrome-pairs/" target="_blank" rel="noopener">336. 回文对</a></li></ul></li></ul><h4 id="③相关博客-18"><a href="#③相关博客-18" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="23-线段树"><a href="#23-线段树" class="headerlink" title="23.线段树"></a>23.线段树</h3><h4 id="①知识点整理-19"><a href="#①知识点整理-19" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><h4 id="②LeetCode-必刷题目（6）"><a href="#②LeetCode-必刷题目（6）" class="headerlink" title="②LeetCode 必刷题目（6）"></a>②LeetCode 必刷题目（6）</h4><ul><li>中等（1）<ul><li><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/" target="_blank" rel="noopener">307. 区域和检索 - 数组可修改</a></li></ul></li><li>困难（5）<ul><li><a href="https://leetcode-cn.com/problems/the-skyline-problem/" target="_blank" rel="noopener">218. 天际线问题</a></li><li><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">315. 计算右侧小于当前元素的个数</a></li><li><a href="https://leetcode-cn.com/problems/count-of-range-sum/" target="_blank" rel="noopener">327. 区间和的个数</a></li><li><a href="https://leetcode-cn.com/problems/reverse-pairs/" target="_blank" rel="noopener">493. 翻转对</a></li><li><a href="https://leetcode-cn.com/problems/my-calendar-iii/" target="_blank" rel="noopener">732. 我的日程安排表 III</a></li></ul></li></ul><h4 id="③相关博客-19"><a href="#③相关博客-19" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="24-队列"><a href="#24-队列" class="headerlink" title="24.队列"></a>24.队列</h3><h4 id="①知识点整理-20"><a href="#①知识点整理-20" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><h4 id="②LeetCode-必刷题目（6）-1"><a href="#②LeetCode-必刷题目（6）-1" class="headerlink" title="②LeetCode 必刷题目（6）"></a>②LeetCode 必刷题目（6）</h4><ul><li>剑指 Offer（2）<ul><li><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">面试题59 - I. 滑动窗口的最大值</a></li><li><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">面试题59 - II. 队列的最大值</a></li></ul></li><li>简单（2）<ul><li><a href="https://leetcode-cn.com/problems/moving-average-from-data-stream/" target="_blank" rel="noopener">346. 数据流中的移动平均值</a></li><li><a href="https://leetcode-cn.com/problems/number-of-recent-calls/" target="_blank" rel="noopener">933. 最近的请求次数</a> </li></ul></li><li>中等（2）<ul><li><a href="https://leetcode-cn.com/problems/design-circular-queue/" target="_blank" rel="noopener">622. 设计循环队列</a></li><li><a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener">641. 设计循环双端队列</a></li></ul></li></ul><h4 id="③相关博客-20"><a href="#③相关博客-20" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="25-红黑树"><a href="#25-红黑树" class="headerlink" title="25.红黑树"></a>25.红黑树</h3><h4 id="①知识点整理-21"><a href="#①知识点整理-21" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li>左旋和右旋怎么做？</li><li>红黑树的时间复杂度</li><li>红黑树和平衡二叉树的区别</li><li>红黑树的应用</li></ul><h4 id="②相关博客"><a href="#②相关博客" class="headerlink" title="②相关博客"></a>②相关博客</h4><ul><li><a href="https://messi1002.top/2020/03/18/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E8%A7%A3/">红黑树详解</a></li><li><a href="https://blog.csdn.net/WantFlyDaCheng/article/details/100078039?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">腾讯面试题：有了二叉查找树、平衡树为啥还需要红黑树？</a></li><li><a href="https://blog.csdn.net/tang_jin2015/article/details/8535670" target="_blank" rel="noopener">红黑树、AVL树、B树的比较</a></li><li><a href="https://blog.csdn.net/ThinkWon/article/details/102571535" target="_blank" rel="noopener">红黑树详细分析(图文详解)，看了都说好</a></li><li><a href="https://blog.csdn.net/hotdust/article/details/73087962" target="_blank" rel="noopener">红黑树和B树应用场景总结</a></li><li><a href="https://riteme.site/blog/2016-3-12/2-3-tree-and-red-black-tree.html" target="_blank" rel="noopener">2-3树与红黑树</a></li><li><a href="https://mp.weixin.qq.com/s/n_kEvLHGMtMhwyuDdo_0-Q" target="_blank" rel="noopener">红黑树，超强动静图详解，简单易懂 </a></li></ul><hr><h3 id="26-海量数据处理"><a href="#26-海量数据处理" class="headerlink" title="26.海量数据处理"></a>26.海量数据处理</h3><hr><h3 id="27-限流算法"><a href="#27-限流算法" class="headerlink" title="27.限流算法"></a>27.限流算法</h3><h4 id="①计数器算法"><a href="#①计数器算法" class="headerlink" title="①计数器算法"></a>①计数器算法</h4><h4 id="②令牌桶算法"><a href="#②令牌桶算法" class="headerlink" title="②令牌桶算法"></a>②令牌桶算法</h4><h4 id="③漏桶算法"><a href="#③漏桶算法" class="headerlink" title="③漏桶算法"></a>③漏桶算法</h4><hr><h3 id="28-查找算法"><a href="#28-查找算法" class="headerlink" title="28.查找算法"></a>28.查找算法</h3><h4 id="①顺序查找"><a href="#①顺序查找" class="headerlink" title="①顺序查找"></a>①顺序查找</h4><h4 id="②二分查找"><a href="#②二分查找" class="headerlink" title="②二分查找"></a>②二分查找</h4><h4 id="③插值查找"><a href="#③插值查找" class="headerlink" title="③插值查找"></a>③插值查找</h4><h4 id="④斐波那契查找"><a href="#④斐波那契查找" class="headerlink" title="④斐波那契查找"></a>④斐波那契查找</h4><h4 id="⑤树表查找"><a href="#⑤树表查找" class="headerlink" title="⑤树表查找"></a>⑤树表查找</h4><h5 id="a-二叉搜索树"><a href="#a-二叉搜索树" class="headerlink" title="a.二叉搜索树"></a>a.二叉搜索树</h5><h5 id="b-平衡查找树之-2-3-Tree"><a href="#b-平衡查找树之-2-3-Tree" class="headerlink" title="b.平衡查找树之 2-3 Tree"></a>b.平衡查找树之 2-3 Tree</h5><h5 id="c-平衡查找树之红黑树"><a href="#c-平衡查找树之红黑树" class="headerlink" title="c.平衡查找树之红黑树"></a>c.平衡查找树之红黑树</h5><h4 id="⑥分块查找"><a href="#⑥分块查找" class="headerlink" title="⑥分块查找"></a>⑥分块查找</h4><h4 id="⑦哈希查找"><a href="#⑦哈希查找" class="headerlink" title="⑦哈希查找"></a>⑦哈希查找</h4><hr><h3 id="29-多线程"><a href="#29-多线程" class="headerlink" title="29.多线程"></a>29.多线程</h3><h4 id="①知识点整理-22"><a href="#①知识点整理-22" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li>实现多线程同步的 ATM 存款取款</li><li>生产者—消费者模型</li><li>设计线程安全的阻塞队列（队列空时消费者阻塞、队列满时生产者阻塞）</li><li>死锁代码示例</li><li>设计一个线程池</li></ul><h4 id="②LeetCode-必刷题目（7）-1"><a href="#②LeetCode-必刷题目（7）-1" class="headerlink" title="②LeetCode 必刷题目（7）"></a>②LeetCode 必刷题目（7）</h4><ul><li>简单（1）<ul><li><a href="https://leetcode-cn.com/problems/print-in-order/" target="_blank" rel="noopener">1114. 按序打印</a></li></ul></li><li>中等（6）<ul><li><a href="https://leetcode-cn.com/problems/print-foobar-alternately/" target="_blank" rel="noopener">1115. 交替打印FooBar</a></li><li><a href="https://leetcode-cn.com/problems/print-zero-even-odd/" target="_blank" rel="noopener">1116. 打印零与奇偶数</a></li><li><a href="https://leetcode-cn.com/problems/building-h2o/" target="_blank" rel="noopener">1117. H2O 生成</a></li><li><a href="https://leetcode-cn.com/problems/design-bounded-blocking-queue/" target="_blank" rel="noopener">1118.设计有限阻塞队列</a></li><li><a href="https://leetcode-cn.com/problems/fizz-buzz-multithreaded/" target="_blank" rel="noopener">1195. 交替打印字符串</a></li><li><a href="https://leetcode-cn.com/problems/the-dining-philosophers/" target="_blank" rel="noopener">1226. 哲学家进餐</a></li></ul></li></ul><h4 id="③相关博客-21"><a href="#③相关博客-21" class="headerlink" title="③相关博客"></a>③相关博客</h4><ul><li><a href="https://messi1002.top/2020/02/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/">Java并发编程之基础概念</a></li><li><a href="https://messi1002.top/2020/02/20/Synchronized%E5%85%B3%E9%94%AE%E5%AD%97/">Synchronized关键字</a></li><li><a href="https://messi1002.top/2020/04/10/finnal%E5%85%B3%E9%94%AE%E5%AD%97/">finnal关键字</a></li><li><a href="https://messi1002.top/2020/04/10/volatile%E5%85%B3%E9%94%AE%E5%AD%97/">volatile关键字</a></li><li><a href="https://messi1002.top/2020/04/10/ReentrantLock%E9%94%81/">ReentrantLock锁</a></li><li><a href="https://messi1002.top/2020/04/03/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/">Java并发编程之线程8大核心基础</a></li><li><a href="https://messi1002.top/2020/04/03/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java并发编程之Java内存模型</a></li><li><a href="https://messi1002.top/2020/04/03/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%AD%BB%E9%94%81%E7%9A%84%E5%89%8D%E7%94%9F%E4%BB%8A%E4%B8%96/">Java并发编程之死锁的前生今世</a></li><li><a href="https://messi1002.top/2020/04/03/Java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%AE%80%E4%BB%8B/">Java并发工具类简介</a></li><li><a href="https://messi1002.top/2020/03/01/LeetCode-1114-%E6%8C%89%E5%BA%8F%E6%89%93%E5%8D%B0%EF%BC%88Easy%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/">[LeetCode] 1114. 按序打印（Easy）Java语言题解</a></li><li><a href="https://messi1002.top/2020/03/01/LeetCode-1115-%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0FooBar%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/">[LeetCode] 1115. 交替打印FooBar（Medium）Java语言题解</a></li><li><a href="https://messi1002.top/2020/03/01/LeetCode-1116-%E6%89%93%E5%8D%B0%E9%9B%B6%E4%B8%8E%E5%A5%87%E5%81%B6%E6%95%B0%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/">[LeetCode] 1116. 打印零与奇偶数（Medium）Java语言题解</a></li><li><a href="https://messi1002.top/2020/03/01/LeetCode-1188-%E8%AE%BE%E8%AE%A1%E6%9C%89%E9%99%90%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/">[LeetCode] 1188. 设计有限阻塞队列（Medium）Java语言题</a></li><li><a href="https://messi1002.top/2020/03/01/LeetCode-1195-%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/">[LeetCode] 1195. 交替打印字符串（Medium）Java语言题解</a></li><li><a href="https://messi1002.top/2020/03/01/LeetCode-1226-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/">[LeetCode] 1226. 哲学家进餐（Medium）Java语言题解</a></li></ul><hr><h3 id="30-智力题"><a href="#30-智力题" class="headerlink" title="30.智力题"></a>30.智力题</h3><ul><li><a href="https://leetcode-cn.com/problems/nim-game/" target="_blank" rel="noopener">292. Nim 游戏</a></li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#119;&#106;&#x79;&#x6d;&#x65;&#115;&#x73;&#x69;&#x40;&#49;&#x36;&#51;&#46;&#99;&#111;&#109;" target="_blank" rel="noopener">&#119;&#106;&#x79;&#x6d;&#x65;&#115;&#x73;&#x69;&#x40;&#49;&#x36;&#51;&#46;&#99;&#111;&#109;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-面经相关&quot;&gt;&lt;a href=&quot;#1-面经相关&quot; class=&quot;headerlink&quot; title=&quot;1.面经相关&quot;&gt;&lt;/a&gt;1.面经相关&lt;/h3&gt;&lt;h4 id=&quot;①相关博客&quot;&gt;&lt;a href=&quot;#①相关博客&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="2020秋招" scheme="http://messi1002.top/categories/2020%E7%A7%8B%E6%8B%9B/"/>
    
      <category term="知识点总结" scheme="http://messi1002.top/categories/2020%E7%A7%8B%E6%8B%9B/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="知识点总结" scheme="http://messi1002.top/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>要怎样努力，才能成为很厉害的人？</title>
    <link href="http://messi1002.top/2020/04/15/%E8%A6%81%E6%80%8E%E6%A0%B7%E5%8A%AA%E5%8A%9B%EF%BC%8C%E6%89%8D%E8%83%BD%E6%88%90%E4%B8%BA%E5%BE%88%E5%8E%89%E5%AE%B3%E7%9A%84%E4%BA%BA%EF%BC%9F/"/>
    <id>http://messi1002.top/2020/04/15/要怎样努力，才能成为很厉害的人？/</id>
    <published>2020-04-15T12:35:15.000Z</published>
    <updated>2020-06-08T13:14:24.988Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Q"><a href="#1-Q" class="headerlink" title="1.Q"></a>1.Q</h3><p>转自：<a href="https://www.zhihu.com/question/22921426" target="_blank" rel="noopener">https://www.zhihu.com/question/22921426</a></p><p>「怎样才是很厉害的人？」<br>「自然是 有好看的身材以及容颜 被很多人喜欢 有很多厉害又有趣的朋友 有对的人 嘻嘻哈哈打打闹闹笑笑人生」</p><p>详见：<a href="https://www.zhihu.com/question/22897987/answer/23051749" target="_blank" rel="noopener">你身上发生过什么事情让你觉得上天特别不公平，你是如何面对的？</a></p><p>题主想兑现一个承诺<br>努力了4年 心如死灰</p><p>2014.3.7补充<br>虽然不想说 不过好像有点儿表达不清</p><p>题主是男生 目前在景色优美的某大学念书<br>题主以前很喜欢一个女生 刚好女生也很喜欢题主 所谓真命天女好像就是那样子<br>在一起 甜蜜又青涩 题主觉得自己是被她所成就的</p><p>后来发生不幸的事情 女生去了另外一个世界<br>过了好久 我才回神过来 整个人都不好了<br>后来做了个梦 梦里面题主答应女生 要找到比她更漂亮更有趣的女朋友<br>题主想成为很厉害很厉害的人</p><p>就是这样的故事 告诉了一些亲近之人<br>题主其实很糟糕 不懂如何与人相处 酷到没朋友<br>一生别扭 孩子气 喜欢看热血漫 所以即使大大的颓唐仍然固执的想看到希望<br>一直很努力 一直不认输<br>可是 感觉这样下去 什么也改变不了吧</p><p>诚心请教诸君 因为越长越大 已经快不知道 要怎么办了</p><hr><h3 id="2-A"><a href="#2-A" class="headerlink" title="2.A"></a>2.A</h3><p>朱炫<br>闷骚而近妖 微博：大师兄_朱炫<br>收录于 知乎周刊 •张振衣 等 91165 人赞同<br>谢邀</p><p>首先，少年，答应别人的承诺，就一定要兑现。</p><p>我以前啊，和你一样，很想成为一个很厉害很厉害很厉害的人。</p><p>喜欢看热血的东西，幻想自己是屠龙的勇士，登塔的先锋，我左手有剑，右手有光，没头没脑的燃烧自己，敌人的骑军来了，我说你们何人堪与之战，我的女人在等我。</p><p>后来我现实了一点，我觉得我要成为那种说走就走，说日就日的男人，我梳大背头，流浪在欧洲或者新几内亚的，我拍孩子，拍野兽，拍流浪的雏妓，与罗伯特德尼罗握手，说嘿，我给你写了愤怒的公牛2。</p><p>再后来，我觉得我人生的梦想，是在城市中心买上一间顶层公寓，把一整面墙都改造成钢化玻璃，在灯火通明的夜晚，我就要端着酒站在巨大的窗前，看整个城市在呼吸，然后我的朋友叩门，他带来了一打嫩模，我们就玩一些成年人的游戏</p><p>现在，我发现龙并不存在，我不会骑马，不会用单反，家住2楼，我能做的，就是把眼前的事儿做好，赚到足够的钱，这样我可以给我的姑娘一个地球仪，然后用飞镖扎它，扎到哪儿，就去哪儿玩。</p><p>这样看来，虽然我的想法随着生殖器的发育，始终在变，但那个很厉害很厉害的人，一直离我很远，甚至越来越远。</p><p>我心中曾经执剑的少年，此刻也混迹在市井之间。</p><p>血似乎都凉了。</p><p>我也不是没有惶恐过，是不是我这一生，都不能左手持剑，右手握着罗伯特德尼罗，说这里的嫩模随便你玩但是你他妈别从窗户上掉下去。</p><p>这样一看，我逊得不行，我的朋友都是一些凡人，比我还逊，业余生活就是推塔、中单、跪。</p><p>我心想，我是不是这辈子都要做一个逊逼，直到我的坟墓上写好墓志铭，我甚至都想好了：</p><p>我来，我见，我挂了。</p><p>最后我给了自己一个否定的答复，我不要。</p><p>我喜欢我的朋友们，喜欢我现在的生活，首先我希望你明白，没有厉害与逊逼得区分，只有血的凉与热，有的人觉得生活就这样吧，我算了，现在没什么不好。</p><p>有的人觉得生活这样挺好，但是我还要更好。</p><p>这种只要剧情稍微热血一点就会热泪盈眶的傻逼，已经不多了，一刻也不要停留。</p><p>所以现在，我和你不一样了，我仍然想成为一个很厉害很厉害很厉害的人，像我们这种剧情稍微热血一点就会热泪盈眶的傻逼，要好好珍惜自己。</p><p>很多人坐下来了，跟你说你不行，说你省点儿心吧，说你请静一静。</p><p>汹涌的人群就把你这样的少年淹没了，人群散去的时候，你也不见了，你那些承诺，谁也听不见，这个世界对于你，就再不可能有什么更有趣更漂亮的女朋友。</p><p>你就失约了，小逼崽子。</p><p>这么跟你说。</p><p>虽然随着年龄的增长，我趋于现实，不能像你那样分分钟冲动的燃烧，然而我每时每刻都有想做的事，有想达成的目标。</p><p>不排除以后的某一年，我会握着罗伯特德尼罗的手，他说这是你写得吗，愤怒的公牛2，只要他还没死。</p><p>故事里拳王拉莫塔忍着伤，他举着铁拳，挥汗如雨，要和命运斗争，他说我怎么能失约呢，我是那个要成为很厉害很厉害的拳王拉莫塔！</p><p>小伙儿，成为很厉害很厉害的人，最重要的，就是要热血，永远也不要让你的血凉下去，你凉下去了，就再也不能找到一个更有趣更漂亮的女友，你就失约了，于是那天她踏梦而来，就成了一个彻头彻尾的笑话。</p><p>当有一天你成为你讨厌的那种人，浑浑噩噩，你走在街上，看见那些更有趣更漂亮的女孩，你会不会想起多年以前，你说我答应你，在一个承诺就是永远的年纪。</p><p>读书，交友，美容，都不如你这一腔狗血，滚烫，灼人，你要燃上大半辈子，才对得起你现在说的这些话。</p><p>我听闻最美的故事，是公主死去了，屠龙的少年还在燃烧。</p><p>火苗再小，你都要反复的点燃。</p><p>所谓热血的少年，青涩的爱恋，死亡与梦之约。</p><p>这么好的故事。</p><p>你可别演砸了。</p><p>最后我给你点个人建议：</p><p>1.读书，读到倦，网上有很多方法，但你从来沉不下心看。<br>2.学习，学到疼，网上有很多方法，但你从来沉不下心看。<br>3.开口说话，冷场也要说话，脸皮薄也要说话，挨打也要说话。<br>4.如果你现在不知道做什么，至少你还可以先从做一个牛逼的学生开始。<br>5.更漂亮更有趣的女孩，五年以后再找。<br>6.承诺是鞭子，不是兴奋剂。<br>7.年纪大了，也不要说什么心如死灰。</p><p>改变自己是非常，非常，非常痛苦的，我能看出来你一腔热血的优点，自然知道你孤僻懒散自以为是的缺点，方法很多，不过我不确定你吃不吃得了苦，我和你共勉吧。</p><p>在成为最厉害最厉害最厉害的道路上。</p><p>完</p><hr><h3 id="3-我想说的"><a href="#3-我想说的" class="headerlink" title="3.我想说的"></a>3.我想说的</h3><p>2020/4/17：在复习的时候看到了这篇文章，突然很有感触。从去年九月到现在，我好像一直都在急匆匆地赶路，毫无经验，慢慢的耗尽了自己的一腔热血。无论是过去四年的感情，还是期待了很久的春招，都在赶路的过程中离我远去了。留下的，只有迷茫。学习方法的问题，学习内容的取舍，以及自己想要什么样的伴侣，怎样的未来…… </p><p>我尽力面对，试图解决，最后还是一团糟。</p><p>2020/5/15： 我已经很努力很努力地忽略原生家庭的问题，控制自己的情绪，忘记过去，专注学习，可是还是很失败。</p><p>2020/6/2：每时每刻都有想做的事，有想达成的目标。</p><p>2020/6/8：对于生活的一腔热血还在，我相信只要不断努力，生活总会越来越好的，未来也会越来越顺利的。</p><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#119;&#106;&#x79;&#109;&#101;&#x73;&#115;&#105;&#x40;&#49;&#54;&#x33;&#x2e;&#x63;&#111;&#109;" target="_blank" rel="noopener">&#119;&#106;&#x79;&#109;&#101;&#x73;&#115;&#105;&#x40;&#49;&#54;&#x33;&#x2e;&#x63;&#111;&#109;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Q&quot;&gt;&lt;a href=&quot;#1-Q&quot; class=&quot;headerlink&quot; title=&quot;1.Q&quot;&gt;&lt;/a&gt;1.Q&lt;/h3&gt;&lt;p&gt;转自：&lt;a href=&quot;https://www.zhihu.com/question/22921426&quot; target=&quot;_blan
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://messi1002.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="转载" scheme="http://messi1002.top/categories/%E9%9A%8F%E7%AC%94/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="随笔" scheme="http://messi1002.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>finnal关键字</title>
    <link href="http://messi1002.top/2020/04/10/finnal%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://messi1002.top/2020/04/10/finnal关键字/</id>
    <published>2020-04-10T13:58:14.000Z</published>
    <updated>2020-04-10T13:59:08.724Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="并发编程" scheme="http://messi1002.top/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock锁</title>
    <link href="http://messi1002.top/2020/04/10/ReentrantLock%E9%94%81/"/>
    <id>http://messi1002.top/2020/04/10/ReentrantLock锁/</id>
    <published>2020-04-10T09:50:17.000Z</published>
    <updated>2020-04-10T12:55:58.929Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="并发编程" scheme="http://messi1002.top/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之死锁的前生今世</title>
    <link href="http://messi1002.top/2020/04/03/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%AD%BB%E9%94%81%E7%9A%84%E5%89%8D%E7%94%9F%E4%BB%8A%E4%B8%96/"/>
    <id>http://messi1002.top/2020/04/03/Java并发编程之死锁的前生今世/</id>
    <published>2020-04-03T11:57:16.000Z</published>
    <updated>2020-06-20T00:25:27.935Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-死锁是什么？有什么危害？"><a href="#1-死锁是什么？有什么危害？" class="headerlink" title="1.死锁是什么？有什么危害？"></a>1.死锁是什么？有什么危害？</h3><h4 id="①什么是死锁"><a href="#①什么是死锁" class="headerlink" title="①什么是死锁"></a>①什么是死锁</h4><ol><li>它是发生在并发中的（单线程是不会发生死锁的）</li><li>一定要互不相让：两个（或多个）线程（或进程）相互持有对方所需要的资源，又不主动释放，导致大家都无法继续前进，程序陷入无尽的阻塞，这就是死锁。</li></ol><ul><li>下图形象地模拟了两个线程（或进程）互不相让的情况：</li></ul><p><img src="./1592039326131.png" alt="Alt text"></p><ul><li>两个线程造成死锁的情况<ul><li>如下图所示，线程 A 持有锁 1 的同时试图获取锁 2，线程 B 持有锁 2 的同时试图获取锁 1。因为锁在同一时刻只能被一个线程拥有，所以锁 1 不可能被线程 B 拿走（已经被线程 A 拿走了），锁 2 也不可能被线程 A 拿走（已经被线程 B 拿走了）。</li></ul></li></ul><p><img src="./1583111303926.png" alt="Alt text"></p><ul><li>多个线程造成死锁的情况<ul><li>如果多个线程之间存在环路的锁的依赖关系，那么也可能会发生死锁。 </li><li>如下图所示（纵轴表示时间），线程 1 持有锁 A 的同时试图获取锁 B，线程 2 持有锁 B 的同时试图获取锁 C，线程 3 持有锁 C 的同时试图获取锁 A。因为锁在同一时刻只能被一个线程拥有，所以线程 1 获取不到锁 B（已经被线程 2 拿走了），线程 2 获取不到锁 C（已经被线程 3 拿走了），线程 3 也获取不到锁 A（已经被线程 1 拿走了），多个线程之间形成了锁的环路。</li></ul></li></ul><p><img src="./1583111690488.png" alt="Alt text"></p><h4 id="②死锁的影响"><a href="#②死锁的影响" class="headerlink" title="②死锁的影响"></a>②死锁的影响</h4><ul><li>死锁对于不同系统的影响和危害是不一样的，这取决于系统对死锁的处理能力。<ul><li>在一部分数据库中，拥有检测并且放弃事务（即修复死锁）的能力。如果多个事务发生了死锁，数据库会检测到这个情况并且指派某个事务先放弃，在其他事务顺利执行后，再让被放弃的事务执行。</li><li>在 JVM 中，无法自动处理死锁，但是它的一些工具可以帮助我们检测死锁。</li></ul></li></ul><h4 id="③死锁的特点"><a href="#③死锁的特点" class="headerlink" title="③死锁的特点"></a>③死锁的特点</h4><ul><li>不一定发生，但是遵守 “墨菲定律”（如果事情有变坏的可能，不管这种可能性有多小，它总会发生）。</li><li>几率不高但危害大<ul><li>一旦发生，多是高并发场景，影响用户多。</li></ul></li><li>根据死锁所在的位置不同，可能会使得整个系统崩溃、子系统崩溃或者系统的性能降低。</li><li>压力测试无法找出所有潜在的死锁<ul><li>压力测试是高并发系统上线前必须要做的环节，需要模拟很多用户量做全链路压测，来发现系统中薄弱的部分并做出提升，以便更好的应对高并发的情况。</li><li>死锁的发生与并发量是正相关的关系，而不是必然的关系。如果系统的业务包含随机获取锁，此时压力测试不一定能模拟出所有的情况。</li></ul></li></ul><hr><h3 id="2-发生死锁的例子"><a href="#2-发生死锁的例子" class="headerlink" title="2.发生死锁的例子"></a>2.发生死锁的例子</h3><h4 id="①最简单的情况"><a href="#①最简单的情况" class="headerlink" title="①最简单的情况"></a>①最简单的情况</h4><ul><li>第一个线程首先启动（标记位为 1），它首先锁定 o1，然后睡眠 500 毫秒，然后尝试获取 o2。</li><li>在第一个线程睡眠的时候，第二个线程启动（标记位为 2）。它首先锁定 o2，然后睡眠 500 毫秒，然后尝试获取 o1（等待第一个线程释放 o1）。</li><li>第一个线程睡眠结束后需要锁定 o2 才能继续执行，而此时 o2 已经被第二个线程锁定。</li><li>第二个线程睡眠结束后需要锁定 o1 才能继续执行，而此时 o1 已经被第一个线程锁定。</li><li>第一个线程和第二个线程相互等待，它们都持有对方想要的资源，同时又想拿到对方已经拥有的资源，就陷入了死锁。</li><li>具体代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> threadcoreknowledge.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/3/2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 必定发生死锁的情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MustDeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建两把锁</span></span><br><span class="line">    <span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// 标记位，以便让不同的线程执行不同的策略(不同的线程会根据标记位状态的不同去执行不同的内容)。</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"flag = "</span> + flag);</span><br><span class="line">        <span class="comment">// 线程1执行</span></span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 第一个线程拿到第一把锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"获取到o1"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 确保第二个线程拿到第二把锁</span></span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 第一个线程尝试获取第二把锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"获取到o2"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 线程2执行</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 第二个线程拿到第二把锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"获取到o2"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 确保第一个线程拿到第一把锁</span></span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 第二个线程尝试获取第一把锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"获取到o1"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建两个Runnable实例，其内部的flag值不同。</span></span><br><span class="line">        MustDeadLock instance1 = <span class="keyword">new</span> MustDeadLock();</span><br><span class="line">        MustDeadLock instance2 = <span class="keyword">new</span> MustDeadLock();</span><br><span class="line">        instance1.flag = <span class="number">1</span>;</span><br><span class="line">        instance2.flag = <span class="number">2</span>;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(instance1);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1592053763309.png" alt="Alt text"></p><blockquote><p>注意看退出信号：Process finished with exit code -1，是非正常退出的信号，对比正常结束的程序的退出码是 0。<br>尽量要避免非正常退出情况的发生，因为强行退出可能会导致数据不完整。</p></blockquote><h4 id="②实际生产中的例子：转账"><a href="#②实际生产中的例子：转账" class="headerlink" title="②实际生产中的例子：转账"></a>②实际生产中的例子：转账</h4><ul><li>A 给 B 转账：需要两把锁（先锁 A、再锁 B）<ul><li>A 被扣钱时需要一把锁（锁住 A）：防止多个线程同时对 A 扣钱</li><li>B 收钱时需要一把锁（锁住 B）：防止多个线程同时给 B 转钱</li><li>成功获取两把锁后，需要 ①检查 A 的余额是否充足、②扣除 A 的余额、③增加 B 的余额。必须将这三个步骤变成原子操作，期间不能被其他线程打断或者执行一半就结束，而是要符合原子操作的定义，要不全部执行成功，要不全部执行不成功。</li></ul></li><li>具体代码如下： </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> threadcoreknowledge.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/3/2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 模拟两个人互相转账。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferMoney</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Acount的实例，模拟a和b两个账户。</span></span><br><span class="line">    <span class="keyword">static</span> Account a = <span class="keyword">new</span> Account(<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">static</span> Account b = <span class="keyword">new</span> Account(<span class="number">500</span>);</span><br><span class="line">    <span class="comment">// 标记位，以便让不同的线程执行不同的策略(不同的线程会根据标记位状态的不同去执行不同的内容)。</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// a给b转账</span></span><br><span class="line">            transferMoney(a, b, <span class="number">200</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// b给a转账</span></span><br><span class="line">            transferMoney(b, a, <span class="number">300</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 转账</span></span><br><span class="line"><span class="comment">     * from: 钱从哪里来(转出方)</span></span><br><span class="line"><span class="comment">     * to: 钱到哪里去(转入方)</span></span><br><span class="line"><span class="comment">     * amount: 钱(金额)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [from, to, amount]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/6/13 22:17</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(Account from, Account to, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取转出方的锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">            <span class="comment">// 获取转入方的锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                <span class="comment">// 成功获取两把锁之后，进行转账操作。</span></span><br><span class="line">                <span class="comment">// 判断余额是否充足</span></span><br><span class="line">                <span class="keyword">if</span> (from.balance - amount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"余额不足，转账失败。"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 扣钱</span></span><br><span class="line">                    from.balance -= amount;</span><br><span class="line">                    <span class="comment">// 加钱</span></span><br><span class="line">                    to.balance += amount;</span><br><span class="line">                    System.out.println(<span class="string">"成功转账"</span> + amount + <span class="string">"元"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建两个Runnable实例，其内部的flag值不同。</span></span><br><span class="line">        TransferMoney instance1 = <span class="keyword">new</span> TransferMoney();</span><br><span class="line">        TransferMoney instance2 = <span class="keyword">new</span> TransferMoney();</span><br><span class="line">        instance1.flag = <span class="number">1</span>;</span><br><span class="line">        instance2.flag = <span class="number">2</span>;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(instance1);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line">        <span class="comment">// 启动两个子线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="comment">// 主线程等待两个子线程执行完毕</span></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">"a的余额"</span> + a.balance);</span><br><span class="line">        System.out.println(<span class="string">"b的余额"</span> + b.balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 余额</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> balance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1592058244554.png" alt="Alt text"></p><ul><li>如果两个人互相转钱，此时两个人获取锁的顺序相反，可能会导致死锁发生。</li><li>通过如下代码模拟死锁发生的情形：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> threadcoreknowledge.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/3/2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 模拟两个人互相转账时发生死锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferMoney</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Acount的实例，模拟a和b两个账户。</span></span><br><span class="line">    <span class="keyword">static</span> Account a = <span class="keyword">new</span> Account(<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">static</span> Account b = <span class="keyword">new</span> Account(<span class="number">500</span>);</span><br><span class="line">    <span class="comment">// 标记位，以便让不同的线程执行不同的策略(不同的线程会根据标记位状态的不同去执行不同的内容)。</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// a给b转账</span></span><br><span class="line">            transferMoney(a, b, <span class="number">200</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// b给a转账</span></span><br><span class="line">            transferMoney(b, a, <span class="number">300</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 转账</span></span><br><span class="line"><span class="comment">     * from: 钱从哪里来(转出方)</span></span><br><span class="line"><span class="comment">     * to: 钱到哪里去(转入方)</span></span><br><span class="line"><span class="comment">     * amount: 钱(金额)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [from, to, amount]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/6/13 22:17</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(Account from, Account to, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取转出方的锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">            <span class="comment">// 死锁形成的原因: 获取锁的顺序是相反的。</span></span><br><span class="line">            <span class="comment">// 第一个线程(a给b转账)拿到a的锁开始睡眠、第二个线程(b给a转账)拿到b的锁开始睡眠。</span></span><br><span class="line">            <span class="comment">// 当它们苏醒后，却发现自己想要拿的锁已经被对方拿到了，于是陷入死锁。</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取转入方的锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                <span class="comment">// 成功获取两把锁之后，进行转账操作。</span></span><br><span class="line">                <span class="comment">// 判断余额是否充足</span></span><br><span class="line">                <span class="keyword">if</span> (from.balance - amount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"余额不足，转账失败。"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 扣钱</span></span><br><span class="line">                    from.balance -= amount;</span><br><span class="line">                    <span class="comment">// 加钱</span></span><br><span class="line">                    to.balance += amount;</span><br><span class="line">                    System.out.println(<span class="string">"成功转账"</span> + amount + <span class="string">"元"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建两个Runnable实例，其内部的flag值不同。</span></span><br><span class="line">        TransferMoney instance1 = <span class="keyword">new</span> TransferMoney();</span><br><span class="line">        TransferMoney instance2 = <span class="keyword">new</span> TransferMoney();</span><br><span class="line">        instance1.flag = <span class="number">1</span>;</span><br><span class="line">        instance2.flag = <span class="number">2</span>;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(instance1);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line">        <span class="comment">// 启动两个子线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="comment">// 主线程等待两个子线程执行完毕</span></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">"a的余额"</span> + a.balance);</span><br><span class="line">        System.out.println(<span class="string">"b的余额"</span> + b.balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 余额</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> balance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1592058614663.png" alt="Alt text"></p><blockquote><p>注意：<br>1.在单机的情况下，一个 static 对象在 Java 虚拟机中只有一个实例，所以不同的线程同时获取这个锁时最多有一个线程能够获取到它。<br>2.在分布式的情况下，一些锁的规则和单机情况是不一样的。</p></blockquote><h4 id="③模拟多人随机转账"><a href="#③模拟多人随机转账" class="headerlink" title="③模拟多人随机转账"></a>③模拟多人随机转账</h4><ul><li>假如有五千人同时随机转账，看似发生死锁的几率降低了，但是依然会发生死锁（墨菲定律）。<ul><li>账户数量可以决定死锁发生几率的高低 — 账户越少，发生死锁的几率越高。但是根据墨菲定律，即使账户数量很多，只要有发生死锁的风险，随着时间的推移，也会发生死锁。</li></ul></li><li>死锁的危害很大，如果发生多人连环死锁，会导致这些人的交易都无法进行。在线上系统中，一旦发生死锁，可能会导致系统崩溃或者子系统崩溃，从而影响很多用户。</li><li>具体代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> threadcoreknowledge.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/3/2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 多人同时随机转账，依然很危险。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> balance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransferMoney</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(Account from, Account to, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                <span class="keyword">if</span> (from.balance - amount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"余额不足，转账失败。"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    from.balance -= amount;</span><br><span class="line">                    to.balance += amount;</span><br><span class="line">                    System.out.println(<span class="string">"成功转账"</span> + amount + <span class="string">"元"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiTransferMoney</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 防止魔法值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_ACCOUNTS = <span class="number">5000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_MONEY = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_ITERATIONS = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_THREADS = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">// 模拟5000个账户</span></span><br><span class="line">        Account[] accounts = <span class="keyword">new</span> Account[NUM_ACCOUNTS];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; accounts.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 初始化每个账户，并设置默认的账户余额(1000元)。</span></span><br><span class="line">            accounts[i] = <span class="keyword">new</span> Account(NUM_MONEY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 转账线程类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TransferThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 每个线程转账1000000次，每次随机转账(金额随机、转出人和转入人也随机)。</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_ITERATIONS; i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> from = random.nextInt(NUM_ACCOUNTS);</span><br><span class="line">                    <span class="keyword">int</span> to = random.nextInt(NUM_ACCOUNTS);</span><br><span class="line">                    <span class="keyword">if</span> (from != to) &#123;</span><br><span class="line">                        <span class="keyword">int</span> amount = random.nextInt(NUM_MONEY);</span><br><span class="line">                        <span class="keyword">new</span> TransferMoney().transferMoney(accounts[from], accounts[to], amount);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 20个线程同时进行转账</span></span><br><span class="line">        <span class="comment">// 程序不继续输出，说明20个线程都不运转了。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> TransferThread().start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1592192778570.png" alt="Alt text"><br><img src="./1592192842233.png" alt="Alt text"></p><blockquote><p><strong>结论：在写程序的时候就要避免程序有发生死锁的可能，不能因为死锁发生的几率小或转账的人数多就忽视它。</strong></p></blockquote><hr><h3 id="3-死锁的-4-个必要条件"><a href="#3-死锁的-4-个必要条件" class="headerlink" title="3.死锁的 4 个必要条件"></a>3.死锁的 4 个必要条件</h3><blockquote><p><strong>这 4 个条件缺一不可，只有这 4 个条件同时满足时，才会发生死锁。</strong></p></blockquote><h4 id="①互斥条件"><a href="#①互斥条件" class="headerlink" title="①互斥条件"></a>①互斥条件</h4><ul><li>一个资源每次只能被同一个进程或线程使用。若是资源可以无限共享（多个进程或线程可以同时使用），说明它不满足互斥条件，这时就不会发生死锁。</li></ul><h4 id="②请求与保持条件"><a href="#②请求与保持条件" class="headerlink" title="②请求与保持条件"></a>②请求与保持条件</h4><ul><li>进程或线程因请求资源而阻塞时，对已经获得的资源保持不放。</li></ul><h4 id="③不剥夺条件"><a href="#③不剥夺条件" class="headerlink" title="③不剥夺条件"></a>③不剥夺条件</h4><ul><li>进程或线程已经获得的资源，在没有使用完之前，不能被强行剥夺。<ul><li>注意：数据库不满足不剥夺条件</li></ul></li></ul><h4 id="④循环等待条件"><a href="#④循环等待条件" class="headerlink" title="④循环等待条件"></a>④循环等待条件</h4><ul><li>若干进程或线程之间形成一种头尾相接的循环等待资源的关系，即获取锁的顺序必须构成环路。</li></ul><blockquote><p><strong>只要破坏以上任意一个条件，死锁就不会发生。</strong></p></blockquote><hr><h3 id="4-如何定位死锁？"><a href="#4-如何定位死锁？" class="headerlink" title="4.如何定位死锁？"></a>4.如何定位死锁？</h3><ol><li>jstack：在命令行中使用，更加灵活。</li><li>ThreadMXBean：写在代码中，可以提前让程序拥有发生死锁后的处理能力。</li></ol><h4 id="①jstack"><a href="#①jstack" class="headerlink" title="①jstack"></a>①jstack</h4><ul><li>它是 Java 提供的一个工具，使用 <code>jstack</code> 命令可以检测出相对明显的死锁关系。对于不明显的死锁关系，可能无法检测出来，但是它至少可以帮助我们分析一下线程栈，看看每个线程持有哪些锁，方便我们发现锁的依赖关系（可以看到哪个线程加了哪些锁、获取了哪些锁、是在哪些语句中做的、正在等待或者阻塞的线程是哪些 ……）。</li><li>如何使用：</li></ul><ol><li>在命令行中找到正在运行的 Java 程序的 pid（windows 下查看进程的命令为 <code>tasklist</code>）</li></ol><p><img src="./1592308056466.png" alt="Alt text"></p><ol start="2"><li>执行 <code>jstack pid</code> 命令：帮助我们判断正在运行的程序是否产生了死锁</li></ol><p><img src="./1592308426895.png" alt="Alt text"></p><ul><li>多人转账代码分析：一旦其中几个线程发生死锁后，就会逐渐导致所有的线程都不可用。因为转账选择线程是随机的，一旦某个线程随机选择了已经陷入死锁的线程，此时这个线程也要陷入无穷的等待了，因为这个线程所等待的线程永远也不会苏醒过来。这样恶性循环下去，所有线程都会陷入死锁。</li></ul><p><img src="./1592313757732.png" alt="Alt text"></p><h4 id="②ThreadMXBean"><a href="#②ThreadMXBean" class="headerlink" title="②ThreadMXBean"></a>②ThreadMXBean</h4><ul><li>在经常调用锁的地方，可以通过 ThreadMXBean 判断是否发生了死锁，然后用报警机制、记录日志或者重启程序等方式及时解决死锁问题。</li><li>如下代码模拟了死锁发生的情形并通过 ThreadMXBean 检测出了死锁：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> threadcoreknowledge.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ThreadInfo;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ThreadMXBean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/3/2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 用ThreadMXBean检测死锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadMXBeanDetection</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"flag = "</span> + flag);</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"获取到o1"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">600</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"获取到o2"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"获取到o2"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">600</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"获取到o1"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadMXBeanDetection instance1 = <span class="keyword">new</span> ThreadMXBeanDetection();</span><br><span class="line">        ThreadMXBeanDetection instance2 = <span class="keyword">new</span> ThreadMXBeanDetection();</span><br><span class="line">        instance1.flag = <span class="number">1</span>;</span><br><span class="line">        instance2.flag = <span class="number">2</span>;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(instance1);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="comment">// 等待两个子线程陷入死锁</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 得到ThreadMXBean实例</span></span><br><span class="line">        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">        <span class="comment">// 返回检测到的陷入死锁的线程</span></span><br><span class="line">        <span class="keyword">long</span>[] deadlockedThreads = threadMXBean.findDeadlockedThreads();</span><br><span class="line">        <span class="keyword">if</span> (deadlockedThreads != <span class="keyword">null</span> &amp;&amp; deadlockedThreads.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deadlockedThreads.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 通过线程id获取线程信息</span></span><br><span class="line">                ThreadInfo threadInfo = threadMXBean.getThreadInfo(deadlockedThreads[i]);</span><br><span class="line">                System.out.println(<span class="string">"发现死锁"</span> + threadInfo.getThreadName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1592311095575.png" alt="Alt text"></p><hr><h3 id="5-修复死锁的策略"><a href="#5-修复死锁的策略" class="headerlink" title="5.修复死锁的策略"></a>5.修复死锁的策略</h3><h4 id="①线上发生死锁应该怎么办？"><a href="#①线上发生死锁应该怎么办？" class="headerlink" title="①线上发生死锁应该怎么办？"></a>①线上发生死锁应该怎么办？</h4><ul><li>死锁的特点：不可提前预料、蔓延的速度非常快、危害非常大。</li><li>任何线上问题都需要防患于未然，一旦发生类似于死锁的严重影响可用性的问题，不造成损失地补救几乎是不可能的。</li><li>线上发生死锁问题后，必须立刻保存案发现场，然后重启服务器以暂时保证线上服务的安全，然后利用刚才保存的堆栈信息，排查死锁，修改代码，重新发版。<ul><li>关于案发现场：日志信息远远不如堆栈信息详细，不方便我们进一步排查，所以必须要保存当前堆栈信息。</li><li>第一优先级：立刻恢复线上的正常环境，不能影响用户体验。</li></ul></li></ul><h4 id="②常见修复策略"><a href="#②常见修复策略" class="headerlink" title="②常见修复策略"></a>②常见修复策略</h4><ul><li>避免策略：如哲学家就餐问题的换手方案、转账换序方案等。<ul><li>思路：避免相反的获取锁的顺序</li><li>转账时避免死锁：实际上我们并不在乎获取锁的顺序，它不影响程序的正确性，我们只在乎最后是否把两把锁（转入方的锁和转出方的锁）都拿在手里，至于哪把锁先拿，哪把锁后拿都没有关系。</li><li>如下代码根据避免策略修复了双人转账代码的死锁问题：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> threadcoreknowledge.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/3/2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 通过避免策略修复死锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepairDeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Account a = <span class="keyword">new</span> Account(<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">static</span> Account b = <span class="keyword">new</span> Account(<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            transferMoney(a, b, <span class="number">200</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            transferMoney(b, a, <span class="number">200</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(Account from, Account to, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Helper</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account from, Account to, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (from.balance - amount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"余额不足，转账失败。"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    from.balance -= amount;</span><br><span class="line">                    to.balance += amount;</span><br><span class="line">                    System.out.println(<span class="string">"成功转账"</span> + amount + <span class="string">"元"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 让互相转账的两个人获取锁的顺序一致</span></span><br><span class="line">        <span class="comment">// 利用对象的哈希值来保证获取锁的顺序的一致性(总是先获取哈希值小的账户的锁)</span></span><br><span class="line">        <span class="comment">// 在实际开发中，可以用主键代替对象的哈希值(主键不会发生冲突)。</span></span><br><span class="line">        <span class="keyword">int</span> fromHash = System.identityHashCode(from);</span><br><span class="line">        <span class="keyword">int</span> toHash = System.identityHashCode(to);</span><br><span class="line">        <span class="keyword">if</span> (fromHash &lt; toHash) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                    <span class="keyword">new</span> Helper().transfer(from, to, amount);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (fromHash &gt; toHash) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">                    <span class="keyword">new</span> Helper().transfer(from, to, amount);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还要考虑发生哈希冲突的情况</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 发生哈希冲突时，谁先抢到lock锁，谁先执行这笔交易。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                        <span class="keyword">new</span> Helper().transfer(from, to, amount);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        RepairDeadLock instance1 = <span class="keyword">new</span> RepairDeadLock();</span><br><span class="line">        RepairDeadLock instance2 = <span class="keyword">new</span> RepairDeadLock();</span><br><span class="line">        instance1.flag = <span class="number">1</span>;</span><br><span class="line">        instance2.flag = <span class="number">2</span>;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(instance1);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">"a的余额"</span> + a.balance);</span><br><span class="line">        System.out.println(<span class="string">"b的余额"</span> + b.balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1592315309576.png" alt="Alt text"></p><ul><li>检查与恢复策略：一段时间检查是否有死锁，如果有就剥夺某一个资源，来打开死锁。</li><li>鸵鸟策略：如果发生死锁的概率极其低，那么我们就直接忽略它，直到死锁发生的时候，再人工修复。</li></ul><h5 id="a-避免策略（优先推荐）"><a href="#a-避免策略（优先推荐）" class="headerlink" title="a.避免策略（优先推荐）"></a>a.避免策略（优先推荐）</h5><ul><li>哲学家就餐问题<ul><li>问题描述：如下图所示</li><li>有死锁和资源耗尽的风险：每个哲学家都拿着左边的叉子，永远都在等右边的叉子（或者相反）。</li></ul></li></ul><p><img src="./1583160335745.png" alt="Alt text"><br><img src="./1592316362175.png" alt="Alt text"></p><ul><li>如下代码演示了哲学家就餐问题导致的死锁：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> threadcoreknowledge.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/3/2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 演示哲学家就餐问题导致的死锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object leftFork;</span><br><span class="line">        <span class="keyword">private</span> Object rightFork;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(Object leftFork, Object rightFork)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.leftFork = leftFork;</span><br><span class="line">            <span class="keyword">this</span>.rightFork = rightFork;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    doAction(<span class="string">"Thinking"</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (leftFork) &#123;</span><br><span class="line">                        doAction(<span class="string">"Picked up left fork"</span>);</span><br><span class="line">                        <span class="keyword">synchronized</span> (rightFork) &#123;</span><br><span class="line">                            doAction(<span class="string">"Picked up right fork - eating"</span>);</span><br><span class="line">                            doAction(<span class="string">"Put down right fork"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        doAction(<span class="string">"Put down left fork"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(String action)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + action);</span><br><span class="line">            <span class="comment">// 随机休眠一段时间</span></span><br><span class="line">            Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Philosopher[] philosophers = <span class="keyword">new</span> Philosopher[<span class="number">5</span>];</span><br><span class="line">        Object[] forks = <span class="keyword">new</span> Object[philosophers.length];</span><br><span class="line">        <span class="comment">// 初始化叉子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; forks.length; i++) &#123;</span><br><span class="line">            forks[i] = <span class="keyword">new</span> Object();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化哲学家</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; philosophers.length; i++) &#123;</span><br><span class="line">            Object leftFork = forks[i];</span><br><span class="line">            <span class="comment">// (i+1)%forks.length: 防止越界。</span></span><br><span class="line">            Object rightFork = forks[(i + <span class="number">1</span>) % forks.length];</span><br><span class="line">            philosophers[i] = <span class="keyword">new</span> Philosopher(leftFork, rightFork);</span><br><span class="line">            <span class="keyword">new</span> Thread(philosophers[i], <span class="string">"哲学家"</span> + (i + <span class="number">1</span>) + <span class="string">"号"</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1592317478432.png" alt="Alt text"></p><ul><li>多种解决方案：</li></ul><ol><li>服务员检查（避免策略）：每次吃饭前判断是否会发生死锁，如果会发生，就不能继续接下来的动作。</li><li>改变一个哲学家拿叉子的顺序（避免策略）：要想发生死锁，必须所有人同时拿起左边的叉子，但是如果有一个哲学家先拿起右边的叉子、再拿起左边的叉子，就不会发生死锁，即避免发生环路，破坏了死锁的循环等待条件。</li><li>餐票（避免策略）：要求必须拿到餐票才能吃饭，而我们为了避免死锁，一共只发四张餐票，这样就可以避免五个人同时准备吃饭的情况。</li><li>领导调节（检测与恢复策略）：当发生死锁时，命令一个哲学家放下筷子让别人先吃，破坏了死锁的不可剥夺条件。</li></ol><ul><li>如下代码演示了解决方案 2：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> threadcoreknowledge.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/3/2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 解决哲学家就餐问题导致的死锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object leftFork;</span><br><span class="line">        <span class="keyword">private</span> Object rightFork;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(Object leftFork, Object rightFork)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.leftFork = leftFork;</span><br><span class="line">            <span class="keyword">this</span>.rightFork = rightFork;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    doAction(<span class="string">"Thinking"</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (leftFork) &#123;</span><br><span class="line">                        doAction(<span class="string">"Picked up left fork"</span>);</span><br><span class="line">                        <span class="keyword">synchronized</span> (rightFork) &#123;</span><br><span class="line">                            doAction(<span class="string">"Picked up right fork - eating"</span>);</span><br><span class="line">                            doAction(<span class="string">"Put down right fork"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        doAction(<span class="string">"Put down left fork"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(String action)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + action);</span><br><span class="line">            <span class="comment">// 随机休眠一段时间</span></span><br><span class="line">            Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Philosopher[] philosophers = <span class="keyword">new</span> Philosopher[<span class="number">5</span>];</span><br><span class="line">        Object[] forks = <span class="keyword">new</span> Object[philosophers.length];</span><br><span class="line">        <span class="comment">// 初始化叉子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; forks.length; i++) &#123;</span><br><span class="line">            forks[i] = <span class="keyword">new</span> Object();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化哲学家</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; philosophers.length; i++) &#123;</span><br><span class="line">            Object leftFork = forks[i];</span><br><span class="line">            <span class="comment">// (i+1)%forks.length: 防止越界。</span></span><br><span class="line">            Object rightFork = forks[(i + <span class="number">1</span>) % forks.length];</span><br><span class="line">            <span class="comment">// 让最后一位哲学家先拿起右边的叉子，再拿起左边的叉子。</span></span><br><span class="line">            <span class="keyword">if</span> (i == philosophers.length - <span class="number">1</span>) &#123;</span><br><span class="line">                philosophers[i] = <span class="keyword">new</span> Philosopher(rightFork, leftFork);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                philosophers[i] = <span class="keyword">new</span> Philosopher(leftFork, rightFork);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">new</span> Thread(philosophers[i], <span class="string">"哲学家"</span> + (i + <span class="number">1</span>) + <span class="string">"号"</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>哲学家就餐问题的练习题：<a href="https://leetcode-cn.com/problems/the-dining-philosophers/" target="_blank" rel="noopener">1226. 哲学家进餐</a><br>题目对应的题解：<a href="https://messi1002.top/2020/03/01/LeetCode-1226-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/">[LeetCode] 1226. 哲学家进餐（Medium）Java语言题解</a></p></blockquote><h5 id="b-检测与恢复策略"><a href="#b-检测与恢复策略" class="headerlink" title="b.检测与恢复策略"></a>b.检测与恢复策略</h5><ul><li>检测算法：锁的调用链路图（虽然允许发生死锁，但是在每次调用锁时都把它记录下来，并用一个图维护它，然后定期检查 “锁的调用链路图” 中是否存在环路，一旦存在环路（即发生死锁），就用死锁恢复机制来进行恢复。）</li></ul><p><img src="./1583169772201.png" alt="Alt text"></p><ul><li>死锁恢复方法 1 — 进程或线程终止：逐个终止进程或线程，直到死锁消除。<br>终止顺序的三个考虑因素：<ul><li>①程序重要性的优先级（前台交互优先于后台处理）</li><li>②已占用资源、还需要的资源</li><li>③已经运行的时间</li></ul></li><li>死锁恢复方法 2 — 资源抢占：将已经分发出去的锁收回来，让线程回退几步，这样就不用结束整个线程，成本比较低。<ul><li>缺点：如果同一个线程一直被抢占，就会造成饥饿（线程一直得不到运行）。</li></ul></li></ul><h5 id="c-鸵鸟策略（不推荐）"><a href="#c-鸵鸟策略（不推荐）" class="headerlink" title="c.鸵鸟策略（不推荐）"></a>c.鸵鸟策略（不推荐）</h5><ul><li>编码代价小，适用于发生死锁的概率极其低的情况。</li></ul><hr><h3 id="6-实际工程中如何避免死锁？"><a href="#6-实际工程中如何避免死锁？" class="headerlink" title="6.实际工程中如何避免死锁？"></a>6.实际工程中如何避免死锁？</h3><blockquote><p>如果在开发的过程中遵守以下规范，那么发生死锁的概率就会大大降低。</p></blockquote><h4 id="①设置超时时间"><a href="#①设置超时时间" class="headerlink" title="①设置超时时间"></a>①设置超时时间</h4><ul><li>synchronized 不具备尝试获取锁的能力。</li><li>而 Lock 类的 tryLock(long timeout, TimeUnit unit) 方法具备尝试获取锁的能力，其中 timeout 指超时时间，若是过了超时时间还没有拿到锁，它就会放弃拿锁，退回去做别的事情，这样也能防止死锁的发生。<ul><li>造成超时的原因：发生了死锁、线程陷入死循环、线程执行很慢等。</li><li>获取锁失败后需要打印日志、发报警邮件、重启等。</li></ul></li><li>如下代码演示了使用 tryLock 方法来避免死锁：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> threadcoreknowledge.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/3/3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 用tryLock方法来避免死锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryLockDeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ReentrantLock: 可重入锁</span></span><br><span class="line">    <span class="keyword">static</span> Lock lock1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">static</span> Lock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lock1.tryLock(<span class="number">800</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"获取到锁1"</span>);</span><br><span class="line">                        Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">                        <span class="keyword">if</span> (lock2.tryLock(<span class="number">800</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">"获取到锁2"</span>);</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">"成功获取到两把锁"</span>);</span><br><span class="line">                            lock2.unlock();</span><br><span class="line">                            lock1.unlock();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">"尝试获取锁2失败"</span>);</span><br><span class="line">                            lock1.unlock();</span><br><span class="line">                            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"尝试获取锁1失败，即将重试。"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lock2.tryLock(<span class="number">3000</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"获取到锁2"</span>);</span><br><span class="line">                        Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">                        <span class="keyword">if</span> (lock1.tryLock(<span class="number">3000</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">"获取到锁1"</span>);</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">"成功获取到两把锁"</span>);</span><br><span class="line">                            lock1.unlock();</span><br><span class="line">                            lock2.unlock();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">"尝试获取锁1失败"</span>);</span><br><span class="line">                            lock2.unlock();</span><br><span class="line">                            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"尝试获取锁2失败，即将重试。"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TryLockDeadLock instance1 = <span class="keyword">new</span> TryLockDeadLock();</span><br><span class="line">        TryLockDeadLock instance2 = <span class="keyword">new</span> TryLockDeadLock();</span><br><span class="line">        instance1.flag = <span class="number">1</span>;</span><br><span class="line">        instance2.flag = <span class="number">2</span>;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(instance1);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1592361521413.png" alt="Alt text"></p><h4 id="②多使用并发类而不是自己设计锁"><a href="#②多使用并发类而不是自己设计锁" class="headerlink" title="②多使用并发类而不是自己设计锁"></a>②多使用并发类而不是自己设计锁</h4><ol><li>JDK 1.5 以后引入了很多并发类（ConcurrentHashMap、ConcurrentLinkedQueue、AtomicInteger、AtomicBoolean 等），使用这些并发类，就不用自己手动控制 wait、notify 等底层语句，并且使用成熟的并发类可以降低发生死锁的概率。</li><li>在实际应用中 java.util.concurrent.atomic 包十分有用，包中的原子类具有原子性，可以直接使用（线程安全），简单方便且效率比使用 Lock 更高。</li><li>多用并发集合少用同步集合，并发集合比同步集合的可扩展性更好。并发场景需要用到 map，应该首先想到用 ConcurrentHashMap。 </li></ol><h4 id="③尽量降低锁的使用粒度：用不同的锁而不是一把锁"><a href="#③尽量降低锁的使用粒度：用不同的锁而不是一把锁" class="headerlink" title="③尽量降低锁的使用粒度：用不同的锁而不是一把锁"></a>③尽量降低锁的使用粒度：用不同的锁而不是一把锁</h4><ul><li>一把锁所保护的范围在满足业务要求的前提下越小越好。</li></ul><h4 id="④如果能使用同步代码块，就不使用同步方法：自己指定锁对象"><a href="#④如果能使用同步代码块，就不使用同步方法：自己指定锁对象" class="headerlink" title="④如果能使用同步代码块，就不使用同步方法：自己指定锁对象"></a>④如果能使用同步代码块，就不使用同步方法：自己指定锁对象</h4><ol><li>使用同步代码块可以缩小锁的范围（同步方法的范围较大）。</li><li>同步代码块中使用的锁对象是可以由我们自己控制的。</li></ol><h4 id="⑤给线程起个有意义的名字"><a href="#⑤给线程起个有意义的名字" class="headerlink" title="⑤给线程起个有意义的名字"></a>⑤给线程起个有意义的名字</h4><ul><li>debug 和排查时事半功倍，框架和 JDK 都遵守这个最佳实践。</li></ul><h4 id="⑥避免锁的嵌套"><a href="#⑥避免锁的嵌套" class="headerlink" title="⑥避免锁的嵌套"></a>⑥避免锁的嵌套</h4><ul><li>一旦获取锁的顺序相反，就可能造成死锁。<ul><li>如 MustDeadLock 类，具体见 <strong>2.发生死锁的例子 — ①最简单的情况</strong>。</li></ul></li></ul><h4 id="⑦分配资源前先看能不能收回来：银行家算法"><a href="#⑦分配资源前先看能不能收回来：银行家算法" class="headerlink" title="⑦分配资源前先看能不能收回来：银行家算法"></a>⑦分配资源前先看能不能收回来：银行家算法</h4><ul><li>在资源放出去之前进行有效的计算，判断一下放出去之后有没有可能导致死锁，要是不可能导致死锁，再放出去。</li></ul><h4 id="⑧尽量不要几个功能用同一把锁：专锁专用"><a href="#⑧尽量不要几个功能用同一把锁：专锁专用" class="headerlink" title="⑧尽量不要几个功能用同一把锁：专锁专用"></a>⑧尽量不要几个功能用同一把锁：专锁专用</h4><ul><li>不同的功能使用不同的锁对象，专锁专用。</li></ul><hr><h3 id="7-面试常考问题"><a href="#7-面试常考问题" class="headerlink" title="7.面试常考问题"></a>7.面试常考问题</h3><h4 id="①写一个必然死锁的例子"><a href="#①写一个必然死锁的例子" class="headerlink" title="①写一个必然死锁的例子"></a>①写一个必然死锁的例子</h4><blockquote><p>具体见 <strong>2.发生死锁的例子 — ①最简单的情况</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> threadcoreknowledge.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/3/2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 必定发生死锁的情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MustDeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建两把锁</span></span><br><span class="line">    <span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// 标记位，以便让不同的线程执行不同的策略(不同的线程会根据标记位状态的不同去执行不同的内容)。</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"flag = "</span> + flag);</span><br><span class="line">        <span class="comment">// 线程1执行</span></span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 第一个线程拿到第一把锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"获取到o1"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 确保第二个线程拿到第二把锁</span></span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 第一个线程尝试获取第二把锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"获取到o2"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 线程2执行</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 第二个线程拿到第二把锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"获取到o2"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 确保第一个线程拿到第一把锁</span></span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 第二个线程尝试获取第一把锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"获取到o1"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建两个Runnable实例，其内部的flag值不同。</span></span><br><span class="line">        MustDeadLock instance1 = <span class="keyword">new</span> MustDeadLock();</span><br><span class="line">        MustDeadLock instance2 = <span class="keyword">new</span> MustDeadLock();</span><br><span class="line">        instance1.flag = <span class="number">1</span>;</span><br><span class="line">        instance2.flag = <span class="number">2</span>;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(instance1);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②生产中什么场景下可能发生死锁？"><a href="#②生产中什么场景下可能发生死锁？" class="headerlink" title="②生产中什么场景下可能发生死锁？"></a>②生产中什么场景下可能发生死锁？</h4><ol><li>最明显的情况：在一个方法中获取多个锁</li><li>在多个方法中循环调用锁，形成锁的链路（如库存的增减、金钱的转移等）。</li></ol><h4 id="③发生死锁必须满足哪些条件？"><a href="#③发生死锁必须满足哪些条件？" class="headerlink" title="③发生死锁必须满足哪些条件？"></a>③发生死锁必须满足哪些条件？</h4><blockquote><p>具体见 <strong>3.死锁的 4 个必要条件</strong></p></blockquote><ol><li>互斥条件</li><li>请求与保持条件</li><li>不剥夺条件</li><li>循环等待条件</li></ol><h4 id="④如何定位死锁？"><a href="#④如何定位死锁？" class="headerlink" title="④如何定位死锁？"></a>④如何定位死锁？</h4><blockquote><p>具体见 <strong>4.如何定位死锁？</strong></p></blockquote><ol><li>jstack：发生死锁后对程序进行堆栈分析来定位死锁。</li><li>ThreadMXBean：防患于未然， 在程序运行中利用这个类撰写代码（如定时扫描等）帮助我们找到死锁并处理（如重启线程、报警、记录日志等）它。</li></ol><h4 id="⑤有哪些解决死锁问题的策略？"><a href="#⑤有哪些解决死锁问题的策略？" class="headerlink" title="⑤有哪些解决死锁问题的策略？"></a>⑤有哪些解决死锁问题的策略？</h4><blockquote><p>具体见 <strong>5.修复死锁的策略 — ②常见修复策略</strong></p></blockquote><ol><li>避免策略（优先推荐）：如哲学家就餐问题的换手方案、转账换序方案等。</li><li>检测与恢复策略：如哲学家就餐问题的领导调节等。</li><li>鸵鸟策略（不推荐）：适用于发生死锁的概率极其低的情况。</li></ol><h4 id="⑥讲讲经典的哲学家就餐问题"><a href="#⑥讲讲经典的哲学家就餐问题" class="headerlink" title="⑥讲讲经典的哲学家就餐问题"></a>⑥讲讲经典的哲学家就餐问题</h4><blockquote><p>具体见 <strong>5.修复死锁的策略 — ②常见修复策略 — a.避免策略（优先推荐）</strong></p></blockquote><ul><li>问题描述</li><li>有死锁和资源耗尽的风险</li><li>多种解决方案</li></ul><ol><li>服务员检查（避免策略）</li><li>改变一个哲学家拿叉子的顺序（避免策略）</li><li>餐票（避免策略）</li><li>领导调节（检测与恢复策略）</li></ol><h4 id="⑦实际工程中如何避免死锁？"><a href="#⑦实际工程中如何避免死锁？" class="headerlink" title="⑦实际工程中如何避免死锁？"></a>⑦实际工程中如何避免死锁？</h4><blockquote><p>具体见 <strong>6.实际工程中如何避免死锁？</strong></p></blockquote><ol><li>设置超时时间</li><li>多使用并发类而不是自己设计锁</li><li>尽量降低锁的使用粒度：用不同的锁而不是一把锁</li><li>如果能使用同步代码块，就不使用同步方法：自己指定锁对象</li><li>给线程起个有意义的名字</li><li>避免锁的嵌套</li><li>分配资源前先看能不能收回来：银行家算法</li><li>尽量不要几个功能用同一把锁：专锁专用</li></ol><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#119;&#106;&#121;&#109;&#101;&#x73;&#115;&#105;&#64;&#x31;&#54;&#51;&#46;&#99;&#x6f;&#x6d;" target="_blank" rel="noopener">&#119;&#106;&#121;&#109;&#101;&#x73;&#115;&#105;&#64;&#x31;&#54;&#51;&#46;&#99;&#x6f;&#x6d;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-死锁是什么？有什么危害？&quot;&gt;&lt;a href=&quot;#1-死锁是什么？有什么危害？&quot; class=&quot;headerlink&quot; title=&quot;1.死锁是什么？有什么危害？&quot;&gt;&lt;/a&gt;1.死锁是什么？有什么危害？&lt;/h3&gt;&lt;h4 id=&quot;①什么是死锁&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="并发编程" scheme="http://messi1002.top/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之线程8大核心基础-下篇</title>
    <link href="http://messi1002.top/2020/03/29/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80-%E4%B8%8B%E7%AF%87/"/>
    <id>http://messi1002.top/2020/03/29/Java并发编程之线程8大核心基础-下篇/</id>
    <published>2020-03-29T14:50:37.000Z</published>
    <updated>2020-06-20T11:26:26.338Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="并发编程" scheme="http://messi1002.top/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之线程8大核心基础-中篇</title>
    <link href="http://messi1002.top/2020/03/26/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80-%E4%B8%AD%E7%AF%87/"/>
    <id>http://messi1002.top/2020/03/26/Java并发编程之线程8大核心基础-中篇/</id>
    <published>2020-03-26T14:50:37.000Z</published>
    <updated>2020-06-20T11:26:17.267Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="并发编程" scheme="http://messi1002.top/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之线程8大核心基础-上篇</title>
    <link href="http://messi1002.top/2020/03/24/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80-%E4%B8%8A%E7%AF%87/"/>
    <id>http://messi1002.top/2020/03/24/Java并发编程之线程8大核心基础-上篇/</id>
    <published>2020-03-24T14:50:37.000Z</published>
    <updated>2020-06-20T11:26:57.059Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="并发编程" scheme="http://messi1002.top/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>红黑树详解</title>
    <link href="http://messi1002.top/2020/03/18/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E8%A7%A3/"/>
    <id>http://messi1002.top/2020/03/18/红黑树详解/</id>
    <published>2020-03-18T13:47:52.000Z</published>
    <updated>2020-06-12T11:51:08.310Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-相关博客"><a href="#1-相关博客" class="headerlink" title="1.相关博客"></a>1.相关博客</h3><ul><li><a href="https://messi1002.top/2019/02/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%80%A7%E8%B4%A8/">二叉树的定义及性质</a></li><li><a href="https://messi1002.top/2019/02/11/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E9%80%92%E5%BD%92-%E8%BF%AD%E4%BB%A3/">树的遍历（递归加迭代）</a></li><li><a href="https://messi1002.top/2019/02/15/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/">二叉搜索树的常用操作</a></li></ul><hr><h3 id="2-2-3-树"><a href="#2-2-3-树" class="headerlink" title="2.2-3 树"></a>2.2-3 树</h3><h4 id="①定义"><a href="#①定义" class="headerlink" title="①定义"></a>①定义</h4><ul><li>虽然它不是一种二叉树，但是它满足二分搜索树的基本性质。每次操作节点时，都按照二分搜索树的策略查找它的位置。</li></ul><p><img src="./1585224465398.png" alt="Alt text"><br><img src="./1585224858183.png" alt="Alt text"></p><ul><li>它有两种节点，一种节点可以存放一个元素（与普通的二分搜索树的节点一样，有左右两个孩子，左孩子的值小于该节点的值，右孩子的值大于该节点的值），另一种节点可以存放两个元素（有三个孩子，三个孩子分别在第一个元素的左侧、两个元素的中间和第二个元素的右侧。且这个节点左孩子的值小于左侧元素的值，中间孩子的值在两个元素之间，右孩子的值大于右侧元素的值），所以存放两个元素的节点也满足二分搜索树的基本性质。</li><li>2-3 树的每个节点有 2 个或者 3 个孩子，通常将存放一个元素且有两个孩子的节点叫做 2 节点，将存放两个元素且有三个孩子的节点叫做 3 节点。</li></ul><p><img src="./1591155532615.png" alt="Alt text"></p><ul><li>下图为一颗 2-3 树：</li></ul><p><img src="./1585060829837.png" alt="Alt text"></p><h4 id="②性质—绝对平衡性"><a href="#②性质—绝对平衡性" class="headerlink" title="②性质—绝对平衡性"></a>②性质—绝对平衡性</h4><ul><li>2-3 树是一颗绝对平衡的树（与 2-3 树本身插入元素时的构建方法相关）<ul><li>绝对平衡：从根节点到任意一个叶子节点所经过的节点数量一定是相同的（即对于任意一个节点来说，左右子树的高度一定是相同的，可以将 2-3 树类比为满二叉树）</li></ul></li><li>2-3 树如何维持绝对的平衡：添加节点将永远不会添加到一个空的位置，只会和最后找到的叶子节点做融合，若最后找到的叶子节点是 2 节点，则添加进 2 节点，形成一个 3 节点，否则添加进 3 节点，暂时形成一个 4 节点，然后对 4 节点做一个变形处理，形成由三个 2 节点组成的子树。 </li></ul><p><img src="./1591158783683.png" alt="Alt text"><br><img src="./1591158764465.png" alt="Alt text"></p><ul><li>若暂时形成的 4 节点是根节点，则变形处理即可。</li><li>若暂时形成的 4 节点是叶子节点，则在变形处理后，将子树的根节点继续向其父亲节点（即变形处理前 4 节点的父亲节点，简称 A）融合。如果 A 为 2 节点，则融合后 A 变成一个 3 节点，子树中剩下的两个节点变为 A 的左孩子和中孩子（或者中孩子和右孩子）。如果 A 为 3 节点，则暂时形成一个 4 节点，然后对 4 节点做一个变形处理，再形成由三个 2 节点组成的子树，将子树的根节点继续向其父亲节点融合……直到融合到根节点或者 2 节点。</li></ul><p><img src="./1585064434426.png" alt="Alt text"><br><img src="./1585227128943.png" alt="Alt text"></p><h4 id="③模拟添加节点的过程"><a href="#③模拟添加节点的过程" class="headerlink" title="③模拟添加节点的过程"></a>③模拟添加节点的过程</h4><ul><li>下面我们通过向 2-3 树中添加节点，来看看 2-3 树是如何维持绝对平衡的。</li><li>添加第一个节点：作为根节点，形成一个 2 节点。</li></ul><p><img src="./1585061325704.png" alt="Alt text"></p><ul><li>添加第二个节点：和最后找到的叶子节点（42）做融合，形成一个 3 节点。</li></ul><p><img src="./1585062667731.png" alt="Alt text"></p><ul><li>添加第三个节点：和最后找到的叶子节点（37 | 42）做融合，暂时形成一个 4 节点，然后将 4 节点变形成由三个 2 节点组成的平衡的树。</li></ul><p><img src="./1585063161812.png" alt="Alt text"><br><img src="./1585062829673.png" alt="Alt text"></p><ul><li>添加第四个节点：和最后找到的叶子节点（12）做融合，形成一个 3 节点。</li></ul><p><img src="./1585063005182.png" alt="Alt text"></p><ul><li>添加第五个节点：和最后找到的叶子节点（12 | 18）做融合，暂时形成一个 4 节点，然后将 4 节点变形成由三个 2 节点组成的子树，将子树的根节点（12）继续向上融合，融合后形成一个 3 节点。</li></ul><p><img src="./1585063135172.png" alt="Alt text"><br><img src="./1585063188667.png" alt="Alt text"><br><img src="./1585063276086.png" alt="Alt text"></p><ul><li>添加第六个节点：和最后找到的叶子节点（6）做融合，形成一个 3 节点。</li></ul><p><img src="./1585063531640.png" alt="Alt text"></p><ul><li>添加第七个节点：和最后找到的叶子节点（6 | 11）做融合，暂时形成一个 4 节点，然后将 4 节点变形成由三个 2 节点组成的子树，将子树的根节点（6）继续向上融合，融合后又形成一个 4 节点，继续将 4 节点变形成由三个 2 节点组成的子树，此时已经融合到根节点，表示添加成功。</li></ul><p><img src="./1585063585154.png" alt="Alt text"><br><img src="./1585063602258.png" alt="Alt text"><br><img src="./1585063676521.png" alt="Alt text"><br><img src="./1585063783118.png" alt="Alt text"></p><h4 id="④红黑树和-2-3-树的等价性"><a href="#④红黑树和-2-3-树的等价性" class="headerlink" title="④红黑树和 2-3 树的等价性"></a>④红黑树和 2-3 树的等价性</h4><ul><li>红黑树本质上与 2-3 树是等价的<ul><li>2-3 树是包含两种节点（2 节点和 3 节点）的树结构，而红黑树是包含一种节点（每个节点只能存储一个元素）的树结构。虽然红黑树与 2-3 树的数据结构不同，但是它们实现了相同的逻辑。</li></ul></li><li>红黑树是一种自平衡的二分搜索树，在红黑树中，对每一个节点都附着了一个颜色 — 红色或者黑色。<ul><li>黑色节点：普通节点，表示在原来的 2-3 树中的 2 节点。</li><li>红色节点：和其父亲节点（黑色节点）一起表示在原来的 2-3 树中的 3 节点</li><li>左倾红黑树：所有的红色节点都是向左倾斜的。左倾红节点来表示 2-3 树中的 3 节点（2-3 树的 3 节点的左边元素在红黑树中通过红色节点（简称 A）表示，3 节点的右边元素在红黑树中通过黑色节点（简称 B）表示，并且 A 是 B 的左孩子，表示 A 与 B 在原来的 2-3 树中是并列关系，一起存放在一个 3 节点中）。</li><li>右倾红黑树：所有的红色节点都是向右倾斜的。右倾红节点来表示 2-3 树中的 3 节点（2-3 树的 3 节点的左边元素在红黑树中通过黑色节点（简称 A）表示，3 节点的右边元素在红黑树中通过红色节点（简称 B）表示，并且 B 是 A 的右孩子，表示 A 与 B 在原来的 2-3 树中是并列关系，一起存放在一个 3 节点中）。</li></ul></li></ul><p><img src="./1585104517935.png" alt="Alt text"><br><img src="./1585104479733.png" alt="Alt text"></p><blockquote><p><strong>ps：左倾红黑树是红黑树相对标准的一种实现方式，但并不是唯一的实现方式，这篇博客的后续内容都以左倾红黑树为例进行分析。</strong></p></blockquote><ul><li>与 2-3 树等价的红黑树：2-3 树中有三个 3 节点 —&gt; 红黑树中有三个红色节点，每一个 3 节点产生一个红色节点。</li><li>对于任何一颗 2-3 树，我们都可以使用以上规则将之转化成一颗红黑树。</li></ul><p><img src="./1585095199689.png" alt="Alt text"><br><img src="./1585094681384.png" alt="Alt text"></p><hr><h3 id="3-红黑树"><a href="#3-红黑树" class="headerlink" title="3.红黑树"></a>3.红黑树</h3><h4 id="①概念"><a href="#①概念" class="headerlink" title="①概念"></a>①概念</h4><ul><li>红黑树（Red Black Tree）是一种自平衡的二分搜索树，它在每个结点上增加一个存储位来表示结点的颜色，可以是 Red 或 Black。红黑树通过对任意一条从根到叶子的路径上的各个结点着色方式的限制，确保没有一条路径会比其他路径长出两倍，因而是接近平衡的。</li><li>下图为一颗红黑树：</li></ul><p><img src="./1585059312441.png" alt="Alt text"></p><h4 id="②基本性质"><a href="#②基本性质" class="headerlink" title="②基本性质"></a>②基本性质</h4><ul><li>红黑树必须满足如下条件：</li><li>①（定义）每个节点或者是红色的，或者是黑色的。</li><li>②根节点是黑色的<ul><li>在 2-3 树中，根节点或者是 2 节点，或者是 3 节点，而 2 节点和 3 节点在与之等价的红黑树（左倾红黑树）中表示为下图的两种情况。</li><li>由下图可见， 2-3 树中的 2 节点和 3 节点对应到与之等价的红黑树中，根节点都是黑色的。</li></ul></li></ul><p><img src="./1591180272683.png" alt="Alt text"></p><ul><li>③（定义）每一个叶子节点（这里的叶子节点指的是最后的空节点）是黑色的<ul><li>相当于定义空节点本身是黑色的， 一颗空树本身也是一颗红黑树，它的根节点和叶子节点都是空节点（空节点是黑色节点），同时满足 ②、③ 条性质。</li></ul></li><li>④如果一个节点是红色的，那么它的孩子节点都是黑色的。<ul><li>在红黑树中，只有表示原来的 2-3 树中的 3 节点时，才会出现红色节点。此时红色节点的两个孩子节点是原来的 2-3 树中 3 节点的左孩子和中间的孩子，不管两个孩子是 2 节点还是 3 节点，其对应到红黑树中，根结点都是黑色的（具体见 <strong>性质②</strong>）。</li><li>黑色节点的右孩子一定是黑色的节点（对于左倾红黑树来说，这是我们的定义），它的左孩子可能是红色的节点，也可能是黑色的节点。如果是红色的，表示这两个节点是原来的 2-3 树中的一个 3 节点。如果是黑色的，表示这两个节点是原来的 2-3 树中的两个节点。</li></ul></li><li>⑤（核心）从任意一个节点到其每个叶子节点（空节点），经过的黑色节点数量是一样的。<ul><li>2-3 树是一颗绝对平衡的树，从 2-3 树的任意一个节点出发到其每个叶子节点，经过的节点数量是一样的。</li><li>因为 2-3 树的 2 节点或 3 节点转换成红黑树中的节点表示时，都会有一个黑色的节点，所以从红黑树的任意一个节点出发，每经过一个黑色节点，等于一定经过了原来的 2-3 树中的某个节点。</li><li>红黑树是保持 “黑平衡” 的二叉树（黑平衡是指从根节点到任意一个叶子节点，经过的黑色节点数量是一样的）。从严格意义上讲，红黑树不是平衡二叉树，平衡二叉树的定义为左右子树的高度差不能超过 1，红黑树并不符合。</li></ul></li></ul><h4 id="③数据结构"><a href="#③数据结构" class="headerlink" title="③数据结构"></a>③数据结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTree</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> TreeNode left;</span><br><span class="line">        <span class="keyword">public</span> TreeNode right;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> color;</span><br><span class="line">        </span><br><span class="line">        TreeNode(<span class="keyword">int</span> key, <span class="keyword">int</span> value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 默认的节点颜色为红色</span></span><br><span class="line">            <span class="keyword">this</span>.color = RED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为什么默认的节点颜色为红色？<ul><li>在 2-3 树中添加一个节点，永远是和最后找到的叶子节点做融合，融合后或者形成一个 3 节点，或者形成一个临时的 4 节点。在红黑树中，红色节点代表它和它的父亲节点（黑色节点）在原来的 2-3 树中是在一起的，等价于 2-3 树中的一个 3 节点。所以在红黑树中，总是将新添加的节点的颜色设置为红色，等价于在 2-3 树中永远将新节点融合进已有的节点中。</li><li>在红黑树中添加红色节点后，可能会破坏红黑树的基本性质，此时需要再做一些调整工作（具体见下文）。</li></ul></li></ul><h4 id="④保持根节点为黑色"><a href="#④保持根节点为黑色" class="headerlink" title="④保持根节点为黑色"></a>④保持根节点为黑色</h4><blockquote><p><strong>红黑树中添加新元素之保持根节点为黑色</strong></p></blockquote><ul><li>添加根节点：添加第一个红色节点，作为红黑树的根节点。由红黑树的基本性质②（根节点是黑色的）可知，需要将根节点变成黑色。<ul><li>结论：若插入的红色节点是红黑树的根结点，应该将红色节点变为黑色节点。 </li></ul></li></ul><p><img src="./1585136914860.png" alt="Alt text"><br><img src="./1585136939404.png" alt="Alt text"></p><ul><li>添加普通节点：在原来的 2-3 树中添加元素 4 时，元素 4 应该添加到元素 2 和元素 5 组成的 3 节点中，形成一个临时的 4 节点（2 | 4 | 5）。然后将临时的 4 节点变形成由三个 2 节点组成的子树，让子树的根节点（即节点 4） 向上融合（与元素 6 和元素 8 所在的 3 节点进行融合），再形成一个临时的 4 节点（4 | 6 | 8），然后再将它变形成由三个 2 节点组成的子树，此时这颗子树的根节点是整棵 2-3 树的根节点，不再向上融合。由于元素  4 和元素 6 在原来的 2-3 树中是向上融合的，所以在与之等价的红黑树中，它们所在的节点是红色的。由于节点 6 是最后的根节点，所以在与之等价的红黑树中，元素 6 所在的节点是黑色的。<ul><li>结论：对于临时的 4 节点，在 2-3 树的添加过程中每次都要向上融合一个元素，这个元素所在的节点在红黑树的表示中应该是红色的节点。直到它融合到了根节点，再也不能向上走时，变为黑色的节点。</li></ul></li></ul><p><img src="./1585150450933.png" alt="Alt text"></p><ul><li>代码实践：保持根节点为黑色</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能描述: 向红黑树中添加新的节点(key, value)</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>: [key, value]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/3/15 17:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 见⑧添加新元素</span></span><br><span class="line">    node = insert(node, key, value);</span><br><span class="line">    <span class="comment">// 保持根节点为黑色</span></span><br><span class="line">    node.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑤左旋转"><a href="#⑤左旋转" class="headerlink" title="⑤左旋转"></a>⑤左旋转</h4><ul><li><strong>向 2-3 树的 2 节点中添加一个新元素的第一种情况</strong> —&gt; 对应到红黑树中表示：如下图所示。</li></ul><p><img src="./1585150770595.png" alt="Alt text"></p><ul><li>在上图的红黑树中，添加的新元素（红色节点）在黑色节点的左侧：直接添加（对应 2-3 树中的一个 3 节点）<br></li><li><strong>向 2-3 树的 2 节点中添加一个新元素的第二种情况</strong> —&gt; 对应到红黑树中表示：如下图所示。</li></ul><p><img src="./1585150912880.png" alt="Alt text"></p><ul><li>在上图的红黑树中，添加的新元素（红色节点）在黑色节点的右侧：先添加（此时红黑树不满足我们定义的左倾红黑树的性质) 、再调整（进行一次左旋转）。</li></ul><p><img src="./1585150990487.png" alt="Alt text"></p><ul><li>左旋转的过程（注意：旋转前后的红黑树都要满足二分搜索树的性质）<ol><li>让 x 的左子树 T2 变成 node 的右子树</li><li>让 node 变成 x 的左子树</li><li>维护节点的颜色<ul><li>x 的颜色等于 node 的颜色（可能是红色，也可能是黑色）。因为在左旋转之前的树中，node 是根节点，现在 x 变成了根节点，根节点的颜色应该保持一致。</li><li>node 的颜色应该设置为红色。在原来的 2-3 树中，新加入的节点 42 与 37 形成了一个新的 3 节点。通过左旋转之后，并没有改变 3 节点中的两个元素，只是置换了两个元素的位置（在红黑树中）。所以为了表示它们在旋转前后都是原来的 2-3 树中的同一个 3 节点，node 节点要设置为红色。</li></ul></li></ol></li></ul><p><img src="./1585151213731.png" alt="Alt text"><br><img src="./1585151171223.png" alt="Alt text"><br><img src="./1585151276886.png" alt="Alt text"><br><img src="./1585190185726.png" alt="Alt text"><br><img src="./1585151357938.png" alt="Alt text"></p><ul><li>注意：</li></ul><ol><li>左旋转只是一个子过程，在左旋转的过程中并不维持红黑树的性质，我们只需要通过旋转操作让两个元素对应是原来的 2-3 树中的一个 3 节点即可。</li><li>在左旋转之后有可能产生两个连续的红色节点。</li></ol><ul><li>代码实践：左旋转</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能描述: 对传入的node节点进行左旋转</span></span><br><span class="line"><span class="comment"> * 返回旋转之后新的子树的根节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   node                     x</span></span><br><span class="line"><span class="comment"> *  /    \     左旋转(node)  /   \</span></span><br><span class="line"><span class="comment"> * T1     x   ---------&gt;  node  T3</span></span><br><span class="line"><span class="comment"> *       / \              /   \</span></span><br><span class="line"><span class="comment"> *      T2 T3            T1   T2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>: [node]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: tree.redblacktree.RBTree.TreeNode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/3/15 23:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">leftRotate</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录node节点的右孩子x</span></span><br><span class="line">    TreeNode x = node.right;</span><br><span class="line">    <span class="comment">// 左旋转</span></span><br><span class="line">    node.right = x.left;</span><br><span class="line">    x.left = node;</span><br><span class="line">    <span class="comment">// 维持节点的颜色</span></span><br><span class="line">    x.color = node.color;</span><br><span class="line">    node.color = RED;</span><br><span class="line">    <span class="comment">// 返回旋转后子树的新的根节点，在添加元素的操作中会对根节点的颜色做进一步的处理。</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑥颜色翻转"><a href="#⑥颜色翻转" class="headerlink" title="⑥颜色翻转"></a>⑥颜色翻转</h4><ul><li><strong>向 2-3 树的 3 节点中添加一个新元素的第一种情况</strong> —&gt; 对应到红黑树中表示：如下图所示。</li></ul><p><img src="./1585191325921.png" alt="Alt text"><br><img src="./1585191796271.png" alt="Alt text"></p><ul><li>在上图的红黑树中添加一个新元素 66，应该添加到 42 的右孩子。—&gt; 对应到 2-3 树中表示：原来的 2-3 树中有一个 3 节点（37 | 42），添加一个新元素 66，形成一个临时的 4 节点（37 | 42 | 66）。</li><li>然后将临时的 4 节点变形成由 3 个 2 节点组成的子树。 —&gt; 对应到红黑树中表示：三个节点都应该是黑色的节点，我们需要将两个红色节点的颜色翻转成黑色。</li></ul><p><img src="./1585191845084.png" alt="Alt text"></p><ul><li>最后由 3 个 2 节点组成的子树的根节点要继续向上与其父亲节点进行融合。—&gt; 对应到红黑树中表示：需要将根节点的颜色翻转成红色。</li></ul><p><img src="./1585192443861.png" alt="Alt text"></p><ul><li>代码实践：颜色翻转</li></ul><p><img src="./1591323538754.png" alt="Alt text"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 功能描述: 颜色翻转</span></span><br><span class="line"><span class="comment">  * 调用前需要保证以node为根的子树满足翻转条件</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>: [node]</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@date</span>: 2020/3/15 11:16</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    node.color = RED;</span><br><span class="line">    node.left.color = BLACK;</span><br><span class="line">    node.right.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑦右旋转"><a href="#⑦右旋转" class="headerlink" title="⑦右旋转"></a>⑦右旋转</h4><ul><li><strong>向 2-3 树的 3 节点中添加一个新元素的第二种情况</strong> —&gt; 对应到红黑树中表示：如下图所示。</li></ul><p><img src="./1585192749464.png" alt="Alt text"><br><img src="./1585193005457.png" alt="Alt text"></p><ul><li>在上图的红黑树中添加一个新元素 12，应该添加到 37 的左孩子。—&gt; 对应到 2-3 树中表示：原来的 2-3 树中有一个 3 节点（37 | 42），添加一个新元素 12，形成一个临时的 4 节点（12 | 37 | 42）。</li><li>然后将临时的 4 节点变形成由 3 个 2 节点组成的子树 —&gt; 对应到红黑树中表示：需要先对节点 42 进行一次右旋转，右旋转之后，红黑树的结构满足进行颜色翻转的条件，此时再对红黑树进行一次颜色翻转，具体见 <strong>⑥颜色翻转</strong>。</li><li>右旋转的过程（注意：旋转前后的红黑树都要满足二分搜索树的性质）<ol><li>让 x 的右子树 T1 变成 node 的左子树</li><li>让 node 变成 x 的右子树</li><li>维护节点的颜色<ul><li>x 的颜色等于 node 的颜色（可能是红色，也可能是黑色），因为在右旋转之前的树中，node 是根节点，现在 x 变成了根节点，根节点的颜色应该保持一致。</li><li>node 的颜色应该设置为红色。因为在右旋转之后，三个节点对应到原来的 2-3 树中还是临时的 4 节点，所以 node 节点是红色表示它和它的父亲节点在原来的 2-3 树中是融合在一起的。</li></ul></li></ol></li></ul><p><img src="./1585193103904.png" alt="Alt text"><br><img src="./1585193143226.png" alt="Alt text"><br><img src="./1585193182809.png" alt="Alt text"><br><img src="./1585193261795.png" alt="Alt text"><br><img src="./1585193291665.png" alt="Alt text"><br><img src="./1585193369299.png" alt="Alt text"></p><ul><li>代码实践：右旋转</li></ul><p><img src="./1591323448245.png" alt="Alt text"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能描述: 对传入的node节点进行右旋转</span></span><br><span class="line"><span class="comment"> * 返回旋转之后新的子树的根节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *        y                            x</span></span><br><span class="line"><span class="comment"> *       / \                         /   \</span></span><br><span class="line"><span class="comment"> *      x   T4     向右旋转(y)        z     y</span></span><br><span class="line"><span class="comment"> *     / \       - - - - - - - -&gt;   / \   / \</span></span><br><span class="line"><span class="comment"> *    z   T3                      T1  T2 T3 T4</span></span><br><span class="line"><span class="comment"> *   / \</span></span><br><span class="line"><span class="comment"> * T1   T2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>: [node]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: tree.redblacktree.RBTree.TreeNode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/3/15 11:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">rightRotate</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录node节点的左孩子x</span></span><br><span class="line">    TreeNode x = node.left;</span><br><span class="line">    <span class="comment">// 右旋转</span></span><br><span class="line">    node.left = x.right;</span><br><span class="line">    x.right = node;</span><br><span class="line">    <span class="comment">// 维持节点的颜色</span></span><br><span class="line">    x.color = node.color;</span><br><span class="line">    node.color = RED;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li><strong>向 2-3 树的 3 节点中添加一个新元素的第三种情况</strong> —&gt; 对应到红黑树中表示：如下图所示。</li></ul><p><img src="./1585197158785.png" alt="Alt text"><br><img src="./1585197126604.png" alt="Alt text"></p><ul><li>在上图的红黑树中添加一个新元素 40，应该添加到 37 的右孩子。—&gt; 对应到 2-3 树中表示：原来的 2-3 树中有一个 3 节点（37 | 42），添加一个新元素 12，形成一个临时的 4 节点（37 | 40 | 42）。</li><li>然后将临时的 4 节点变形成由 3 个 2 节点组成的子树 —&gt; 对应到红黑树中表示：需要先对节点 37 进行一次左旋转，左旋转之后，红黑树的结构满足进行右旋转的条件，此时再对红黑树进行一次右旋转，具体见 <strong>⑦右旋转</strong>。</li></ul><p><img src="./1585197094171.png" alt="Alt text"><br><img src="./1585197060938.png" alt="Alt text"><br><img src="./1585197212159.png" alt="Alt text"><br><img src="./1585197245720.png" alt="Alt text"><br><img src="./1591323375387.png" alt="Alt text"></p><h4 id="⑧添加新元素"><a href="#⑧添加新元素" class="headerlink" title="⑧添加新元素"></a>⑧添加新元素</h4><ul><li>下图总结了在红黑树中添加新元素的所有情况：</li></ul><p><img src="./1591325370914.png" alt="Alt text"></p><ul><li>添加新元素后维护红黑树性质的方法：使用二分搜索树的策略将新元素添加进红黑树后，按照上图顺序依次判断该子树是否需要左旋转、右旋转和颜色翻转，然后将维护后的新的根节点返回给递归调用的上一层，在上一层继续维护红黑树的性质。</li><li>代码实践：添加新元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能描述: 向以node为根的红黑树中插入新的节点(key, value)</span></span><br><span class="line"><span class="comment"> * 返回插入新节点后红黑树的根</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>: [node, key, value]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: tree.redblacktree.RBTree.TreeNode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/3/15 17:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">insert</span><span class="params">(TreeNode node, <span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 搜索插入位置</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// 默认插入红色节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key == node.key) &#123;</span><br><span class="line">        node.value = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">        node.left = insert(node.left, key, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.right = insert(node.right, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 红黑树性质的维护</span></span><br><span class="line">    <span class="comment">// 是否需要左旋转</span></span><br><span class="line">    <span class="keyword">if</span> (isRed(node.right) &amp;&amp; !isRed(node.left)) &#123;</span><br><span class="line">        node = leftRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否需要右旋转</span></span><br><span class="line">    <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.left.left)) &#123;</span><br><span class="line">        node = rightRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否需要翻转</span></span><br><span class="line">    <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.right)) &#123;</span><br><span class="line">        flipColors(node);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑨删除新元素"><a href="#⑨删除新元素" class="headerlink" title="⑨删除新元素"></a>⑨删除新元素</h4><ul><li><a href="https://blog.csdn.net/ThinkWon/article/details/102571535" target="_blank" rel="noopener">参考链接</a></li></ul><h4 id="⑩代码实现-测试"><a href="#⑩代码实现-测试" class="headerlink" title="⑩代码实现 + 测试"></a>⑩代码实现 + 测试</h4><ul><li>查找方法与二分搜索树（红黑树是一种自平衡的二分搜索树）的查找方法一致</li><li>前序、中序、后序和层序遍历方法与树的遍历方法一致</li><li>红黑树的全部操作如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tree.redblacktree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/3/15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTree</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> TreeNode left;</span><br><span class="line">        <span class="keyword">public</span> TreeNode right;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> color;</span><br><span class="line">        </span><br><span class="line">        TreeNode(<span class="keyword">int</span> key, <span class="keyword">int</span> value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 默认的节点颜色为红色</span></span><br><span class="line">            <span class="keyword">this</span>.color = RED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> TreeNode node;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RBTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 判断节点的颜色</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [node]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: boolean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 12:23</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> BLACK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.color;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 查看以node为根的红黑树中是否包含键值为key的节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [node, key]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: boolean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 17:58</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contain</span><span class="params">(TreeNode node, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key == node.key) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">            <span class="keyword">return</span> contain(node.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> contain(node.right, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对传入的node节点进行左旋转</span></span><br><span class="line"><span class="comment">     * 返回旋转之后新的子树的根节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   node                     x</span></span><br><span class="line"><span class="comment">     *  /    \     左旋转(node)  /   \</span></span><br><span class="line"><span class="comment">     * T1     x   ---------&gt;  node  T3</span></span><br><span class="line"><span class="comment">     *       / \              /   \</span></span><br><span class="line"><span class="comment">     *      T2 T3            T1   T2</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [node]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: tree.redblacktree.RBTree.TreeNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 23:53</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">leftRotate</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录node节点的右孩子x</span></span><br><span class="line">        TreeNode x = node.right;</span><br><span class="line">        <span class="comment">// 左旋转</span></span><br><span class="line">        node.right = x.left;</span><br><span class="line">        x.left = node;</span><br><span class="line">        <span class="comment">// 维持节点的颜色</span></span><br><span class="line">        x.color = node.color;</span><br><span class="line">        node.color = RED;</span><br><span class="line">        <span class="comment">// 返回旋转后子树的新的根节点，在添加元素的操作中会对根节点的颜色做进一步的处理。</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对传入的node节点进行右旋转</span></span><br><span class="line"><span class="comment">     * 返回旋转之后新的子树的根节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *        y                            x</span></span><br><span class="line"><span class="comment">     *       / \                         /   \</span></span><br><span class="line"><span class="comment">     *      x   T4     向右旋转(y)        z     y</span></span><br><span class="line"><span class="comment">     *     / \       - - - - - - - -&gt;   / \   / \</span></span><br><span class="line"><span class="comment">     *    z   T3                      T1  T2 T3 T4</span></span><br><span class="line"><span class="comment">     *   / \</span></span><br><span class="line"><span class="comment">     * T1   T2</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [node]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: tree.redblacktree.RBTree.TreeNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 11:29</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">rightRotate</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录node节点的左孩子x</span></span><br><span class="line">        TreeNode x = node.left;</span><br><span class="line">        <span class="comment">// 右旋转</span></span><br><span class="line">        node.left = x.right;</span><br><span class="line">        x.right = node;</span><br><span class="line">        <span class="comment">// 维持节点的颜色</span></span><br><span class="line">        x.color = node.color;</span><br><span class="line">        node.color = RED;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 颜色翻转</span></span><br><span class="line"><span class="comment">     * 调用前需要保证以node为根的子树满足翻转条件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [node]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 11:16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        node.color = RED;</span><br><span class="line">        node.left.color = BLACK;</span><br><span class="line">        node.right.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 向以node为根的红黑树中插入新的节点(key, value)</span></span><br><span class="line"><span class="comment">     * 返回插入新节点后红黑树的根</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [node, key, value]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: tree.redblacktree.RBTree.TreeNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 17:50</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">insert</span><span class="params">(TreeNode node, <span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 搜索插入位置</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// 默认插入红色节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key == node.key) &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">            node.left = insert(node.left, key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.right = insert(node.right, key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 红黑树性质的维护</span></span><br><span class="line">        <span class="comment">// 是否需要左旋转</span></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.right) &amp;&amp; !isRed(node.left)) &#123;</span><br><span class="line">            node = leftRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否需要右旋转</span></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.left.left)) &#123;</span><br><span class="line">            node = rightRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否需要翻转</span></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.right)) &#123;</span><br><span class="line">            flipColors(node);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对以node为根的红黑树进行层序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [node]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 18:12</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(node);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode treeNode = queue.poll();</span><br><span class="line">            System.out.print(treeNode.key + <span class="string">"("</span> + treeNode.color + <span class="string">") "</span>);</span><br><span class="line">            <span class="keyword">if</span> (treeNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(treeNode.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (treeNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(treeNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对以node为根的红黑树进行前序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [node]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 1:29</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(node.key + <span class="string">" "</span>);</span><br><span class="line">        preOrder(node.left);</span><br><span class="line">        preOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对以node为根的红黑树进行中序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [node]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 17:58</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(node.left);</span><br><span class="line">        System.out.print(node.key + <span class="string">" "</span>);</span><br><span class="line">        inOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对以node为根的红黑树进行后序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [node]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 1:30</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postOrder(node.left);</span><br><span class="line">        postOrder(node.right);</span><br><span class="line">        System.out.print(node.key + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 判断是否包含key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [key]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: boolean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 17:55</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contain</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contain(node, key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 向红黑树中添加新的节点(key, value)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [key, value]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 17:55</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        node = insert(node, key, value);</span><br><span class="line">        <span class="comment">// 保持根节点为黑色</span></span><br><span class="line">        node.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 红黑树的层序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 17:45</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        levelOrder(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 红黑树的前序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 18:05</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        preOrder(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 红黑树的中序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 18:05</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inOrder(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 红黑树的后序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 18:05</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        postOrder(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试红黑树的代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tree.redblacktree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/3/15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 测试红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">42</span>, <span class="number">37</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="number">6</span>, <span class="number">11</span>&#125;;</span><br><span class="line">        RBTree rbTree = <span class="keyword">new</span> RBTree();</span><br><span class="line">        System.out.println(<span class="string">"红黑树是否为空: "</span> + rbTree.isEmpty());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            rbTree.insert(arr[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"红黑树的节点个数: "</span> + rbTree.size());</span><br><span class="line">        System.out.println(<span class="string">"红黑树的层序遍历: "</span>);</span><br><span class="line">        rbTree.levelOrder();</span><br><span class="line">        System.out.println(<span class="string">"\n红黑树的前序遍历: "</span>);</span><br><span class="line">        rbTree.preOrder();</span><br><span class="line">        System.out.println(<span class="string">"\n红黑树的中序遍历: "</span>);</span><br><span class="line">        rbTree.inOrder();</span><br><span class="line">        System.out.println(<span class="string">"\n红黑树的后序遍历: "</span>);</span><br><span class="line">        rbTree.postOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1591342373714.png" alt="Alt text"></p><ul><li>通过前序、中序、后序和层序遍历的结果可以推算出红黑树的结构：</li></ul><p><img src="./1585218547226.png" alt="Alt text"></p><ul><li>也可以推算出与其等价的 2-3 树的结构：</li></ul><p><img src="./1585218240250.png" alt="Alt text"></p><hr><h3 id="4-常见面试问题"><a href="#4-常见面试问题" class="headerlink" title="4.常见面试问题"></a>4.常见面试问题</h3><h4 id="①红黑树的数据结构是怎么定义的？"><a href="#①红黑树的数据结构是怎么定义的？" class="headerlink" title="①红黑树的数据结构是怎么定义的？"></a>①红黑树的数据结构是怎么定义的？</h4><ul><li>具体见 <strong>3.红黑树—③数据结构</strong></li></ul><h4 id="②红黑树有哪些性质？"><a href="#②红黑树有哪些性质？" class="headerlink" title="②红黑树有哪些性质？"></a>②红黑树有哪些性质？</h4><ul><li>具体见 <strong>3.红黑树—②基本性质</strong></li></ul><h4 id="③红黑树的各种操作的时间复杂度是多少？"><a href="#③红黑树的各种操作的时间复杂度是多少？" class="headerlink" title="③红黑树的各种操作的时间复杂度是多少？"></a>③红黑树的各种操作的时间复杂度是多少？</h4><ul><li>最大高度： <code>2logn</code>（<code>logn</code> 个红色节点 + <code>logn</code> 个黑色节点，此时该条路径上每一个黑色节点的左孩子都是红色节点。）</li><li>增删改查的时间复杂度：<code>O（logn）</code></li></ul><h4 id="④红黑树相比于-BST-和-AVL-树有什么优点？"><a href="#④红黑树相比于-BST-和-AVL-树有什么优点？" class="headerlink" title="④红黑树相比于 BST 和 AVL 树有什么优点？"></a>④红黑树相比于 BST 和 AVL 树有什么优点？</h4><ul><li>BST：最大高度不定，可能会退化为链表。<ul><li>优点：内部实现简单，没有复杂的维持平衡的操作。对于完全随机的数据，并不会退化为链表。</li><li>缺点：极端情况会退化为链表（数据按顺序进入二分搜索树时）或者高度不平衡（数据近乎有序时）</li></ul></li><li>AVL 树：采用了平衡二叉树的策略，最大高度为 <code>logn</code>，且不会退化为链表，对于查询操作（get、set、contain 等方法）性能较高。</li><li>红黑树：并不完全满足平衡二叉树的定义，最大高度为 <code>2logn</code>，它可以保持自平衡而不会退化为链表，对于插入和删除操作（insert、delete 等方法）性能较高。 </li><li>AVL 树和红黑树的对比：<ul><li>它们都是在二分搜索树的基础上添加了一些其他的性质，来保证自己不会退化为链表。</li><li>红黑树的增删操作快于 AVL 树，查找操作慢于 AVL 树（因为 AVL 树的最大高度是 <code>logn</code>，红黑树的最大高度是 <code>2logn</code>，它们是常数级别的差异），所以 AVL 树适用于查询较多的情况，而红黑树适用于插入和删除较多的情况。</li><li>红黑树的统计性能更优，虽然其时间复杂度与 AVL 树是同一个级别的，但是综合增删改查所有的操作，红黑树在平均情况下更好一些。</li><li>总结：红黑树相对于 AVL 树来说，牺牲了部分平衡性以换取插入 / 删除操作时少量的旋转操作，整体性能要优于 AVL 树。</li></ul></li></ul><h4 id="⑤红黑树的应用？"><a href="#⑤红黑树的应用？" class="headerlink" title="⑤红黑树的应用？"></a>⑤红黑树的应用？</h4><ul><li>由于红黑树的统计性能（综合增删改查所有的操作）更优，所以很多语言内部的容器类中的有序映射都是基于红黑树实现的。例如：Java 中的 TreeMap、TreeSet、JDK 1.8 后的 HashMap 和 C++ 的 STL 中的 map 和 set。</li><li><a href="https://messi1002.top/2020/03/04/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Java集合框架总结+源码分析</a></li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#106;&#121;&#x6d;&#101;&#x73;&#115;&#105;&#x40;&#49;&#54;&#51;&#x2e;&#x63;&#x6f;&#109;" target="_blank" rel="noopener">&#x77;&#106;&#121;&#x6d;&#101;&#x73;&#115;&#105;&#x40;&#49;&#54;&#51;&#x2e;&#x63;&#x6f;&#109;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-相关博客&quot;&gt;&lt;a href=&quot;#1-相关博客&quot; class=&quot;headerlink&quot; title=&quot;1.相关博客&quot;&gt;&lt;/a&gt;1.相关博客&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://messi1002.top/2019/02/08/%E4%BA
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://messi1002.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法总结" scheme="http://messi1002.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="树" scheme="http://messi1002.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 1115. 交替打印FooBar（Medium）Java语言题解</title>
    <link href="http://messi1002.top/2020/03/01/LeetCode-1115-%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0FooBar%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/"/>
    <id>http://messi1002.top/2020/03/01/LeetCode-1115-交替打印FooBar（Medium）Java语言题解/</id>
    <published>2020-03-01T05:27:27.000Z</published>
    <updated>2020-06-12T12:54:14.632Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目相关"><a href="#1-题目相关" class="headerlink" title="1.题目相关"></a>1.题目相关</h3><h4 id="①题目及示例"><a href="#①题目及示例" class="headerlink" title="①题目及示例"></a>①题目及示例</h4><p><img src="./1583213174374.png" alt="Alt text"><br><img src="./1583213199829.png" alt="Alt text"></p><h4 id="②相关标签"><a href="#②相关标签" class="headerlink" title="②相关标签"></a>②相关标签</h4><ul><li>多线程</li></ul><h4 id="③题目地址"><a href="#③题目地址" class="headerlink" title="③题目地址"></a>③题目地址</h4><ul><li><a href="https://leetcode-cn.com/problems/print-foobar-alternately/" target="_blank" rel="noopener">1115. 交替打印FooBar — 力扣网</a></li></ul><hr><h3 id="2-解题方法"><a href="#2-解题方法" class="headerlink" title="2.解题方法"></a>2.解题方法</h3><h4 id="①synchronized-关键字-this-锁对象"><a href="#①synchronized-关键字-this-锁对象" class="headerlink" title="①synchronized 关键字 + this 锁对象"></a>①synchronized 关键字 + this 锁对象</h4><ul><li>原因：两个线程属于同一个实例，虽然两个线程访问的是一个类的不同的普通同步方法，但是两个普通同步方法默认都是以 this 对象作为同步方法的锁，所以它们会争抢同一把锁（对于同一个实例来讲，两个方法的 this 对象是同一个）。</li><li>结果：两个线程争抢同一把锁，同一时刻只能有一个线程执行该线程对应的同步方法，然后再使用 wait 方法和 notify 方法，使得两个线程交替运行。</li></ul><h4 id="②lock-condition"><a href="#②lock-condition" class="headerlink" title="②lock + condition"></a>②lock + condition</h4><ul><li>lock 代替 synchronized 关键字</li><li>condition 中的 await 方法和 release 方法代替 Object 对象的 wait 方法和 notify 方法</li></ul><h4 id="③信号量"><a href="#③信号量" class="headerlink" title="③信号量"></a>③信号量</h4><ul><li>两个线程第一次执行时，因为 bar 信号量的计数器初始值为 0，所以需要等 foo 线程中释放了 bar 信号量，bar 线程才能开始执行。而 foo 信号量在获取了一个许可后，其计数器值也变为 0，所以 foo 线程在下一次循环开始时需要等 bar 线程中释放了 foo 信号量，foo 线程才能继续执行。</li></ul><h4 id="④CountDownLatch-CyclicBarrier"><a href="#④CountDownLatch-CyclicBarrier" class="headerlink" title="④CountDownLatch + CyclicBarrier"></a>④CountDownLatch + CyclicBarrier</h4><ul><li>CyclicBarrier 用于保证任务按组循环执行</li><li>CounDownLatch 用于保证一个循环内线程执行的先后顺序</li><li>具体实现见代码</li></ul><hr><h3 id="3-代码详解"><a href="#3-代码详解" class="headerlink" title="3.代码详解"></a>3.代码详解</h3><h4 id="①synchronized-关键字-this-锁对象-1"><a href="#①synchronized-关键字-this-锁对象-1" class="headerlink" title="①synchronized 关键字 + this 锁对象"></a>①synchronized 关键字 + this 锁对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.synchronized关键字+this锁对象(两个不同的线程将会共用一个FooBar实例)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                printFoo.run();</span><br><span class="line">                <span class="comment">// 唤醒另一个线程</span></span><br><span class="line">                <span class="keyword">this</span>.notify();</span><br><span class="line">                <span class="comment">// 自己陷入等待</span></span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                printBar.run();</span><br><span class="line">                <span class="comment">// 唤醒另一个线程</span></span><br><span class="line">                <span class="keyword">this</span>.notify();</span><br><span class="line">                <span class="comment">// 防止线程在最后一次打印Bar时睡眠，从而造成死锁。</span></span><br><span class="line">                <span class="keyword">if</span> (i != n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 自己陷入等待</span></span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②lock-condition-1"><a href="#②lock-condition-1" class="headerlink" title="②lock + condition"></a>②lock + condition</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.lock+condition</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            printFoo.run();</span><br><span class="line">            <span class="comment">// 唤醒另一个线程</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">            <span class="comment">// 自己陷入等待</span></span><br><span class="line">            condition.await();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            printBar.run();</span><br><span class="line">            <span class="comment">// 唤醒另一个线程</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">            <span class="comment">// 防止线程在最后一次打印Bar时睡眠，从而造成死锁。</span></span><br><span class="line">            <span class="keyword">if</span> (i != n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 自己陷入等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③信号量-1"><a href="#③信号量-1" class="headerlink" title="③信号量"></a>③信号量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.信号量(Semaphore)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> Semaphore foo = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> Semaphore bar = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 获取foo信号量的一个许可</span></span><br><span class="line">            foo.acquire();</span><br><span class="line">            printFoo.run();</span><br><span class="line">            <span class="comment">// 释放bar信号量的一个许可</span></span><br><span class="line">            bar.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 获取bar信号量的一个许可</span></span><br><span class="line">            bar.acquire();</span><br><span class="line">            printBar.run();</span><br><span class="line">            <span class="comment">// 释放foo信号量的一个许可</span></span><br><span class="line">            foo.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="④CountDownLatch-CyclicBarrier-1"><a href="#④CountDownLatch-CyclicBarrier-1" class="headerlink" title="④CountDownLatch + CyclicBarrier"></a>④CountDownLatch + CyclicBarrier</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.CountDownLatch+CyclicBarrier</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">// CyclicBarrier用于保证任务按组循环执行</span></span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// CounDownLatch用于保证一个循环内线程执行的先后顺序</span></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                printFoo.run();</span><br><span class="line">                <span class="comment">// 触发bar线程执行</span></span><br><span class="line">                latch.countDown();</span><br><span class="line">                <span class="comment">// 等待bar线程执行完成</span></span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span>(Exception e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 等待被触发</span></span><br><span class="line">                latch.await();</span><br><span class="line">                printBar.run();</span><br><span class="line">                latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 触发foo线程和bar线程继续执行(进行下一次循环)</span></span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#106;&#121;&#109;&#101;&#x73;&#115;&#x69;&#64;&#x31;&#x36;&#51;&#46;&#99;&#111;&#109;" target="_blank" rel="noopener">&#x77;&#106;&#121;&#109;&#101;&#x73;&#115;&#x69;&#64;&#x31;&#x36;&#51;&#46;&#99;&#111;&#109;</a></li><li>关于 <strong>数据结构与算法</strong> 的更多代码 请查看我的 <a href="https://github.com/messi1002/leetcode" target="_blank" rel="noopener">GitHub仓库</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目相关&quot;&gt;&lt;a href=&quot;#1-题目相关&quot; class=&quot;headerlink&quot; title=&quot;1.题目相关&quot;&gt;&lt;/a&gt;1.题目相关&lt;/h3&gt;&lt;h4 id=&quot;①题目及示例&quot;&gt;&lt;a href=&quot;#①题目及示例&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="LeetCode-多线程题解" scheme="http://messi1002.top/categories/Java/LeetCode-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="LeetCode题解" scheme="http://messi1002.top/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 1188. 设计有限阻塞队列（Medium）Java语言题解</title>
    <link href="http://messi1002.top/2020/03/01/LeetCode-1188-%E8%AE%BE%E8%AE%A1%E6%9C%89%E9%99%90%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/"/>
    <id>http://messi1002.top/2020/03/01/LeetCode-1188-设计有限阻塞队列（Medium）Java语言题解/</id>
    <published>2020-03-01T05:25:08.000Z</published>
    <updated>2020-06-12T12:54:16.794Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目相关"><a href="#1-题目相关" class="headerlink" title="1.题目相关"></a>1.题目相关</h3><h4 id="①题目及示例"><a href="#①题目及示例" class="headerlink" title="①题目及示例"></a>①题目及示例</h4><p><img src="./1583212951968.png" alt="Alt text"><br><img src="./1583213004641.png" alt="Alt text"></p><h4 id="②相关标签"><a href="#②相关标签" class="headerlink" title="②相关标签"></a>②相关标签</h4><ul><li>多线程</li></ul><h4 id="③题目地址"><a href="#③题目地址" class="headerlink" title="③题目地址"></a>③题目地址</h4><ul><li><a href="https://leetcode-cn.com/problems/design-bounded-blocking-queue/" target="_blank" rel="noopener">1188. 设计有限阻塞队列 — 力扣网</a></li></ul><hr><h3 id="2-解题方法"><a href="#2-解题方法" class="headerlink" title="2.解题方法"></a>2.解题方法</h3><ul><li>使用 LinkedList 集合模拟阻塞队列</li><li>存储当前队列元素个数的变量是 AtomicInteger 类型（来保证原子性）</li></ul><h4 id="①synchronized-关键字-this-锁对象"><a href="#①synchronized-关键字-this-锁对象" class="headerlink" title="①synchronized 关键字 + this 锁对象"></a>①synchronized 关键字 + this 锁对象</h4><ul><li>使用 synchronized 关键字对入队和出队操作加锁</li><li>使用 Object 对象的 wait 方法 和 notify 方法控制两个线程的相互等待和唤醒操作</li></ul><h4 id="②lock-condition"><a href="#②lock-condition" class="headerlink" title="②lock + condition"></a>②lock + condition</h4><ul><li>使用 lock 对入队和出队操作加锁</li><li>使用 condition 控制两个线程的相互等待和唤醒操作</li></ul><hr><h3 id="3-代码详解"><a href="#3-代码详解" class="headerlink" title="3.代码详解"></a>3.代码详解</h3><h4 id="①synchronized-关键字-this-锁对象-1"><a href="#①synchronized-关键字-this-锁对象-1" class="headerlink" title="①synchronized 关键字 + this 锁对象"></a>①synchronized 关键字 + this 锁对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.synchronized关键字+this锁对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBlockingQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用线程安全的集合实现一个阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 存储当前队列元素个数</span></span><br><span class="line">    AtomicInteger size = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 存储队列长度上限</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> element)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果队列满，调用线程被阻塞直到队列非满。</span></span><br><span class="line">            <span class="keyword">while</span> (size.get() &gt;= capacity) &#123;</span><br><span class="line">                <span class="comment">// 线程阻塞时会释放锁</span></span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在队首增加一个element</span></span><br><span class="line">            list.addFirst(element);</span><br><span class="line">            <span class="comment">// 当前队列元素个数加一</span></span><br><span class="line">            size.incrementAndGet();</span><br><span class="line">            <span class="comment">// 通知消费者线程可以继续消费了</span></span><br><span class="line">            <span class="keyword">this</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dequeue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果队列空，调用线程被阻塞直到队列非空。</span></span><br><span class="line">            <span class="keyword">while</span> (size.get() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 线程阻塞时会释放锁</span></span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回队尾元素并从队列中将其删除</span></span><br><span class="line">            <span class="keyword">int</span> value = list.getLast();</span><br><span class="line">            list.removeLast();</span><br><span class="line">            <span class="comment">// 当前队列元素个数减一</span></span><br><span class="line">            size.decrementAndGet();</span><br><span class="line">            <span class="comment">// 通知生产者线程可以继续生产了</span></span><br><span class="line">            <span class="keyword">this</span>.notify();</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②lock-condition-1"><a href="#②lock-condition-1" class="headerlink" title="②lock + condition"></a>②lock + condition</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.lock+condition</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBlockingQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用线程安全的集合实现一个阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 存储当前队列元素个数</span></span><br><span class="line">    AtomicInteger size = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 存储队列长度上限</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition procuder = lock.newCondition();</span><br><span class="line">    Condition consumer = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> element)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">// 如果队列满，调用线程被阻塞直到队列非满。</span></span><br><span class="line">            <span class="keyword">while</span> (size.get() &gt;= capacity) &#123;</span><br><span class="line">                <span class="comment">// 线程阻塞时会释放锁</span></span><br><span class="line">                procuder.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在队首增加一个element</span></span><br><span class="line">            list.addFirst(element);</span><br><span class="line">            <span class="comment">// 当前队列元素个数加一</span></span><br><span class="line">            size.incrementAndGet();</span><br><span class="line">            <span class="comment">// 通知消费者线程可以继续消费了</span></span><br><span class="line">            consumer.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dequeue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">// 如果队列空，调用线程被阻塞直到队列非空。</span></span><br><span class="line">            <span class="keyword">while</span> (size.get() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 线程阻塞时会释放锁</span></span><br><span class="line">                consumer.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回队尾元素并从队列中将其删除</span></span><br><span class="line">            <span class="keyword">int</span> value = list.getLast();</span><br><span class="line">            list.removeLast();</span><br><span class="line">            <span class="comment">// 当前队列元素个数减一</span></span><br><span class="line">            size.decrementAndGet();</span><br><span class="line">            <span class="comment">// 通知生产者线程可以继续生产了</span></span><br><span class="line">            procuder.signal();</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#119;&#106;&#x79;&#x6d;&#x65;&#x73;&#115;&#105;&#x40;&#x31;&#x36;&#x33;&#x2e;&#99;&#x6f;&#x6d;" target="_blank" rel="noopener">&#119;&#106;&#x79;&#x6d;&#x65;&#x73;&#115;&#105;&#x40;&#x31;&#x36;&#x33;&#x2e;&#99;&#x6f;&#x6d;</a></li><li>关于 <strong>数据结构与算法</strong> 的更多代码 请查看我的 <a href="https://github.com/messi1002/leetcode" target="_blank" rel="noopener">GitHub仓库</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目相关&quot;&gt;&lt;a href=&quot;#1-题目相关&quot; class=&quot;headerlink&quot; title=&quot;1.题目相关&quot;&gt;&lt;/a&gt;1.题目相关&lt;/h3&gt;&lt;h4 id=&quot;①题目及示例&quot;&gt;&lt;a href=&quot;#①题目及示例&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="LeetCode-多线程题解" scheme="http://messi1002.top/categories/Java/LeetCode-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="LeetCode题解" scheme="http://messi1002.top/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 1195. 交替打印字符串（Medium）Java语言题解</title>
    <link href="http://messi1002.top/2020/03/01/LeetCode-1195-%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/"/>
    <id>http://messi1002.top/2020/03/01/LeetCode-1195-交替打印字符串（Medium）Java语言题解/</id>
    <published>2020-03-01T05:17:28.000Z</published>
    <updated>2020-06-12T12:54:19.329Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目相关"><a href="#1-题目相关" class="headerlink" title="1.题目相关"></a>1.题目相关</h3><h4 id="①题目及示例"><a href="#①题目及示例" class="headerlink" title="①题目及示例"></a>①题目及示例</h4><p><img src="./1583212471785.png" alt="Alt text"></p><h4 id="②相关标签"><a href="#②相关标签" class="headerlink" title="②相关标签"></a>②相关标签</h4><ul><li>多线程</li></ul><h4 id="③题目地址"><a href="#③题目地址" class="headerlink" title="③题目地址"></a>③题目地址</h4><ul><li><a href="https://leetcode-cn.com/problems/fizz-buzz-multithreaded/" target="_blank" rel="noopener">1195. 交替打印字符串 — 力扣网</a></li></ul><hr><h3 id="2-解题方法"><a href="#2-解题方法" class="headerlink" title="2.解题方法"></a>2.解题方法</h3><h4 id="①synchronized-关键字-this-锁对象"><a href="#①synchronized-关键字-this-锁对象" class="headerlink" title="①synchronized 关键字 + this 锁对象"></a>①synchronized 关键字 + this 锁对象</h4><ul><li>原因：四个线程属于同一个实例，虽然四个线程访问的是一个类的不同的普通同步方法，但是四个普通同步方法默认都是以 this 对象作为同步方法的锁，所以它们会争抢同一把锁（对于同一个实例来讲，四个方法的 this 对象是同一个）。</li><li>结果：四个线程争抢同一把锁，同一时刻只能有一个线程执行该线程对应的同步方法，然后再使用 wait 方法和 notify 方法，使得四个线程交替运行。</li></ul><h4 id="②lock-condition"><a href="#②lock-condition" class="headerlink" title="②lock + condition"></a>②lock + condition</h4><ul><li>lock 代替 synchronized 关键字</li><li>condition 中的 await 方法和 release 方法代替 Object 对象的 wait 方法和 notify 方法</li></ul><h4 id="③信号量"><a href="#③信号量" class="headerlink" title="③信号量"></a>③信号量</h4><ul><li>四个线程第一次执行时，因为只有 number 信号量的计数器初始值为 1，其余都为 0，所以 number 线程先执行，让它不断判断接下来该哪个线程执行，并释放对应线程的信号量，对应线程执行一次循环后，释放 number 信号量，以便 number 线程继续判断。</li></ul><h4 id="④原子变量"><a href="#④原子变量" class="headerlink" title="④原子变量"></a>④原子变量</h4><ul><li>使用一个原子变量控制，把并发调用变成按顺序调用。</li></ul><h4 id="⑤volatile-关键字"><a href="#⑤volatile-关键字" class="headerlink" title="⑤volatile 关键字"></a>⑤volatile 关键字</h4><ul><li>使用 volatile 关键字保证变量的可见性，把并发调用变成按顺序调用。</li></ul><hr><h3 id="3-代码详解"><a href="#3-代码详解" class="headerlink" title="3.代码详解"></a>3.代码详解</h3><h4 id="①synchronized-关键字-this-锁对象-1"><a href="#①synchronized-关键字-this-锁对象-1" class="headerlink" title="①synchronized 关键字 + this 锁对象"></a>①synchronized 关键字 + this 锁对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.synchronized关键字+this锁对象(四个不同的线程将会共用一个FizzBuzz实例)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FizzBuzz</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizz</span><span class="params">(Runnable printFizz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num &lt;= n) &#123;    </span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// 是3的倍数且不是5的倍数</span></span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; num % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                    printFizz.run();</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 唤醒所有线程</span></span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">                <span class="comment">// 防止线程在最后一次打印时睡眠，从而造成死锁。</span></span><br><span class="line">                <span class="keyword">if</span> (num &lt;= n) &#123;</span><br><span class="line">                    <span class="comment">// 自己陷入等待</span></span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buzz</span><span class="params">(Runnable printBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num &lt;= n) &#123;    </span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// 是5的倍数且不是3的倍数</span></span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">5</span> == <span class="number">0</span> &amp;&amp; num % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                    printBuzz.run();</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 唤醒所有线程</span></span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">                <span class="comment">// 防止线程在最后一次打印时睡眠，从而造成死锁。</span></span><br><span class="line">                <span class="keyword">if</span> (num &lt;= n) &#123;</span><br><span class="line">                    <span class="comment">// 自己陷入等待</span></span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span><span class="params">(Runnable printFizzBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">         <span class="keyword">while</span> (num &lt;= n) &#123;    </span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// 是3的倍数且是5的倍数</span></span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; num % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    printFizzBuzz.run();</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 唤醒所有线程</span></span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">                <span class="comment">// 防止线程在最后一次打印时睡眠，从而造成死锁。</span></span><br><span class="line">                <span class="keyword">if</span> (num &lt;= n) &#123;</span><br><span class="line">                    <span class="comment">// 自己陷入等待</span></span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">number</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num &lt;= n) &#123;    </span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// 不是3的倍数且不是5的倍数</span></span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">3</span> != <span class="number">0</span> &amp;&amp; num % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                    printNumber.accept(num);</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 唤醒所有线程</span></span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">                <span class="comment">// 防止线程在最后一次打印时睡眠，从而造成死锁。</span></span><br><span class="line">                <span class="keyword">if</span> (num &lt;= n) &#123;</span><br><span class="line">                    <span class="comment">// 自己陷入等待</span></span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②lock-condition-1"><a href="#②lock-condition-1" class="headerlink" title="②lock + condition"></a>②lock + condition</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.lock+condition</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FizzBuzz</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizz</span><span class="params">(Runnable printFizz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num &lt;= n) &#123;    </span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">// 是3的倍数且不是5的倍数</span></span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; num % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                printFizz.run();</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 唤醒所有线程</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">            <span class="comment">// 防止线程在最后一次打印时睡眠，从而造成死锁。</span></span><br><span class="line">            <span class="keyword">if</span> (num &lt;= n) &#123;</span><br><span class="line">                <span class="comment">// 自己陷入等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buzz</span><span class="params">(Runnable printBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num &lt;= n) &#123; </span><br><span class="line">            lock.lock();   </span><br><span class="line">            <span class="comment">// 是5的倍数且不是3的倍数</span></span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">5</span> == <span class="number">0</span> &amp;&amp; num % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                printBuzz.run();</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 唤醒所有线程</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">            <span class="comment">// 防止线程在最后一次打印时睡眠，从而造成死锁。</span></span><br><span class="line">            <span class="keyword">if</span> (num &lt;= n) &#123;</span><br><span class="line">                <span class="comment">// 自己陷入等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span><span class="params">(Runnable printFizzBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">         <span class="keyword">while</span> (num &lt;= n) &#123;</span><br><span class="line">            lock.lock();    </span><br><span class="line">            <span class="comment">// 是3的倍数且是5的倍数</span></span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; num % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                printFizzBuzz.run();</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 唤醒所有线程</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">            <span class="comment">// 防止线程在最后一次打印时睡眠，从而造成死锁。</span></span><br><span class="line">            <span class="keyword">if</span> (num &lt;= n) &#123;</span><br><span class="line">                <span class="comment">// 自己陷入等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">number</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num &lt;= n) &#123; </span><br><span class="line">            lock.lock();   </span><br><span class="line">            <span class="comment">// 不是3的倍数且不是5的倍数</span></span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">3</span> != <span class="number">0</span> &amp;&amp; num % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                printNumber.accept(num);</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 唤醒所有线程</span></span><br><span class="line">            condition.signalAll();            </span><br><span class="line">            <span class="comment">// 防止线程在最后一次打印时睡眠，从而造成死锁。</span></span><br><span class="line">            <span class="keyword">if</span> (num &lt;= n) &#123;</span><br><span class="line">                <span class="comment">// 自己陷入等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③信号量-1"><a href="#③信号量-1" class="headerlink" title="③信号量"></a>③信号量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.信号量(Semaphore)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FizzBuzz</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> Semaphore fizz = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> Semaphore buzz = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> Semaphore fizzbuzz = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> Semaphore number = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizz</span><span class="params">(Runnable printFizz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i += <span class="number">3</span>) &#123;     </span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取fizz信号量的一个许可</span></span><br><span class="line">                fizz.acquire();</span><br><span class="line">                printFizz.run();</span><br><span class="line">                <span class="comment">// 释放number信号量的一个许可</span></span><br><span class="line">                number.release();</span><br><span class="line">            &#125;             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buzz</span><span class="params">(Runnable printBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= n; i += <span class="number">5</span>) &#123;      </span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取buzz信号量的一个许可</span></span><br><span class="line">                buzz.acquire();</span><br><span class="line">                printBuzz.run();</span><br><span class="line">                <span class="comment">// 释放number信号量的一个许可</span></span><br><span class="line">                number.release();</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span><span class="params">(Runnable printFizzBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">15</span>; i &lt;= n; i += <span class="number">15</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取fizzbuzz信号量的一个许可</span></span><br><span class="line">            fizzbuzz.acquire();</span><br><span class="line">            printFizzBuzz.run();</span><br><span class="line">            <span class="comment">// 释放number信号量的一个许可</span></span><br><span class="line">            number.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">number</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 获取number信号量的一个许可</span></span><br><span class="line">            number.acquire();</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 释放fizzbuzz信号量的一个许可</span></span><br><span class="line">                fizzbuzz.release();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 释放fizz信号量的一个许可</span></span><br><span class="line">                fizz.release();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 释放buzz信号量的一个许可</span></span><br><span class="line">                buzz.release();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                printNumber.accept(i);</span><br><span class="line">                <span class="comment">// 释放number信号量的一个许可</span></span><br><span class="line">                number.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="④原子变量-1"><a href="#④原子变量-1" class="headerlink" title="④原子变量"></a>④原子变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.原子变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FizzBuzz</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger num = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizz</span><span class="params">(Runnable printFizz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num.get() &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = num.get();</span><br><span class="line">            <span class="comment">// 是3的倍数且不是5的倍数</span></span><br><span class="line">            <span class="keyword">if</span> (temp % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; temp % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                printFizz.run();</span><br><span class="line">                num.getAndIncrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buzz</span><span class="params">(Runnable printBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num.get() &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = num.get();</span><br><span class="line">            <span class="comment">// 不是3的倍数且是5的倍数</span></span><br><span class="line">            <span class="keyword">if</span> (temp % <span class="number">3</span> != <span class="number">0</span> &amp;&amp; temp % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                printBuzz.run();</span><br><span class="line">                num.getAndIncrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span><span class="params">(Runnable printFizzBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num.get() &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = num.get();</span><br><span class="line">            <span class="comment">// 是3的倍数且是5的倍数</span></span><br><span class="line">            <span class="keyword">if</span> (temp % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; temp % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                printFizzBuzz.run();</span><br><span class="line">                num.getAndIncrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">number</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num.get() &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = num.get();</span><br><span class="line">            <span class="comment">// 不是3的倍数且不是5的倍数</span></span><br><span class="line">            <span class="keyword">if</span> (temp % <span class="number">3</span> != <span class="number">0</span> &amp;&amp; temp % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                printNumber.accept(temp);</span><br><span class="line">                num.getAndIncrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑤volatile-关键字-1"><a href="#⑤volatile-关键字-1" class="headerlink" title="⑤volatile 关键字"></a>⑤volatile 关键字</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.volatile关键字</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FizzBuzz</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizz</span><span class="params">(Runnable printFizz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i += <span class="number">3</span>) &#123;   </span><br><span class="line">            <span class="comment">// 是3的倍数且不是5的倍数</span></span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (flag != <span class="number">1</span>) &#123; Thread.sleep(<span class="number">1</span>);&#125;</span><br><span class="line">                printFizz.run();</span><br><span class="line">                <span class="comment">// 将控制权交还给number()方法</span></span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buzz</span><span class="params">(Runnable printBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= n; i += <span class="number">5</span>) &#123; </span><br><span class="line">            <span class="comment">// 不是3的倍数且是5的倍数</span></span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (flag != <span class="number">2</span>) &#123; Thread.sleep(<span class="number">1</span>);&#125;</span><br><span class="line">                printBuzz.run();</span><br><span class="line">                <span class="comment">// 控制权交还给number()方法</span></span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span><span class="params">(Runnable printFizzBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">15</span>; i &lt;= n; i += <span class="number">15</span>) &#123;</span><br><span class="line">            <span class="comment">// 是3的倍数且是5的倍数</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">3</span>) &#123; Thread.sleep(<span class="number">1</span>);&#125;</span><br><span class="line">            printFizzBuzz.run();</span><br><span class="line">            <span class="comment">// 控制权交还给number()方法</span></span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">number</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">0</span>) &#123; Thread.sleep(<span class="number">1</span>);&#125;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不是3的倍数且不是5的倍数</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                printNumber.accept(i);</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#x6a;&#121;&#109;&#x65;&#115;&#115;&#105;&#x40;&#x31;&#x36;&#x33;&#x2e;&#99;&#111;&#109;" target="_blank" rel="noopener">&#x77;&#x6a;&#121;&#109;&#x65;&#115;&#115;&#105;&#x40;&#x31;&#x36;&#x33;&#x2e;&#99;&#111;&#109;</a></li><li>关于 <strong>数据结构与算法</strong> 的更多代码 请查看我的 <a href="https://github.com/messi1002/leetcode" target="_blank" rel="noopener">GitHub仓库</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目相关&quot;&gt;&lt;a href=&quot;#1-题目相关&quot; class=&quot;headerlink&quot; title=&quot;1.题目相关&quot;&gt;&lt;/a&gt;1.题目相关&lt;/h3&gt;&lt;h4 id=&quot;①题目及示例&quot;&gt;&lt;a href=&quot;#①题目及示例&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="LeetCode-多线程题解" scheme="http://messi1002.top/categories/Java/LeetCode-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="LeetCode题解" scheme="http://messi1002.top/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 1116. 打印零与奇偶数（Medium）Java语言题解</title>
    <link href="http://messi1002.top/2020/03/01/LeetCode-1116-%E6%89%93%E5%8D%B0%E9%9B%B6%E4%B8%8E%E5%A5%87%E5%81%B6%E6%95%B0%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/"/>
    <id>http://messi1002.top/2020/03/01/LeetCode-1116-打印零与奇偶数（Medium）Java语言题解/</id>
    <published>2020-03-01T05:13:37.000Z</published>
    <updated>2020-06-12T12:54:15.704Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目相关"><a href="#1-题目相关" class="headerlink" title="1.题目相关"></a>1.题目相关</h3><h4 id="①题目及示例"><a href="#①题目及示例" class="headerlink" title="①题目及示例"></a>①题目及示例</h4><p><img src="./1583212287951.png" alt="Alt text"><br><img src="./1583212316793.png" alt="Alt text"></p><h4 id="②相关标签"><a href="#②相关标签" class="headerlink" title="②相关标签"></a>②相关标签</h4><ul><li>多线程</li></ul><h4 id="③题目地址"><a href="#③题目地址" class="headerlink" title="③题目地址"></a>③题目地址</h4><ul><li><a href="https://leetcode-cn.com/problems/print-zero-even-odd/" target="_blank" rel="noopener">1116. 打印零与奇偶数 — 力扣网</a></li></ul><hr><h3 id="2-解题方法"><a href="#2-解题方法" class="headerlink" title="2.解题方法"></a>2.解题方法</h3><h4 id="①synchronized-关键字-this-锁对象"><a href="#①synchronized-关键字-this-锁对象" class="headerlink" title="①synchronized 关键字 + this 锁对象"></a>①synchronized 关键字 + this 锁对象</h4><ul><li>原因：三个线程属于同一个实例，虽然三个线程访问的是一个类的不同的普通同步方法，但是三个普通同步方法默认都是以 this 对象作为同步方法的锁，所以它们会争抢同一把锁（对于同一个实例来讲，三个方法的 this 对象是同一个）。</li><li>结果：三个线程争抢同一把锁，同一时刻只能有一个线程执行该线程对应的同步方法，然后再使用 wait 方法和 notify 方法，使得三个线程按题意顺序运行。</li></ul><h4 id="②lock-condition"><a href="#②lock-condition" class="headerlink" title="②lock + condition"></a>②lock + condition</h4><ul><li>lock 代替 synchronized 关键字</li><li>condition 中的 await 方法和 release 方法代替 Object 对象的 wait 方法和 notify 方法</li></ul><h4 id="③信号量"><a href="#③信号量" class="headerlink" title="③信号量"></a>③信号量</h4><ul><li>三个线程第一次执行时，因为只有 zero 信号量的计数器初始值为 1，其余都为 0，所以 zero 线程先执行，让它不断判断接下来该哪个线程执行，并释放对应线程的信号量，对应线程执行一次循环后，释放 zero 信号量，以便 zero 线程继续判断。</li></ul><h4 id="④volatile-关键字"><a href="#④volatile-关键字" class="headerlink" title="④volatile 关键字"></a>④volatile 关键字</h4><ul><li>直接使用 volatile 关键字控制三个线程的执行顺序</li><li>具体实现见代码</li></ul><hr><h3 id="3-代码详解"><a href="#3-代码详解" class="headerlink" title="3.代码详解"></a>3.代码详解</h3><h4 id="①synchronized-关键字-this-锁对象-1"><a href="#①synchronized-关键字-this-锁对象-1" class="headerlink" title="①synchronized 关键字 + this 锁对象"></a>①synchronized 关键字 + this 锁对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.synchronized关键字+this锁对象(三个不同的线程将会共用一个ZeroEvenOdd实例)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZeroEvenOdd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 自己陷入等待</span></span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                printNumber.accept(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    flag = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 唤醒所有线程</span></span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (flag != <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="comment">// 自己陷入等待</span></span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                printNumber.accept(i);</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 唤醒所有线程</span></span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (flag != <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 自己陷入等待</span></span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                printNumber.accept(i);</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 唤醒所有线程</span></span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②lock-condition-1"><a href="#②lock-condition-1" class="headerlink" title="②lock + condition"></a>②lock + condition</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.lock+condition</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZeroEvenOdd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 自己陷入等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            printNumber.accept(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 唤醒所有线程</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 自己陷入等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            printNumber.accept(i);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 唤醒所有线程</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 自己陷入等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            printNumber.accept(i);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 唤醒所有线程</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③信号量-1"><a href="#③信号量-1" class="headerlink" title="③信号量"></a>③信号量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.信号量(Semaphore)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> Semaphore zero = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);    </span><br><span class="line">    <span class="keyword">private</span> Semaphore even = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> Semaphore odd = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZeroEvenOdd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 获取zero信号量的一个许可</span></span><br><span class="line">            zero.acquire();</span><br><span class="line">            printNumber.accept(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 释放odd信号量的一个许可</span></span><br><span class="line">                odd.release();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 释放even信号量的一个许可</span></span><br><span class="line">                even.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取even信号量的一个许可</span></span><br><span class="line">            even.acquire();</span><br><span class="line">            printNumber.accept(i);</span><br><span class="line">            <span class="comment">// 释放zero信号量的一个许可</span></span><br><span class="line">            zero.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取odd信号量的一个许可</span></span><br><span class="line">            odd.acquire();</span><br><span class="line">            printNumber.accept(i);</span><br><span class="line">            <span class="comment">// 释放zero信号量的一个许可</span></span><br><span class="line">            zero.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="④volatile-关键字-1"><a href="#④volatile-关键字-1" class="headerlink" title="④volatile 关键字"></a>④volatile 关键字</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.volatile</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZeroEvenOdd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            printNumber.accept(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">2</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            printNumber.accept(i);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">1</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            printNumber.accept(i);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#119;&#x6a;&#121;&#x6d;&#101;&#x73;&#x73;&#x69;&#x40;&#x31;&#x36;&#51;&#46;&#99;&#111;&#x6d;" target="_blank" rel="noopener">&#119;&#x6a;&#121;&#x6d;&#101;&#x73;&#x73;&#x69;&#x40;&#x31;&#x36;&#51;&#46;&#99;&#111;&#x6d;</a></li><li>关于 <strong>数据结构与算法</strong> 的更多代码 请查看我的 <a href="https://github.com/messi1002/leetcode" target="_blank" rel="noopener">GitHub仓库</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目相关&quot;&gt;&lt;a href=&quot;#1-题目相关&quot; class=&quot;headerlink&quot; title=&quot;1.题目相关&quot;&gt;&lt;/a&gt;1.题目相关&lt;/h3&gt;&lt;h4 id=&quot;①题目及示例&quot;&gt;&lt;a href=&quot;#①题目及示例&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="LeetCode-多线程题解" scheme="http://messi1002.top/categories/Java/LeetCode-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="LeetCode题解" scheme="http://messi1002.top/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 1226. 哲学家进餐（Medium）Java语言题解</title>
    <link href="http://messi1002.top/2020/03/01/LeetCode-1226-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/"/>
    <id>http://messi1002.top/2020/03/01/LeetCode-1226-哲学家进餐（Medium）Java语言题解/</id>
    <published>2020-03-01T05:05:45.000Z</published>
    <updated>2020-06-12T12:54:20.568Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目相关"><a href="#1-题目相关" class="headerlink" title="1.题目相关"></a>1.题目相关</h3><h4 id="①题目及示例"><a href="#①题目及示例" class="headerlink" title="①题目及示例"></a>①题目及示例</h4><p><img src="./1583212242316.png" alt="Alt text"><br><img src="./1583212055232.png" alt="Alt text"></p><h4 id="②相关标签"><a href="#②相关标签" class="headerlink" title="②相关标签"></a>②相关标签</h4><ul><li>多线程</li></ul><h4 id="③题目地址"><a href="#③题目地址" class="headerlink" title="③题目地址"></a>③题目地址</h4><ul><li><a href="https://leetcode-cn.com/problems/the-dining-philosophers/" target="_blank" rel="noopener">1226. 哲学家进餐 — 力扣网</a></li></ul><hr><h3 id="2-解题方法"><a href="#2-解题方法" class="headerlink" title="2.解题方法"></a>2.解题方法</h3><ul><li>哲学家进餐问题有死锁和资源耗尽的风险：每个哲学家同时拿着左边的筷子，永远都在等右边的筷子。</li><li>所以本题的重点在于如何避免死锁，我们采用两种常用的解决方法：<ol><li>改变一个哲学家拿叉子的顺序</li><li>餐票策略</li></ol></li></ul><h4 id="①synchronized-关键字-改变一个哲学家拿叉子的顺序"><a href="#①synchronized-关键字-改变一个哲学家拿叉子的顺序" class="headerlink" title="①synchronized 关键字 + 改变一个哲学家拿叉子的顺序"></a>①synchronized 关键字 + 改变一个哲学家拿叉子的顺序</h4><ul><li>改变一个哲学家拿叉子的顺序：要想发生死锁，必须所有人同时拿起左边的筷子，但是如果这时有一个哲学家先拿右边再拿左边，就不会发生死锁。即避免发生环路，属于避免策略。</li><li>使用 synchronized 关键字对拿起的筷子加锁</li></ul><h4 id="②lock-改变一个哲学家拿叉子的顺序"><a href="#②lock-改变一个哲学家拿叉子的顺序" class="headerlink" title="②lock + 改变一个哲学家拿叉子的顺序"></a>②lock + 改变一个哲学家拿叉子的顺序</h4><ul><li>改变一个哲学家拿叉子的顺序：要想发生死锁，必须所有人同时拿起左边的筷子，但是如果这时有一个哲学家先拿右边再拿左边，就不会发生死锁。即避免发生环路，属于避免策略。</li><li>使用 lock 对拿起的筷子加锁</li></ul><h4 id="③synchronized-关键字-信号量-餐票策略"><a href="#③synchronized-关键字-信号量-餐票策略" class="headerlink" title="③synchronized 关键字 + 信号量 + 餐票策略"></a>③synchronized 关键字 + 信号量 + 餐票策略</h4><ul><li>餐票策略：要求必须拿到餐票才能吃饭，而我们为了避免死锁，总共只发三张餐票，这样可以避免五个人同时准备吃饭的情况，也属于避免策略。</li><li>使用 synchronized 关键字对拿起的筷子加锁</li><li>使用信号量模拟餐票</li></ul><h4 id="④lock-信号量-餐票策略"><a href="#④lock-信号量-餐票策略" class="headerlink" title="④lock + 信号量 + 餐票策略"></a>④lock + 信号量 + 餐票策略</h4><ul><li>餐票策略：要求必须拿到餐票才能吃饭，而我们为了避免死锁，总共只发三张餐票，这样可以避免五个人同时准备吃饭的情况，也属于避免策略。</li><li>使用 lock 对拿起的筷子加锁</li><li>使用信号量模拟餐票</li></ul><hr><h3 id="3-代码详解"><a href="#3-代码详解" class="headerlink" title="3.代码详解"></a>3.代码详解</h3><h4 id="①synchronized-关键字-改变一个哲学家拿叉子的顺序-1"><a href="#①synchronized-关键字-改变一个哲学家拿叉子的顺序-1" class="headerlink" title="①synchronized 关键字 + 改变一个哲学家拿叉子的顺序"></a>①synchronized 关键字 + 改变一个哲学家拿叉子的顺序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.synchronized+改变一个哲学家拿叉子的顺序来避免死锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] locks = <span class="keyword">new</span> Object[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            locks[i] = <span class="keyword">new</span> Object();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickRightFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable eat,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putRightFork)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 改变0号哲学家拿叉子的顺序 </span></span><br><span class="line">        <span class="keyword">int</span> leftForkNumber = philosopher == <span class="number">0</span>? (philosopher + <span class="number">1</span>) % <span class="number">5</span>: philosopher;</span><br><span class="line">        <span class="keyword">int</span> rightForkNumber = philosopher == <span class="number">0</span>? philosopher: (philosopher + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (locks[leftForkNumber]) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (locks[rightForkNumber]) &#123;</span><br><span class="line">                pickLeftFork.run();</span><br><span class="line">                pickRightFork.run();</span><br><span class="line">                eat.run();</span><br><span class="line">                putLeftFork.run();</span><br><span class="line">                putRightFork.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②lock-改变一个哲学家拿叉子的顺序-1"><a href="#②lock-改变一个哲学家拿叉子的顺序-1" class="headerlink" title="②lock + 改变一个哲学家拿叉子的顺序"></a>②lock + 改变一个哲学家拿叉子的顺序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.lock+改变一个哲学家拿叉子的顺序来避免死锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock[] locks = &#123;<span class="keyword">new</span> ReentrantLock(), <span class="keyword">new</span> ReentrantLock(), <span class="keyword">new</span> ReentrantLock(), <span class="keyword">new</span> ReentrantLock(), <span class="keyword">new</span> ReentrantLock()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickRightFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable eat,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putRightFork)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 改变0号哲学家拿叉子的顺序</span></span><br><span class="line">        <span class="keyword">int</span> leftForkNumber = philosopher == <span class="number">0</span>? (philosopher + <span class="number">1</span>) % <span class="number">5</span>: philosopher;</span><br><span class="line">        <span class="keyword">int</span> rightForkNumber = philosopher == <span class="number">0</span>? philosopher: (philosopher + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">        locks[leftForkNumber].lock();</span><br><span class="line">        locks[rightForkNumber].lock();</span><br><span class="line">        pickLeftFork.run();</span><br><span class="line">        pickRightFork.run();</span><br><span class="line">        eat.run();</span><br><span class="line">        putLeftFork.run();</span><br><span class="line">        putRightFork.run();</span><br><span class="line">        locks[rightForkNumber].unlock();</span><br><span class="line">        locks[leftForkNumber].unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③synchronized-关键字-信号量-餐票策略-1"><a href="#③synchronized-关键字-信号量-餐票策略-1" class="headerlink" title="③synchronized 关键字 + 信号量 + 餐票策略"></a>③synchronized 关键字 + 信号量 + 餐票策略</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.synchronized+信号量+餐票策略来避免死锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] locks = <span class="keyword">new</span> Object[<span class="number">5</span>];    </span><br><span class="line">    <span class="keyword">private</span> Semaphore limit = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            locks[i] = <span class="keyword">new</span> Object();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickRightFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable eat,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putRightFork)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftForkNumber = philosopher;</span><br><span class="line">        <span class="keyword">int</span> rightForkNumber = (philosopher + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 规定最多有三个哲学家同时拿起叉子</span></span><br><span class="line">        limit.acquire();</span><br><span class="line">        <span class="keyword">synchronized</span> (locks[leftForkNumber]) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (locks[rightForkNumber]) &#123;</span><br><span class="line">                pickLeftFork.run();</span><br><span class="line">                pickRightFork.run();</span><br><span class="line">                eat.run();</span><br><span class="line">                putLeftFork.run();</span><br><span class="line">                putRightFork.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        limit.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="④lock-信号量-餐票策略-1"><a href="#④lock-信号量-餐票策略-1" class="headerlink" title="④lock + 信号量 + 餐票策略"></a>④lock + 信号量 + 餐票策略</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.lock+信号量+餐票策略来避免死锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock[] locks = &#123;<span class="keyword">new</span> ReentrantLock(), <span class="keyword">new</span> ReentrantLock(), <span class="keyword">new</span> ReentrantLock(), <span class="keyword">new</span> ReentrantLock(), <span class="keyword">new</span> ReentrantLock()&#125;;</span><br><span class="line">    <span class="keyword">private</span> Semaphore limit = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickRightFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable eat,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putRightFork)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftForkNumber = philosopher;</span><br><span class="line">        <span class="keyword">int</span> rightForkNumber = (philosopher + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 规定最多有三个哲学家同时拿起叉子</span></span><br><span class="line">        limit.acquire();</span><br><span class="line">        locks[leftForkNumber].lock();</span><br><span class="line">        locks[rightForkNumber].lock();</span><br><span class="line">        pickLeftFork.run();</span><br><span class="line">        pickRightFork.run();</span><br><span class="line">        eat.run();</span><br><span class="line">        putLeftFork.run();</span><br><span class="line">        putRightFork.run();</span><br><span class="line">        locks[rightForkNumber].unlock();</span><br><span class="line">        locks[leftForkNumber].unlock();</span><br><span class="line">        limit.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#119;&#106;&#x79;&#109;&#x65;&#115;&#115;&#x69;&#x40;&#x31;&#54;&#x33;&#46;&#x63;&#x6f;&#x6d;" target="_blank" rel="noopener">&#119;&#106;&#x79;&#109;&#x65;&#115;&#115;&#x69;&#x40;&#x31;&#54;&#x33;&#46;&#x63;&#x6f;&#x6d;</a></li><li>关于 <strong>数据结构与算法</strong> 的更多代码 请查看我的 <a href="https://github.com/messi1002/leetcode" target="_blank" rel="noopener">GitHub仓库</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目相关&quot;&gt;&lt;a href=&quot;#1-题目相关&quot; class=&quot;headerlink&quot; title=&quot;1.题目相关&quot;&gt;&lt;/a&gt;1.题目相关&lt;/h3&gt;&lt;h4 id=&quot;①题目及示例&quot;&gt;&lt;a href=&quot;#①题目及示例&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="LeetCode-多线程题解" scheme="http://messi1002.top/categories/Java/LeetCode-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="LeetCode题解" scheme="http://messi1002.top/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 1114. 按序打印（Easy）Java语言题解</title>
    <link href="http://messi1002.top/2020/03/01/LeetCode-1114-%E6%8C%89%E5%BA%8F%E6%89%93%E5%8D%B0%EF%BC%88Easy%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/"/>
    <id>http://messi1002.top/2020/03/01/LeetCode-1114-按序打印（Easy）Java语言题解/</id>
    <published>2020-03-01T05:04:48.000Z</published>
    <updated>2020-06-12T12:54:12.921Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目相关"><a href="#1-题目相关" class="headerlink" title="1.题目相关"></a>1.题目相关</h3><h4 id="①题目及示例"><a href="#①题目及示例" class="headerlink" title="①题目及示例"></a>①题目及示例</h4><p><img src="./1583211789594.png" alt="Alt text"><br><img src="./1583211834605.png" alt="Alt text"></p><h4 id="②相关标签"><a href="#②相关标签" class="headerlink" title="②相关标签"></a>②相关标签</h4><ul><li>多线程</li></ul><h4 id="③题目地址"><a href="#③题目地址" class="headerlink" title="③题目地址"></a>③题目地址</h4><ul><li><a href="https://leetcode-cn.com/problems/print-in-order/" target="_blank" rel="noopener">1114. 按序打印 — 力扣网</a></li></ul><hr><h3 id="2-解题方法"><a href="#2-解题方法" class="headerlink" title="2.解题方法"></a>2.解题方法</h3><h4 id="①原子变量"><a href="#①原子变量" class="headerlink" title="①原子变量"></a>①原子变量</h4><ul><li>使用一个原子变量控制，把并发调用变成按顺序调用。</li></ul><h4 id="②volatile-关键字"><a href="#②volatile-关键字" class="headerlink" title="②volatile 关键字"></a>②volatile 关键字</h4><ul><li>使用 volatile 关键字保证变量的可见性，把并发调用变成按顺序调用。</li></ul><h4 id="③信号量"><a href="#③信号量" class="headerlink" title="③信号量"></a>③信号量</h4><ul><li>三个线程第一次执行时，因为 flag1 信号量和 flag2 信号量的计数器初始值都为 0，所以需要等 first 线程中释放了 flag1 信号量，second 线程才能开始执行，需要等 second 线程中释放了 flag2 信号量，third 线程才能开始执行。</li></ul><h4 id="④CountDownLatch"><a href="#④CountDownLatch" class="headerlink" title="④CountDownLatch"></a>④CountDownLatch</h4><ul><li>两个 CountDownLatch 实例可以控制三个线程执行的先后顺序</li><li>具体实现见代码</li></ul><h4 id="⑤CyclicBarrier"><a href="#⑤CyclicBarrier" class="headerlink" title="⑤CyclicBarrier"></a>⑤CyclicBarrier</h4><ul><li>两个 CyclicBarrier 实例可以控制三个线程执行的先后顺序</li><li>具体实现见代码</li></ul><hr><h3 id="3-代码详解"><a href="#3-代码详解" class="headerlink" title="3.代码详解"></a>3.代码详解</h3><h4 id="①原子变量-1"><a href="#①原子变量-1" class="headerlink" title="①原子变量"></a>①原子变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.使用一个原子变量控制，把并发调用变成按顺序调用。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger n = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        printFirst.run();</span><br><span class="line">        n.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 等待第一个线程执行完毕</span></span><br><span class="line">        <span class="keyword">while</span> (n.get() != <span class="number">1</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        printSecond.run();</span><br><span class="line">        n.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 等待第二个线程执行完毕</span></span><br><span class="line">        <span class="keyword">while</span> (n.get() != <span class="number">2</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        printThird.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②volatile-关键字-1"><a href="#②volatile-关键字-1" class="headerlink" title="②volatile 关键字"></a>②volatile 关键字</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.volatile关键字</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        printFirst.run();</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 等待第一个线程执行完毕</span></span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">1</span>) &#123;&#125;</span><br><span class="line">        printSecond.run();</span><br><span class="line">        flag = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 等待第二个线程执行完毕</span></span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">2</span>) &#123;&#125;</span><br><span class="line">        printThird.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③信号量-1"><a href="#③信号量-1" class="headerlink" title="③信号量"></a>③信号量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.信号量(Semaphore)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Semaphore flag1 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> Semaphore flag2 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        printFirst.run();</span><br><span class="line">        <span class="comment">// 释放flag1信号量的一个许可</span></span><br><span class="line">        flag1.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取flag1信号量的一个许可</span></span><br><span class="line">        flag1.acquire();</span><br><span class="line">        printSecond.run();</span><br><span class="line">        <span class="comment">// 释放flag2信号量的一个许可</span></span><br><span class="line">        flag2.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取flag2信号量的一个许可</span></span><br><span class="line">        flag2.acquire();</span><br><span class="line">        printThird.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="④CountDownLatch-1"><a href="#④CountDownLatch-1" class="headerlink" title="④CountDownLatch"></a>④CountDownLatch</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.CountDownLatch</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch1 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch2 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        printFirst.run();</span><br><span class="line">        <span class="comment">// 触发second线程执行</span></span><br><span class="line">        latch1.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 等待被触发</span></span><br><span class="line">        latch1.await();</span><br><span class="line">        printSecond.run();</span><br><span class="line">        <span class="comment">// 触发third线程执行</span></span><br><span class="line">        latch2.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 等待被触发</span></span><br><span class="line">        latch2.await();</span><br><span class="line">        printThird.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑤CyclicBarrier-1"><a href="#⑤CyclicBarrier-1" class="headerlink" title="⑤CyclicBarrier"></a>⑤CyclicBarrier</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.CyclicBarrier</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier barrier1 = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier barrier2 = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            printFirst.run();</span><br><span class="line">            barrier1.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 等待fisrt线程执行完printFirst.run();</span></span><br><span class="line">            barrier1.await();</span><br><span class="line">            printSecond.run();</span><br><span class="line">            barrier2.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;&#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 等待second线程执行完printSecond.run();</span></span><br><span class="line">            barrier2.await();</span><br><span class="line">            printThird.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;&#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#x6a;&#x79;&#x6d;&#x65;&#115;&#x73;&#105;&#64;&#49;&#x36;&#51;&#x2e;&#x63;&#x6f;&#109;" target="_blank" rel="noopener">&#x77;&#x6a;&#x79;&#x6d;&#x65;&#115;&#x73;&#105;&#64;&#49;&#x36;&#51;&#x2e;&#x63;&#x6f;&#109;</a></li><li>关于 <strong>数据结构与算法</strong> 的更多代码 请查看我的 <a href="https://github.com/messi1002/leetcode" target="_blank" rel="noopener">GitHub仓库</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目相关&quot;&gt;&lt;a href=&quot;#1-题目相关&quot; class=&quot;headerlink&quot; title=&quot;1.题目相关&quot;&gt;&lt;/a&gt;1.题目相关&lt;/h3&gt;&lt;h4 id=&quot;①题目及示例&quot;&gt;&lt;a href=&quot;#①题目及示例&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="LeetCode-多线程题解" scheme="http://messi1002.top/categories/Java/LeetCode-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="LeetCode题解" scheme="http://messi1002.top/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之基础概念</title>
    <link href="http://messi1002.top/2020/02/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://messi1002.top/2020/02/25/Java并发编程之基础概念/</id>
    <published>2020-02-25T04:30:32.000Z</published>
    <updated>2020-03-25T13:26:17.609Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1.进程和线程"></a>1.进程和线程</h3><h4 id="①与操作系统的关系"><a href="#①与操作系统的关系" class="headerlink" title="①与操作系统的关系"></a>①与操作系统的关系</h4><ul><li>一个操作系统可以拥有多个进程（process）</li><li>一个进程可以拥有多个线程（thread）</li><li>即操作系统是包含多个进程的容器，而每个进程又都是容纳多个线程的容器。</li></ul><p><img src="./1582653441280.png" alt="Alt text"></p><h4 id="②进程定义"><a href="#②进程定义" class="headerlink" title="②进程定义"></a>②进程定义</h4><ul><li>Oracle 的官方定义：<ul><li>进程：使用 fork 系统调用创建的 UNIX 环境（包括文件描述符、用户 ID 、CPU 使用时间、存储器、IO 设备、内存等），它被设置为运行程序。</li><li>线程：在进程上下文中执行的一系列指令</li></ul></li><li>通俗理解进程：<ul><li>进程指的是程序的一次执行。在用户下达运行程序的命令后，就会产生进程。没有运行的程序占用的空间大部分是磁盘空间，将程序运行起来时就变成了一个进程。</li><li>比喻：进程是对代码的实例化</li><li>在任务管理器中可以查看正在运行的进程：</li></ul></li></ul><p><img src="./1582626838174.png" alt="Alt text"></p><ul><li>总结进程：进程是程序的真正运行实例，是资源分配的基本单位。内存、CPU 等资源都是以进程为单位进行分配的。</li></ul><h4 id="③线程定义"><a href="#③线程定义" class="headerlink" title="③线程定义"></a>③线程定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 创建100个线程，用任务管理器可以看到Java线程数量的变化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Create100Threads</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建100个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 睡眠10s</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序运行前：</li></ul><p><img src="./1582627116360.png" alt="Alt text"></p><ul><li>程序运行过程：</li></ul><p><img src="./1582627170456.png" alt="Alt text"></p><ul><li>程序运行结束：</li></ul><p><img src="./1582627247395.png" alt="Alt text"></p><ul><li>通俗理解线程：<ul><li>线程是 CPU 的基本调度单位，每个线程执行的都是进程代码的某个片段。</li><li>进程是线程的容器，让线程利用进程中的资源执行代码。进程的线程数量若是大于 1，则是多线程的情况，多个线程帮助同一进程执行代码。</li></ul></li></ul><h4 id="④两者的异同"><a href="#④两者的异同" class="headerlink" title="④两者的异同"></a>④两者的异同</h4><ol><li>起源不同<ul><li>回顾操作系统的历史，先有进程后有线程。</li><li>由于处理器的速度往往比外设（键盘、硬盘等）快，所以为了提高 CPU 的利用率，才诞生了线程，目的是提高程序的执行效率。</li></ul></li><li>概念不同<ul><li>进程是具有独立功能的程序运行起来的一个活动，是一个实例，也是系统分配资源和调度的独立单位。</li><li>线程是 CPU 的基本调度单位</li></ul></li><li>内存共享方式不同<ul><li>对于进程而言，每个进程都会被操作系统分配到一定的内存，不同进程之间的内存通常是不共享的。例如：浏览器无法访问正在播放的 qq 音乐，它们之间想要通讯的话，需要使用进程间通讯 RPC。</li><li>线程与线程之间服务于同一个进程，需要合作，所以两个线程之间通讯很容易，可以共享由操作系统分配给其父进程的相同内存块。</li></ul></li><li>拥有的资源不用<ul><li>线程本身是进程的一部分，拥有的资源一定少于进程。</li><li>不同的线程之间共享的内容：①进程代码段（重点）、②进程的公有数据（利用这些共享的数据，线程很容易实现互相通讯）、③进程打开的文件描述符、④信号的处理器、⑤进程的当前目录、⑥进程用户 ID 与进程组 ID</li><li>不同的线程之间独有的内容：①线程 ID、②寄存器组的值、③线程的堆栈（重点）、④错误返回码、⑤线程的信号屏蔽码</li></ul></li><li>进程和线程的数量不同<ul><li>进程只有一个，线程可以有多个。</li><li>一个进程至少拥有一个线程，否则没有办法执行。</li></ul></li><li>开销不同<ul><li>因为进程和线程本身不是一个数量级的东西，所以线程始终比进程更轻量级。</li><li>线程的创建、终止时间比进程短。</li><li>同一进程内的线程切换时间比进程切换时间短</li><li>同一进程的各个线程间共享内存和文件资源，可以不通过内核进行通信。而进程间想要通信，需要借助内核帮忙。</li></ul></li><li>相同点：从生命周期 / 状态上来看，进程和线程从创建到结束都有就绪、等待、运行等状态。</li></ol><h4 id="⑤Java-语言和多线程的关系"><a href="#⑤Java-语言和多线程的关系" class="headerlink" title="⑤Java 语言和多线程的关系"></a>⑤Java 语言和多线程的关系</h4><ul><li>Java 语言的显著优势：在设计之初就支持多线程（当时大部分编程语言不支持多线程）。</li><li>Java 语言可以将我们创建的线程一对一映射到操作系统的内核线程中。而有些语言的线程是虚拟线程，不会在操作系统中对应的建立线程。</li></ul><p><img src="./1582636089900.png" alt="Alt text"></p><ul><li>JVM 自动启动线程：即使在代码中不显式的创建线程，在运行 main 函数时，JVM 也会自动地启动其他线程，这些线程都有特定的含义。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 即使在代码中不显式的创建线程，在运行main函数时，JVM也会自动地启动其他线程。</span></span><br><span class="line"><span class="comment"> * 并且这些线程都有特定的含义和作用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaAndThreads</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello Threads!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582628395824.png" alt="Alt text"></p><ul><li>Signal Dispatcher：把操作系统发来的信号分发给适当的处理程序，用于连接操作系统和应用程序。</li><li>Finalizer：负责对象的 finalize() 方法。在每个对象结束的时候，可能会实现 finalize() 方法，主要是为了处理该方法。但是随着 Java 语言的发展，不再推荐使用该方法。</li><li>Reference Handler：和 GC、引用相关的线程。将每一个对象的引用记录在案，以便配合 GC 进行垃圾回收。</li><li>main：主线程，用户程序的主入口，编写的代码从这里开始执行。</li><li>以上线程都是 JVM 自动创建的，由此可以看出 Java 语言和多线程息息相关。</li></ul><hr><h3 id="2-多线程"><a href="#2-多线程" class="headerlink" title="2.多线程"></a>2.多线程</h3><h4 id="①定义"><a href="#①定义" class="headerlink" title="①定义"></a>①定义</h4><ul><li>多线程：在单个进程中运行多个线程</li><li>多线程程序：如果一个程序允许运行两个或两个以上的线程，那么它就是多线程程序。<ul><li>现在绝大部分的程序都是多线程程序。例如：在浏览器中可以同时打开几个网页、同时下载几个文件，以及服务端可以同时处理多个请求。</li></ul></li><li>每个线程拥有自己的独立资源（ID、堆栈等），进程的内存空间对每个线程敞开，每个线程都可以到进程的内存空间中获取想要的资源并且互相通信。</li><li>相互独立的任务：没必要使用多线程</li><li>数据和资源共享的任务：需要使用多线程，并且要考虑线程的同步，确保线程的安全。</li></ul><h4 id="②多线程实例"><a href="#②多线程实例" class="headerlink" title="②多线程实例"></a>②多线程实例</h4><ul><li>多线程实例：抢火车票</li><li>最开始在火车站买火车票，是全国统一进行放票。假设全国使用同一个服务器（类比为一个进程）进行放票，而多个售票窗口就可以类比为多个线程。不同的线程之间互相配合或竞争。</li></ul><p><img src="./1582653407376.png" alt="Alt text"></p><ul><li>不断迭代后：<ul><li>增加放票时间段（分散压力），不同的车次有自己的放票时间。</li><li>增加候补功能</li><li>增加买票限制</li></ul></li><li>以上都是为了减少服务器的并发压力</li></ul><h4 id="③为什么需要多线程？"><a href="#③为什么需要多线程？" class="headerlink" title="③为什么需要多线程？"></a>③为什么需要多线程？</h4><ol><li>提高 CPU 的利用率（最主要的目的）<ul><li>目前大部分 CPU 都是两核或者两核以上，如果不发挥多线程的优势，始终使用单线程，就会浪费计算资源。多线程程序可以充分发挥多核 CPU 的优势，提高计算机的运行效率。</li><li>①提高了处理速度（CPU 的运行效率远远超过内存、磁盘、外设等） </li><li>②避免了无效等待（在读取磁盘 IO 的时候，CPU 没有必要等待，而应该去做其他的事情。）</li><li>③提高了用户体验：避免卡顿、缩短等待时间（并行处理，提高性能，例如 Tomcat 服务器用多个线程去接收 HTTP 请求，可以同时服务于多个用户。）</li></ul></li><li>便于编程建模（简化任务）<ul><li>将大任务拆解为 A、B、C、D 并建立模型，类似的任务都可以使用模型处理。然后用多线程分别执行这 4 个任务，就简单很多。因为每个子任务的目的明确、功能单一。</li></ul></li><li>计算机性能定律：摩尔定律失效，阿姆达尔定律登上舞台。<ul><li>摩尔定律：当价格不变时，集成电路上可容纳的晶体管数目约每隔 18 个月便会增加一倍，意味着 CPU 的性能可以提高一倍。这个定律告诉我们长期以来 CPU 的性能都是以指数型快速增长的。但是，近年来陷入了瓶颈。</li><li>阿姆达尔定律：处理器（CPU）越多，程序的执行速度就越快。但是执行速度也有上限，取决于程序中串行部分的比例，并行的比例越高，多处理器的效果越明显。对于串行任务，无论有多少 CPU 资源，都没有办法提高速度。</li><li>并行比例与提升速度的关系：</li></ul></li></ol><p><img src="./1582653374893.png" alt="Alt text"></p><ul><li>在未来，CPU 的性能的提升速度放缓了，这就要求我们把程序中更多可并行的部分并行化，以提高程序的性能。</li></ul><h4 id="④什么场景中会用到多线程？"><a href="#④什么场景中会用到多线程？" class="headerlink" title="④什么场景中会用到多线程？"></a>④什么场景中会用到多线程？</h4><ol><li>执行耗时任务（IO、磁盘读写、网络通信等）新开线程，不但不会影响主程序的运行，也不会因为耗时任务执行时间过慢而影响其他任务的运行。</li><li>为了同时做多件不同的事：①使用浏览器的同时听音乐、②后台定时任务等</li><li>提高工作效率、处理能力<ul><li>①Tomcat 可以同时并行处理多个线程进来的请求</li><li>②下载文件时可以选择线程数，多线程并行下载（每个线程都去和服务器通信，都去做独立的下载任务，并且把下载的任务进行分割，最后再把下载到的文件拼接起来），以提高下载效率。</li><li>③NIO：将 IO 操作升级为多线程操作，提高了 IO 的处理能力。</li></ul></li><li>需要同时有很大并发量的时候（比如进行服务器承受压力的能力的测试时，需要多线程并行请求）</li></ol><h4 id="⑤多线程的局限"><a href="#⑤多线程的局限" class="headerlink" title="⑤多线程的局限"></a>⑤多线程的局限</h4><ol><li>性能问题：上下文切换带来的消耗<ul><li>线程之间切换时会有上下文切换，会保存一些 CPU 所需要的数据，如当前运行到哪一行代码等。</li></ul></li><li>异构化任务很难高效并行<ul><li>每个任务之间的结构都不一样，很难总结为多个任务的拆解。</li></ul></li><li>带来线程安全问题：包括数据安全问题（例如 <code>i++</code> 总数不一致）以及线程带来的活跃性问题（线程饥饿、死锁等）<ul><li>线程饥饿：某个线程想要执行任务，但是被其他线程强先，这个线程始终没有事干。</li><li>死锁：两个线程相互拥有对方所需要的资源但都不肯放手，于是陷入无穷等待。</li></ul></li></ol><hr><h3 id="3-串行、并行、并发"><a href="#3-串行、并行、并发" class="headerlink" title="3.串行、并行、并发"></a>3.串行、并行、并发</h3><h4 id="①串行、并行、并发"><a href="#①串行、并行、并发" class="headerlink" title="①串行、并行、并发"></a>①串行、并行、并发</h4><ul><li>串行：大家排队一个个来<ul><li>左图：线程 A -&gt; B -&gt; C 依次执行</li><li>右图：将数据一位一位发送</li></ul></li><li>并行：大家一起来<ul><li>左图：线程 A / B / C 同时执行</li><li>右图：将 8 个数据一次性发送出去</li></ul></li></ul><p><img src="./1582653345934.png" alt="Alt text"></p><ul><li>并发（Concurrency）：单核就能实现并发、属于逻辑上的同时运行（由于处理器的处理速度很快，所以线程之间的切换肉眼是感知不到的，感觉它是在同时执行多个程序，实际某一时间只有一个程序执行（单处理器））。<ul><li>在物理层面并发就是串行，只不过是在多个程序上快速的来回切换而不是一个个依次执行，所以在用户看来相当于三个程序同时执行。</li></ul></li><li>并行（Parallelism）：多核处理器，物理上的同时运行，多个处理器都在同时执行任务。</li></ul><p><img src="./1582653313196.png" alt="Alt text"><br><img src="./1582086357063.png" alt="Alt text"></p><ul><li>并行是真正的 “同时” 运行：在同一时刻，有多个任务同时执行。<ul><li>单核处理器是无法实现并行的，因为单核处理器无法在同一时刻执行多个任务。</li></ul></li><li>并发可以对应到两个不同的概念</li><li>①形容多个任务的执行状态：<ul><li>两个或多个任务可以在重叠的时间段（不是指真正重叠的同一时刻，而是一段时间内交替运行）内启动，运行和完成。</li><li>并行（两个线程同时执行）一定是并发，两者是包含关系。</li><li>并发 + 多核 + 同一时刻执行同一段代码 = 并行</li><li>并发：不同的线程交替给一个 CPU 执行（蓝色竖线：CPU 的时间片）</li><li>并行：多个线程同时被多个 CPU 执行</li></ul></li></ul><p><img src="./1582653247372.png" alt="Alt text"><br><img src="./1582653213782.png" alt="Alt text"></p><ul><li>②对 “并发性” 的简称：<ul><li>如果一个程序具有并发性，指的是程序不同的部分可以无序或同时执行，且不影响最终的执行结果。</li><li>在不同核心数的计算机上的表现不同：</li><li>在多核 CPU 上，可以并行执行并发性程序。</li><li>在单核 CPU 上，可以并发执行并发性程序，串行执行非并发性程序。</li><li>此时，并行和并发的概念并不在同一维度上。并发指的是并发性，并行指的是多个程序在同一时刻同时执行。一个程序如果想要并发 / 并行执行，前提条件是它具有并发性。并发性是并发执行和并行执行的前提条件和必要条件。如果一个程序可以并行执行，就代表它一定具有并发性。</li></ul></li></ul><h4 id="②是什么让并发和并行成为可能？"><a href="#②是什么让并发和并行成为可能？" class="headerlink" title="②是什么让并发和并行成为可能？"></a>②是什么让并发和并行成为可能？</h4><ol><li>CPU 升级<ul><li>CPU 之前一直遵循摩尔定律，性能提升的很快，它的处理速度远远比其他部件快。但是每个 CPU 同一时刻只能执行一个指令，出于这个原因，操作系统开发出了新的技术，可以让用户同时运行多个进程或者多个线程。</li></ul></li><li>操作系统的升级<ul><li>升级之后将 CPU 完美的调度了起来，即便是单核 CPU，也能让不同的进程使用时间片的方式（抢占式的方式）不停地切换。</li><li>抢占式多任务处理：现代 CPU 最主要的一种处理方式，即操作系统有权利中断正在执行的任务。</li><li>诞生多核处理器后，操作系统可以自动检测 CPU 核心的数量，为每个核心分配不同的任务，以实现真正地同一时刻运行多个程序。</li></ul></li><li>编程语言的升级<ul><li>Java 语言诞生之前，很多编程语言不支持多线程。随着 Java 的诞生，多线程编程开始逐渐火热并且发展成熟。</li></ul></li></ol><hr><h3 id="4-高并发"><a href="#4-高并发" class="headerlink" title="4.高并发"></a>4.高并发</h3><h4 id="①定义-1"><a href="#①定义-1" class="headerlink" title="①定义"></a>①定义</h4><ul><li>高并发：同时有很多个请求发送给服务器系统，服务器会并行处理。</li><li>高并发场景：天猫双十一、春晚微信摇一摇、12306 卖火车票</li><li>一般将系统的承受能力设计为目前系统访问量的十倍比较合适</li></ul><h4 id="②高并发和多线程的异同？"><a href="#②高并发和多线程的异同？" class="headerlink" title="②高并发和多线程的异同？"></a>②高并发和多线程的异同？</h4><ul><li>高并发：指大量的请求同时到达服务器所带来的结果（结果指服务器需要同时处理很多请求），它是一种状态。系统需要应对高并发这种状态所带来的后果，如果处理不当，会导致请求的响应速度慢、无响应甚至服务器死机。</li><li>多线程并不意味着高并发，多线程编程是一种编程方式，是一种解决方案，不仅可以解决高并发所带来的线程安全问题 / 性能问题，还可以提高硬件的利用率，以便获取到更多的资源，从而解决高并发带来的服务器死机、响应慢等问题。<ul><li>多线程编程是我们应对高并发场景的一种重要的解决方案。</li></ul></li><li>高并发并不一定要通过多线程的方式解决<ul><li>例如：解决数据库的高并发问题可以利用 Redis 缓存层（可能带来缓存不一致的问题，但不会带来线程安全问题）</li></ul></li><li>总结：高并发并不意味着多线程（例如：Redis 底层是用单线程处理的）。高并发是一种状态，作为服务器开发者，最好用多线程的方式解决，这样可以提高 CPU 等资源的利用率，加快用户的响应速度。但是在场景不同，资源不同的情况下，也可以选择其他的解决方案。</li></ul><h4 id="③高并发有哪些指标？"><a href="#③高并发有哪些指标？" class="headerlink" title="③高并发有哪些指标？"></a>③高并发有哪些指标？</h4><ul><li>QPS（Queries Per Second）：每秒钟的查询（请求）数</li><li>PV（Page View）：24 小时内的页面点击量（综合浏览量）</li><li>UV（Unique Visitor）：24 小时内访问的用户数量（根据 Cookie）、UV &lt;= PV</li><li>并发连接数：某个时刻服务器所接受的请求的数目。<ul><li>对于同一个用户而言，可以同时产生很多个会话 / 连接，所以数目 &gt; 同时在线的用户数量。</li><li>对服务器来说，这个连接有一个上限</li></ul></li><li>服务器平均请求等待时间：服务器处理一个请求所花费的时间</li></ul><hr><h3 id="5-同步与异步、阻塞与非阻塞"><a href="#5-同步与异步、阻塞与非阻塞" class="headerlink" title="5.同步与异步、阻塞与非阻塞"></a>5.同步与异步、阻塞与非阻塞</h3><h4 id="①同步与异步"><a href="#①同步与异步" class="headerlink" title="①同步与异步"></a>①同步与异步</h4><ul><li>同步与异步：被调用方是否主动告诉调用方结果。<ul><li>同步与异步是被调用方（即服务端）的行为，而不是调用方的行为。</li><li>同步：在没有得到结果之前，服务端不返回任何结果。</li><li>异步：调用在发出之后，服务端会立刻返回，告诉调用方 “我收到你的请求了，我会马上处理的”，等服务器处理完成以后，会再次告诉调用方 “我已经处理完了”。</li></ul></li></ul><p><img src="./1582653108706.png" alt="Alt text"><br><img src="./1582653143245.png" alt="Alt text"><br><img src="./1582653156676.png" alt="Alt text"><br><img src="./1582653175803.png" alt="Alt text"></p><h4 id="②阻塞与非阻塞"><a href="#②阻塞与非阻塞" class="headerlink" title="②阻塞与非阻塞"></a>②阻塞与非阻塞</h4><ul><li>站在线程状态的角度：阻塞指当前线程不能继续执行，需要等待一段时间或者被唤醒。</li><li>站在线程发出请求的角度：我是调用方，我调用一个东西后，在返回结果前是否还能做其他事情。</li><li>阻塞与非阻塞是调用方的行为，而不是被调用方的行为。<ul><li>阻塞：调用一个东西后，返回结果前什么也不做。</li><li>非阻塞：调用一个东西后，返回结果前做其他事情。</li></ul></li></ul><h4 id="③同步阻塞、同步非阻塞、异步阻塞、异步非阻塞"><a href="#③同步阻塞、同步非阻塞、异步阻塞、异步非阻塞" class="headerlink" title="③同步阻塞、同步非阻塞、异步阻塞、异步非阻塞"></a>③同步阻塞、同步非阻塞、异步阻塞、异步非阻塞</h4><ul><li>同步不一定是阻塞，阻塞也不一定是同步。</li><li>异步不一定是非阻塞，非阻塞也不一定是异步。</li><li>同步阻塞：（被调用方）执行完成后才返回结果、（调用方）在返回结果前什么也不做。</li><li>同步非阻塞：（被调用方）执行完成后才返回结果、（调用方）在返回结果前做其他事情，不时地检查一下被调用方是否返回结果。</li><li>异步阻塞：调用方在发出请求之后，被调用方会立刻告诉调用方已经收到请求，当被调用方处理完成以后，会再次告诉调用方已经处理完了、但是（调用方）在返回结果前什么也不做。</li><li>异步非阻塞：调用方在发出请求之后，被调用方会立刻告诉调用方已经收到请求，当被调用方处理完成以后，会再次告诉调用方已经处理完了、（调用方）在返回结果前做其他事情，等待被调用方主动返回结果。</li></ul><hr><h3 id="6-常见面试问题"><a href="#6-常见面试问题" class="headerlink" title="6.常见面试问题"></a>6.常见面试问题</h3><h4 id="①进程和线程的异同？"><a href="#①进程和线程的异同？" class="headerlink" title="①进程和线程的异同？"></a>①进程和线程的异同？</h4><ul><li>不同：起源、概念、内存共享方式、拥有的资源、数量、开销</li><li>相同：生命周期（状态）</li><li>具体见 <strong>1.进程和线程——④两者的异同</strong></li></ul><h4 id="②并行和并发的异同？"><a href="#②并行和并发的异同？" class="headerlink" title="②并行和并发的异同？"></a>②并行和并发的异同？</h4><ul><li>都在形容一个程序的运行状态时：并行一定是并发。</li><li>并发也可以形容一个程序的属性，即程序是否具有并发性。若是程序没有并发性，表示程序只能串行执行。</li></ul><h4 id="③多线程就是高并发吗？有什么反例？"><a href="#③多线程就是高并发吗？有什么反例？" class="headerlink" title="③多线程就是高并发吗？有什么反例？"></a>③多线程就是高并发吗？有什么反例？</h4><ul><li>高并发指服务器同时接受很多请求，受到极大压力。</li><li>多线程是针对高并发的一个解决方案，可以使用多线程将这个压力迅速化解。</li><li>反例：Redis 本身是单线程的，但是同样可以支持高并发的场景。</li><li>应对高并发时，不仅可以通过多线程的方式解决，也可以从整体架构、缓存层的设计、MQ 队列等地方着手解决。</li></ul><h4 id="④多线程可以提高程序的执行效率，你知不知道有哪些弊端？"><a href="#④多线程可以提高程序的执行效率，你知不知道有哪些弊端？" class="headerlink" title="④多线程可以提高程序的执行效率，你知不知道有哪些弊端？"></a>④多线程可以提高程序的执行效率，你知不知道有哪些弊端？</h4><ol><li>性能问题（上下文切换、保存 CPU cache）</li><li>异构化任务或不能并行执行的任务用多线程反而不如用单线程合适</li><li>线程安全问题</li></ol><h4 id="⑤什么是同步？什么是异步？什么是阻塞？什么是非阻塞？"><a href="#⑤什么是同步？什么是异步？什么是阻塞？什么是非阻塞？" class="headerlink" title="⑤什么是同步？什么是异步？什么是阻塞？什么是非阻塞？"></a>⑤什么是同步？什么是异步？什么是阻塞？什么是非阻塞？</h4><ul><li>同步、异步指的是被调用方在调用结束后是否主动返回结果</li><li>阻塞、非阻塞指的是调用方在调用后是否可以去做其他事情</li><li>具体见 <strong>5.同步与异步、阻塞与非阻塞</strong></li></ul><h4 id="⑥在单核-CPU-上运行多线程程序有意义吗？"><a href="#⑥在单核-CPU-上运行多线程程序有意义吗？" class="headerlink" title="⑥在单核 CPU 上运行多线程程序有意义吗？"></a>⑥在单核 CPU 上运行多线程程序有意义吗？</h4><ul><li>有意义，虽然在单核 CPU 上执行真正的并行是不可能的，因为只有一个处理器，但是对于应用程序而言，我们不知道它未来会运行在单核 CPU 还是多核 CPU 上，所以在编写时肯定以多核 CPU 为准。其次，对于多线程程序，当其中一个线程执行缓慢或者被阻塞时，其他线程可以利用这些时间（如读取磁盘的时间）做其他事情，让程序保持高效运转。</li><li>如果 CPU 被挤满，并不是说在单核 CPU 上运行多线程程序没有意义，而是说线程的数量设置不合理，应该减少线程的数量。</li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#119;&#106;&#x79;&#x6d;&#x65;&#x73;&#115;&#105;&#x40;&#x31;&#x36;&#51;&#x2e;&#99;&#111;&#x6d;" target="_blank" rel="noopener">&#119;&#106;&#x79;&#x6d;&#x65;&#x73;&#115;&#105;&#x40;&#x31;&#x36;&#51;&#x2e;&#99;&#111;&#x6d;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-进程和线程&quot;&gt;&lt;a href=&quot;#1-进程和线程&quot; class=&quot;headerlink&quot; title=&quot;1.进程和线程&quot;&gt;&lt;/a&gt;1.进程和线程&lt;/h3&gt;&lt;h4 id=&quot;①与操作系统的关系&quot;&gt;&lt;a href=&quot;#①与操作系统的关系&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="并发编程" scheme="http://messi1002.top/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
