<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wjy&#39;s blog</title>
  
  <subtitle>行到水穷处，坐看云起时。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://messi1002.top/"/>
  <updated>2020-03-04T03:19:06.467Z</updated>
  <id>http://messi1002.top/</id>
  
  <author>
    <name>围巾一</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java集合总结+源码分析</title>
    <link href="http://messi1002.top/2020/03/04/Java%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://messi1002.top/2020/03/04/Java集合总结-源码分析/</id>
    <published>2020-03-04T02:42:31.000Z</published>
    <updated>2020-03-04T03:19:06.467Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
    
      <category term="集合" scheme="http://messi1002.top/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 1115. 交替打印FooBar（Medium）Java语言题解</title>
    <link href="http://messi1002.top/2020/03/01/LeetCode-1115-%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0FooBar%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/"/>
    <id>http://messi1002.top/2020/03/01/LeetCode-1115-交替打印FooBar（Medium）Java语言题解/</id>
    <published>2020-03-01T05:27:27.000Z</published>
    <updated>2020-03-03T05:41:38.822Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="LeetCode-多线程" scheme="http://messi1002.top/categories/Java/LeetCode-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 1188. 设计有限阻塞队列（Medium）Java语言题解</title>
    <link href="http://messi1002.top/2020/03/01/LeetCode-1188-%E8%AE%BE%E8%AE%A1%E6%9C%89%E9%99%90%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/"/>
    <id>http://messi1002.top/2020/03/01/LeetCode-1188-设计有限阻塞队列（Medium）Java语言题解/</id>
    <published>2020-03-01T05:25:08.000Z</published>
    <updated>2020-03-03T05:41:46.478Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="LeetCode-多线程" scheme="http://messi1002.top/categories/Java/LeetCode-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 1195. 交替打印字符串（Medium）Java语言题解</title>
    <link href="http://messi1002.top/2020/03/01/LeetCode-1195-%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/"/>
    <id>http://messi1002.top/2020/03/01/LeetCode-1195-交替打印字符串（Medium）Java语言题解/</id>
    <published>2020-03-01T05:17:28.000Z</published>
    <updated>2020-03-03T05:41:50.732Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="LeetCode-多线程" scheme="http://messi1002.top/categories/Java/LeetCode-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 1116. 打印零与奇偶数（Medium）Java语言题解</title>
    <link href="http://messi1002.top/2020/03/01/LeetCode-1116-%E6%89%93%E5%8D%B0%E9%9B%B6%E4%B8%8E%E5%A5%87%E5%81%B6%E6%95%B0%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/"/>
    <id>http://messi1002.top/2020/03/01/LeetCode-1116-打印零与奇偶数（Medium）Java语言题解/</id>
    <published>2020-03-01T05:13:37.000Z</published>
    <updated>2020-03-03T05:41:56.094Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="LeetCode-多线程" scheme="http://messi1002.top/categories/Java/LeetCode-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 1226. 哲学家进餐（Medium）Java语言题解</title>
    <link href="http://messi1002.top/2020/03/01/LeetCode-1226-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/"/>
    <id>http://messi1002.top/2020/03/01/LeetCode-1226-哲学家进餐（Medium）Java语言题解/</id>
    <published>2020-03-01T05:05:45.000Z</published>
    <updated>2020-03-03T05:41:59.468Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="LeetCode-多线程" scheme="http://messi1002.top/categories/Java/LeetCode-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 1114. 按序打印（Easy）Java语言题解</title>
    <link href="http://messi1002.top/2020/03/01/LeetCode-1114-%E6%8C%89%E5%BA%8F%E6%89%93%E5%8D%B0%EF%BC%88Easy%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/"/>
    <id>http://messi1002.top/2020/03/01/LeetCode-1114-按序打印（Easy）Java语言题解/</id>
    <published>2020-03-01T05:04:48.000Z</published>
    <updated>2020-03-03T05:42:05.252Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="LeetCode-多线程" scheme="http://messi1002.top/categories/Java/LeetCode-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之死锁</title>
    <link href="http://messi1002.top/2020/02/28/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%AD%BB%E9%94%81/"/>
    <id>http://messi1002.top/2020/02/28/Java并发编程之死锁/</id>
    <published>2020-02-28T00:39:27.000Z</published>
    <updated>2020-03-02T00:39:56.114Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之基础概念</title>
    <link href="http://messi1002.top/2020/02/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://messi1002.top/2020/02/25/Java并发编程之基础概念/</id>
    <published>2020-02-25T04:30:32.000Z</published>
    <updated>2020-02-25T18:06:26.015Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1.进程和线程"></a>1.进程和线程</h3><h4 id="①与操作系统的关系"><a href="#①与操作系统的关系" class="headerlink" title="①与操作系统的关系"></a>①与操作系统的关系</h4><ul><li>一个操作系统可以拥有多个进程（process）</li><li>一个进程可以拥有多个线程（thread）</li><li>即操作系统是包含多个进程的容器，而每个进程又都是容纳多个线程的容器。</li></ul><p><img src="./1582653441280.png" alt="Alt text"></p><h4 id="②进程定义"><a href="#②进程定义" class="headerlink" title="②进程定义"></a>②进程定义</h4><ul><li>Oracle 的官方定义：<ul><li>进程：使用 fork 系统调用创建的 UNIX 环境（包括文件描述符、用户 ID 、CPU 使用时间、存储器、IO 设备、内存等），它被设置为运行程序。</li><li>线程：在进程上下文中执行的一系列指令</li></ul></li><li>通俗理解进程：<ul><li>进程指的是程序的一次执行。在用户下达运行程序的命令后，就会产生进程。没有运行的程序占用的空间大部分是磁盘空间，将程序运行起来时就变成了一个进程。</li><li>比喻：进程是对代码的实例化</li><li>在任务管理器中可以查看正在运行的进程：</li></ul></li></ul><p><img src="./1582626838174.png" alt="Alt text"></p><ul><li>总结进程：进程是程序的真正运行实例，是资源分配的基本单位。内存、CPU 等资源都是以进程为单位进行分配的。</li></ul><h4 id="③线程定义"><a href="#③线程定义" class="headerlink" title="③线程定义"></a>③线程定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 创建100个线程，用任务管理器可以看到Java线程数量的变化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Create100Threads</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建100个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 睡眠10s</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序运行前：</li></ul><p><img src="./1582627116360.png" alt="Alt text"></p><ul><li>程序运行过程：</li></ul><p><img src="./1582627170456.png" alt="Alt text"></p><ul><li>程序运行结束：</li></ul><p><img src="./1582627247395.png" alt="Alt text"></p><ul><li>通俗理解线程：<ul><li>线程是 CPU 的基本调度单位，每个线程执行的都是进程代码的某个片段。</li><li>进程是线程的容器，让线程利用进程中的资源执行代码。进程的线程数量若是大于 1，则是多线程的情况，多个线程帮助同一进程执行代码。</li></ul></li></ul><h4 id="④两者的异同"><a href="#④两者的异同" class="headerlink" title="④两者的异同"></a>④两者的异同</h4><ol><li>起源不同<ul><li>回顾操作系统的历史，先有进程后有线程。</li><li>由于处理器的速度往往比外设（键盘、硬盘等）快，所以为了提高 CPU 的利用率，才诞生了线程，目的是提高程序的执行效率。</li></ul></li><li>概念不同<ul><li>进程是具有独立功能的程序运行起来的一个活动，是一个实例，也是系统分配资源和调度的独立单位。</li><li>线程是 CPU 的基本调度单位</li></ul></li><li>内存共享方式不同<ul><li>对于进程而言，每个进程都会被操作系统分配到一定的内存，不同进程之间的内存通常是不共享的。例如：浏览器无法访问正在播放的 qq 音乐，它们之间想要通讯的话，需要使用进程间通讯 RPC。</li><li>线程与线程之间服务于同一个进程，需要合作，所以两个线程之间通讯很容易，可以共享由操作系统分配给其父进程的相同内存块。</li></ul></li><li>拥有的资源不用<ul><li>线程本身是进程的一部分，拥有的资源一定少于进程。</li><li>不同的线程之间共享的内容：①进程代码段（重点）、②进程的公有数据（利用这些共享的数据，线程很容易实现互相通讯）、③进程打开的文件描述符、④信号的处理器、⑤进程的当前目录、⑥进程用户 ID 与进程组 ID</li><li>不同的线程之间独有的内容：①线程 ID、②寄存器组的值、③线程的堆栈（重点）、④错误返回码、⑤线程的信号屏蔽码</li></ul></li><li>进程和线程的数量不同<ul><li>进程只有一个，线程可以有多个。</li><li>一个进程至少拥有一个线程，否则没有办法执行。</li></ul></li><li>开销不同<ul><li>因为进程和线程本身不是一个数量级的东西，所以线程始终比进程更轻量级。</li><li>线程的创建、终止时间比进程短。</li><li>同一进程内的线程切换时间比进程切换时间短</li><li>同一进程的各个线程间共享内存和文件资源，可以不通过内核进行通信。而进程间想要通信，需要借助内核帮忙。</li></ul></li><li>相同点：从生命周期 / 状态上来看，进程和线程从创建到结束都有就绪、等待、运行等状态。</li></ol><h4 id="⑤Java-语言和多线程的关系"><a href="#⑤Java-语言和多线程的关系" class="headerlink" title="⑤Java 语言和多线程的关系"></a>⑤Java 语言和多线程的关系</h4><ul><li>Java 语言的显著优势：在设计之初就支持多线程（当时大部分编程语言不支持多线程）。</li><li>Java 语言可以将我们创建的线程一对一映射到操作系统的内核线程中。而有些语言的线程是虚拟线程，不会在操作系统中对应的建立线程。</li></ul><p><img src="./1582636089900.png" alt="Alt text"></p><ul><li>JVM 自动启动线程：即使在代码中不显式的创建线程，在运行 main 函数时，JVM 也会自动地启动其他线程，这些线程都有特定的含义。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 即使在代码中不显式的创建线程，在运行main函数时，JVM也会自动地启动其他线程。</span></span><br><span class="line"><span class="comment"> * 并且这些线程都有特定的含义和作用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaAndThreads</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello Threads!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582628395824.png" alt="Alt text"></p><ul><li>Signal Dispatcher：把操作系统发来的信号分发给适当的处理程序，用于连接操作系统和应用程序。</li><li>Finalizer：负责对象的 finalize() 方法。在每个对象结束的时候，可能会实现 finalize() 方法，主要是为了处理该方法。但是随着 Java 语言的发展，不再推荐使用该方法。</li><li>Reference Handler：和 GC、引用相关的线程。将每一个对象的引用记录在案，以便配合 GC 进行垃圾回收。</li><li>main：主线程，用户程序的主入口，编写的代码从这里开始执行。</li><li>以上线程都是 JVM 自动创建的，由此可以看出 Java 语言和多线程息息相关。</li></ul><hr><h3 id="2-多线程"><a href="#2-多线程" class="headerlink" title="2.多线程"></a>2.多线程</h3><h4 id="①定义"><a href="#①定义" class="headerlink" title="①定义"></a>①定义</h4><ul><li>多线程：在单个进程中运行多个线程</li><li>多线程程序：如果一个程序允许运行两个或两个以上的线程，那么它就是多线程程序。<ul><li>现在绝大部分的程序都是多线程程序。例如：在浏览器中可以同时打开几个网页、同时下载几个文件，以及服务端可以同时处理多个请求。</li></ul></li><li>每个线程拥有自己的独立资源（ID、堆栈等），进程的内存空间对每个线程敞开，每个线程都可以到进程的内存空间中获取想要的资源并且互相通信。</li><li>相互独立的任务：没必要使用多线程</li><li>数据和资源共享的任务：需要使用多线程，并且要考虑线程的同步，确保线程的安全。</li></ul><h4 id="②多线程实例"><a href="#②多线程实例" class="headerlink" title="②多线程实例"></a>②多线程实例</h4><ul><li>多线程实例：抢火车票</li><li>最开始在火车站买火车票，是全国统一进行放票。假设全国使用同一个服务器（类比为一个进程）进行放票，而多个售票窗口就可以类比为多个线程。不同的线程之间互相配合或竞争。</li></ul><p><img src="./1582653407376.png" alt="Alt text"></p><ul><li>不断迭代后：<ul><li>增加放票时间段（分散压力），不同的车次有自己的放票时间。</li><li>增加候补功能</li><li>增加买票限制</li></ul></li><li>以上都是为了减少服务器的并发压力</li></ul><h4 id="③为什么需要多线程？"><a href="#③为什么需要多线程？" class="headerlink" title="③为什么需要多线程？"></a>③为什么需要多线程？</h4><ol><li>提高 CPU 的利用率（最主要的目的）<ul><li>目前大部分 CPU 都是两核或者两核以上，如果不发挥多线程的优势，始终使用单线程，就会浪费计算资源。多线程程序可以充分发挥多核 CPU 的优势，提高计算机的运行效率。</li><li>①提高了处理速度（CPU 的运行效率远远超过内存、磁盘、外设等） </li><li>②避免了无效等待（在读取磁盘 IO 的时候，CPU 没有必要等待，而应该去做其他的事情。）</li><li>③提高了用户体验：避免卡顿、缩短等待时间（并行处理，提高性能，例如 Tomcat 服务器用多个线程去接收 HTTP 请求，可以同时服务于多个用户。）</li></ul></li><li>便于编程建模（简化任务）<ul><li>将大任务拆解为 A、B、C、D 并建立模型，类似的任务都可以使用模型处理。然后用多线程分别执行这 4 个任务，就简单很多。因为每个子任务的目的明确、功能单一。</li></ul></li><li>计算机性能定律：摩尔定律失效，阿姆达尔定律登上舞台。<ul><li>摩尔定律：当价格不变时，集成电路上可容纳的晶体管数目约每隔 18 个月便会增加一倍，意味着 CPU 的性能可以提高一倍。这个定律告诉我们长期以来 CPU 的性能都是以指数型快速增长的。但是，近年来陷入了瓶颈。</li><li>阿姆达尔定律：处理器（CPU）越多，程序的执行速度就越快。但是执行速度也有上限，取决于程序中串行部分的比例，并行的比例越高，多处理器的效果越明显。对于串行任务，无论有多少 CPU 资源，都没有办法提高速度。</li><li>并行比例与提升速度的关系：</li></ul></li></ol><p><img src="./1582653374893.png" alt="Alt text"></p><ul><li>在未来，CPU 的性能的提升速度放缓了，这就要求我们把程序中更多可并行的部分并行化，以提高程序的性能。</li></ul><h4 id="④什么场景中会用到多线程？"><a href="#④什么场景中会用到多线程？" class="headerlink" title="④什么场景中会用到多线程？"></a>④什么场景中会用到多线程？</h4><ol><li>执行耗时任务（IO、磁盘读写、网络通信等）新开线程，不但不会影响主程序的运行，也不会因为耗时任务执行时间过慢而影响其他任务的运行。</li><li>为了同时做多件不同的事：①使用浏览器的同时听音乐、②后台定时任务等</li><li>提高工作效率、处理能力<ul><li>①Tomcat 可以同时并行处理多个线程进来的请求</li><li>②下载文件时可以选择线程数，多线程并行下载（每个线程都去和服务器通信，都去做独立的下载任务，并且把下载的任务进行分割，最后再把下载到的文件拼接起来），以提高下载效率。</li><li>③NIO：将 IO 操作升级为多线程操作，提高了 IO 的处理能力。</li></ul></li><li>需要同时有很大并发量的时候（比如进行服务器承受压力的能力的测试时，需要多线程并行请求）</li></ol><h4 id="⑤多线程的局限"><a href="#⑤多线程的局限" class="headerlink" title="⑤多线程的局限"></a>⑤多线程的局限</h4><ol><li>性能问题：上下文切换带来的消耗<ul><li>线程之间切换时会有上下文切换，会保存一些 CPU 所需要的数据，如当前运行到哪一行代码等。</li></ul></li><li>异构化任务很难高效并行<ul><li>每个任务之间的结构都不一样，很难总结为多个任务的拆解。</li></ul></li><li>带来线程安全问题：包括数据安全问题（例如 <code>i++</code> 总数不一致）以及线程带来的活跃性问题（线程饥饿、死锁等）<ul><li>线程饥饿：某个线程想要执行任务，但是被其他线程强先，这个线程始终没有事干。</li><li>死锁：两个线程相互拥有对方所需要的资源但都不肯放手，于是陷入无穷等待。</li></ul></li></ol><hr><h3 id="3-串行、并行、并发"><a href="#3-串行、并行、并发" class="headerlink" title="3.串行、并行、并发"></a>3.串行、并行、并发</h3><h4 id="①串行、并行、并发"><a href="#①串行、并行、并发" class="headerlink" title="①串行、并行、并发"></a>①串行、并行、并发</h4><ul><li>串行：大家排队一个个来<ul><li>左图：线程 A -&gt; B -&gt; C 依次执行</li><li>右图：将数据一位一位发送</li></ul></li><li>并行：大家一起来<ul><li>左图：线程 A / B / C 同时执行</li><li>右图：将 8 个数据一次性发送出去</li></ul></li></ul><p><img src="./1582653345934.png" alt="Alt text"></p><ul><li>并发（Concurrency）：单核就能实现并发、属于逻辑上的同时运行（由于处理器的处理速度很快，所以线程之间的切换肉眼是感知不到的，感觉它是在同时执行多个程序，实际某一时间只有一个程序执行（单处理器））。<ul><li>在物理层面并发就是串行，只不过是在多个程序上快速的来回切换而不是一个个依次执行，所以在用户看来相当于三个程序同时执行。</li></ul></li><li>并行（Parallelism）：多核处理器，物理上的同时运行，多个处理器都在同时执行任务。</li></ul><p><img src="./1582653313196.png" alt="Alt text"><br><img src="./1582086357063.png" alt="Alt text"></p><ul><li>并行是真正的 “同时” 运行：在同一时刻，有多个任务同时执行。<ul><li>单核处理器是无法实现并行的，因为单核处理器无法在同一时刻执行多个任务。</li></ul></li><li>并发可以对应到两个不同的概念</li><li>①形容多个任务的执行状态：<ul><li>两个或多个任务可以在重叠的时间段（不是指真正重叠的同一时刻，而是一段时间内交替运行）内启动，运行和完成。</li><li>并行（两个线程同时执行）一定是并发，两者是包含关系。</li><li>并发 + 多核 + 同一时刻执行同一段代码 = 并行</li><li>并发：不同的线程交替给一个 CPU 执行（蓝色竖线：CPU 的时间片）</li><li>并行：多个线程同时被多个 CPU 执行</li></ul></li></ul><p><img src="./1582653247372.png" alt="Alt text"><br><img src="./1582653213782.png" alt="Alt text"></p><ul><li>②对 “并发性” 的简称：<ul><li>如果一个程序具有并发性，指的是程序不同的部分可以无序或同时执行，且不影响最终的执行结果。</li><li>在不同核心数的计算机上的表现不同：</li><li>在多核 CPU 上，可以并行执行并发性程序。</li><li>在单核 CPU 上，可以并发执行并发性程序，串行执行非并发性程序。</li><li>此时，并行和并发的概念并不在同一维度上。并发指的是并发性，并行指的是多个程序在同一时刻同时执行。一个程序如果想要并发 / 并行执行，前提条件是它具有并发性。并发性是并发执行和并行执行的前提条件和必要条件。如果一个程序可以并行执行，就代表它一定具有并发性。</li></ul></li></ul><h4 id="②是什么让并发和并行成为可能？"><a href="#②是什么让并发和并行成为可能？" class="headerlink" title="②是什么让并发和并行成为可能？"></a>②是什么让并发和并行成为可能？</h4><ol><li>CPU 升级<ul><li>CPU 之前一直遵循摩尔定律，性能提升的很快，它的处理速度远远比其他部件快。但是每个 CPU 同一时刻只能执行一个指令，出于这个原因，操作系统开发出了新的技术，可以让用户同时运行多个进程或者多个线程。</li></ul></li><li>操作系统的升级<ul><li>升级之后将 CPU 完美的调度了起来，即便是单核 CPU，也能让不同的进程使用时间片的方式（抢占式的方式）不停地切换。</li><li>抢占式多任务处理：现代 CPU 最主要的一种处理方式，即操作系统有权利中断正在执行的任务。</li><li>诞生多核处理器后，操作系统可以自动检测 CPU 核心的数量，为每个核心分配不同的任务，以实现真正地同一时刻运行多个程序。</li></ul></li><li>编程语言的升级<ul><li>Java 语言诞生之前，很多编程语言不支持多线程。随着 Java 的诞生，多线程编程开始逐渐火热并且发展成熟。</li></ul></li></ol><hr><h3 id="4-高并发"><a href="#4-高并发" class="headerlink" title="4.高并发"></a>4.高并发</h3><h4 id="①定义-1"><a href="#①定义-1" class="headerlink" title="①定义"></a>①定义</h4><ul><li>高并发：同时有很多个请求发送给服务器系统，服务器会并行处理。</li><li>高并发场景：天猫双十一、春晚微信摇一摇、12306 卖火车票</li><li>一般将系统的承受能力设计为目前系统访问量的十倍比较合适</li></ul><h4 id="②高并发和多线程的异同？"><a href="#②高并发和多线程的异同？" class="headerlink" title="②高并发和多线程的异同？"></a>②高并发和多线程的异同？</h4><ul><li>高并发：指大量的请求同时到达服务器所带来的结果（结果指服务器需要同时处理很多请求），它是一种状态。系统需要应对高并发这种状态所带来的后果，如果处理不当，会导致请求的响应速度慢、无响应甚至服务器死机。</li><li>多线程并不意味着高并发，多线程编程是一种编程方式，是一种解决方案，不仅可以解决高并发所带来的线程安全问题 / 性能问题，还可以提高硬件的利用率，以便获取到更多的资源，从而解决高并发带来的服务器死机、响应慢等问题。<ul><li>多线程编程是我们应对高并发场景的一种重要的解决方案。</li></ul></li><li>高并发并不一定要通过多线程的方式解决<ul><li>例如：解决数据库的高并发问题可以利用 Redis 缓存层（可能带来缓存不一致的问题，但不会带来线程安全问题）</li></ul></li><li>总结：高并发并不意味着多线程（例如：Redis 底层是用单线程处理的）。高并发是一种状态，作为服务器开发者，最好用多线程的方式解决，这样可以提高 CPU 等资源的利用率，加快用户的响应速度。但是在场景不同，资源不同的情况下，也可以选择其他的解决方案。</li></ul><h4 id="③高并发有哪些指标？"><a href="#③高并发有哪些指标？" class="headerlink" title="③高并发有哪些指标？"></a>③高并发有哪些指标？</h4><ul><li>QPS（Queries Per Second）：每秒钟的查询（请求）数</li><li>PV（Page View）：24 小时内的页面点击量（综合浏览量）</li><li>UV（Unique Visitor）：24 小时内访问的用户数量（根据 Cookie）、UV &lt;= PV</li><li>并发连接数：某个时刻服务器所接受的请求的数目。<ul><li>对于同一个用户而言，可以同时产生很多个会话 / 连接，所以数目 &gt; 同时在线的用户数量。</li><li>对服务器来说，这个连接有一个上限</li></ul></li><li>服务器平均请求等待时间：服务器处理一个请求所花费的时间</li></ul><hr><h3 id="5-同步与异步、阻塞与非阻塞"><a href="#5-同步与异步、阻塞与非阻塞" class="headerlink" title="5.同步与异步、阻塞与非阻塞"></a>5.同步与异步、阻塞与非阻塞</h3><h4 id="①同步与异步"><a href="#①同步与异步" class="headerlink" title="①同步与异步"></a>①同步与异步</h4><ul><li>同步与异步：被调用方是否主动告诉调用方结果。<ul><li>同步与异步是被调用方（即服务端）的行为，而不是调用方的行为。</li><li>同步：在没有得到结果之前，服务端不返回任何结果。</li><li>异步：调用在发出之后，服务端会立刻返回，告诉调用方 “我收到你的请求了，我会马上处理的”，等服务器处理完成以后，会再次告诉调用方 “我已经处理完了”。</li></ul></li></ul><p><img src="./1582653108706.png" alt="Alt text"><br><img src="./1582653143245.png" alt="Alt text"><br><img src="./1582653156676.png" alt="Alt text"><br><img src="./1582653175803.png" alt="Alt text"></p><h4 id="②阻塞与非阻塞"><a href="#②阻塞与非阻塞" class="headerlink" title="②阻塞与非阻塞"></a>②阻塞与非阻塞</h4><ul><li>站在线程状态的角度：阻塞指当前线程不能继续执行，需要等待一段时间或者被唤醒。</li><li>站在线程发出请求的角度：我是调用方，我调用一个东西后，在返回结果前是否还能做其他事情。</li><li>阻塞与非阻塞是调用方的行为，而不是被调用方的行为。<ul><li>阻塞：调用一个东西后，返回结果前什么也不做。</li><li>非阻塞：调用一个东西后，返回结果前做其他事情。</li></ul></li></ul><h4 id="③同步阻塞、同步非阻塞、异步阻塞、异步非阻塞"><a href="#③同步阻塞、同步非阻塞、异步阻塞、异步非阻塞" class="headerlink" title="③同步阻塞、同步非阻塞、异步阻塞、异步非阻塞"></a>③同步阻塞、同步非阻塞、异步阻塞、异步非阻塞</h4><ul><li>同步不一定是阻塞，阻塞也不一定是同步。</li><li>异步不一定是非阻塞，非阻塞也不一定是异步。</li><li>同步阻塞：（被调用方）执行完成后才返回结果、（调用方）在返回结果前什么也不做。</li><li>同步非阻塞：（被调用方）执行完成后才返回结果、（调用方）在返回结果前做其他事情，不时地检查一下被调用方是否返回结果。</li><li>异步阻塞：调用方在发出请求之后，被调用方会立刻告诉调用方已经收到请求，当被调用方处理完成以后，会再次告诉调用方已经处理完了、但是（调用方）在返回结果前什么也不做。</li><li>异步非阻塞：调用方在发出请求之后，被调用方会立刻告诉调用方已经收到请求，当被调用方处理完成以后，会再次告诉调用方已经处理完了、（调用方）在返回结果前做其他事情，等待被调用方主动返回结果。</li></ul><hr><h3 id="6-常见面试问题"><a href="#6-常见面试问题" class="headerlink" title="6.常见面试问题"></a>6.常见面试问题</h3><h4 id="①进程和线程的异同？"><a href="#①进程和线程的异同？" class="headerlink" title="①进程和线程的异同？"></a>①进程和线程的异同？</h4><ul><li>不同：起源、概念、内存共享方式、拥有的资源、数量、开销</li><li>相同：生命周期（状态）</li><li>具体见 <strong>1.进程和线程——④两者的异同</strong></li></ul><h4 id="②并行和并发的异同？"><a href="#②并行和并发的异同？" class="headerlink" title="②并行和并发的异同？"></a>②并行和并发的异同？</h4><ul><li>都在形容一个程序的运行状态时：并行一定是并发。</li><li>并发也可以形容一个程序的属性，即程序是否具有并发性。若是程序没有并发性，表示程序只能串行执行。</li></ul><h4 id="③多线程就是高并发吗？有什么反例？"><a href="#③多线程就是高并发吗？有什么反例？" class="headerlink" title="③多线程就是高并发吗？有什么反例？"></a>③多线程就是高并发吗？有什么反例？</h4><ul><li>高并发指服务器同时接受很多请求，受到极大压力。</li><li>多线程是针对高并发的一个解决方案，可以使用多线程将这个压力迅速化解。</li><li>反例：Redis 本身是单线程的，但是同样可以支持高并发的场景。</li><li>应对高并发时，不仅可以通过多线程的方式解决，也可以从整体架构、缓存层的设计、MQ 队列等地方着手解决。</li></ul><h4 id="④多线程可以提高程序的执行效率，你知不知道有哪些弊端？"><a href="#④多线程可以提高程序的执行效率，你知不知道有哪些弊端？" class="headerlink" title="④多线程可以提高程序的执行效率，你知不知道有哪些弊端？"></a>④多线程可以提高程序的执行效率，你知不知道有哪些弊端？</h4><ol><li>性能问题（上下文切换、保存 CPU cache）</li><li>异构化任务或不能并行执行的任务用多线程反而不如用单线程合适</li><li>线程安全问题</li></ol><h4 id="⑤什么是同步？什么是异步？什么是阻塞？什么是非阻塞？"><a href="#⑤什么是同步？什么是异步？什么是阻塞？什么是非阻塞？" class="headerlink" title="⑤什么是同步？什么是异步？什么是阻塞？什么是非阻塞？"></a>⑤什么是同步？什么是异步？什么是阻塞？什么是非阻塞？</h4><ul><li>同步、异步指的是被调用方在调用结束后是否主动返回结果</li><li>阻塞、非阻塞指的是调用方在调用后是否可以去做其他事情</li><li>具体见 <strong>5.同步与异步、阻塞与非阻塞</strong></li></ul><h4 id="⑥在单核-CPU-上运行多线程程序有意义吗？"><a href="#⑥在单核-CPU-上运行多线程程序有意义吗？" class="headerlink" title="⑥在单核 CPU 上运行多线程程序有意义吗？"></a>⑥在单核 CPU 上运行多线程程序有意义吗？</h4><ul><li>有意义，虽然在单核 CPU 上执行真正的并行是不可能的，因为只有一个处理器，但是对于应用程序而言，我们不知道它未来会运行在单核 CPU 还是多核 CPU 上，所以在编写时肯定以多核 CPU 为准。其次，对于多线程程序，当其中一个线程执行缓慢或者被阻塞时，其他线程可以利用这些时间（如读取磁盘的时间）做其他事情，让程序保持高效运转。</li><li>如果 CPU 被挤满，并不是说在单核 CPU 上运行多线程程序没有意义，而是说线程的数量设置不合理，应该减少线程的数量。</li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#119;&#x6a;&#121;&#x6d;&#101;&#115;&#115;&#105;&#64;&#49;&#54;&#51;&#x2e;&#x63;&#111;&#x6d;" target="_blank" rel="noopener">&#119;&#x6a;&#121;&#x6d;&#101;&#115;&#115;&#105;&#64;&#49;&#54;&#51;&#x2e;&#x63;&#111;&#x6d;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-进程和线程&quot;&gt;&lt;a href=&quot;#1-进程和线程&quot; class=&quot;headerlink&quot; title=&quot;1.进程和线程&quot;&gt;&lt;/a&gt;1.进程和线程&lt;/h3&gt;&lt;h4 id=&quot;①与操作系统的关系&quot;&gt;&lt;a href=&quot;#①与操作系统的关系&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized关键字</title>
    <link href="http://messi1002.top/2020/02/20/Synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://messi1002.top/2020/02/20/Synchronized关键字/</id>
    <published>2020-02-20T04:21:51.000Z</published>
    <updated>2020-02-25T04:45:17.641Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><h4 id="①作用"><a href="#①作用" class="headerlink" title="①作用"></a>①作用</h4><ul><li>Oracle 的官方解释：synchronized 关键字的同步方法支持一种简单的策略来防止线程干扰和内存一致性错误。<ul><li>如果一个对象对多个线程可见，则对该对象变量的所有读取或写入都是通过同步方法完成的。</li></ul></li><li>一句话总结 synchronized 的作用：能够保证在同一时刻最多只有一个线程执行该段代码，以达到保证并发安全的效果。<ul><li>被 synchronized 关键字修饰的代码会以原子的方式执行，即多个线程不会同时执行这段代码，同一时刻最多只有一个线程执行该段代码。</li><li>如何控制同一时刻只有一个线程执行该段代码？有一把锁，当第一个线程执行这段代码时拿到这把锁，直到方法执行结束或一定条件后才会释放这把锁。在这把锁释放前，其他线程想要执行这段代码，只能等待或者阻塞。直到锁释放后，其他线程才能执行这段代码。</li></ul></li></ul><h4 id="②地位"><a href="#②地位" class="headerlink" title="②地位"></a>②地位</h4><ul><li>synchronized 是 Java 的关键字，被 Java 语言原生支持。<ul><li><strong>volatile</strong> 也是 Java 的关键字（它们都是 Java 并发编程中的重要关键字）</li></ul></li><li>它是最基本的互斥同步手段<ul><li>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。　　</li><li>同步：指程序用于控制不同线程之间操作发生相对顺序的机制。</li></ul></li><li>它是并发编程中的元老级角色，是并发编程的必学内容。</li></ul><h4 id="③不使用并发（同步方法）的后果"><a href="#③不使用并发（同步方法）的后果" class="headerlink" title="③不使用并发（同步方法）的后果"></a>③不使用并发（同步方法）的后果</h4><ul><li>代码实战：两个线程同时执行 <code>a++</code>，最后结果会被预计的少。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 不使用并发手段，建立两个线程一起执行a++。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoUseConcurrency</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建类的实例</span></span><br><span class="line">    <span class="keyword">static</span> NoUseConcurrency instance = <span class="keyword">new</span> NoUseConcurrency();</span><br><span class="line">    <span class="comment">// 初始化a的值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 建立两个线程，利用同一个实例，共用实例中的方法。</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待两个子线程都执行完成</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>连续运行三次程序，打印的结果各不相同。</li></ul><p><img src="./1582533268242.png" alt="Alt text"><br><img src="./1582533337941.png" alt="Alt text"><br><img src="./1582533388383.png" alt="Alt text"></p><ul><li>原因：<code>a++</code> 看上去只是一个操作，实际上包含了三个步骤：<ul><li>①读取 a</li><li>②将 a 的值加 1</li><li>③将 a 的值写入到内存中</li></ul></li><li>而在多线程的情况下任何一步执行完成后都有可能被打断，都有可能轮到另一个线程去执行，即线程不安全。</li></ul><h4 id="④使用并发（同步方法）"><a href="#④使用并发（同步方法）" class="headerlink" title="④使用并发（同步方法）"></a>④使用并发（同步方法）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 使用并发手段，建立两个线程一起执行a++。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseConcurrency</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> UseConcurrency instance = <span class="keyword">new</span> UseConcurrency();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 建立两个线程，利用同一个实例，共用实例中的方法。</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待两个子线程都执行完成</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对象锁-方法锁</span></span><br><span class="line">    <span class="comment">// 将关键字加在普通方法上</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重复运行多次程序，打印结果都是 <code>a = 200000</code>。</li></ul><hr><h3 id="2-用法"><a href="#2-用法" class="headerlink" title="2.用法"></a>2.用法</h3><blockquote><p>synchronized 关键字也叫做同步修饰符<br>音标：[ˈsɪŋkrənaɪzd]</p></blockquote><h4 id="①对象锁"><a href="#①对象锁" class="headerlink" title="①对象锁"></a>①对象锁</h4><ul><li>对象锁的两种形式：</li><li>同步代码块锁<ul><li>手动指定锁对象（this 或自定义对象）</li></ul></li><li>方法锁<ul><li>synchronized 修饰普通方法（不能修饰静态方法），锁对象默认为 this。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 对象锁实例1之同步代码块形式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectLock1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObjectLock1 instance = <span class="keyword">new</span> SynchronizedObjectLock1();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 默认用this(当前对象)作为锁对象</span></span><br><span class="line">        <span class="comment">// 保护以下代码块串行执行</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"开始执行"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 建立两个线程，利用同一个实例，共用实例中的方法。</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待两个子线程都执行完成</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码线程 0 先执行，执行完成后线程 1 再执行。</li></ul><p><img src="./1582534624946.png" alt="Alt text"><br><img src="./1582534690028.png" alt="Alt text"><br><img src="./1582534597454.png" alt="Alt text"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 对象锁实例1之同步代码块形式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectLock1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObjectLock1 instance = <span class="keyword">new</span> SynchronizedObjectLock1();</span><br><span class="line">    <span class="comment">// 创建自定义锁对象，lock1和lock2保护的时机不相同。</span></span><br><span class="line">    Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">    Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义锁对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"开始执行(lock1)"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行结束(lock1)"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"开始执行(lock2)"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行结束(lock2)"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 建立两个线程，利用同一个实例，共用实例中的方法。</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待两个子线程都执行完成</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码线程 0 拿到第 2 把锁的同时，线程 1 拿到第 1 把锁，并行执行（第一把锁和第二把锁不相同，互不影响）。</li></ul><p><img src="./1582536037312.png" alt="Alt text"><br><img src="./1582536127382.png" alt="Alt text"><br><img src="./1582536195719.png" alt="Alt text"><br><img src="./1582535365421.png" alt="Alt text"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 对象锁示例2之方法锁形式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectLock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObjectLock2 instance = <span class="keyword">new</span> SynchronizedObjectLock2();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对普通方法加上synchronized修饰符，保护以下代码块串行执行。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"对象锁的方法修饰符形式"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"执行结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 建立两个线程，利用同一个实例，共用实例中的方法。</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待两个子线程都执行完成</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码线程 0 先执行，执行完成后线程 1 再执行。</li></ul><p><img src="./1582537941538.png" alt="Alt text"><br><img src="./1582537977048.png" alt="Alt text"><br><img src="./1582538009150.png" alt="Alt text"></p><h4 id="②类锁"><a href="#②类锁" class="headerlink" title="②类锁"></a>②类锁</h4><ul><li>Java 类可能有很多个对象，但是只有 1 个 Class 对象。</li><li>本质：所谓的类锁，就是 Class 对象的锁。</li><li>效果：类锁在同一时刻只能被一个对象拥有</li><li>类锁的两种形式：</li><li>静态锁<ul><li>synchronized 加在 static 方法上 </li></ul></li><li>Class 对象<ul><li>synchronized 代码块（锁对象默认为 Class 对象） </li><li>指定锁为 Class 对象</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 类锁示例1之静态锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedClassLock1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedClassLock1 instance1 = <span class="keyword">new</span> SynchronizedClassLock1();</span><br><span class="line">    <span class="keyword">static</span> SynchronizedClassLock1 instance2 = <span class="keyword">new</span> SynchronizedClassLock1();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// synchronized修饰符修饰静态方法</span></span><br><span class="line">    <span class="comment">// 在全局情况下保护以下代码块串行执行(不是对象的层面)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 建立两个线程，两个线程分别引用同一个类的不同实例。</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待两个子线程都执行完成</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码线程 0 先执行，执行完成后线程 1 再执行。</li></ul><p><img src="./1582539304996.png" alt="Alt text"><br><img src="./1582539337288.png" alt="Alt text"><br><img src="./1582539375670.png" alt="Alt text"></p><ul><li>若是将 <code>method()</code> 方法变为非静态方法，此时就算加了 synchronized 关键字，线程 0 和线程 1 也会同时执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 类锁示例1之静态锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedClassLock1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedClassLock1 instance1 = <span class="keyword">new</span> SynchronizedClassLock1();</span><br><span class="line">    <span class="keyword">static</span> SynchronizedClassLock1 instance2 = <span class="keyword">new</span> SynchronizedClassLock1();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// synchronized修饰符修饰非静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 建立两个线程，两个线程分别引用同一个类的不同实例</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待两个子线程都执行完成</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">      System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582540371493.png" alt="Alt text"><br><img src="./1582540395219.png" alt="Alt text"></p><ul><li>因为静态方法属于整个类，当多个线程（类的不同实例）访问这个类的静态方法时，实际访问的是同一个方法。所以给这个静态方法上锁之后，同一时刻只能由一个线程执行该方法。</li><li>而非静态方法属于调用它的实例对象，当两个线程分别调用其实例对象的非静态方法时，相当于各自执行自己的方法，这时加或不加锁都不影响各自方法的执行。</li><li>所以类锁适用于在全局情况下同步方法，而不仅仅在对象层面。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 类锁示例2之Class对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedClassLock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedClassLock2 instance1 = <span class="keyword">new</span> SynchronizedClassLock2();</span><br><span class="line">    <span class="keyword">static</span> SynchronizedClassLock2 instance2 = <span class="keyword">new</span> SynchronizedClassLock2();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 锁对象是SynchronizedClassLock2.class</span></span><br><span class="line">        <span class="comment">// 无论是类的哪个实例用的都是同一个锁对象(串行执行)</span></span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedClassLock2.class) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 建立两个线程，两个线程分别引用同一个类的不同实例</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待两个子线程都执行完成</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码线程 0 先执行，执行完成后线程 1 再执行。</li></ul><p><img src="./1582541802253.png" alt="Alt text"><br><img src="./1582541826775.png" alt="Alt text"><br><img src="./1582541841546.png" alt="Alt text"></p><ul><li>若是将 synchronized 代码块中的 <code>SynchronizedClassLock2.class</code> 改为 <code>this</code>，此时就算是加了 synchronized 关键字，线程 0 和线程 1 也会同时执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 类锁示例2之Class对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedClassLock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedClassLock2 instance1 = <span class="keyword">new</span> SynchronizedClassLock2();</span><br><span class="line">    <span class="keyword">static</span> SynchronizedClassLock2 instance2 = <span class="keyword">new</span> SynchronizedClassLock2();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 锁对象是this</span></span><br><span class="line">        <span class="comment">// 不同实例的锁对象不同，多个线程并行执行。</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 建立两个线程，两个线程分别引用同一个类的不同实例</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待两个子线程都执行完成</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582542407010.png" alt="Alt text"><br><img src="./1582542460177.png" alt="Alt text"></p><ul><li>原因：不同实例的锁对象不同，多个线程并行执行。</li></ul><hr><h3 id="3-多线程访问同步方法的-7-种情况（面试常考）"><a href="#3-多线程访问同步方法的-7-种情况（面试常考）" class="headerlink" title="3.多线程访问同步方法的 7 种情况（面试常考）"></a>3.多线程访问同步方法的 7 种情况（面试常考）</h3><blockquote><p>同步方法：被 synchronized 关键字所修饰的方法<br>非同步方法：没有被 synchronized 关键字所修饰的方法<br>普通方法：指非静态方法</p></blockquote><h4 id="①两个线程同时访问一个对象的同步方法"><a href="#①两个线程同时访问一个对象的同步方法" class="headerlink" title="①两个线程同时访问一个对象的同步方法"></a>①两个线程同时访问一个对象的同步方法</h4><ul><li>原因：两个线程属于同一个实例，所以两个线程访问的是同一个方法，而这个方法被 synchronized 关键字修饰后默认以 this 对象作为同步方法的锁，所以它们会争抢同一把锁。</li><li>结果：两个线程争抢同一把锁，同一时刻只能有一个线程执行该同步方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 两个线程同时访问一个对象的同步方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Situation1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Situation1 instance = <span class="keyword">new</span> Situation1();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Situation1.class finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582547849811.png" alt="Alt text"><br><img src="./1582547871624.png" alt="Alt text"><br><img src="./1582547896299.png" alt="Alt text"></p><h4 id="②两个线程访问的是两个对象的同步方法"><a href="#②两个线程访问的是两个对象的同步方法" class="headerlink" title="②两个线程访问的是两个对象的同步方法"></a>②两个线程访问的是两个对象的同步方法</h4><ul><li>原因：两个线程属于不同的实例，所以两个线程访问的是不同的方法，而每个方法被 synchronized 关键字修饰后默认以 this 对象作为同步方法的锁，所以它们的锁对象不是同一个。</li><li>结果：两个线程的锁对象不是同一个，并行执行，互不干扰。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 两个线程访问的是两个对象的同步方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Situation2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Situation2 instance1 = <span class="keyword">new</span> Situation2();</span><br><span class="line">    <span class="keyword">static</span> Situation2 instance2 = <span class="keyword">new</span> Situation2();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Situation2.class finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582548056867.png" alt="Alt text"><br><img src="./1582548075858.png" alt="Alt text"></p><h4 id="③两个线程访问的是-synchronized-的静态方法"><a href="#③两个线程访问的是-synchronized-的静态方法" class="headerlink" title="③两个线程访问的是 synchronized 的静态方法"></a>③两个线程访问的是 synchronized 的静态方法</h4><ul><li>原因：虽然两个线程属于类的不同实例，但是两个线程访问的方法是类的静态方法，即它们实际访问的是同一个方法。给这个静态方法上锁之后，同一时刻只能有一个线程执行该方法。</li><li>结果：两个线程争抢同一把锁，同一时刻只能有一个线程执行该同步方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 两个线程访问的是synchronized的静态方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Situation3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Situation3 instance1 = <span class="keyword">new</span> Situation3();</span><br><span class="line">    <span class="keyword">static</span> Situation3 instance2 = <span class="keyword">new</span> Situation3();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Situation3.class finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582548260523.png" alt="Alt text"><br><img src="./1582548289256.png" alt="Alt text"><br><img src="./1582548315931.png" alt="Alt text"></p><h4 id="④同时访问同步方法与非同步方法"><a href="#④同时访问同步方法与非同步方法" class="headerlink" title="④同时访问同步方法与非同步方法"></a>④同时访问同步方法与非同步方法</h4><ul><li>原因：synchronized 关键字只作用于其指定的方法中，其他非同步方法不受到影响。</li><li>结果：当线程 0 访问同步方法，线程 1 访问非同步方法时，两个线程并行执行，互不干扰。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 同时访问同步和非同步方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Situation4</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Situation4 instance = <span class="keyword">new</span> Situation4();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 让线程0运行method1()方法，线程1运行method2()方法。</span></span><br><span class="line">        <span class="comment">// 线程的默认名是从Thread-0(Thread-1、Thread-2、...)开始。</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread().getName().equals(<span class="string">"Thread-0"</span>)) &#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            method2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行(加锁的方法)"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行(加锁的方法)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行(没加锁的方法)"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行(没加锁的方法)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Situation4.class finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582548882215.png" alt="Alt text"><br><img src="./1582548895883.png" alt="Alt text"></p><h4 id="⑤同时访问一个类的不同的普通同步方法"><a href="#⑤同时访问一个类的不同的普通同步方法" class="headerlink" title="⑤同时访问一个类的不同的普通同步方法"></a>⑤同时访问一个类的不同的普通同步方法</h4><ul><li>原因：两个线程属于同一个实例，虽然两个线程访问的是一个类的不同的普通同步方法，但是被 synchronized 关键字修饰的普通方法默认都是以 this 对象作为同步方法的锁，所以它们会争抢同一把锁（对于同一个实例来讲，两个方法的 this 对象是同一个）。</li><li>结果：两个线程争抢同一把锁，同一时刻只能有一个线程执行该线程对应的同步方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 同时访问一个类的不同的普通同步方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Situation5</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Situation5 instance = <span class="keyword">new</span> Situation5();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread().getName().equals(<span class="string">"Thread-0"</span>)) &#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            method2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行(加锁的方法)"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行(加锁的方法)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行(加锁的方法)"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行(加锁的方法)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Situation5.class finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582549226682.png" alt="Alt text"><br><img src="./1582549274126.png" alt="Alt text"><br><img src="./1582549286842.png" alt="Alt text"></p><h4 id="⑥同时访问静态-synchronized-和非静态-synchronized-方法"><a href="#⑥同时访问静态-synchronized-和非静态-synchronized-方法" class="headerlink" title="⑥同时访问静态 synchronized 和非静态 synchronized 方法"></a>⑥同时访问静态 synchronized 和非静态 synchronized 方法</h4><ul><li>原因：<ul><li>synchronized 关键字修饰静态方法：类锁，锁住的是 .class 对象。</li><li>synchronized 关键字修饰非静态方法：方法锁，锁住的是实例本身 this。</li><li>两个线程的锁对象不是同一个，所以两个线程可以同时运行。</li></ul></li><li>结果：两个线程的锁对象不是同一个，并行执行，互不干扰。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 同时访问静态synchronized和非静态synchronized方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Situation6</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Situation6 instance = <span class="keyword">new</span> Situation6();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread().getName().equals(<span class="string">"Thread-0"</span>)) &#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            method2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行(静态加锁的方法)"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行(静态加锁的方法)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行(非静态加锁的方法)"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行(非静态加锁的方法)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Situation6.class finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582549897829.png" alt="Alt text"><br><img src="./1582549910266.png" alt="Alt text"></p><h4 id="⑦方法抛出异常后会释放锁"><a href="#⑦方法抛出异常后会释放锁" class="headerlink" title="⑦方法抛出异常后会释放锁"></a>⑦方法抛出异常后会释放锁</h4><ul><li>synchronized：方法抛出异常后会主动释放锁。</li><li>Lock 类：方法抛出异常后不会主动释放锁，必须显式地释放锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 方法抛出异常后会释放锁</span></span><br><span class="line"><span class="comment"> * 展示不抛出异常前和抛出异常后的对比: 一旦第一个线程抛出异常，第二个线程会立刻进入同步方法，意味着锁已经释放。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Situation7</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Situation7 instance = <span class="keyword">new</span> Situation7();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 方法抛出异常后，JVM帮我们释放了锁，不需要手动释放锁。</span></span><br><span class="line">        <span class="comment">// 抛出运行时异常，不强制要求捕获。</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Situation7.class finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582550356233.png" alt="Alt text"><br><img src="./1582550465567.png" alt="Alt text"></p><h4 id="⑧总结"><a href="#⑧总结" class="headerlink" title="⑧总结"></a>⑧总结</h4><ol><li>一把锁只能同时被一个线程获取，没有拿到锁的线程必须等待（对应①、⑤）。</li><li>每个实例都对应有自己的一把锁，不同的实例之间对应不同的锁，所以不同的实例之间互不影响。<ul><li>例外：锁对象是 .class 以及 synchronized 修饰的是 static 方法的时候，所有对象共用同一把类锁（对应②、③、④、⑥） 。</li></ul></li><li>无论是方法正常执行完毕或者方法抛出异常，都会释放锁（对应⑦）。</li><li>在被 synchronized 修饰的方法中调用没有被 synchronized 修饰的方法时，不是线程安全的，因为没有被 synchronized 修饰的方法是可以被多个线程同时访问的。</li></ol><hr><h3 id="4-性质"><a href="#4-性质" class="headerlink" title="4.性质"></a>4.性质</h3><h4 id="①可重入性（递归锁）"><a href="#①可重入性（递归锁）" class="headerlink" title="①可重入性（递归锁）"></a>①可重入性（递归锁）</h4><ul><li><p>这是它区别于其他锁的关键特点</p></li><li><p>可重入性：指的是同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁。</p><ul><li>ReentrantLock 也是可重入锁</li></ul></li><li><p>好处：</p><ul><li>避免死锁（假设方法 1 和方法 2 都被 synchronized 关键字修饰，此时某线程执行方法 1 和方法 2 时都需要同一把锁。假如线程 A 执行了方法 1 并且获得了这把锁，此时方法 1 要想访问方法 2，假设 synchronized 关键字没有可重入性，相当于线程 A 没有方法 2 的锁，不能直接使用本身已经获得的锁。既想要拿到方法 2 的锁又不释放方法 1 的锁<br>（方法 1 和方法 2 是同一把锁），就开始了永久等待，变成了死锁。）</li><li>提升封装性（避免一次次解锁、加锁，提高了封装性，简化了并发编程的难度。）</li></ul></li><li><p>粒度：即范围，默认加锁的范围是线程而非调用。</p><ul><li>情况1：访问同一个方法是可重入的</li><li>情况2：可重入不要求是同一个方法（即证明在一个同步方法中调用另一个同步方法是可行的）</li><li>情况3：可重入不要求是同一个类中的</li><li>以上三种情况证明了可重入的粒度不是调用范围的，而是线程范围的。所以在同一个线程中，如果已经拿到了一把锁，又想继续使用这把锁访问其他（类的）方法时，只要锁是同一把锁，就可以访问。</li></ul></li><li><p>证明情况1：访问同一个方法是可重入的</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 可重入粒度测试1——递归调用本方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantGranularityTest1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a = "</span> + a);</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">            a++;</span><br><span class="line">            <span class="comment">// 调用方法本身</span></span><br><span class="line">            method();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantGranularityTest1 test1 = <span class="keyword">new</span> ReentrantGranularityTest1();</span><br><span class="line">        test1.method();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582552644697.png" alt="Alt text"></p><ul><li>证明情况2：可重入不要求是同一个方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 可重入粒度测试2——调用类内其他的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantGranularityTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是方法一"</span>);</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是方法二"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantGranularityTest2 test2 = <span class="keyword">new</span> ReentrantGranularityTest2();</span><br><span class="line">        test2.method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582552602807.png" alt="Alt text"></p><ul><li>证明情况3：可重入不要求是同一个类中的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 可重入粒度测试3——父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantGranularityTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是父类方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 可重入粒度测试3——调用父类的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantGranularityTest3</span> <span class="keyword">extends</span> <span class="title">ReentrantGranularityTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 重写父类方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/20 22:30</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是子类方法"</span>);</span><br><span class="line">        <span class="comment">// 调用父类方法</span></span><br><span class="line">        <span class="keyword">super</span>.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantGranularityTest3 test3 = <span class="keyword">new</span> ReentrantGranularityTest3();</span><br><span class="line">        <span class="comment">// 执行子类方法</span></span><br><span class="line">        test3.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582552861324.png" alt="Alt text"></p><h4 id="②不可中断性"><a href="#②不可中断性" class="headerlink" title="②不可中断性"></a>②不可中断性</h4><ul><li>这个性质是 synchronized 关键字的劣势</li><li>不可中断性：一旦这个锁已经被别人获得了，如果我还想获取，我只能选择等待或者阻塞，直到别的线程释放这个锁。如果别人永远不释放锁，那么我只能永远等待下去。</li><li>而 Lock 类拥有可以中断的能力<ul><li>如果我觉得我等待的时间太长了，有权中断现在已经获取到锁的那个线程的执行。</li><li>如果我觉得我等待的时间太长了不想再等了，也可以直接退出。</li></ul></li></ul><hr><h3 id="5-原理"><a href="#5-原理" class="headerlink" title="5.原理"></a>5.原理</h3><h4 id="①加锁和释放锁的原理"><a href="#①加锁和释放锁的原理" class="headerlink" title="①加锁和释放锁的原理"></a>①加锁和释放锁的原理</h4><ul><li>每一个类的实例对应着一把锁，而每一个被 synchronized 关键字修饰的方法都必须首先获得调用该方法的类的实例的锁才能执行，否则线程就会阻塞。而方法一旦执行，就会独占这把锁，直到该方法返回或者抛出异常，才会将锁释放。释放之后，其他被阻塞的线程就能获得这把锁，重新进入到可执行的状态。</li><li>即当一个对象中有 synchronized 关键字修饰的方法或者代码块时，要想执行这段代码，就必须先获得对象锁。如果此对象的对象锁已经被其他调用者占用了，就必须等待它被释放。所有的 Java 对象都含有一个互斥锁，这个锁由 JVM 自动去获取和释放，我们只需要指定这个对象就可以了。</li><li>获取和释放锁的时机：内置锁<ul><li>每个 Java 对象都可以用作一个实现同步的锁，这个锁被称为内置锁或监视器锁。线程在进入到同步代码块之前，会自动获得这个锁，并且在退出同步代码块的时候，会自动释放。</li><li>获得内置锁的唯一途径，就是进入到锁所保护的同步代码块或方法中。</li></ul></li><li>下面用 Lock 模拟 synchronized 加锁和释放锁的时机：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 用lock模拟synchronized加锁和释放锁的时机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockAndUnlock</span> </span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 进入方法时隐形地获取一把锁</span></span><br><span class="line">        System.out.println(<span class="string">"我是synchronized形式的锁"</span>);</span><br><span class="line">        <span class="comment">// 退出方法时隐形地释放一把锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"我是lock形式的锁"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// synchronized和lock在底层可以相互类比和配合</span></span><br><span class="line">        <span class="comment">// method1方法和method2方法等价</span></span><br><span class="line">        <span class="comment">// 将method1中synchronized锁住和解锁的时机用method2中拆分的形式表达</span></span><br><span class="line">        LockAndUnlock l = <span class="keyword">new</span> LockAndUnlock();</span><br><span class="line">        l.method1();</span><br><span class="line">        l.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582555202885.png" alt="Alt text"></p><h4 id="③反编译看-monitor-指令"><a href="#③反编译看-monitor-指令" class="headerlink" title="③反编译看 monitor 指令"></a>③反编译看 monitor 指令</h4><ul><li><p>synchronized 是如何工作的</p><ul><li>synchronized 用的锁是 Java 对象头里的一个字段（每一个对象都有一个对象头，对象头可以存储很多信息，其中有一个部分就是用来存储 synchronize 关键字的锁的，表明是否被锁住。）</li><li>细节：当线程访问一个同步代码块时，必须要得到这把锁，退出整个代码块或者抛出异常的时候必须释放锁，而锁存储在 Java 对象头中。在 JVM 规范中对于 synchronized 的实现原理已经有了说明，它的进入锁和释放锁是基于 Moniter 对象来实现同步方法和同步代码块的。Monditor 对象主要有两个指令：Monditorenter（插入到同步代码块开始的位置）和 Monditorexit（插入到方法结束的时候和退出的时候）。JVM 规范保证每一个 enter 之后必须要有 exit 和它对应，但是可能有多个 exit 和同一个 enter 对应，因为退出的时机包括方法结束和抛出异常。每一个对象都有一个 Monditor 和它关联，并且一旦一个 Monditor 被持有后，就会处于锁定状态，当线程执行到 Monditorenter 指令时，会尝试获取这个对象对应的 Monditor 的所有权，也就是尝试获取这个对象锁。</li></ul></li><li><p>编译：<code>javac 类名.java</code></p><ul><li>将 Java 类编译为 .class 文件</li></ul></li><li><p>反编译：<code>javap -verbose class文件名.class</code></p><ul><li>将 .class 文件反编译为字节码文件</li></ul></li><li><p>反编译结果：</p></li></ul><p><img src="./1582444077456.png" alt="Alt text"></p><ul><li>详细解读 Monditorenter 和 Monditorexit 指令：Monditorenter 和 Monditorexit 指令在执行的时候会使对象的锁计数加 1 或者减 1。每一个对象都和一个 Monditor 相关联，一个 Moditor 的 lock 锁只能被一个线程在同一时间获得，一个线程在尝试获得与这个对象关联的 Monditor 的所有权的时候，只会发生以下三种情况之一（即 Monditorenter 指令的三种情况）：<ul><li>成功获得锁：Monditor 计数器为 0，意味着目前还没有被获得，这个线程就会立刻获得，然后把计数器加 1，之后别人再想进来就会看到信号，知道它已经被其他线程所持有，所以加 1 意味着当前线程是这个 Moditor 的持有者。</li><li>已经拿到这把锁的所有权再次重入时：计数器随着重入次数的增加而增加（每次加 1）。</li><li>Monditor 已经被其他线程所持有了：当前线程再次获取就会得到现在无法获取的信号，就会进入阻塞状态，直到 Moditor 的计数器变为0，才会再次尝试获取这个锁。</li></ul></li><li>Monditorexit：释放 Monditor 的所有权（可以将 Monditor 理解为锁）<ul><li>前提是已经拥有了锁的所有权</li><li>释放的过程：将 Monditor 的计数器减 1，如果减完之后变成 0 就意味着当前线程不再拥有对 Monditor 的所有权，即解锁。如果减完之后不是 0，意味着刚才是可重入进来的，所以还是继续持有这把锁。最终计数器减到 0 之后，不仅意味着释放锁了，还意味着刚才被阻塞的线程会再次尝试获取对这把锁的所有权。</li></ul></li></ul><h4 id="③可重入原理"><a href="#③可重入原理" class="headerlink" title="③可重入原理"></a>③可重入原理</h4><ul><li>可重入性：一个线程拿到一把锁之后，如果还想再次进入由这把锁所控制的方法，可以直接进入。</li><li>可重入原理：利用加锁次数计数器<ul><li>每个对象自动地含有一把锁，JVM 负责跟踪对象被加锁的次数。 线程第一次给对象加锁的时候，计数变为 1。每当这个相同的线程在此对象上再次获得锁时，计数递增。每当任务结束离开时，计数递减，当计数为 0 的时候，锁被完全释放。</li></ul></li></ul><h4 id="④可见性原理"><a href="#④可见性原理" class="headerlink" title="④可见性原理"></a>④可见性原理</h4><ul><li>保证可见性的原理：Java 内存模型<ul><li>共享变量的副本：将主内存的变量复制一份，放在自己的本地内存。原因：加速程序的运行，因为线程所使用的内存速度比主存中的速度快。</li><li>两个线程要想互相通信-要怎么做：线程 A 将共享变量的副本写到主内存中，因为主内存是它们相互沟通的桥梁，然后线程 B 再去主内存中读取。</li><li>这个过程是 JMM（Java 内存模型的缩写）控制的，JMM 通过控制主内存与每个线程的本地内存的交互来提供内存可见性的保证。</li></ul></li></ul><p><img src="./1582445087616.png" alt="Alt text"></p><ul><li>synchronized 是如何做到可见性的实现的？<ul><li>一旦代码块或者方法被 synchronized 关键字所修饰，那么它在执行完毕之后，被锁住的对象所做的任何修改，都要在释放锁之前，从线程内存写回到主内存中（不会存在线程内存和主内存不一致的情况）。</li><li>同样，在进入代码块获得锁之后，被锁定对象的数据也是直接从主内存中读取出来的。</li></ul></li></ul><hr><h3 id="6-缺陷"><a href="#6-缺陷" class="headerlink" title="6.缺陷"></a>6.缺陷</h3><ol><li>效率低<ul><li>锁的释放情况少：当一个线程获取到锁并在执行过程中，其他线程也想要获得该锁时，只能等待当前线程释放。而当前线程只有在两种情况下才会释放锁：①线程执行完该段代码、②执行过程中发生异常（JVM 将锁释放）。如果要等待 IO 这种耗时操作或者线程 sleep 时，不会主动释放锁，其他线程只能等待，非常影响程序执行的效率。这时需要一种机制，遏制这些情况。（Lock 类可以做到）</li><li>试图获得锁时不能设定超时时间，只能等待。（Lock 类可以做到）</li><li>不能中断一个正在试图获得锁的线程（Lock 类可以做到）</li></ul></li><li>不够灵活（读写锁更灵活）<ul><li>加锁和释放锁的时机单一，每个锁仅有单一的条件（某个对象）。锁住某个对象，某个对象就是这把锁。释放这个对象，才意味着解了这把锁。</li></ul></li><li>无法知道是否成功获取到锁（Lock 类可以做到）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 展示Lock的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="comment">// 通过这两个方法灵活得控制这把锁，且可以配置自定义的锁。</span></span><br><span class="line">        <span class="comment">// 锁住</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">        <span class="comment">// 在规定的超时时间内等待获得锁。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 不设置超时时间的tryLock()</span></span><br><span class="line">            lock.tryLock();</span><br><span class="line">            <span class="comment">// 若是10s拿不到锁，会主动放弃。</span></span><br><span class="line">            lock.tryLock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="7-常见面试问题"><a href="#7-常见面试问题" class="headerlink" title="7.常见面试问题"></a>7.常见面试问题</h3><h4 id="①synchronized-关键字有哪些使用注意点？"><a href="#①synchronized-关键字有哪些使用注意点？" class="headerlink" title="①synchronized 关键字有哪些使用注意点？"></a>①synchronized 关键字有哪些使用注意点？</h4><ol><li>锁对象不能为空<ul><li>指定一个对象作为锁对象时，必须是一个实例对象被 new 过，或者使用其他方法创建好的，而不是空对象。这是因为锁的信息保存在对象头中的，如果对象都没有，就没有对象头，所以这个锁是不能工作的。</li></ul></li><li>作用域不宜过大<ul><li>将尽可能多的代码使用 synchronized 包裹，虽然会降低出并发问题的可能性（大部分线程都是串行工作），但是没有达到多线程编程的目的，影响程序执行的效率。</li></ul></li><li>避免死锁</li></ol><h4 id="②如何选择-Lock-和-synchronized-关键字？"><a href="#②如何选择-Lock-和-synchronized-关键字？" class="headerlink" title="②如何选择 Lock 和 synchronized 关键字？"></a>②如何选择 Lock 和 synchronized 关键字？</h4><ol><li>如果可以的话，两者都不要使用，应该使用 JUC 中的各种类（更方便，不容易出错）。</li><li>如果 synchronized 关键字在程序中适用，那么就优先使用（可以减少所需要编写的代码，也就减少了出错的几率）。</li><li>如果需要使用到 Lock 类独有的特性（如灵活的加解锁机制），再使用 Lock。</li></ol><h4 id="③多线程访问同步方法的各种具体情况"><a href="#③多线程访问同步方法的各种具体情况" class="headerlink" title="③多线程访问同步方法的各种具体情况"></a>③多线程访问同步方法的各种具体情况</h4><ul><li>具体见 <strong>3.多线程访问同步方法的 7 种情况</strong></li></ul><hr><h3 id="8-思考"><a href="#8-思考" class="headerlink" title="8.思考"></a>8.思考</h3><ol><li>多个线程等待同一个 synchronized 锁的时候，JVM 如何选择下一个获取锁的是哪个线程？<ul><li>有内部锁调度机制有关</li><li>持有锁的线程在运行完成或抛出异常后，就会释放这把锁。线程释放锁之后，竞争锁的对象有：等待中的线程、刚刚申请这把锁的线程。内部锁调度机制实现细节和 JVM 的版本、具体实现相关，不能依赖算法。</li><li>目前是处于随机的，不公平的状态。</li><li>synchronized 是非公平锁，ReentrantLock 可以设置是否是公平锁。</li></ul></li><li>synchronized 使得同时只有一个线程可以执行，性能较差，有什么方法可以提升性能？<ul><li>优化使用范围（临界区在符合要求的情况下尽可能得小）</li><li>使用其他类型的锁（如读写锁）</li><li>自己实现 Lock 接口，自由设定锁持有时间</li></ul></li><li>想灵活的控制锁的获取和释放怎么办（现在释放锁的时机都被规定死了）？<ul><li>自己实现一个锁</li></ul></li><li>什么是锁的升级和降级？什么是 JVM 里的偏斜锁、轻量级锁、重量级锁？</li></ol><p><img src="./1582467175893.png" alt="Alt text"></p><hr><h3 id="9-总结"><a href="#9-总结" class="headerlink" title="9.总结"></a>9.总结</h3><ul><li>一句话介绍 synchronized：JVM 会自动通过使用 monitor 来自动加锁和解锁，保证了同时只有一个线程可以执行指定代码，从而保证了线程安全，同时具有可重入和不可中断的性质。</li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#106;&#121;&#109;&#x65;&#x73;&#115;&#105;&#x40;&#x31;&#x36;&#x33;&#46;&#x63;&#111;&#x6d;" target="_blank" rel="noopener">&#x77;&#106;&#121;&#109;&#x65;&#x73;&#115;&#105;&#x40;&#x31;&#x36;&#x33;&#46;&#x63;&#111;&#x6d;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.简介&quot;&gt;&lt;/a&gt;1.简介&lt;/h3&gt;&lt;h4 id=&quot;①作用&quot;&gt;&lt;a href=&quot;#①作用&quot; class=&quot;headerlink&quot; title=&quot;①作用&quot;&gt;&lt;/a&gt;①作
      
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb相关软件安装包分享</title>
    <link href="http://messi1002.top/2020/02/18/JavaWeb%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8C%85%E5%88%86%E4%BA%AB/"/>
    <id>http://messi1002.top/2020/02/18/JavaWeb相关软件安装包分享/</id>
    <published>2020-02-18T09:32:45.000Z</published>
    <updated>2020-02-23T13:58:11.245Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Linux-版本（JavaWeb-程序）"><a href="#1-Linux-版本（JavaWeb-程序）" class="headerlink" title="1.Linux 版本（JavaWeb 程序）"></a>1.Linux 版本（JavaWeb 程序）</h3><ul><li>链接：<a href="https://pan.baidu.com/s/1BHFbs0_sMzfBdQGIOCrQ-w" target="_blank" rel="noopener">https://pan.baidu.com/s/1BHFbs0_sMzfBdQGIOCrQ-w</a> </li><li>提取码：wvtt </li><li></li><li>jdk-8u201-linux-x64.tar.gz</li><li>apache-tomcat-8.5.39.tar.gz</li><li>apache-maven-3.6.0-bin.tar.gz</li><li>nginx-1.8.0.tar.gz</li><li>redis-5.0.4.tar.gz</li></ul><hr><h3 id="2-Windows-版本（JavaWeb-程序）"><a href="#2-Windows-版本（JavaWeb-程序）" class="headerlink" title="2.Windows 版本（JavaWeb 程序）"></a>2.Windows 版本（JavaWeb 程序）</h3><ul><li>链接：<a href="https://pan.baidu.com/s/1H4o8uCxwYVn_x0wn7aNvpg" target="_blank" rel="noopener">https://pan.baidu.com/s/1H4o8uCxwYVn_x0wn7aNvpg</a> </li><li>提取码：9h05</li><li></li><li>jdk-8u65-windows-x64.zip</li><li>mysql-5.7.24-winx64.zip</li><li>Redis-x64-3.0.504.msi</li><li>gradle-5.2.1-all.zip</li><li>elasticsearch-7.1.1-windows-x86_64.zip</li><li>elasticsearch-head-master.zip</li></ul><hr><h3 id="3-其他工具（Windows）"><a href="#3-其他工具（Windows）" class="headerlink" title="3.其他工具（Windows）"></a>3.其他工具（Windows）</h3><ul><li>链接：<a href="https://pan.baidu.com/s/1LnO1znY4nlDuu8QvC957bQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1LnO1znY4nlDuu8QvC957bQ</a> </li><li>提取码：ihaf</li><li></li><li>谷歌访问助手_v2.3.0.crx（翻墙）</li><li>Git-2.19.1-64-bit.exe</li><li>GitHubDesktopSetup.exe</li><li>redis-desktop-manager-0.8.8.384.exe</li><li>Xftp.6.0.0105.v2.7z（Xftp.exe）</li><li>Xshell.6.0.0111.v2.7z（Xshell.exe）</li><li>notepad++.exe</li><li>VMware-workstation-full-15.0.0-10134415.exe</li><li>CentOS-7-x86_64-Minimal-1908.iso（CentOS 镜像 在 VMware 中使用）</li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#119;&#106;&#121;&#109;&#x65;&#115;&#x73;&#105;&#64;&#49;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#109;" target="_blank" rel="noopener">&#119;&#106;&#121;&#109;&#x65;&#115;&#x73;&#105;&#64;&#49;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#109;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Linux-版本（JavaWeb-程序）&quot;&gt;&lt;a href=&quot;#1-Linux-版本（JavaWeb-程序）&quot; class=&quot;headerlink&quot; title=&quot;1.Linux 版本（JavaWeb 程序）&quot;&gt;&lt;/a&gt;1.Linux 版本（JavaWeb 程
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://messi1002.top/categories/JavaWeb/"/>
    
    
      <category term="资源分享" scheme="http://messi1002.top/tags/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>八种排序算法的总结及性能分析</title>
    <link href="http://messi1002.top/2020/02/12/%E5%85%AB%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <id>http://messi1002.top/2020/02/12/八种排序算法的总结及性能分析/</id>
    <published>2020-02-12T13:12:59.000Z</published>
    <updated>2020-03-01T22:20:06.484Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://messi1002.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://messi1002.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat+Nginx配置HTTPS</title>
    <link href="http://messi1002.top/2019/09/13/Tomcat-Nginx%E9%85%8D%E7%BD%AEHTTPS/"/>
    <id>http://messi1002.top/2019/09/13/Tomcat-Nginx配置HTTPS/</id>
    <published>2019-09-13T08:37:51.000Z</published>
    <updated>2019-10-13T08:43:15.492Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ps：每次修改配置后，需要重启 Nginx。<br>命令：<strong>systemctl restart nginx</strong>。<br>Nginx 的配置文件：<strong>/etc/nginx/nginx.conf</strong>。</p></blockquote><hr><h3 id="1-相关博客"><a href="#1-相关博客" class="headerlink" title="1.相关博客"></a>1.相关博客</h3><ul><li><a href="https://messi1002.top/2019/05/07/%E9%98%BF%E9%87%8C%E4%BA%91CentOS7%E5%AE%89%E8%A3%85Nginx/">阿里云CentOS7安装Nginx</a></li><li><a href="https://messi1002.top/2019/09/12/Nginx%E4%B9%8B%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/">Nginx之访问服务器静态资源</a></li><li><a href="https://messi1002.top/2019/09/12/Nginx%E4%B9%8Brewrite%E9%85%8D%E7%BD%AE%E5%9F%9F%E5%90%8D%E8%B7%B3%E8%BD%AC/#more">Nginx之rewrite配置域名跳转</a></li></ul><hr><h3 id="2-准备SSL证书"><a href="#2-准备SSL证书" class="headerlink" title="2.准备SSL证书"></a>2.准备SSL证书</h3><blockquote><p>在域名备案的前提下，我们需要购买 SSL 证书。<br>一般情况下，购买免费版即可。</p></blockquote><h4 id="①什么是SSL证书"><a href="#①什么是SSL证书" class="headerlink" title="①什么是SSL证书"></a>①什么是SSL证书</h4><p><img src="./1568361392033.png" alt="Alt text"><br><img src="./1568361434320.png" alt="Alt text"></p><h4 id="②准备过程"><a href="#②准备过程" class="headerlink" title="②准备过程"></a>②准备过程</h4><ul><li>进入阿里云控制台 购买免费版 SSL 证书 </li><li>然后在签发后下载 Nginx 服务器类型的证书并上传到服务器</li></ul><p><img src="./1568361492288.png" alt="Alt text"><br><img src="./1568361516967.png" alt="Alt text"><br><img src="./1568361531993.png" alt="Alt text"><br><img src="./1568361548330.png" alt="Alt text"><br><img src="./1568361629734.png" alt="Alt text"></p><hr><h3 id="3-具体配置"><a href="#3-具体配置" class="headerlink" title="3.具体配置"></a>3.具体配置</h3><h4 id="①强制HTTPS（可选）"><a href="#①强制HTTPS（可选）" class="headerlink" title="①强制HTTPS（可选）"></a>①强制HTTPS（可选）</h4><ul><li>把 HTTP 的域名请求转成 HTTPS</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  a.com;  # 使用证书绑定的域名替换localhost</span><br><span class="line">    return       301 https://$server_name$request_uri; </span><br><span class="line">    # 返回301状态码进行跳转被Google认为是将网站地址由HTTP迁移到HTTPS的最佳方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②开启HTTPS"><a href="#②开启HTTPS" class="headerlink" title="②开启HTTPS"></a>②开启HTTPS</h4><p><img src="./1568364999187.png" alt="Alt text"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl; # 监听433端口</span><br><span class="line">    server_name a.com; # 证书绑定的域名</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate /usr/local/javaweb/cert/2557101_a.com.pem; # 证书的文件名</span><br><span class="line">    ssl_certificate_key /usr/local/javaweb/cert/2557101_a.com.key; # 证书的密钥文件名</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:8080; # 对应tomcat的端口号</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto https;</span><br><span class="line">    proxy_redirect off;</span><br><span class="line">    proxy_connect_timeout 240;</span><br><span class="line">    proxy_send_timeout 240;</span><br><span class="line">    proxy_read_timeout 240;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置成功</li></ul><p><img src="./1568365113022.png" alt="Alt text"></p><hr><h3 id="4-工作原理"><a href="#4-工作原理" class="headerlink" title="4.工作原理"></a>4.工作原理</h3><blockquote><p>浏览器发送的请求是发送到 Nginx 的，Nginx 作为代理服务器再转发到 Tomcat，浏览器和 Nginx 之间以 HTTPS 协议传输数据，而 Nginx 和 Tomcat 之间通过 proxy_pass 以 HTTP 协议传输数据。<br>Nginx 是中间的代理服务器。</p></blockquote><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#106;&#121;&#109;&#x65;&#115;&#x73;&#105;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#111;&#x6d;" target="_blank" rel="noopener">&#x77;&#106;&#121;&#109;&#x65;&#115;&#x73;&#105;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#111;&#x6d;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;ps：每次修改配置后，需要重启 Nginx。&lt;br&gt;命令：&lt;strong&gt;systemctl restart nginx&lt;/strong&gt;。&lt;br&gt;Nginx 的配置文件：&lt;strong&gt;/etc/nginx/nginx.conf&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://messi1002.top/categories/Linux/"/>
    
      <category term="服务器" scheme="http://messi1002.top/categories/Linux/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Nginx" scheme="http://messi1002.top/tags/Nginx/"/>
    
      <category term="Tomcat" scheme="http://messi1002.top/tags/Tomcat/"/>
    
      <category term="HTTPS" scheme="http://messi1002.top/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>Nginx之rewrite配置域名跳转</title>
    <link href="http://messi1002.top/2019/09/12/Nginx%E4%B9%8Brewrite%E9%85%8D%E7%BD%AE%E5%9F%9F%E5%90%8D%E8%B7%B3%E8%BD%AC/"/>
    <id>http://messi1002.top/2019/09/12/Nginx之rewrite配置域名跳转/</id>
    <published>2019-09-12T03:22:31.000Z</published>
    <updated>2019-10-13T08:43:06.909Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ps：每次修改配置后，需要重启 Nginx。<br>命令：<strong>systemctl restart nginx</strong>。<br>Nginx 的配置文件：<strong>/etc/nginx/nginx.conf</strong>。</p></blockquote><hr><h3 id="1-相关博客"><a href="#1-相关博客" class="headerlink" title="1.相关博客"></a>1.相关博客</h3><ul><li><a href="https://messi1002.top/2019/05/07/%E9%98%BF%E9%87%8C%E4%BA%91CentOS7%E5%AE%89%E8%A3%85Nginx/">阿里云CentOS7安装Nginx</a></li><li><a href="https://messi1002.top/2019/09/12/Nginx%E4%B9%8B%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/">Nginx之访问服务器静态资源</a></li><li><a href="https://messi1002.top/2019/09/13/Tomcat-Nginx%E9%85%8D%E7%BD%AEHTTPS/">Tomcat+Nginx配置HTTPS</a></li></ul><hr><h3 id="2-语法格式"><a href="#2-语法格式" class="headerlink" title="2.语法格式"></a>2.语法格式</h3><ul><li>rewrite 作用：将某个 URL 重写为特定的 URL</li><li>语法格式：<code>rewrite</code>（关键字） <code>&lt;regex&gt;</code>（正则表达式） <code>&lt;replacement&gt;</code>（替代内容）<ul><li>根据 <code>正则表达式</code> 重定向到 <code>replacement</code></li></ul></li></ul><hr><h3 id="3-对a域名的访问全部redirect到b域名"><a href="#3-对a域名的访问全部redirect到b域名" class="headerlink" title="3.对a域名的访问全部redirect到b域名"></a>3.对a域名的访问全部redirect到b域名</h3><ul><li>配置前 <code>server</code> 中不允许存在 <code>location / { ... }</code></li><li>配置示例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    rewrite ^/(.*) http://1000.xidian.edu.cn/$1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>跳转前：<a href="http://a.com/index.php/Request/" target="_blank" rel="noopener">http://a.com/index.php/Request/</a>…</li><li>跳转后：</li></ul><p><img src="./1568295962831.png" alt="Alt text"></p><ul><li>通过 <code>location /</code> 匹配所有以 <code>/</code> 开头的请求（即所有请求）</li><li><code>rewrite</code> 为固定关键字 </li><li><code>regex</code> 部分表示匹配完整的域名和之后的路径</li><li><code>replacement</code> 部分中的 <code>$1</code> 取自 <code>regex</code> 部分 <code>( )</code> 中的内容</li><li>即 nginx 将 <code>a.com/</code> 之后的路径拼接到了 <code>http://1000.xidian.edu.cn/</code> 后</li></ul><hr><h3 id="4-对a域名的不同访问redirect到不同域名"><a href="#4-对a域名的不同访问redirect到不同域名" class="headerlink" title="4.对a域名的不同访问redirect到不同域名"></a>4.对a域名的不同访问redirect到不同域名</h3><h4 id="①应用场景"><a href="#①应用场景" class="headerlink" title="①应用场景"></a>①应用场景</h4><ul><li>同一个域名下的不同 URL 需要跳转到不同的域名下</li></ul><h4 id="②示例一"><a href="#②示例一" class="headerlink" title="②示例一"></a>②示例一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /xiaoyuan/ &#123;</span><br><span class="line">    rewrite ^/xiaoyuan(.*) http://ehall.xidian.edu.cn$1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>跳转前：<code>http://a.com/xiaoyuan/jwapp/sys/cjcx</code></li><li>跳转后：</li></ul><p><img src="./1568261314056.png" alt="Alt text"></p><ul><li>通过 <code>location /xiaoyuan/</code> 匹配所有以 <code>/xiaoyuan/</code> 开头的请求</li><li><code>rewrite</code> 为固定关键字 </li><li><code>regex</code> 部分表示匹配完整的域名和之后的路径</li><li><code>replacement</code> 部分中的 <code>$1</code> 取自 <code>regex</code> 部分 <code>( )</code> 中的内容</li><li>即 nginx 将 <code>a.com/xiaoyuan</code> 之后的路径拼接到了 <code>http://ehall.xidian.edu.cn</code> 后</li></ul><h4 id="③示例二"><a href="#③示例二" class="headerlink" title="③示例二"></a>③示例二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /houqin/ &#123;</span><br><span class="line">    rewrite ^/houqin(.*) http://1000.xidian.edu.cn$1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>跳转前：<code>http://a.com/houqin/index.php/Request/...</code></li><li>跳转后：</li></ul><p><img src="./1568259929117.png" alt="Alt text"></p><ul><li>通过 <code>location /houqin/</code> 匹配所有以 <code>/houqin/</code> 开头的请求</li><li><code>rewrite</code> 为固定关键字 </li><li><code>regex</code> 部分表示匹配完整的域名和之后的路径</li><li><code>replacement</code> 部分中的 <code>$1</code> 取自 <code>regex</code> 部分 <code>( )</code> 中的内容</li><li>即 nginx 将 <code>a.com/houqin</code> 之后的路径拼接到了 <code>http://1000.xidian.edu.cn</code> 后</li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#106;&#121;&#x6d;&#101;&#x73;&#x73;&#105;&#x40;&#49;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#109;" target="_blank" rel="noopener">&#x77;&#106;&#121;&#x6d;&#101;&#x73;&#x73;&#105;&#x40;&#49;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#109;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;ps：每次修改配置后，需要重启 Nginx。&lt;br&gt;命令：&lt;strong&gt;systemctl restart nginx&lt;/strong&gt;。&lt;br&gt;Nginx 的配置文件：&lt;strong&gt;/etc/nginx/nginx.conf&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://messi1002.top/categories/Linux/"/>
    
      <category term="服务器" scheme="http://messi1002.top/categories/Linux/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Nginx" scheme="http://messi1002.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx之访问服务器静态资源</title>
    <link href="http://messi1002.top/2019/09/12/Nginx%E4%B9%8B%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/"/>
    <id>http://messi1002.top/2019/09/12/Nginx之访问服务器静态资源/</id>
    <published>2019-09-12T03:19:49.000Z</published>
    <updated>2019-10-13T08:26:49.788Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ps：每次修改配置后，需要重启 Nginx。<br>命令：<strong>systemctl restart nginx</strong>。<br>Nginx 的配置文件：<strong>/etc/nginx/nginx.conf</strong>。</p></blockquote><hr><h3 id="1-相关博客"><a href="#1-相关博客" class="headerlink" title="1.相关博客"></a>1.相关博客</h3><ul><li><a href="https://messi1002.top/2019/05/07/%E9%98%BF%E9%87%8C%E4%BA%91CentOS7%E5%AE%89%E8%A3%85Nginx/">阿里云CentOS7安装Nginx</a></li><li><a href="https://messi1002.top/2019/09/13/Tomcat-Nginx%E9%85%8D%E7%BD%AEHTTPS/">Tomcat+Nginx配置HTTPS</a></li><li><a href="https://messi1002.top/2019/09/12/Nginx%E4%B9%8Brewrite%E9%85%8D%E7%BD%AE%E5%9F%9F%E5%90%8D%E8%B7%B3%E8%BD%AC/#more">Nginx之rewrite配置域名跳转</a></li></ul><hr><h3 id="2-通过域名-文件名-文件类型的URL格式访问"><a href="#2-通过域名-文件名-文件类型的URL格式访问" class="headerlink" title="2.通过域名/文件名.文件类型的URL格式访问"></a>2.通过<code>域名/文件名.文件类型</code>的URL格式访问</h3><blockquote><p>应用场景：小程序业务域名的验证。</p></blockquote><h4 id="①方法一"><a href="#①方法一" class="headerlink" title="①方法一"></a>①方法一</h4><ul><li>当 <code>server</code> 的配置中不存在 <code>location / { ... }</code> 时</li><li>配置示例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80 default_server; # 监听80端口</span><br><span class="line">    server_name  localhost; # 可自定义域名</span><br><span class="line">    root /usr; # 注意：/usr为文件所在目录,可任意设置</span><br><span class="line">    # root /; # 当文件在根目录时如此配置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②方法二"><a href="#②方法二" class="headerlink" title="②方法二"></a>②方法二</h4><ul><li>当 <code>server</code> 的配置中存在 <code>location / { ... }</code> 时</li><li>配置示例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在server中添加：</span><br><span class="line">location /文件名.文件类型 &#123;</span><br><span class="line">    root /usr; # 注意：/usr为文件所在目录,可任意设置</span><br><span class="line">    # root /; # 当文件在根目录时如此配置</span><br><span class="line">    expires 30d;</span><br><span class="line">    access_log off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 <code>/文件名.文件类型</code> 匹配以 <code>/文件名.文件类型</code> 开头的请求</li></ul><h4 id="③验证配置"><a href="#③验证配置" class="headerlink" title="③验证配置"></a>③验证配置</h4><p><img src="./1568213380744.png" alt="Alt text"><br><img src="./1568213790446.png" alt="Alt text"></p><hr><h3 id="3-通过域名-自定义-文件名-文件类型的URL格式访问"><a href="#3-通过域名-自定义-文件名-文件类型的URL格式访问" class="headerlink" title="3.通过域名/自定义/文件名.文件类型的URL格式访问"></a>3.通过<code>域名/自定义/文件名.文件类型</code>的URL格式访问</h3><blockquote><p>应用场景：搭建 Nginx 图片服务器。</p></blockquote><ul><li>配置示例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location /images/ &#123;</span><br><span class="line">    root  /usr/local/javaweb/xdxlb/; </span><br><span class="line">    # 将/images/映射到/usr/local/javaweb/xdxlb/images/</span><br><span class="line">    autoindex on; # 打开浏览功能</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 <code>location /images/</code> 匹配所有以 <code>/images/</code> 开头的请求</li><li>验证配置：</li></ul><p><img src="./1568252577331.png" alt="Alt text"><br><img src="./1568252491321.png" alt="Alt text"></p><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#119;&#x6a;&#x79;&#109;&#101;&#x73;&#115;&#x69;&#64;&#49;&#x36;&#51;&#x2e;&#99;&#111;&#x6d;" target="_blank" rel="noopener">&#119;&#x6a;&#x79;&#109;&#101;&#x73;&#115;&#x69;&#64;&#49;&#x36;&#51;&#x2e;&#99;&#111;&#x6d;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;ps：每次修改配置后，需要重启 Nginx。&lt;br&gt;命令：&lt;strong&gt;systemctl restart nginx&lt;/strong&gt;。&lt;br&gt;Nginx 的配置文件：&lt;strong&gt;/etc/nginx/nginx.conf&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://messi1002.top/categories/Linux/"/>
    
      <category term="服务器" scheme="http://messi1002.top/categories/Linux/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Nginx" scheme="http://messi1002.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Java发起HTTP请求的工具类</title>
    <link href="http://messi1002.top/2019/08/15/Java%E5%8F%91%E8%B5%B7HTTP%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://messi1002.top/2019/08/15/Java发起HTTP请求的工具类/</id>
    <published>2019-08-15T02:42:54.000Z</published>
    <updated>2020-03-01T22:24:55.838Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ps：CloseableHttpClient 是 HttpClient 接口的实现类</p></blockquote><h3 id="1-发起GET请求"><a href="#1-发起GET请求" class="headerlink" title="1.发起GET请求"></a>1.发起GET请求</h3><h4 id="①无参数的GET请求"><a href="#①无参数的GET请求" class="headerlink" title="①无参数的GET请求"></a>①无参数的GET请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能描述: 无参数的GET请求</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>: [url]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: java.lang.String</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/5/31 22:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doGet</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> doGet(url, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②有参数的GET请求"><a href="#②有参数的GET请求" class="headerlink" title="②有参数的GET请求"></a>②有参数的GET请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 功能描述: 有参数的GET请求</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>: [url, param]</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>: java.lang.String</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@date</span>: 2019/5/31 22:05</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doGet</span><span class="params">(String url, LinkedHashMap&lt;String, String&gt; param)</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 创建HttpClient对象</span></span><br><span class="line">     CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line">     CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">// GET请求的返回内容</span></span><br><span class="line">     String resultString = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         URIBuilder builder = <span class="keyword">new</span> URIBuilder(url);</span><br><span class="line">         <span class="comment">// 设置请求参数</span></span><br><span class="line">         <span class="keyword">if</span> (param != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">for</span> (String key : param.keySet()) &#123;</span><br><span class="line">                 builder.addParameter(key, param.get(key));</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 构建一个URI对象</span></span><br><span class="line">         URI uri = builder.build();</span><br><span class="line">         <span class="comment">// 创建GET请求</span></span><br><span class="line">         HttpGet httpGet = <span class="keyword">new</span> HttpGet(uri);</span><br><span class="line">         <span class="comment">// 执行GET请求</span></span><br><span class="line">         response = httpClient.execute(httpGet);</span><br><span class="line">         <span class="comment">// 获取响应状态码</span></span><br><span class="line">         <span class="keyword">if</span> (response.getStatusLine().getStatusCode() == <span class="number">200</span>) &#123;</span><br><span class="line">             resultString = EntityUtils.toString(response.getEntity(), <span class="string">"UTF-8"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         log.error(<span class="string">"GET Method Catch Unexception Hanlder:&#123;&#125;, message:&#123;&#125;"</span>, e, e.getMessage());</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ServiceException(e.getMessage());</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 response.close();</span><br><span class="line">             &#125;</span><br><span class="line">             httpClient.close();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> resultString;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-发起POST请求"><a href="#2-发起POST请求" class="headerlink" title="2.发起POST请求"></a>2.发起POST请求</h3><h4 id="①参数为Map对象的POST请求"><a href="#①参数为Map对象的POST请求" class="headerlink" title="①参数为Map对象的POST请求"></a>①参数为Map对象的POST请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 功能描述: 有参数(Map对象)的POST请求</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>: [url, param]</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>: java.lang.String</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@date</span>: 2019/5/31 22:06</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doPost</span><span class="params">(String url, Map&lt;String, String&gt; param)</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 创建HttpClient对象</span></span><br><span class="line">     CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line">     CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">// POST请求的返回内容</span></span><br><span class="line">     String resultString = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 创建POST请求</span></span><br><span class="line">         HttpPost httpPost = <span class="keyword">new</span> HttpPost(url);</span><br><span class="line">         <span class="comment">// 创建请求参数列表</span></span><br><span class="line">         <span class="keyword">if</span> (param != <span class="keyword">null</span>) &#123;</span><br><span class="line">             List&lt;NameValuePair&gt; paramList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">             <span class="keyword">for</span> (String key : param.keySet()) &#123;</span><br><span class="line">                 paramList.add(<span class="keyword">new</span> BasicNameValuePair(key, param.get(key)));</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 构造form表单式的实体</span></span><br><span class="line">             UrlEncodedFormEntity entity = <span class="keyword">new</span> UrlEncodedFormEntity(paramList);</span><br><span class="line">             httpPost.setEntity(entity);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 执行POST请求</span></span><br><span class="line">         response = httpClient.execute(httpPost);</span><br><span class="line">         <span class="comment">// 获取响应状态码</span></span><br><span class="line">         <span class="keyword">if</span> (response.getStatusLine().getStatusCode() == <span class="number">200</span>) &#123;</span><br><span class="line">             resultString = EntityUtils.toString(response.getEntity(), <span class="string">"UTF-8"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         log.error(<span class="string">"POST Method Catch Unexception Hanlder:&#123;&#125;, message:&#123;&#125;"</span>, e, e.getMessage());</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ServiceException(e.getMessage());</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 response.close();</span><br><span class="line">             &#125;</span><br><span class="line">             httpClient.close();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> resultString;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="②参数为JSON字符串的POST请求"><a href="#②参数为JSON字符串的POST请求" class="headerlink" title="②参数为JSON字符串的POST请求"></a>②参数为JSON字符串的POST请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能描述: 有参数(Json字符串)的POST请求</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>: [url, jsonData]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: java.lang.String</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/6/25 17:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doPost</span><span class="params">(String url, String jsonData)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建HttpClient对象</span></span><br><span class="line">    CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line">    CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// POST请求的返回内容</span></span><br><span class="line">    String resultString = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建POST请求</span></span><br><span class="line">        HttpPost httpPost = <span class="keyword">new</span> HttpPost(url);</span><br><span class="line">        <span class="comment">// 解析Json数据并构造实体</span></span><br><span class="line">        StringEntity stringEntity = <span class="keyword">new</span> StringEntity(jsonData, ContentType.APPLICATION_JSON);</span><br><span class="line">        httpPost.setEntity(stringEntity);</span><br><span class="line">        <span class="comment">// 执行POST请求</span></span><br><span class="line">        response = httpClient.execute(httpPost);</span><br><span class="line">        <span class="comment">// 获取响应状态码</span></span><br><span class="line">        <span class="keyword">if</span> (response.getStatusLine().getStatusCode() == <span class="number">200</span>) &#123;</span><br><span class="line">            resultString = EntityUtils.toString(response.getEntity(), <span class="string">"UTF-8"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">"POST Method Catch Exception Handler:&#123;&#125;, message:&#123;&#125;"</span>, e, e.getMessage());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                response.close();</span><br><span class="line">            &#125;</span><br><span class="line">            httpClient.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resultString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#119;&#106;&#x79;&#109;&#101;&#x73;&#x73;&#105;&#x40;&#x31;&#54;&#51;&#46;&#99;&#111;&#109;" target="_blank" rel="noopener">&#119;&#106;&#x79;&#109;&#101;&#x73;&#x73;&#105;&#x40;&#x31;&#54;&#51;&#46;&#99;&#111;&#109;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;ps：CloseableHttpClient 是 HttpClient 接口的实现类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-发起GET请求&quot;&gt;&lt;a href=&quot;#1-发起GET请求&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://messi1002.top/categories/JavaWeb/"/>
    
    
      <category term="HTTP" scheme="http://messi1002.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb开发总结</title>
    <link href="http://messi1002.top/2019/08/12/JavaWeb%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    <id>http://messi1002.top/2019/08/12/JavaWeb开发总结/</id>
    <published>2019-08-12T07:00:40.000Z</published>
    <updated>2020-03-01T22:24:05.791Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-开发环境"><a href="#1-开发环境" class="headerlink" title="1.开发环境"></a>1.开发环境</h3><h4 id="①开发必备"><a href="#①开发必备" class="headerlink" title="①开发必备"></a>①开发必备</h4><ul><li>Java 版本：JDK8</li><li>Web 服务器：Tomcat9（运行后端）、Nginx（前端请求转发和搭建图片服务器）</li><li>工程框架：Spring Boot 2.0</li><li>操作数据库：Spring Boot Jpa（优先） / Mybatis</li><li>其他：Lombok 插件、JSON（fastjson / jackson）</li></ul><h4 id="②数据库"><a href="#②数据库" class="headerlink" title="②数据库"></a>②数据库</h4><ul><li>MySQL（主 db）</li><li>Redis（处理缓存）</li><li>MongoDB （特殊需求使用）</li></ul><h4 id="③编译器-amp-构建工具-amp-测试工具"><a href="#③编译器-amp-构建工具-amp-测试工具" class="headerlink" title="③编译器&amp;构建工具&amp;测试工具"></a>③编译器&amp;构建工具&amp;测试工具</h4><ul><li>IDEA</li><li>maven（优先） / gradle</li><li>Postman </li></ul><hr><h3 id="2-框架分层"><a href="#2-框架分层" class="headerlink" title="2.框架分层"></a>2.框架分层</h3><h4 id="①总览"><a href="#①总览" class="headerlink" title="①总览"></a>①总览</h4><ul><li>common（公共包）<ul><li>enums（枚举类）</li><li>exception（全局异常处理）</li><li>interceptor（拦截器）</li><li>jpa（jpa 配置）</li><li>log（AOP 方式的日志埋点）</li><li>utils（工具类）</li></ul></li><li>controller（控制层）</li><li>model（DAO 层）<ul><li>dto（数据传输对象）</li><li>entity（数据库实体类）</li></ul></li><li>repository / mapper（数据库操作层）</li><li>service（服务层)<ul><li>base（基础服务）</li><li>impl（业务服务实现类）</li></ul></li><li>resources（资源目录）<ul><li>application.yml（切换配置文件）</li><li>application-dev.yml（本地配置文件）</li><li>application-pro.yml （服务器配置文件）</li></ul></li></ul><h4 id="②common层"><a href="#②common层" class="headerlink" title="②common层"></a>②common层</h4><ul><li>ResultEnum 类：用于存放前端请求的响应 / 执行结果<ul><li>注意枚举类定义格式 私有变量名不能定义为 name</li></ul></li></ul><h4 id="③controller层"><a href="#③controller层" class="headerlink" title="③controller层"></a>③controller层</h4><ul><li>调用 service 层方法</li><li>提供对外暴露的接口</li></ul><h4 id="④model层"><a href="#④model层" class="headerlink" title="④model层"></a>④model层</h4><ul><li>ResultDTO 类：统一使用此类将数据封装好返回给前端</li><li>关于使用 DTO：从数据库中查出的是一个完整的对象，而大多数时候只会用到某些字段，这时候需要 DTO。</li></ul><hr><h3 id="3-代码规范"><a href="#3-代码规范" class="headerlink" title="3.代码规范"></a>3.代码规范</h3><h4 id="①注释"><a href="#①注释" class="headerlink" title="①注释"></a>①注释</h4><ul><li>类注释（配置模板）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @功能名称: HttpClient(举例)</span><br><span class="line"> * @文件名称: HttpUtil.java(举例)</span><br><span class="line"> * @Date: $date$ $time$</span><br><span class="line"> * @Author: 自定义</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><ul><li>方法注释（配置模板）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 功能描述: </span><br><span class="line"> *</span><br><span class="line"> * @param: $param$</span><br><span class="line"> * @return: $return$</span><br><span class="line"> * @auther: 自定义</span><br><span class="line"> * @date: $date$ $time$</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><ul><li>变量注释</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 文字</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><ul><li>方法内注释</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 文字</span><br></pre></td></tr></table></figure><h4 id="②注解"><a href="#②注解" class="headerlink" title="②注解"></a>②注解</h4><ul><li>自动装配用 @Autowired 注解 其 byType 注入 注解在字段上</li><li>@component：泛指组件 把普通 POJO 实例化到 spring 容器中</li><li>@Service：用于标注业务层组件</li><li>@RestController：用于标注控制层组件</li><li>@Repository：用于标注数据访问组件 即 DAO 组件</li><li>@RequestMapping(value = “/URI”)：标注控制层组件中的方法</li><li>@GetMapping(value = “/URI”)：标注控制层组件中的方法 </li><li>@PostMapping(value = “/URI”)：标注控制层组件中的方法</li><li>@RequestParam：用于标注控制层组件的方法的参数<ul><li>参数名与前端传来的必须吻合 若是不吻合 需要加 value = “…” 使参数名一一对应</li></ul></li></ul><h4 id="③配置文件"><a href="#③配置文件" class="headerlink" title="③配置文件"></a>③配置文件</h4><ul><li>application.yml：总控制文件 可随时切换为本地 / 服务器的配置文件 便于开发</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">dev/pro</span></span><br></pre></td></tr></table></figure><ul><li>application-dev.yml</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="string">本地访问端口号</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># MySQL数据库配置</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    driverClass:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://localhost:3306/数据库名?characterEncoding=utf-8&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">自定义</span></span><br><span class="line">  <span class="comment"># Redis配置</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    database:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">自定义</span></span><br><span class="line">  <span class="comment"># MongoDB配置</span></span><br><span class="line"><span class="attr">  data:</span></span><br><span class="line"><span class="attr">    mongodb:</span></span><br><span class="line"><span class="attr">      uri:</span> <span class="attr">mongodb://用户名:密码@localhost:27017/数据库名</span></span><br><span class="line">  <span class="comment"># jpa配置</span></span><br><span class="line"><span class="attr">  jpa:</span></span><br><span class="line"><span class="attr">    hibernate:</span></span><br><span class="line">      <span class="comment"># 在程序启动时更新实体类对应的表</span></span><br><span class="line"><span class="attr">      ddl-auto:</span> <span class="string">update</span></span><br><span class="line">    <span class="comment"># 在日志中打印出执行的SQL语句信息</span></span><br><span class="line"><span class="attr">    show-sql:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    naming:</span></span><br><span class="line"><span class="attr">      physical-strategy:</span> <span class="string">org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy</span></span><br><span class="line">  <span class="comment"># mybatis配置</span></span><br><span class="line"><span class="attr">  mybatis:</span></span><br><span class="line"><span class="attr">    type-aliases-package:</span> <span class="string">数据库实体类所在包</span></span><br><span class="line">    <span class="comment"># 下划线自动转驼峰</span></span><br><span class="line"><span class="attr">    configuration:</span></span><br><span class="line"><span class="attr">      map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      use-generated-keys:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># jackson配置</span></span><br><span class="line"><span class="attr">  jackson:</span></span><br><span class="line"><span class="attr">    serialization:</span></span><br><span class="line"><span class="attr">      indent-output:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>application-pro.yml</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="string">服务器端口号</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># MySQL数据库配置</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    driverClass:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://服务器公网ip:3306/数据库名?characterEncoding=utf-8&amp;serverTimezone=GMT%2B8&amp;useSSL=true</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">自定义</span></span><br><span class="line">  <span class="comment"># Redis配置</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    database:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">    host:</span> <span class="string">服务器公网ip</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">自定义</span></span><br><span class="line">  <span class="comment"># MongoDB配置</span></span><br><span class="line"><span class="attr">  data:</span></span><br><span class="line"><span class="attr">    mongodb:</span></span><br><span class="line"><span class="attr">      uri:</span> <span class="attr">mongodb://用户名:密码@服务器ip:27017/数据库名</span></span><br><span class="line">  <span class="string">...其他如上</span></span><br></pre></td></tr></table></figure><h4 id="④pom-xml（maven）"><a href="#④pom-xml（maven）" class="headerlink" title="④pom.xml（maven）"></a>④pom.xml（maven）</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- MySQL --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Redis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- MongoDB --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- jpa --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- lombok插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- httpclient --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- maven插件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 解决项目启动bug --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="⑤其他"><a href="#⑤其他" class="headerlink" title="⑤其他"></a>⑤其他</h4><ul><li>将私有常量值单独定义在类的开头 公有常量值定义在公有枚举类中</li><li>工具类一般不需要被注入或构造 只包含普通的类方法</li><li>所有需要注入的类，都应该放到 Service 目录下</li><li>除 db 对象外 尽量使用全参构造对象</li><li>尽量消除魔法值 可使用枚举类封装</li><li>遵循《阿里巴巴Java代码开发规范》进行开发</li></ul><hr><h3 id="4-安装插件"><a href="#4-安装插件" class="headerlink" title="4.安装插件"></a>4.安装插件</h3><ul><li>安装插件：<strong>Settings —&gt; Plugins —&gt; Marketplace —&gt; 查找所需插件 —&gt; Install</strong></li><li>查看安装的所有插件：</li></ul><p><img src="./1563267874950.png" alt="Alt text"></p><ul><li>安装后需要重启 IDEA</li></ul><h4 id="①Lombok"><a href="#①Lombok" class="headerlink" title="①Lombok"></a>①Lombok</h4><blockquote><p>以简单的注解形式来简化 Java 代码，提高开发人员的开发效率。</p></blockquote><ul><li>@Getter：注解在类上 为类提供 get 方法 </li><li>@Setter：注解在类上 为类提供 set 方法</li><li>@Data：注解在类上 为类提供读写属性 此外还提供了equals()、hashCode()、toString() 方法</li><li>@AllArgsConstructor：注解在类上 为类提供一个全参的构造方法</li><li>@NoArgsConstructor：注解在类上 为类提供一个无参的构造方法</li><li>@Slf4j：注解在类上 为类提供一个属性名为 log 的 log4j 日志对象</li><li><strong>@Slf4j 相当于 private static final Logger log = LoggerFactory.getLogger(CategoryServiceImpl.class);</strong></li></ul><h4 id="②Alibaba-Java-Coding-Guidelines"><a href="#②Alibaba-Java-Coding-Guidelines" class="headerlink" title="②Alibaba Java Coding Guidelines"></a>②Alibaba Java Coding Guidelines</h4><blockquote><p>阿里巴巴 Java 代码规约检测</p></blockquote><ul><li>使用插件：</li></ul><p><img src="./1563265527020.png" alt="Alt text"></p><h4 id="③Grep-Console"><a href="#③Grep-Console" class="headerlink" title="③Grep Console"></a>③Grep Console</h4><blockquote><p>可以将不同级别的日志通过颜色区分，便于查看。</p></blockquote><ul><li>配置各级日志的颜色：</li></ul><p><img src="./1563850702962.png" alt="Alt text"></p><hr><h3 id="5-前后端交互"><a href="#5-前后端交互" class="headerlink" title="5.前后端交互"></a>5.前后端交互</h3><h4 id="①交互流程"><a href="#①交互流程" class="headerlink" title="①交互流程"></a>①交互流程</h4><p>1.通过原型图确定产品功能（明确每个细节）<br>2.后端撰写 API 文档及建表<br>3.前后端按照 API 文档各自开发<br>4.测试</p><h4 id="②API文档"><a href="#②API文档" class="headerlink" title="②API文档"></a>②API文档</h4><ul><li><a href="https://www.showdoc.cc/" target="_blank" rel="noopener">ShowDoc</a></li><li>举例：</li></ul><p><img src="./1563442671800.png" alt="Alt text"></p><h4 id="③RESTful-API"><a href="#③RESTful-API" class="headerlink" title="③RESTful API"></a>③RESTful API</h4><ul><li>后端撰写请求 URL 时 必须遵守 <a href="https://github.com/godruoyi/restful-api-specification" target="_blank" rel="noopener">RESTful API 设计规范</a></li></ul><p><img src="./1562896136514.png" alt="Alt text"></p><ul><li>举例：</li></ul><p><img src="./1562896118142.png" alt="Alt text"></p><hr><h3 id="6-关于团队协作（git）"><a href="#6-关于团队协作（git）" class="headerlink" title="6.关于团队协作（git）"></a>6.关于团队协作（git）</h3><blockquote><p>GitHub 客户端每次只能 commit 一个文件，不利于版本回滚和团队协作，所以尽量使用 git 命令行。</p></blockquote><h4 id="①git同步流程"><a href="#①git同步流程" class="headerlink" title="①git同步流程"></a>①git同步流程</h4><ol><li>一般开发完成、但还没有测试的文件都会被提交到暂存区</li><li>将暂存区的文件（测试好的）提交到本地仓库</li><li>通过 git push 提交修改到远程仓库</li></ol><h4 id="②git常用命令"><a href="#②git常用命令" class="headerlink" title="②git常用命令"></a>②git常用命令</h4><ul><li>git add 文件名：将本地某个文件添加到暂存区</li><li>git add *：将本地所有文件添加到暂存区</li><li>git commit -m “本次提交说明（自定义）”：将暂存区文件提交到本地仓库</li><li>git push -u origin master：使用本地 master 分支来更新远程 master 分支（远程仓库）</li><li>git reset HEAD 文件名（将暂存区的内容还原为最后一次提交的内容）</li><li>git checkout – 文件名（将工作区的内容还原为最后一次提交的内容）</li><li>git tag -a name -m “comment”：新建标签并指定提交信息</li><li>git tag -d  name：删除标签</li><li>git branch：查看当前所有分支</li><li>git branch name：创建分支</li><li>git checkout name：进入分支</li><li>通过两种方式克隆仓库：<ul><li>Clone with SSH：git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:messi1002/leetcode.git</li><li>Clone with HTTPS：git clone <a href="https://github.com/messi1002/leetcode.git" target="_blank" rel="noopener">https://github.com/messi1002/leetcode.git</a></li></ul></li></ul><p><img src="./1563441995129.png" alt="Alt text"><br><img src="./1563442009700.png" alt="Alt text"></p><h4 id="③git高级操作"><a href="#③git高级操作" class="headerlink" title="③git高级操作"></a>③git高级操作</h4><ul><li>git stash save “注释”：将工作区和暂存区的新内容暂时保存在栈中</li><li>git stash list：显示缓存堆栈中的内容</li><li>git stash pop：将缓存堆栈中的第一个 stash 内容恢复到工作区后删除</li><li>git commit –amend：将缓存区的内容补充到上次 commit 并可以修改上次 commit 的描述（用来修复最近一次 commit）</li><li>git rebase -i  [startpoint]  [endpoint]：每一个功能开发完成后 对多个 commit 进行合并处理（变基）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[startpoint] 和 [endpoint] 指定了一个编辑区间，前开后闭。</span><br><span class="line">如果不指定 [endpoint]，则该区间的终点默认是当前分支 HEAD 所指向的 commit。</span><br><span class="line">进入编辑页面后，按照指令说明修改指令即可。</span><br></pre></td></tr></table></figure><hr><h3 id="7-入门博客汇总"><a href="#7-入门博客汇总" class="headerlink" title="7.入门博客汇总"></a>7.入门博客汇总</h3><ul><li><a href="https://blog.csdn.net/baidu_31071595/article/details/51320622" target="_blank" rel="noopener">StringUtils用法+StringUtils详细介绍</a></li><li><a href="https://blog.csdn.net/anhuoren/article/details/41313213" target="_blank" rel="noopener">Java 枚举类Enum的用法总结</a></li><li><a href="http://www.ityouknow.com/springboot/2016/03/06/spring-boot-redis.html" target="_blank" rel="noopener">Spring Boot 中 Redis 的使用</a></li><li><a href="https://www.jianshu.com/p/7bf5dc61ca06" target="_blank" rel="noopener">如何使用RedisTemplate访问Redis数据结构</a></li><li><a href="http://blog.didispace.com/springbootredis/" target="_blank" rel="noopener">Spring Boot中使用Redis数据库</a></li><li><a href="https://juejin.im/post/5afb9de8518825426c690307" target="_blank" rel="noopener">Spring Boot中快速操作Mongodb</a></li><li><a href="http://www.ityouknow.com/springboot/2017/05/08/spring-boot-mongodb.html" target="_blank" rel="noopener">Spring Boot 中 MongoDB 的使用</a></li><li><a href="https://www.cnblogs.com/ityouknow/p/5891443.html" target="_blank" rel="noopener">Spring Boot Jpa 的使用</a></li><li><a href="http://www.ityouknow.com/springboot/2016/11/06/spring-boot-mybatis.html" target="_blank" rel="noopener">如何优雅的使用 Mybatis</a></li><li><a href="https://w6513017.iteye.com/blog/1512761" target="_blank" rel="noopener">MyBatis中Like语句使用方式</a></li><li><a href="https://blog.csdn.net/lonelymanontheway/article/details/78221296" target="_blank" rel="noopener">Java 开发工具–Lombok 介绍</a></li><li><a href="https://blog.51cto.com/7308310/2310930" target="_blank" rel="noopener">Spring Boot中Jackson应用详解</a></li><li><a href="https://blog.csdn.net/xzp_12345/article/details/80272981" target="_blank" rel="noopener">JSON框架之阿里fastjson的介绍</a></li><li><a href="https://github.com/godruoyi/restful-api-specification" target="_blank" rel="noopener">RESTful API 设计规范</a></li><li><a href="https://blog.csdn.net/qq_41979043/article/details/89319160#3Git__74" target="_blank" rel="noopener">Git—版本控制工具</a></li><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">Git教程</a></li><li><a href="https://blog.csdn.net/Code_shadow/article/details/81454334" target="_blank" rel="noopener">上传图片到七牛云（前端和后端）</a></li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#x6a;&#121;&#109;&#x65;&#115;&#x73;&#x69;&#64;&#x31;&#x36;&#x33;&#x2e;&#x63;&#111;&#109;" target="_blank" rel="noopener">&#x77;&#x6a;&#121;&#109;&#x65;&#115;&#x73;&#x69;&#64;&#x31;&#x36;&#x33;&#x2e;&#x63;&#111;&#109;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-开发环境&quot;&gt;&lt;a href=&quot;#1-开发环境&quot; class=&quot;headerlink&quot; title=&quot;1.开发环境&quot;&gt;&lt;/a&gt;1.开发环境&lt;/h3&gt;&lt;h4 id=&quot;①开发必备&quot;&gt;&lt;a href=&quot;#①开发必备&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://messi1002.top/categories/JavaWeb/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker入门</title>
    <link href="http://messi1002.top/2019/07/20/Docker%E5%85%A5%E9%97%A8/"/>
    <id>http://messi1002.top/2019/07/20/Docker入门/</id>
    <published>2019-07-20T00:46:31.000Z</published>
    <updated>2020-03-03T05:39:55.918Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="微服务" scheme="http://messi1002.top/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="Docker" scheme="http://messi1002.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>使用GoLand创建go工程</title>
    <link href="http://messi1002.top/2019/07/12/%E4%BD%BF%E7%94%A8GoLand%E5%88%9B%E5%BB%BAgo%E5%B7%A5%E7%A8%8B/"/>
    <id>http://messi1002.top/2019/07/12/使用GoLand创建go工程/</id>
    <published>2019-07-12T04:14:37.000Z</published>
    <updated>2020-03-01T22:22:07.672Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h3><ul><li>下载 JetBrains GoLand</li><li>配置 go 的开发环境</li></ul><hr><h3 id="2-hello-go-代码"><a href="#2-hello-go-代码" class="headerlink" title="2.hello go 代码"></a>2.hello go 代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"你好"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-创建-go-工程"><a href="#3-创建-go-工程" class="headerlink" title="3.创建 go 工程"></a>3.创建 go 工程</h3><ul><li>新建工程、选择 GOROOT 路径</li></ul><p><img src="./1562229247677.png" alt="Alt text"></p><ul><li>创建目录结构、创建 hello.go 文件<ul><li><strong>bin：包含生成的执行文件</strong></li><li><strong>pkg：包含编译的中间文件</strong></li><li><strong>src：包含程序的代码文件</strong> </li></ul></li></ul><p><img src="./1562229372284.png" alt="Alt text"></p><ul><li>配置全局路径和项目路径</li></ul><p><img src="./1562230835348.png" alt="Alt text"></p><ul><li>配置并运行 hello.go 文件</li></ul><p><img src="./1562231300913.png" alt="Alt text"><br><img src="./1562231159822.png" alt="Alt text"></p><hr><h3 id="4-命令行中运行-go-文件-windows"><a href="#4-命令行中运行-go-文件-windows" class="headerlink" title="4.命令行中运行 go 文件(windows)"></a>4.命令行中运行 go 文件(windows)</h3><p><img src="./1562228274537.png" alt="Alt text"></p><ul><li><strong>go run 文件名.go</strong>：编译一个或多个以 .go 结尾的源文件，链接库文件并运行最终生成的可执行文件</li><li><strong>go build 文件名.go</strong>：生成一个可执行的二进制文件</li><li><strong>文件名.exe</strong>：运行生成的文件</li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#x6a;&#x79;&#109;&#x65;&#x73;&#x73;&#105;&#x40;&#49;&#x36;&#51;&#x2e;&#x63;&#111;&#x6d;" target="_blank" rel="noopener">&#x77;&#x6a;&#x79;&#109;&#x65;&#x73;&#x73;&#105;&#x40;&#49;&#x36;&#51;&#x2e;&#x63;&#111;&#x6d;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-准备工作&quot;&gt;&lt;a href=&quot;#1-准备工作&quot; class=&quot;headerlink&quot; title=&quot;1.准备工作&quot;&gt;&lt;/a&gt;1.准备工作&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;下载 JetBrains GoLand&lt;/li&gt;
&lt;li&gt;配置 go 的开发环境&lt;/li&gt;
&lt;/
      
    
    </summary>
    
    
      <category term="Go" scheme="http://messi1002.top/categories/Go/"/>
    
    
      <category term="Go" scheme="http://messi1002.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>华为春招面经2020届JavaWeb</title>
    <link href="http://messi1002.top/2019/05/13/%E5%8D%8E%E4%B8%BA%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F2020%E5%B1%8AJavaWeb/"/>
    <id>http://messi1002.top/2019/05/13/华为春招面经2020届JavaWeb/</id>
    <published>2019-05-13T11:56:10.000Z</published>
    <updated>2020-03-01T22:22:03.927Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-投递职位"><a href="#1-投递职位" class="headerlink" title="1.投递职位"></a>1.投递职位</h3><ul><li><strong>华为 2020 届勇敢星实习—通用软件开发工程师</strong></li><li>年龄：大二(非大三)</li><li>时间：2019 年</li><li>地点：华为西研所</li><li><a href="http://career.huawei.com/reccampportal/campus4_index.html#campus4/pages/joblist/jobList.html?jobFamClsCode=JFC1&type=0" target="_blank" rel="noopener">华为校招官网</a></li></ul><hr><h3 id="2-我的招聘流程"><a href="#2-我的招聘流程" class="headerlink" title="2.我的招聘流程"></a>2.我的招聘流程</h3><p><strong>3.29 投递简历 ——&gt; 4.2 性格测试 ——&gt; 4.3 线上笔试 ——&gt; 4.20 面试 ——&gt; 4.25 收到 offer ——&gt; 5.6 签约</strong></p><hr><h3 id="3-性格测试"><a href="#3-性格测试" class="headerlink" title="3.性格测试"></a>3.性格测试</h3><blockquote><p>华为比较重视这个，最好认真做完。<br>可以在网上查查技巧，反正我是挂了(⊙o⊙)…。</p></blockquote><hr><h3 id="4-笔试"><a href="#4-笔试" class="headerlink" title="4.笔试"></a>4.笔试</h3><h4 id="①题目分析"><a href="#①题目分析" class="headerlink" title="①题目分析"></a>①题目分析</h4><blockquote><p>华为的笔试题都是基础的编程题，比较简单。<br>总共有三道题，分值分别为 100、200、300，难度递增。<br>第一题重点考察输入与输出， 第二题重点考察对语言类库的运用，第三题重点考察数据结构与算法。<br><strong>注意：最好在笔试后仔细研究研究未 AC 的题，面试官可能会问。</strong></p></blockquote><h4 id="②练习网址"><a href="#②练习网址" class="headerlink" title="②练习网址"></a>②练习网址</h4><ul><li>牛客网：<a href="https://www.nowcoder.com/ta/huawei" target="_blank" rel="noopener">https://www.nowcoder.com/ta/huawei</a></li></ul><h4 id="③我的笔试"><a href="#③我的笔试" class="headerlink" title="③我的笔试"></a>③我的笔试</h4><blockquote><p>当时我 AC 了第一题和第二题(300 分)，由于第三题涉及到的算法还没有学习过，故放弃。<br>不过只要拿 100 分，就能得到面试机会。</p></blockquote><hr><h3 id="5-一面-35min"><a href="#5-一面-35min" class="headerlink" title="5.一面(35min)"></a>5.一面(35min)</h3><h4 id="①面试问题"><a href="#①面试问题" class="headerlink" title="①面试问题"></a>①面试问题</h4><ul><li>自我介绍</li><li>对华为的了解</li><li>为什么来华为实习</li><li>笔试中未做出的题</li><li>三道算法题</li><li>做项目遇到的困难</li><li>对软件工程的了解</li><li>对”好代码”的理解</li></ul><h4 id="②面试技巧"><a href="#②面试技巧" class="headerlink" title="②面试技巧"></a>②面试技巧</h4><ol><li>面试前最好了解一下企业文化及其业务方向。</li><li><strong>面试官很看重应聘者解决问题的能力，即面对一个完全陌生的问题，应聘者能将之快速理解并想出求解方法。</strong></li><li><strong>在解决算法题的时候，最好先从最基础的求解方法开始分析，逐步优化并且分析每种解法的复杂度和优缺点(系统原理、安全漏洞等)。</strong></li><li>如果实在想不出求解方法，也要尽可能地想出一个大概思路，最好别卡壳。如果面试时很紧张，会非常非常影响思路！所以一定要放松！！</li><li><strong>底层知识一定要重视！要将学过的知识点充分理解！</strong></li><li>注意：思考面试官问你的题目之间是否有关联，也许这是一个很好的解题突破点。</li></ol><hr><h3 id="6-二面-20min"><a href="#6-二面-20min" class="headerlink" title="6.二面(20min)"></a>6.二面(20min)</h3><h4 id="①面试问题-1"><a href="#①面试问题-1" class="headerlink" title="①面试问题"></a>①面试问题</h4><ul><li>自我介绍</li><li>对 996 的看法</li><li>为什么跨专业学习</li><li>职业规划</li><li>关于读研</li><li>想在华为学到什么</li><li>项目介绍</li><li>英语能力及课内成绩</li><li>瞎聊…</li></ul><h4 id="②面试体验"><a href="#②面试体验" class="headerlink" title="②面试体验"></a>②面试体验</h4><blockquote><p>一面结束后，排队等待二面，二面相对比较轻松。因为我是跨专业自学 CS，所以面试官一直逮着这点问，emmm。然后就会和你聊聊家庭情况、未来规划、学习情况等。</p></blockquote><hr><h3 id="7-等待结果"><a href="#7-等待结果" class="headerlink" title="7.等待结果"></a>7.等待结果</h3><ul><li>面试完成后官网会更新 <code>应聘进展</code></li><li>我的状态码：</li></ul><p><img src="./1556286277599.png" alt="Alt text"></p><ul><li>状态码：6、1 </li><li>性格测试貌似挂了 但没有被安排重测</li><li><code>面试考核</code> 下无小字：</li></ul><p><img src="./1556286450801.png" alt="Alt text"></p><ul><li>but 5 天后就收到 offer 啦</li></ul><hr><blockquote><p>ps：谢谢男票陪我去面试，肝就对了！<br>纪念收到的第一个 offer！</p></blockquote><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#106;&#121;&#109;&#x65;&#x73;&#x73;&#x69;&#x40;&#49;&#x36;&#51;&#x2e;&#x63;&#111;&#109;" target="_blank" rel="noopener">&#x77;&#106;&#121;&#109;&#x65;&#x73;&#x73;&#x69;&#x40;&#49;&#x36;&#51;&#x2e;&#x63;&#111;&#109;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-投递职位&quot;&gt;&lt;a href=&quot;#1-投递职位&quot; class=&quot;headerlink&quot; title=&quot;1.投递职位&quot;&gt;&lt;/a&gt;1.投递职位&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;华为 2020 届勇敢星实习—通用软件开发工程师&lt;/strong&gt;&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
      <category term="面经" scheme="http://messi1002.top/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="面经" scheme="http://messi1002.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
</feed>
