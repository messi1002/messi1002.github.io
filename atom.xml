<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wjy&#39;s blog</title>
  
  <subtitle>行到水穷处，坐看云起时。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://messi1002.top/"/>
  <updated>2020-06-12T13:01:39.562Z</updated>
  <id>http://messi1002.top/</id>
  
  <author>
    <name>围巾一</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020秋招复习之数据结构与算法</title>
    <link href="http://messi1002.top/2020/06/08/2020%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://messi1002.top/2020/06/08/2020秋招复习之数据结构与算法/</id>
    <published>2020-06-08T09:01:28.000Z</published>
    <updated>2020-06-12T13:01:39.562Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-面经相关"><a href="#1-面经相关" class="headerlink" title="1.面经相关"></a>1.面经相关</h3><h4 id="①相关博客"><a href="#①相关博客" class="headerlink" title="①相关博客"></a>①相关博客</h4><ul><li><a href="https://canghaizanhua6.github.io/2020/05/01/%E5%85%AC%E5%8F%B8%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/" target="_blank" rel="noopener">大厂秋招笔试真题汇总</a></li><li><a href="https://canghaizanhua6.github.io/2020/05/03/%E7%AC%94%E8%AF%95%E9%A2%98%E5%88%86%E7%B1%BB%E7%BB%9F%E8%AE%A1/" target="_blank" rel="noopener">大厂秋招笔试真题分类统计</a></li></ul><h4 id="②分类优先级"><a href="#②分类优先级" class="headerlink" title="②分类优先级"></a>②分类优先级</h4><p>29.多线程 &gt; 15.设计 &gt; 23.线段树 &gt; 22.字典树 &gt; 19.堆 &gt; 20.分治算法 &gt; 4.动态规划 &gt; 14.回溯算法 &gt; 11.贪心算法 &gt; 8.图 &gt; 7.树 &gt; 13.栈 &gt; 24.队列 &gt; 16.位运算 &gt; 17.排序 &gt; 18.链表 &gt; 21.递归 &gt; 12.滑动窗口 &gt; 10.二分查找 &gt; 9.哈希表 &gt; 12.双指针 &gt; 6.数学 &gt; 5.字符串 &gt; 3.数组</p><hr><h3 id="2-算法复杂度"><a href="#2-算法复杂度" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h3><ul><li>什么是算法复杂度</li><li>时间 / 空间复杂度的含义</li><li>大 O 复杂度具体指的是什么？</li><li>有哪些常见的时间复杂度，分别举一个例子。</li><li>多举几个 O(1) 时间复杂度的例子</li></ul><hr><h3 id="3-数组"><a href="#3-数组" class="headerlink" title="3.数组"></a>3.数组</h3><h4 id="①知识点整理"><a href="#①知识点整理" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li>数组和链表的差别</li><li>标记数组</li></ul><h4 id="②LeetCode-必刷题目（49）"><a href="#②LeetCode-必刷题目（49）" class="headerlink" title="②LeetCode 必刷题目（49）"></a>②LeetCode 必刷题目（49）</h4><ul><li>剑指 Offer（3）<ul><li><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/" target="_blank" rel="noopener">面试题21. 调整数组顺序使奇数位于偶数前面</a></li><li><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">面试题29. 顺时针打印矩阵</a></li><li><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/" target="_blank" rel="noopener">面试题66. 构建乘积数组</a></li></ul></li><li>简单（34）<ul><li><a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener">66. 加一</a> </li><li><a href="https://leetcode-cn.com/problems/pascals-triangle/" target="_blank" rel="noopener">118. 杨辉三角</a></li><li><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/" target="_blank" rel="noopener">119. 杨辉三角 II</a></li><li><a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">189. 旋转数组</a></li><li><a href="https://leetcode-cn.com/problems/third-maximum-number/" target="_blank" rel="noopener">414. 第三大的数</a></li><li><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">448. 找到所有数组中消失的数字</a></li><li><a href="https://leetcode-cn.com/problems/max-consecutive-ones/" target="_blank" rel="noopener">485. 最大连续1的个数</a></li><li><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. 斐波那契数</a></li><li><a href="https://leetcode-cn.com/problems/array-partition-i/" target="_blank" rel="noopener">561. 数组拆分 I</a></li><li><a href="https://leetcode-cn.com/problems/reshape-the-matrix/" target="_blank" rel="noopener">566. 重塑矩阵</a></li><li><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">581. 最短无序连续子数组</a></li><li><a href="https://leetcode-cn.com/problems/image-smoother/" target="_blank" rel="noopener">661. 图片平滑器</a></li><li><a href="https://leetcode-cn.com/problems/non-decreasing-array/" target="_blank" rel="noopener">665. 非递减数列</a></li><li><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">674. 最长连续递增序列</a></li><li><a href="https://leetcode-cn.com/problems/degree-of-an-array/" target="_blank" rel="noopener">697. 数组的度</a></li><li><a href="https://leetcode-cn.com/problems/1-bit-and-2-bit-characters/" target="_blank" rel="noopener">717. 1比特与2比特字符</a></li><li><a href="https://leetcode-cn.com/problems/find-pivot-index/" target="_blank" rel="noopener">724. 寻找数组的中心索引</a></li><li><a href="https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others/" target="_blank" rel="noopener">747. 至少是其他数字两倍的最大数</a></li><li><a href="https://leetcode-cn.com/problems/toeplitz-matrix/" target="_blank" rel="noopener">766. 托普利茨矩阵</a></li><li><a href="https://leetcode-cn.com/problems/positions-of-large-groups/" target="_blank" rel="noopener">830. 较大分组的位置</a></li><li><a href="https://leetcode-cn.com/problems/flipping-an-image/" target="_blank" rel="noopener">832. 翻转图像</a></li><li><a href="https://leetcode-cn.com/problems/transpose-matrix/" target="_blank" rel="noopener">867. 转置矩阵</a></li><li><a href="https://leetcode-cn.com/problems/fair-candy-swap/" target="_blank" rel="noopener">888. 公平的糖果交换</a></li><li><a href="https://leetcode-cn.com/problems/monotonic-array/" target="_blank" rel="noopener">896. 单调数列</a></li><li><a href="https://leetcode-cn.com/problems/sort-array-by-parity/" target="_blank" rel="noopener">905. 按奇偶排序数组</a></li><li><a href="https://leetcode-cn.com/problems/valid-mountain-array/" target="_blank" rel="noopener">941. 有效的山脉数组</a></li><li><a href="https://leetcode-cn.com/problems/sum-of-even-numbers-after-queries/" target="_blank" rel="noopener">985. 查询后的偶数和</a></li><li><a href="https://leetcode-cn.com/problems/add-to-array-form-of-integer/" target="_blank" rel="noopener">989. 数组形式的整数加法</a></li><li><a href="https://leetcode-cn.com/problems/available-captures-for-rook/" target="_blank" rel="noopener">999. 可以被一步捕获的棋子数</a></li><li><a href="https://leetcode-cn.com/problems/height-checker/" target="_blank" rel="noopener">1051. 高度检查器</a></li><li><a href="https://leetcode-cn.com/problems/sum-of-digits-in-the-minimum-number/" target="_blank" rel="noopener">1085. 最小元素各数位之和</a></li><li><a href="https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits/" target="_blank" rel="noopener">1295. 统计位数为偶数的数字</a></li><li><a href="https://leetcode-cn.com/problems/find-n-unique-integers-sum-up-to-zero/" target="_blank" rel="noopener">1304. 和为零的N个唯一整数</a></li><li><a href="https://leetcode-cn.com/problems/decompress-run-length-encoded-list/" target="_blank" rel="noopener">1313. 解压缩编码列表</a></li></ul></li><li>中等（11）<ul><li><a href="https://leetcode-cn.com/problems/rotate-matrix-lcci/" target="_blank" rel="noopener">面试题 01.07. 旋转矩阵</a></li><li><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">31. 下一个排列</a></li><li><a href="https://leetcode-cn.com/problems/rotate-image/" target="_blank" rel="noopener">48. 旋转图像</a></li><li><a href="https://leetcode-cn.com/problems/spiral-matrix/" target="_blank" rel="noopener">54. 螺旋矩阵</a></li><li><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/" target="_blank" rel="noopener">59. 螺旋矩阵 II</a></li><li><a href="https://leetcode-cn.com/problems/set-matrix-zeroes/" target="_blank" rel="noopener">73. 矩阵置零</a></li><li><a href="https://leetcode-cn.com/problems/majority-element-ii/" target="_blank" rel="noopener">229. 求众数 II</a></li><li><a href="https://leetcode-cn.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">238. 除自身以外数组的乘积</a></li><li><a href="https://leetcode-cn.com/problems/game-of-life/" target="_blank" rel="noopener">289. 生命游戏</a></li><li><a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/" target="_blank" rel="noopener">442. 数组中重复的数据</a></li><li><a href="https://leetcode-cn.com/problems/my-calendar-i/" target="_blank" rel="noopener">729. 我的日程安排表 I</a></li></ul></li><li>困难（1）<ul><li><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">41. 缺失的第一个正数</a></li></ul></li></ul><h4 id="③相关博客"><a href="#③相关博客" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="4-动态规划"><a href="#4-动态规划" class="headerlink" title="4.动态规划"></a>4.动态规划</h3><hr><h3 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5.字符串"></a>5.字符串</h3><h4 id="①知识点整理-1"><a href="#①知识点整理-1" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li>KMP 算法</li><li>正则表达式</li></ul><h4 id="②LeetCode-必刷题目（40）"><a href="#②LeetCode-必刷题目（40）" class="headerlink" title="②LeetCode 必刷题目（40）"></a>②LeetCode 必刷题目（40）</h4><ul><li>剑指 Offer（3）<ul><li><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">面试题05. 替换空格</a></li><li><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/" target="_blank" rel="noopener">面试题58 - I. 翻转单词顺序</a> </li><li><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/" target="_blank" rel="noopener">面试题58 - II. 左旋转字符串</a></li></ul></li><li>简单（27）<ul><li><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14. 最长公共前缀</a></li><li><a href="https://leetcode-cn.com/problems/count-and-say/" target="_blank" rel="noopener">38. 外观数列</a></li><li><a href="https://leetcode-cn.com/problems/length-of-last-word/" target="_blank" rel="noopener">58. 最后一个单词的长度</a></li><li><a href="https://leetcode-cn.com/problems/read-n-characters-given-read4/" target="_blank" rel="noopener">157. 用 Read4 读取 N 个字符</a></li><li><a href="https://leetcode-cn.com/problems/ransom-note/" target="_blank" rel="noopener">383. 赎金信</a></li><li><a href="https://leetcode-cn.com/problems/add-strings/" target="_blank" rel="noopener">415. 字符串相加</a></li><li><a href="https://leetcode-cn.com/problems/number-of-segments-in-a-string/" target="_blank" rel="noopener">434. 字符串中的单词数</a></li><li><a href="https://leetcode-cn.com/problems/string-compression/" target="_blank" rel="noopener">443. 压缩字符串</a></li><li><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/" target="_blank" rel="noopener">459. 重复的子字符串</a></li><li><a href="https://leetcode-cn.com/problems/detect-capital/" target="_blank" rel="noopener">520. 检测大写字母</a></li><li><a href="https://leetcode-cn.com/problems/longest-uncommon-subsequence-i/" target="_blank" rel="noopener">521. 最长特殊序列 Ⅰ</a></li><li><a href="https://leetcode-cn.com/problems/reverse-string-ii/" target="_blank" rel="noopener">541. 反转字符串 II</a></li><li><a href="https://leetcode-cn.com/problems/student-attendance-record-i/" target="_blank" rel="noopener">551. 学生出勤记录 I</a></li><li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/" target="_blank" rel="noopener">557. 反转字符串中的单词 III</a></li><li><a href="https://leetcode-cn.com/problems/robot-return-to-origin/" target="_blank" rel="noopener">657. 机器人能否返回原点</a></li><li><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/" target="_blank" rel="noopener">680. 验证回文字符串 Ⅱ</a></li><li><a href="https://leetcode-cn.com/problems/repeated-string-match/" target="_blank" rel="noopener">686. 重复叠加字符串匹配</a></li><li><a href="https://leetcode-cn.com/problems/count-binary-substrings/" target="_blank" rel="noopener">696. 计数二进制子串</a></li><li><a href="https://leetcode-cn.com/problems/to-lower-case/" target="_blank" rel="noopener">709. 转换成小写字母</a></li><li><a href="https://leetcode-cn.com/problems/rotated-digits/" target="_blank" rel="noopener">788. 旋转数字</a></li><li><a href="https://leetcode-cn.com/problems/unique-morse-code-words/" target="_blank" rel="noopener">804. 唯一摩尔斯密码词</a></li><li><a href="https://leetcode-cn.com/problems/goat-latin/" target="_blank" rel="noopener">824. 山羊拉丁文</a></li><li><a href="https://leetcode-cn.com/problems/groups-of-special-equivalent-strings/" target="_blank" rel="noopener">893. 特殊等价字符串组</a></li><li><a href="https://leetcode-cn.com/problems/unique-email-addresses/" target="_blank" rel="noopener">929. 独特的电子邮件地址</a></li><li><a href="https://leetcode-cn.com/problems/defanging-an-ip-address/" target="_blank" rel="noopener">1108. IP 地址无效化</a></li><li><a href="https://leetcode-cn.com/problems/remove-vowels-from-a-string/" target="_blank" rel="noopener">1119. 删去字符串中的元音</a></li><li><a href="https://leetcode-cn.com/problems/single-row-keyboard/" target="_blank" rel="noopener">1165. 单行键盘</a></li></ul></li><li>中等（8）<ul><li><a href="https://leetcode-cn.com/problems/zigzag-conversion/" target="_blank" rel="noopener">6. Z 字形变换</a></li><li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">151. 翻转字符串里的单词</a></li><li><a href="https://leetcode-cn.com/problems/compare-version-numbers/" target="_blank" rel="noopener">165. 比较版本号</a></li><li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-ii/" target="_blank" rel="noopener">186. 翻转字符串里的单词 II</a></li><li><a href="https://leetcode-cn.com/problems/minimum-time-difference/" target="_blank" rel="noopener">539. 最小时间差</a></li><li><a href="https://leetcode-cn.com/problems/next-greater-element-iii/" target="_blank" rel="noopener">556. 下一个更大元素 II</a></li><li><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/" target="_blank" rel="noopener">583. 两个字符串的删除操作</a></li><li><a href="https://leetcode-cn.com/problems/valid-parenthesis-string/" target="_blank" rel="noopener">678. 有效的括号字符串</a></li></ul></li><li>困难（2）<ul><li><a href="https://leetcode-cn.com/problems/shortest-palindrome/" target="_blank" rel="noopener">214. 最短回文串</a></li><li><a href="https://leetcode-cn.com/problems/find-the-closest-palindrome/" target="_blank" rel="noopener">564. 寻找最近的回文数</a></li></ul></li></ul><h4 id="③相关博客-1"><a href="#③相关博客-1" class="headerlink" title="③相关博客"></a>③相关博客</h4><ul><li>Java 的字符串操作：</li></ul><p><img src="./1589428412427.png" alt="Alt text"><br><img src="./1589428362495.png" alt="Alt text"><br><img src="./1589428335234.png" alt="Alt text"></p><hr><h3 id="6-数学"><a href="#6-数学" class="headerlink" title="6.数学"></a>6.数学</h3><h4 id="①知识点整理-2"><a href="#①知识点整理-2" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li>约瑟夫环</li><li>牛顿迭代法</li><li>排列组合</li><li>前 n 项和</li><li>快速幂算法</li></ul><h4 id="②LeetCode-必刷题目（41）"><a href="#②LeetCode-必刷题目（41）" class="headerlink" title="②LeetCode 必刷题目（41）"></a>②LeetCode 必刷题目（41）</h4><ul><li>剑指 Offer（7）<ul><li><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/" target="_blank" rel="noopener">面试题17. 打印从1到最大的n位数</a></li><li><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank" rel="noopener">面试题20. 表示数值的字符串</a></li><li><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">面试题43. 1～n整数中1出现的次数</a></li><li><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题44. 数字序列中某一位的数字</a></li><li><a href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank" rel="noopener">面试题49. 丑数</a></li><li><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题62. 圆圈中最后剩下的数字</a></li><li><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/" target="_blank" rel="noopener">面试题67. 把字符串转换成整数</a></li></ul></li><li>简单（23）<ul><li><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">7. 整数反转</a></li><li><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">9. 回文数</a></li><li><a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">13. 罗马数字转整数</a></li><li><a href="https://leetcode-cn.com/problems/add-binary/" target="_blank" rel="noopener">67. 二进制求和</a></li><li><a href="https://leetcode-cn.com/problems/excel-sheet-column-title/" target="_blank" rel="noopener">168. Excel表列名称</a></li><li><a href="https://leetcode-cn.com/problems/excel-sheet-column-number/" target="_blank" rel="noopener">171. Excel表列序号</a></li><li><a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/" target="_blank" rel="noopener">172. 阶乘后的零</a></li><li><a href="https://leetcode-cn.com/problems/happy-number/" target="_blank" rel="noopener">202. 快乐数</a></li><li><a href="https://leetcode-cn.com/problems/add-digits/" target="_blank" rel="noopener">258. 各位相加</a></li><li><a href="https://leetcode-cn.com/problems/ugly-number/" target="_blank" rel="noopener">263. 丑数</a></li><li><a href="https://leetcode-cn.com/problems/power-of-three/" target="_blank" rel="noopener">326. 3的幂</a></li><li><a href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/" target="_blank" rel="noopener">453. 最小移动次数使数组元素相等</a></li><li><a href="https://leetcode-cn.com/problems/perfect-number/" target="_blank" rel="noopener">507. 完美数</a></li><li><a href="https://leetcode-cn.com/problems/range-addition-ii/" target="_blank" rel="noopener">598. 范围求和 II</a></li><li><a href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/" target="_blank" rel="noopener">628. 三个数的最大乘积</a></li><li><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/" target="_blank" rel="noopener">633. 平方数之和</a></li><li><a href="https://leetcode-cn.com/problems/self-dividing-numbers/" target="_blank" rel="noopener">728. 自除数</a></li><li><a href="https://leetcode-cn.com/problems/binary-gap/" target="_blank" rel="noopener">868. 二进制间距</a></li><li><a href="https://leetcode-cn.com/problems/smallest-range-i/" target="_blank" rel="noopener">908. 最小差值 I</a></li><li><a href="https://leetcode-cn.com/problems/di-string-match/" target="_blank" rel="noopener">942. 增减字符串匹配</a></li><li><a href="https://leetcode-cn.com/problems/confusing-number/" target="_blank" rel="noopener">1056. 易混淆数</a></li><li><a href="https://leetcode-cn.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/" target="_blank" rel="noopener">1281. 整数的各位积和之差</a></li><li><a href="https://leetcode-cn.com/problems/maximum-69-number/" target="_blank" rel="noopener">1323. 6 和 9 组成的最大数字</a></li></ul></li><li>中等（9）<ul><li><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">8. 字符串转换整数 (atoi)</a></li><li><a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank" rel="noopener">12. 整数转罗马数字</a></li><li><a href="https://leetcode-cn.com/problems/multiply-strings/" target="_blank" rel="noopener">43. 字符串相乘</a></li><li><a href="https://leetcode-cn.com/problems/ugly-number-ii/" target="_blank" rel="noopener">264. 丑数 II</a></li><li><a href="https://leetcode-cn.com/problems/super-pow/" target="_blank" rel="noopener">372. 超级次方</a></li><li><a href="https://leetcode-cn.com/problems/nth-digit/" target="_blank" rel="noopener">400. 第N个数字</a></li><li><a href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/" target="_blank" rel="noopener">462. 最少移动次数使数组元素相等 II</a></li><li><a href="https://leetcode-cn.com/problems/complex-number-multiplication/" target="_blank" rel="noopener">537. 复数乘法</a></li><li><a href="https://leetcode-cn.com/problems/reach-a-number/" target="_blank" rel="noopener">754. 到达终点数字</a></li></ul></li><li>困难（2）<ul><li><a href="https://leetcode-cn.com/problems/number-of-digit-one/" target="_blank" rel="noopener">233. 数字 1 的个数</a></li><li><a href="https://leetcode-cn.com/problems/poor-pigs/" target="_blank" rel="noopener">458. 可怜的小猪</a></li></ul></li></ul><h4 id="③相关博客-2"><a href="#③相关博客-2" class="headerlink" title="③相关博客"></a>③相关博客</h4><ul><li><a href="https://messi1002.top/2019/05/05/LeetCode-172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6%EF%BC%88Easy%EF%BC%89C%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/">172. 阶乘后的零（Easy）C语言题解</a></li><li><a href="https://messi1002.top/2019/05/05/LeetCode-172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6%EF%BC%88Easy%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/">172. 阶乘后的零（Easy）Java语言题解</a></li></ul><hr><h3 id="7-树"><a href="#7-树" class="headerlink" title="7.树"></a>7.树</h3><h4 id="①知识点整理-3"><a href="#①知识点整理-3" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li>树的概念<ul><li>二叉树有哪几种形式？</li><li>什么是平衡二叉树、满二叉树、完全二叉树</li><li>Trie 树和二叉树的区别</li><li>树和链表的区别？</li><li>讲讲树和图，它们有什么区别？</li></ul></li><li>树的遍历</li><li>递归求解树</li><li>路径相关</li><li>二叉搜索树 <ul><li>在含有 100 个节点的二叉搜索树中找到其中第 80 大的节点</li></ul></li></ul><h4 id="②LeetCode-必刷题目（78）"><a href="#②LeetCode-必刷题目（78）" class="headerlink" title="②LeetCode 必刷题目（78）"></a>②LeetCode 必刷题目（78）</h4><ul><li>剑指 Offer（14）<ul><li><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题07. 重建二叉树</a></li><li><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">面试题26. 树的子结构</a></li><li><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">面试题27. 二叉树的镜像</a></li><li><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题28. 对称的二叉树</a></li><li><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题32 - I. 从上到下打印二叉树</a></li><li><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">面试题32 - II. 从上到下打印二叉树 II</a></li><li><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">面试题32 - III. 从上到下打印二叉树 III</a></li><li><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">面试题33. 二叉搜索树的后序遍历序列</a></li><li><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">面试题34. 二叉树中和为某一值的路径</a></li><li><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" target="_blank" rel="noopener">面试题54. 二叉搜索树的第k大节点</a></li><li><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/" target="_blank" rel="noopener">面试题55 - I. 二叉树的深度</a></li><li><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题55 - II. 平衡二叉树</a></li><li><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">面试题68 - I. 二叉搜索树的最近公共祖先</a></li><li><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">面试题68 - II. 二叉树的最近公共祖先</a></li></ul></li><li>树的遍历（19）<ul><li><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. 二叉树的后序遍历</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">107. 二叉树的层次遍历 II</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">103. 二叉树的锯齿形层次遍历</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-vertical-order-traversal/" target="_blank" rel="noopener">314. 二叉树的垂直遍历</a></li><li><a href="https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/" target="_blank" rel="noopener">987. 二叉树的垂序遍历</a></li><li><a href="https://leetcode-cn.com/problems/increasing-order-search-tree/" target="_blank" rel="noopener">897. 递增顺序查找树</a></li><li><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener">637. 二叉树的层平均值</a></li><li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a></li><li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">106. 从中序与后序遍历序列构造二叉树</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">199. 二叉树的右视图</a></li><li><a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">337. 打家劫舍 III</a></li><li><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-bst/" target="_blank" rel="noopener">449. 序列化和反序列化二叉搜索树</a></li><li><a href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/" target="_blank" rel="noopener">863. 二叉树中所有距离为 K 的结点</a></li><li><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">429. N叉树的层序遍历</a></li><li><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="noopener">589. N叉树的前序遍历</a></li><li><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener">590. N叉树的后序遍历</a></li></ul></li><li>适合递归求解（21）<ul><li><a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">100. 相同的树</a></li><li><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. 对称二叉树</a></li><li><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. 二叉树的最大深度</a></li><li><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">110. 平衡二叉树</a></li><li><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. 二叉树的最小深度</a></li><li><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. 二叉树展开为链表</a></li><li><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">222. 完全二叉树的节点个数</a></li><li><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">226. 翻转二叉树</a></li><li><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">404. 左叶子之和</a></li><li><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/" target="_blank" rel="noopener">513. 找树左下角的值</a></li><li><a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/" target="_blank" rel="noopener">515. 在每个树行中找最大值</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-tilt/" target="_blank" rel="noopener">563. 二叉树的坡度</a></li><li><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener">572. 另一个树的子树</a></li><li><a href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/" target="_blank" rel="noopener">606. 根据二叉树创建字符串</a></li><li><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">617. 合并二叉树</a></li><li><a href="https://leetcode-cn.com/problems/maximum-binary-tree/" target="_blank" rel="noopener">654. 最大二叉树</a></li><li><a href="https://leetcode-cn.com/problems/print-binary-tree/" target="_blank" rel="noopener">655. 输出二叉树</a></li><li><a href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/" target="_blank" rel="noopener">671. 二叉树中第二小的节点</a></li><li><a href="https://leetcode-cn.com/problems/leaf-similar-trees/" target="_blank" rel="noopener">872. 叶子相似的树</a></li><li><a href="https://leetcode-cn.com/problems/flip-equivalent-binary-trees/" target="_blank" rel="noopener">951. 翻转等价二叉树</a></li><li><a href="https://leetcode-cn.com/problems/univalued-binary-tree/" target="_blank" rel="noopener">965. 单值二叉树</a></li></ul></li><li>路径相关（8）<ul><li><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">112. 路径总和</a></li><li><a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">113. 路径总和 II</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">124. 二叉树中的最大路径和</a></li><li><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. 二叉树的最近公共祖先</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-paths/" target="_blank" rel="noopener">257. 二叉树的所有路径</a></li><li><a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">437. 路径总和 III</a></li><li><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">543. 二叉树的直径</a></li><li><a href="https://leetcode-cn.com/problems/longest-univalue-path/" target="_blank" rel="noopener">687. 最长同值路径</a></li></ul></li><li>二叉搜索树（16）<ul><li><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a> </li><li><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener">99. 恢复二叉搜索树</a></li><li><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">108. 将有序数组转换为二叉搜索树</a></li><li><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">230. 二叉搜索树中第K小的元素</a></li><li><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">235. 二叉搜索树的最近公共祖先</a></li><li><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">450. 删除二叉搜索树中的节点</a></li><li><a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/" target="_blank" rel="noopener">501. 二叉搜索树中的众数</a></li><li><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener">530. 二叉搜索树的最小绝对差</a></li><li><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">538. 把二叉搜索树转换为累加树</a></li><li><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/" target="_blank" rel="noopener">653. 两数之和 IV - 输入 BST</a> </li><li><a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/" target="_blank" rel="noopener">669. 修剪二叉搜索树</a></li><li><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener">700. 二叉搜索树中的搜索</a></li><li><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">701. 二叉搜索树中的插入操作</a></li><li><a href="https://leetcode-cn.com/problems/split-bst/" target="_blank" rel="noopener">776. 拆分二叉搜索树</a></li><li><a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/" target="_blank" rel="noopener">783. 二叉搜索树节点最小距离</a></li><li><a href="https://leetcode-cn.com/problems/range-sum-of-bst/" target="_blank" rel="noopener">938. 二叉搜索树的范围和</a></li></ul></li></ul><h4 id="③相关博客-3"><a href="#③相关博客-3" class="headerlink" title="③相关博客"></a>③相关博客</h4><ul><li><a href="https://messi1002.top/2019/02/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%80%A7%E8%B4%A8/">二叉树的定义及性质</a></li><li><a href="https://messi1002.top/2019/02/11/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E9%80%92%E5%BD%92-%E8%BF%AD%E4%BB%A3/">树的遍历(递归+迭代)</a></li><li><a href="https://www.tamarous.com/morris_traversal_algorithm/" target="_blank" rel="noopener">二叉树的 Morris 遍历</a></li><li><a href="https://messi1002.top/2019/02/15/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/">二叉搜索树的常用操作</a></li></ul><hr><h3 id="8-图"><a href="#8-图" class="headerlink" title="8.图"></a>8.图</h3><h4 id="①知识点整理-4"><a href="#①知识点整理-4" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li>BFS（广度优先搜索）</li><li>DFS（深度优先搜索）</li><li>最短路径算法</li><li>说一下数据结构中的图如何存储</li><li>一个有向图用邻接矩阵表示，并且是有权图，怎么判断图中有没有环（有向图判断循环引用）</li></ul><h4 id="②LeetCode-必刷题目（11）"><a href="#②LeetCode-必刷题目（11）" class="headerlink" title="②LeetCode 必刷题目（11）"></a>②LeetCode 必刷题目（11）</h4><ul><li>剑指 Offer（1）<ul><li><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">面试题13. 机器人的运动范围</a></li></ul></li><li>中等（8）<ul><li><a href="https://leetcode-cn.com/problems/clone-graph/" target="_blank" rel="noopener">133. 克隆图</a></li><li><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></li><li><a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">207. 课程表</a></li><li><a href="https://leetcode-cn.com/problems/course-schedule-ii/" target="_blank" rel="noopener">210. 课程表 II</a></li><li><a href="https://leetcode-cn.com/problems/minimum-height-trees/" target="_blank" rel="noopener">310. 最小高度树</a></li><li><a href="https://leetcode-cn.com/problems/reconstruct-itinerary/" target="_blank" rel="noopener">332. 重新安排行程</a></li><li><a href="https://leetcode-cn.com/problems/evaluate-division/" target="_blank" rel="noopener">399. 除法求值</a></li><li><a href="https://leetcode-cn.com/problems/redundant-connection/" target="_blank" rel="noopener">684. 冗余连接</a></li></ul></li><li>困难（2）<ul><li><a href="https://leetcode-cn.com/problems/alien-dictionary/" target="_blank" rel="noopener">269. 火星词典</a></li><li><a href="https://leetcode-cn.com/problems/redundant-connection-ii/" target="_blank" rel="noopener">685. 冗余连接 II</a></li></ul></li></ul><h4 id="③相关博客-4"><a href="#③相关博客-4" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="9-哈希表"><a href="#9-哈希表" class="headerlink" title="9.哈希表"></a>9.哈希表</h3><h4 id="①知识点整理-5"><a href="#①知识点整理-5" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li>怎么防止 hash 碰撞</li><li>K—V</li></ul><h4 id="②LeetCode-必刷题目（47）"><a href="#②LeetCode-必刷题目（47）" class="headerlink" title="②LeetCode 必刷题目（47）"></a>②LeetCode 必刷题目（47）</h4><ul><li>剑指 Offer（2）<ul><li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题03. 数组中重复的数字</a></li><li><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/" target="_blank" rel="noopener">面试题50. 第一个只出现一次的字符</a></li></ul></li><li>简单（31）<ul><li><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></li><li><a href="https://leetcode-cn.com/problems/count-primes/" target="_blank" rel="noopener">204. 计数质数</a></li><li><a href="https://leetcode-cn.com/problems/isomorphic-strings/" target="_blank" rel="noopener">205. 同构字符串</a></li><li><a href="https://leetcode-cn.com/problems/contains-duplicate/" target="_blank" rel="noopener">217. 存在重复元素</a></li><li><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">219. 存在重复元素 II</a></li><li><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">242. 有效的字母异位词</a></li><li><a href="https://leetcode-cn.com/problems/word-pattern/" target="_blank" rel="noopener">290. 单词规律</a></li><li><a href="https://leetcode-cn.com/problems/bulls-and-cows/" target="_blank" rel="noopener">299. 猜数字游戏</a></li><li><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">349. 两个数组的交集</a></li><li><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">350. 两个数组的交集 II</a></li><li><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">387. 字符串中的第一个唯一字符</a></li><li><a href="https://leetcode-cn.com/problems/longest-palindrome/" target="_blank" rel="noopener">409. 最长回文串</a></li><li><a href="https://leetcode-cn.com/problems/number-of-boomerangs/" target="_blank" rel="noopener">447. 回旋镖的数量</a></li><li><a href="https://leetcode-cn.com/problems/island-perimeter/" target="_blank" rel="noopener">463. 岛屿的周长</a></li><li><a href="https://leetcode-cn.com/problems/keyboard-row/" target="_blank" rel="noopener">500. 键盘行</a></li><li><a href="https://leetcode-cn.com/problems/distribute-candies/" target="_blank" rel="noopener">575. 分糖果</a></li><li><a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/" target="_blank" rel="noopener">594. 最长和谐子序列</a></li><li><a href="https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/" target="_blank" rel="noopener">599. 两个列表的最小索引总和</a></li><li><a href="https://leetcode-cn.com/problems/set-mismatch/" target="_blank" rel="noopener">645. 错误的集合</a></li><li><a href="https://leetcode-cn.com/problems/shortest-completing-word/" target="_blank" rel="noopener">748. 最短完整词</a></li><li><a href="https://leetcode-cn.com/problems/find-anagram-mappings/" target="_blank" rel="noopener">760. 找出变位映射</a></li><li><a href="https://leetcode-cn.com/problems/jewels-and-stones/" target="_blank" rel="noopener">771. 宝石与石头</a></li><li><a href="https://leetcode-cn.com/problems/subdomain-visit-count/" target="_blank" rel="noopener">811. 子域名访问计数</a></li><li><a href="https://leetcode-cn.com/problems/uncommon-words-from-two-sentences/" target="_blank" rel="noopener">884. 两句话中的不常见单词</a></li><li><a href="https://leetcode-cn.com/problems/verifying-an-alien-dictionary/" target="_blank" rel="noopener">953. 验证外星语词典</a></li><li><a href="https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array/" target="_blank" rel="noopener">961. 重复 N 次的元素</a></li><li><a href="https://leetcode-cn.com/problems/find-common-characters/" target="_blank" rel="noopener">1002. 查找常用字符</a></li><li><a href="https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/" target="_blank" rel="noopener">1160. 拼写单词</a></li><li><a href="https://leetcode-cn.com/problems/maximum-number-of-balloons/" target="_blank" rel="noopener">1189. “气球” 的最大数量</a></li><li><a href="https://leetcode-cn.com/problems/unique-number-of-occurrences/" target="_blank" rel="noopener">1207. 独一无二的出现次数</a></li><li><a href="https://leetcode-cn.com/problems/intersection-of-three-sorted-arrays/" target="_blank" rel="noopener">1213. 三个有序数组的交集</a></li></ul></li><li>中等（9）<ul><li><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></li><li><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a></li><li><a href="https://leetcode-cn.com/problems/valid-sudoku/" target="_blank" rel="noopener">36. 有效的数独</a></li><li><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">49. 字母异位词分组</a></li><li><a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1/" target="_blank" rel="noopener">380. 常数时间插入、删除和获取随机元素</a></li><li><a href="https://leetcode-cn.com/problems/4sum-ii/" target="_blank" rel="noopener">454. 四数相加 II</a></li><li><a href="https://leetcode-cn.com/problems/contiguous-array/" target="_blank" rel="noopener">525. 连续数组</a></li><li><a href="https://leetcode-cn.com/problems/encode-and-decode-tinyurl/" target="_blank" rel="noopener">535. TinyURL 的加密与解密</a></li><li><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. 和为K的子数组</a></li></ul></li><li>困难（5）<ul><li><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/" target="_blank" rel="noopener">30. 串联所有单词的子串</a></li><li><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a></li><li><a href="https://leetcode-cn.com/problems/max-points-on-a-line/" target="_blank" rel="noopener">149. 直线上最多的点数</a></li><li><a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed/" target="_blank" rel="noopener">381. O(1) 时间插入、删除和获取随机元素 - 允许重复</a></li><li><a href="https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/" target="_blank" rel="noopener">632. 最小区间</a></li></ul></li></ul><h4 id="③相关博客-5"><a href="#③相关博客-5" class="headerlink" title="③相关博客"></a>③相关博客</h4><ul><li>Java 集合的用法</li></ul><hr><h3 id="10-二分查找"><a href="#10-二分查找" class="headerlink" title="10.二分查找"></a>10.二分查找</h3><h4 id="①知识点整理-6"><a href="#①知识点整理-6" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><h4 id="②LeetCode-必刷题目（31）"><a href="#②LeetCode-必刷题目（31）" class="headerlink" title="②LeetCode 必刷题目（31）"></a>②LeetCode 必刷题目（31）</h4><ul><li>剑指 Offer（4）<ul><li><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">面试题11. 旋转数组的最小数字</a></li><li><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">面试题16. 数值的整数次方</a></li><li><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank" rel="noopener">面试题53 - I. 在排序数组中查找数字 I</a></li><li><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题53 - II. 0～n-1中缺失的数字</a> </li></ul></li><li>简单（13）<ul><li><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a></li><li><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">69. x 的平方根</a></li><li><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a></li><li><a href="https://leetcode-cn.com/problems/first-bad-version/" target="_blank" rel="noopener">278. 第一个错误的版本</a></li><li><a href="https://leetcode-cn.com/problems/valid-perfect-square/" target="_blank" rel="noopener">367. 有效的完全平方数</a></li><li><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/" target="_blank" rel="noopener">374. 猜数字大小</a></li><li><a href="https://leetcode-cn.com/problems/arranging-coins/" target="_blank" rel="noopener">441. 排列硬币</a></li><li><a href="https://leetcode-cn.com/problems/heaters/" target="_blank" rel="noopener">475. 供暖器</a></li><li><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找</a></li><li><a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/" target="_blank" rel="noopener">744. 寻找比目标字母大的最小字母</a></li><li><a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/" target="_blank" rel="noopener">852. 山脉数组的峰顶索引</a></li><li><a href="https://leetcode-cn.com/problems/fixed-point/" target="_blank" rel="noopener">1064. 不动点</a></li><li><a href="https://leetcode-cn.com/problems/check-if-a-number-is-majority-element-in-a-sorted-array/" target="_blank" rel="noopener">1150. 检查一个数是否在数组中占绝大多数</a></li></ul></li><li>中等（12）<ul><li><a href="https://leetcode-cn.com/problems/divide-two-integers/" target="_blank" rel="noopener">29. 两数相除</a></li><li><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></li><li><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></li><li><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></li><li><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">74. 搜索二维矩阵</a></li><li><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. 搜索旋转排序数组 II</a></li><li><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></li><li><a href="https://leetcode-cn.com/problems/find-peak-element/" target="_blank" rel="noopener">162. 寻找峰值</a></li><li><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">209. 长度最小的子数组</a></li><li><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">287. 寻找重复数</a></li><li><a href="https://leetcode-cn.com/problems/find-right-interval/" target="_blank" rel="noopener">436. 寻找右区间</a></li><li><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener">718. 最长重复子数组</a></li></ul></li><li>困难（2）<ul><li><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. 寻找旋转排序数组中的最小值 II</a></li><li><a href="https://leetcode-cn.com/problems/kth-smallest-number-in-multiplication-table/" target="_blank" rel="noopener">668. 乘法表中第k小的数</a></li></ul></li></ul><h4 id="③相关博客-6"><a href="#③相关博客-6" class="headerlink" title="③相关博客"></a>③相关博客</h4><ul><li><a href="https://messi1002.top/2019/01/05/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/">二分查找法代码实现</a></li><li><a href="https://messi1002.top/2019/01/04/LeetCode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%EF%BC%88Easy%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/">35.搜索插入位置（Easy）Java语言题解</a></li><li><a href="https://messi1002.top/2019/01/04/LeetCode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%EF%BC%88Easy%EF%BC%89C%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/">35.搜索插入位置（Easy）C语言题解</a></li><li><a href="https://mp.weixin.qq.com/s/AlUZ8i6zqap6XIMvgTVO2w" target="_blank" rel="noopener">你真的会写二分查找吗？</a></li></ul><hr><h3 id="11-贪心算法"><a href="#11-贪心算法" class="headerlink" title="11.贪心算法"></a>11.贪心算法</h3><h4 id="①知识点整理-7"><a href="#①知识点整理-7" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><h4 id="②LeetCode-必刷题目（13）"><a href="#②LeetCode-必刷题目（13）" class="headerlink" title="②LeetCode 必刷题目（13）"></a>②LeetCode 必刷题目（13）</h4><ul><li>简单（2）<ul><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a></li><li><a href="https://leetcode-cn.com/problems/assign-cookies/" target="_blank" rel="noopener">455. 分发饼干</a></li></ul></li><li>中等（8）<ul><li><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></li><li><a href="https://leetcode-cn.com/problems/gas-station/" target="_blank" rel="noopener">134. 加油站</a></li><li><a href="https://leetcode-cn.com/problems/remove-k-digits/" target="_blank" rel="noopener">402. 移掉K位数字</a></li><li><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/" target="_blank" rel="noopener">406. 根据身高重建队列</a></li><li><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener">452. 用最少数量的箭引爆气球</a></li><li><a href="https://leetcode-cn.com/problems/task-scheduler/" target="_blank" rel="noopener">621. 任务调度器</a></li><li><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/" target="_blank" rel="noopener">738. 单调递增的数字</a></li><li><a href="https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/" target="_blank" rel="noopener">921. 使括号有效的最少添加</a></li></ul></li><li>困难（3）<ul><li><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II</a></li><li><a href="https://leetcode-cn.com/problems/candy/" target="_blank" rel="noopener">135. 分发糖果</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/" target="_blank" rel="noopener">316. 去除重复字母</a></li></ul></li></ul><h4 id="③相关博客-7"><a href="#③相关博客-7" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="12-双指针（滑动窗口）"><a href="#12-双指针（滑动窗口）" class="headerlink" title="12.双指针（滑动窗口）"></a>12.双指针（滑动窗口）</h3><h4 id="①知识点整理-8"><a href="#①知识点整理-8" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li>滑动窗口</li></ul><h4 id="②LeetCode-必刷题目（26）"><a href="#②LeetCode-必刷题目（26）" class="headerlink" title="②LeetCode 必刷题目（26）"></a>②LeetCode 必刷题目（26）</h4><ul><li>剑指 Offer（4）<ul><li><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">面试题04. 二维数组中的查找</a></li><li><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">面试题48. 最长不含重复字符的子字符串</a></li><li><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/" target="_blank" rel="noopener">面试题57. 和为s的两个数字</a></li><li><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" target="_blank" rel="noopener">面试题57 - II. 和为s的连续正数序列</a></li></ul></li><li>简单（13）<ul><li><a href="https://leetcode-cn.com/problems/sorted-merge-lcci/" target="_blank" rel="noopener">面试题 10.01. 合并排序的数组</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除排序数组中的重复项</a></li><li><a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="noopener">27. 移除元素</a></li><li><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">28. 实现 strStr()</a></li><li><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">88. 合并两个有序数组</a></li><li><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">125. 验证回文串</a></li><li><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">283. 移动零</a></li><li><a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">344. 反转字符串</a></li><li><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="noopener">345. 反转字符串中的元音字母</a></li><li><a href="https://leetcode-cn.com/problems/k-diff-pairs-in-an-array/" target="_blank" rel="noopener">532. 数组中的K-diff数对</a></li><li><a href="https://leetcode-cn.com/problems/long-pressed-name/" target="_blank" rel="noopener">925. 长按键入</a></li><li><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/" target="_blank" rel="noopener">977. 有序数组的平方</a></li><li><a href="https://leetcode-cn.com/problems/diet-plan-performance/" target="_blank" rel="noopener">1176. 健身计划评估</a></li></ul></li><li>中等（9）<ul><li><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a></li><li><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></li><li><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">16. 最接近的三数之和</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/" target="_blank" rel="noopener">80. 删除排序数组中的重复项 II</a></li><li><a href="https://leetcode-cn.com/problems/3sum-smaller/" target="_blank" rel="noopener">259. 较小的三数之和</a></li><li><a href="https://leetcode-cn.com/problems/sort-transformed-array/" target="_blank" rel="noopener">360. 有序转化数组</a></li><li><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/" target="_blank" rel="noopener">424. 替换后的最长重复字符</a></li><li><a href="https://leetcode-cn.com/problems/permutation-in-string/" target="_blank" rel="noopener">567. 字符串的排列</a></li><li><a href="https://leetcode-cn.com/problems/subarray-product-less-than-k/" target="_blank" rel="noopener">713. 乘积小于K的子数组</a></li></ul></li></ul><h4 id="③相关博客-8"><a href="#③相关博客-8" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="13-栈"><a href="#13-栈" class="headerlink" title="13.栈"></a>13.栈</h3><h4 id="①知识点整理-9"><a href="#①知识点整理-9" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li><a href="https://blog.csdn.net/K346K346/article/details/80849966" target="_blank" rel="noopener">堆与栈的区别</a></li><li>栈的时间复杂度、空间复杂度</li><li>栈的应用场景</li></ul><h4 id="②LeetCode-必刷题目（25）"><a href="#②LeetCode-必刷题目（25）" class="headerlink" title="②LeetCode 必刷题目（25）"></a>②LeetCode 必刷题目（25）</h4><ul><li>剑指 Offer（3）<ul><li><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">面试题09. 用两个栈实现队列</a></li><li><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank" rel="noopener">面试题30. 包含min函数的栈</a></li><li><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">面试题31. 栈的压入、弹出序列</a></li></ul></li><li>简单（9）<ul><li><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></li><li><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a> </li><li><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">225. 用队列实现栈</a></li><li><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232. 用栈实现队列</a></li><li><a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">496. 下一个更大元素 I</a></li><li><a href="https://leetcode-cn.com/problems/baseball-game/" target="_blank" rel="noopener">682. 棒球比赛</a></li><li><a href="https://leetcode-cn.com/problems/backspace-string-compare/" target="_blank" rel="noopener">844. 比较含退格的字符串</a></li><li><a href="https://leetcode-cn.com/problems/remove-outermost-parentheses/" target="_blank" rel="noopener">1021. 删除最外层的括号</a></li><li><a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/" target="_blank" rel="noopener">1047. 删除字符串中的所有相邻重复项</a></li></ul></li><li>中等（7）<ul><li><a href="https://leetcode-cn.com/problems/simplify-path/" target="_blank" rel="noopener">71. 简化路径</a></li><li><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">150. 逆波兰表达式求值</a></li><li><a href="https://leetcode-cn.com/problems/mini-parser/" target="_blank" rel="noopener">385. 迷你语法分析器</a></li><li><a href="https://leetcode-cn.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">503. 下一个更大元素 II</a></li><li><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">739. 每日温度</a></li><li><a href="https://leetcode-cn.com/problems/score-of-parentheses/" target="_blank" rel="noopener">856. 括号的分数</a></li><li><a href="https://leetcode-cn.com/problems/validate-stack-sequences/" target="_blank" rel="noopener">946. 验证栈序列</a></li></ul></li><li>困难（6）<ul><li><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水</a></li><li><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a> </li><li><a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">85. 最大矩形</a></li><li><a href="https://leetcode-cn.com/problems/basic-calculator/" target="_blank" rel="noopener">224. 基本计算器</a></li><li><a href="https://leetcode-cn.com/problems/tag-validator/" target="_blank" rel="noopener">591. 标签验证器</a></li><li><a href="https://leetcode-cn.com/problems/number-of-atoms/" target="_blank" rel="noopener">726. 原子的数量</a></li></ul></li></ul><h4 id="③相关博客-9"><a href="#③相关博客-9" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="14-回溯算法"><a href="#14-回溯算法" class="headerlink" title="14.回溯算法"></a>14.回溯算法</h3><h4 id="①知识点整理-10"><a href="#①知识点整理-10" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><h4 id="②LeetCode-必刷题目（23）"><a href="#②LeetCode-必刷题目（23）" class="headerlink" title="②LeetCode 必刷题目（23）"></a>②LeetCode 必刷题目（23）</h4><ul><li>剑指 Offer（1）<ul><li><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">面试题38. 字符串的排列</a> </li></ul></li><li>简单（2）<ul><li><a href="https://leetcode-cn.com/problems/binary-watch/" target="_blank" rel="noopener">401. 二进制手表</a></li><li><a href="https://leetcode-cn.com/problems/letter-case-permutation/" target="_blank" rel="noopener">784. 字母大小写全排列</a></li></ul></li><li>中等（17）<ul><li><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a></li><li><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a></li><li><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和</a></li><li><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II</a></li><li><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></li><li><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">47. 全排列 II</a></li><li><a href="https://leetcode-cn.com/problems/permutation-sequence/" target="_blank" rel="noopener">60. 第k个排列</a></li><li><a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">77. 组合</a></li><li><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a></li><li><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">79. 单词搜索</a></li><li><a href="https://leetcode-cn.com/problems/gray-code/" target="_blank" rel="noopener">89. 格雷编码</a></li><li><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">90. 子集 II</a></li><li><a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">93. 复原IP地址</a></li><li><a href="https://leetcode-cn.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">131. 分割回文串</a></li><li><a href="https://leetcode-cn.com/problems/combination-sum-iii/" target="_blank" rel="noopener">216. 组合总和 III</a></li><li><a href="https://leetcode-cn.com/problems/additive-number/" target="_blank" rel="noopener">306. 累加数</a></li><li><a href="https://leetcode-cn.com/problems/beautiful-arrangement/" target="_blank" rel="noopener">526. 优美的排列</a></li></ul></li><li>困难（3）<ul><li><a href="https://leetcode-cn.com/problems/sudoku-solver/" target="_blank" rel="noopener">37. 解数独</a></li><li><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">51. N皇后</a></li><li><a href="https://leetcode-cn.com/problems/n-queens-ii/" target="_blank" rel="noopener">52. N皇后 II</a></li></ul></li></ul><h4 id="③相关博客-10"><a href="#③相关博客-10" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="15-设计"><a href="#15-设计" class="headerlink" title="15.设计"></a>15.设计</h3><h4 id="①知识点整理-11"><a href="#①知识点整理-11" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><h4 id="②LeetCode-必刷题目（21）"><a href="#②LeetCode-必刷题目（21）" class="headerlink" title="②LeetCode 必刷题目（21）"></a>②LeetCode 必刷题目（21）</h4><ul><li>剑指 Offer（2）<ul><li><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题37. 序列化二叉树</a></li><li><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">面试题41. 数据流中的中位数</a></li></ul></li><li>简单（6）<ul><li><a href="https://leetcode-cn.com/problems/two-sum-iii-data-structure-design/" target="_blank" rel="noopener">170. 两数之和 III - 数据结构设计</a></li><li><a href="https://leetcode-cn.com/problems/logger-rate-limiter/" target="_blank" rel="noopener">359. 日志速率限制器</a></li><li><a href="https://leetcode-cn.com/problems/design-compressed-string-iterator/" target="_blank" rel="noopener">604. 迭代压缩字符串</a></li><li><a href="https://leetcode-cn.com/problems/design-hashset/" target="_blank" rel="noopener">705. 设计哈希集合</a></li><li><a href="https://leetcode-cn.com/problems/design-hashmap/" target="_blank" rel="noopener">706. 设计哈希映射</a></li><li><a href="https://leetcode-cn.com/problems/max-stack/" target="_blank" rel="noopener">716. 最大栈</a></li></ul></li><li>中等（9）<ul><li><a href="https://leetcode-cn.com/problems/lru-cache-lcci/" target="_blank" rel="noopener">面试题 16.25. LRU缓存</a></li><li><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU缓存机制</a></li><li><a href="https://leetcode-cn.com/problems/binary-search-tree-iterator/" target="_blank" rel="noopener">173. 二叉搜索树迭代器</a></li><li><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">208. 实现 Trie (前缀树)</a></li><li><a href="https://leetcode-cn.com/problems/add-and-search-word-data-structure-design/" target="_blank" rel="noopener">211. 添加与搜索单词 - 数据结构设计</a></li><li><a href="https://leetcode-cn.com/problems/peeking-iterator/" target="_blank" rel="noopener">284. 顶端迭代器</a></li><li><a href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/" target="_blank" rel="noopener">341. 扁平化嵌套列表迭代器</a></li><li><a href="https://leetcode-cn.com/problems/design-twitter/" target="_blank" rel="noopener">355. 设计推特</a></li><li><a href="https://leetcode-cn.com/problems/design-linked-list/" target="_blank" rel="noopener">707. 设计链表</a></li></ul></li><li>困难（4）<ul><li><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">295. 数据流的中位数</a></li><li><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">297. 二叉树的序列化与反序列化</a></li><li><a href="https://leetcode-cn.com/problems/all-oone-data-structure/" target="_blank" rel="noopener">432. 全 O(1) 的数据结构</a></li><li><a href="https://leetcode-cn.com/problems/lfu-cache/" target="_blank" rel="noopener">460. LFU缓存</a></li></ul></li></ul><h4 id="③相关博客-11"><a href="#③相关博客-11" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="16-位运算"><a href="#16-位运算" class="headerlink" title="16.位运算"></a>16.位运算</h3><h4 id="①知识点整理-12"><a href="#①知识点整理-12" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li>进制转换</li><li>运算符</li></ul><h4 id="②LeetCode-必刷题目（26）-1"><a href="#②LeetCode-必刷题目（26）-1" class="headerlink" title="②LeetCode 必刷题目（26）"></a>②LeetCode 必刷题目（26）</h4><ul><li>剑指 Offer（4）<ul><li><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">面试题15. 二进制中1的个数</a></li><li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">面试题56 - I. 数组中数字出现的次数</a></li><li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank" rel="noopener">面试题56 - II. 数组中数字出现的次数 II</a></li><li><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" target="_blank" rel="noopener">面试题65. 不用加减乘除做加法</a></li></ul></li><li>简单（14）<ul><li><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. 只出现一次的数字</a></li><li><a href="https://leetcode-cn.com/problems/reverse-bits/" target="_blank" rel="noopener">190. 颠倒二进制位</a></li><li><a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">191. 位1的个数</a></li><li><a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="noopener">231. 2的幂</a></li><li><a href="https://leetcode-cn.com/problems/missing-number/" target="_blank" rel="noopener">268. 缺失数字</a></li><li><a href="https://leetcode-cn.com/problems/power-of-four/" target="_blank" rel="noopener">342. 4的幂</a></li><li><a href="https://leetcode-cn.com/problems/sum-of-two-integers/" target="_blank" rel="noopener">371. 两整数之和</a></li><li><a href="https://leetcode-cn.com/problems/find-the-difference/" target="_blank" rel="noopener">389. 找不同</a></li><li><a href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/" target="_blank" rel="noopener">405. 数字转换为十六进制数</a></li><li><a href="https://leetcode-cn.com/problems/hamming-distance/" target="_blank" rel="noopener">461. 汉明距离</a></li><li><a href="https://leetcode-cn.com/problems/number-complement/" target="_blank" rel="noopener">476. 数字的补数</a></li><li><a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/" target="_blank" rel="noopener">693. 交替位二进制数</a></li><li><a href="https://leetcode-cn.com/problems/prime-number-of-set-bits-in-binary-representation/" target="_blank" rel="noopener">762. 二进制表示中质数个计算置位</a></li><li><a href="https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/" target="_blank" rel="noopener">1290. 二进制链表转整数</a></li></ul></li><li>中等（8）<ul><li><a href="https://leetcode-cn.com/problems/single-number-ii/" target="_blank" rel="noopener">137. 只出现一次的数字 II</a></li><li><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/" target="_blank" rel="noopener">187. 重复的DNA序列</a></li><li><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/" target="_blank" rel="noopener">201. 数字范围按位与</a></li><li><a href="https://leetcode-cn.com/problems/single-number-iii/" target="_blank" rel="noopener">260. 只出现一次的数字 III</a></li><li><a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/" target="_blank" rel="noopener">318. 最大单词长度乘积</a></li><li><a href="https://leetcode-cn.com/problems/utf-8-validation/" target="_blank" rel="noopener">393. UTF-8 编码验证</a></li><li><a href="https://leetcode-cn.com/problems/integer-replacement/" target="_blank" rel="noopener">397. 整数替换</a></li><li><a href="https://leetcode-cn.com/problems/total-hamming-distance/" target="_blank" rel="noopener">477. 汉明距离总和</a></li></ul></li></ul><h4 id="③相关博客-12"><a href="#③相关博客-12" class="headerlink" title="③相关博客"></a>③相关博客</h4><ul><li><a href="https://messi1002.top/2018/09/20/Java%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%8F%8A%E4%BD%8D%E8%BF%90%E7%AE%97/">Java进制转换及位运算</a></li></ul><hr><h3 id="17-排序"><a href="#17-排序" class="headerlink" title="17.排序"></a>17.排序</h3><h4 id="①知识点整理-13"><a href="#①知识点整理-13" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li>比较排序<ul><li>交换排序类：简单交换排序、冒泡排序、快速排序 </li><li>选择排序类：简单选择排序、堆排序 </li><li>插入排序类：直接插入排序、希尔排序 </li><li>归并排序类：归并排序 </li></ul></li><li>非比较排序<ul><li>计数排序</li><li>桶排序</li><li>基数排序 </li></ul></li></ul><h4 id="②LeetCode-必刷题目（21）-1"><a href="#②LeetCode-必刷题目（21）-1" class="headerlink" title="②LeetCode 必刷题目（21）"></a>②LeetCode 必刷题目（21）</h4><ul><li>剑指 Offer（3）<ul><li><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener">面试题45. 把数组排成最小的数</a></li><li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">面试题51. 数组中的逆序对</a></li><li><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/" target="_blank" rel="noopener">面试题61. 扑克牌中的顺子</a></li></ul></li><li>简单（3）<ul><li><a href="https://leetcode-cn.com/problems/meeting-rooms/" target="_blank" rel="noopener">252. 会议室</a></li><li><a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/" target="_blank" rel="noopener">922. 按奇偶排序数组 II</a></li><li><a href="https://leetcode-cn.com/problems/largest-perimeter-triangle/" target="_blank" rel="noopener">976. 三角形的最大周长</a></li></ul></li><li>中等（11）<ul><li><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56. 合并区间</a></li><li><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">75. 颜色分类</a></li><li><a href="https://leetcode-cn.com/problems/insertion-sort-list/" target="_blank" rel="noopener">147. 对链表进行插入排序</a></li><li><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">148. 排序链表</a></li><li><a href="https://leetcode-cn.com/problems/largest-number/" target="_blank" rel="noopener">179. 最大数</a></li><li><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">220. 存在重复元素 III</a></li><li><a href="https://leetcode-cn.com/problems/h-index/" target="_blank" rel="noopener">274. H 指数</a></li><li><a href="https://leetcode-cn.com/problems/wiggle-sort/" target="_blank" rel="noopener">280. 摆动排序</a></li><li><a href="https://leetcode-cn.com/problems/wiggle-sort-ii/" target="_blank" rel="noopener">324. 摆动排序 II</a></li><li><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/" target="_blank" rel="noopener">524. 通过删除字母匹配到字典里最长单词</a></li><li><a href="https://leetcode-cn.com/problems/pancake-sorting/" target="_blank" rel="noopener">969. 煎饼排序</a></li></ul></li><li>困难（4）<ul><li><a href="https://leetcode-cn.com/problems/insert-interval/" target="_blank" rel="noopener">57. 插入区间</a></li><li><a href="https://leetcode-cn.com/problems/maximum-gap/" target="_blank" rel="noopener">164. 最大间距</a></li><li><a href="https://leetcode-cn.com/problems/best-meeting-point/" target="_blank" rel="noopener">296. 最佳的碰头地点</a></li><li><a href="https://leetcode-cn.com/problems/word-abbreviation/" target="_blank" rel="noopener">527. 单词缩写</a></li></ul></li></ul><h4 id="③相关博客-13"><a href="#③相关博客-13" class="headerlink" title="③相关博客"></a>③相关博客</h4><ul><li><a href="https://messi1002.top/2020/02/12/%E5%85%AB%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">八种排序算法的总结及性能分析</a></li><li><a href="https://mp.weixin.qq.com/s/teOGQlslb6aP4AQrx7TTzA" target="_blank" rel="noopener">漫画：“排序算法” 大总结</a></li><li><a href="https://mp.weixin.qq.com/s/l13mNfGZgCaUKLDgh3Jddw" target="_blank" rel="noopener">面试时写不出排序算法？看这篇就够了</a></li></ul><hr><h3 id="18-链表"><a href="#18-链表" class="headerlink" title="18.链表"></a>18.链表</h3><h4 id="①知识点整理-14"><a href="#①知识点整理-14" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li>单链表和双链表的区别及应用场景</li><li>链表和数组的区别</li><li>用数组实现循环链表</li></ul><h4 id="②LeetCode-必刷题目（31）-1"><a href="#②LeetCode-必刷题目（31）-1" class="headerlink" title="②LeetCode 必刷题目（31）"></a>②LeetCode 必刷题目（31）</h4><ul><li>剑指 Offer（7）<ul><li><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">面试题06. 从尾到头打印链表</a></li><li><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/" target="_blank" rel="noopener">面试题18. 删除链表的节点</a></li><li><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">面试题22. 链表中倒数第k个节点</a></li><li><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">面试题24. 反转链表</a></li><li><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/" target="_blank" rel="noopener">面试题25. 合并两个排序的链表</a></li><li><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">面试题35. 复杂链表的复制</a></li><li><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" target="_blank" rel="noopener">面试题52. 两个链表的第一个公共节点</a></li></ul></li><li>简单（9）<ul><li><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">83. 删除排序链表中的重复元素</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表</a></li><li><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160. 相交链表</a></li><li><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">203. 移除链表元素</a></li><li><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></li><li><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. 回文链表</a></li><li><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">237. 删除链表中的节点</a></li><li><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">876. 链表的中间结点</a></li></ul></li><li>中等（14）<ul><li><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">2. 两数相加</a></li><li><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. 删除链表的倒数第N个节点</a></li><li><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. 两两交换链表中的节点</a></li><li><a href="https://leetcode-cn.com/problems/rotate-list/" target="_blank" rel="noopener">61. 旋转链表</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">82. 删除排序链表中的重复元素 II</a></li><li><a href="https://leetcode-cn.com/problems/partition-list/" target="_blank" rel="noopener">86. 分隔链表</a></li><li><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. 反转链表 II</a></li><li><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">138. 复制带随机指针的链表</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II</a></li><li><a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">143. 重排链表</a></li><li><a href="https://leetcode-cn.com/problems/odd-even-linked-list/" target="_blank" rel="noopener">328. 奇偶链表</a></li><li><a href="https://leetcode-cn.com/problems/plus-one-linked-list/" target="_blank" rel="noopener">369. 给单链表加一</a></li><li><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener">445. 两数相加 II</a></li><li><a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/" target="_blank" rel="noopener">725. 分隔链表</a></li></ul></li><li>困难（1）<ul><li><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25. K 个一组翻转链表</a></li></ul></li></ul><h4 id="③相关博客-14"><a href="#③相关博客-14" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="19-堆"><a href="#19-堆" class="headerlink" title="19.堆"></a>19.堆</h3><h4 id="①知识点整理-15"><a href="#①知识点整理-15" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><h4 id="②LeetCode-必刷题目（11）-1"><a href="#②LeetCode-必刷题目（11）-1" class="headerlink" title="②LeetCode 必刷题目（11）"></a>②LeetCode 必刷题目（11）</h4><ul><li>剑指 Offer（1）<ul><li><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">面试题40. 最小的k个数</a></li></ul></li><li>简单（1）<ul><li><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/" target="_blank" rel="noopener">703. 数据流中的第K大元素</a></li></ul></li><li>中等（7）<ul><li><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">215. 数组中的第K个最大元素</a></li><li><a href="https://leetcode-cn.com/problems/ugly-number-ii/" target="_blank" rel="noopener">264. 丑数 II</a></li><li><a href="https://leetcode-cn.com/problems/super-ugly-number/" target="_blank" rel="noopener">313. 超级丑数</a></li><li><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">347. 前 K 个高频元素</a></li><li><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/" target="_blank" rel="noopener">378. 有序矩阵中第K小的元素</a></li><li><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/" target="_blank" rel="noopener">451. 根据字符出现频率排序</a></li><li><a href="https://leetcode-cn.com/problems/k-closest-points-to-origin/" target="_blank" rel="noopener">973. 最接近原点的 K 个点</a></li></ul></li><li>困难（2）<ul><li><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并K个排序链表</a></li><li><a href="https://leetcode-cn.com/problems/trapping-rain-water-ii/" target="_blank" rel="noopener">407. 接雨水 II</a></li></ul></li></ul><h4 id="③相关博客-15"><a href="#③相关博客-15" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="20-分治算法"><a href="#20-分治算法" class="headerlink" title="20.分治算法"></a>20.分治算法</h3><h4 id="①知识点整理-16"><a href="#①知识点整理-16" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><h4 id="②LeetCode-必刷题目（11）-2"><a href="#②LeetCode-必刷题目（11）-2" class="headerlink" title="②LeetCode 必刷题目（11）"></a>②LeetCode 必刷题目（11）</h4><ul><li>剑指 Offer（3）<ul><li><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">面试题36. 二叉搜索树与双向链表</a></li><li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题39. 数组中出现次数超过一半的数字</a></li><li><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">面试题42. 连续子数组的最大和</a></li></ul></li><li>简单（2）<ul><li><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></li><li><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">169. 多数元素</a></li></ul></li><li>中等（2）<ul><li><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">240. 搜索二维矩阵 II</a></li><li><a href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/" target="_blank" rel="noopener">241. 为运算表达式设计优先级</a></li></ul></li><li>困难（4）<ul><li><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个正序数组的中位数</a></li><li><a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">312. 戳气球</a></li><li><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">315. 计算右侧小于当前元素的个数</a></li><li><a href="https://leetcode-cn.com/problems/count-of-range-sum/" target="_blank" rel="noopener">327. 区间和的个数</a></li></ul></li></ul><h4 id="③相关博客-16"><a href="#③相关博客-16" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="21-递归"><a href="#21-递归" class="headerlink" title="21.递归"></a>21.递归</h3><h4 id="①知识点整理-17"><a href="#①知识点整理-17" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li><a href="https://juejin.im/post/5c14c08ce51d4570e5715581" target="_blank" rel="noopener">常见递归算法的时间复杂度分析</a></li></ul><h4 id="②LeetCode-必刷题目（7）"><a href="#②LeetCode-必刷题目（7）" class="headerlink" title="②LeetCode 必刷题目（7）"></a>②LeetCode 必刷题目（7）</h4><ul><li>剑指 Offer（2）<ul><li><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">面试题10- I. 斐波那契数列</a></li><li><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/comments/" target="_blank" rel="noopener">面试题64. 求1+2+…+n</a></li></ul></li><li>简单（1）<ul><li><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/" target="_blank" rel="noopener">1137. 第 N 个泰波那契数</a></li></ul></li><li>中等（3）<ul><li><a href="https://leetcode-cn.com/problems/strobogrammatic-number-ii/" target="_blank" rel="noopener">247. 中心对称数 II</a></li><li><a href="https://leetcode-cn.com/problems/output-contest-matches/" target="_blank" rel="noopener">544. 输出比赛匹配对</a></li><li><a href="https://leetcode-cn.com/problems/minimum-factorization/" target="_blank" rel="noopener">625. 最小因式分解</a></li></ul></li><li>困难（1）<ul><li><a href="https://leetcode-cn.com/problems/strobogrammatic-number-iii/" target="_blank" rel="noopener">248. 中心对称数 III</a></li></ul></li></ul><h4 id="③相关博客-17"><a href="#③相关博客-17" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="22-字典树"><a href="#22-字典树" class="headerlink" title="22.字典树"></a>22.字典树</h3><h4 id="①知识点整理-18"><a href="#①知识点整理-18" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><h4 id="②LeetCode-必刷题目（8）"><a href="#②LeetCode-必刷题目（8）" class="headerlink" title="②LeetCode 必刷题目（8）"></a>②LeetCode 必刷题目（8）</h4><ul><li>简单（1）<ul><li><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/" target="_blank" rel="noopener">720. 词典中最长的单词</a></li></ul></li><li>中等（5）<ul><li><a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/" target="_blank" rel="noopener">421. 数组中两个数的最大异或值</a></li><li><a href="https://leetcode-cn.com/problems/replace-words/" target="_blank" rel="noopener">648. 单词替换</a></li><li><a href="https://leetcode-cn.com/problems/implement-magic-dictionary/" target="_blank" rel="noopener">676. 实现一个魔法字典</a></li><li><a href="https://leetcode-cn.com/problems/map-sum-pairs/" target="_blank" rel="noopener">677. 键值映射</a></li><li><a href="https://leetcode-cn.com/problems/top-k-frequent-words/" target="_blank" rel="noopener">692. 前K个高频单词</a></li></ul></li><li>困难（2）<ul><li><a href="https://leetcode-cn.com/problems/word-search-ii/" target="_blank" rel="noopener">212. 单词搜索 II</a></li><li><a href="https://leetcode-cn.com/problems/palindrome-pairs/" target="_blank" rel="noopener">336. 回文对</a></li></ul></li></ul><h4 id="③相关博客-18"><a href="#③相关博客-18" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="23-线段树"><a href="#23-线段树" class="headerlink" title="23.线段树"></a>23.线段树</h3><h4 id="①知识点整理-19"><a href="#①知识点整理-19" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><h4 id="②LeetCode-必刷题目（6）"><a href="#②LeetCode-必刷题目（6）" class="headerlink" title="②LeetCode 必刷题目（6）"></a>②LeetCode 必刷题目（6）</h4><ul><li>中等（1）<ul><li><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/" target="_blank" rel="noopener">307. 区域和检索 - 数组可修改</a></li></ul></li><li>困难（5）<ul><li><a href="https://leetcode-cn.com/problems/the-skyline-problem/" target="_blank" rel="noopener">218. 天际线问题</a></li><li><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">315. 计算右侧小于当前元素的个数</a></li><li><a href="https://leetcode-cn.com/problems/count-of-range-sum/" target="_blank" rel="noopener">327. 区间和的个数</a></li><li><a href="https://leetcode-cn.com/problems/reverse-pairs/" target="_blank" rel="noopener">493. 翻转对</a></li><li><a href="https://leetcode-cn.com/problems/my-calendar-iii/" target="_blank" rel="noopener">732. 我的日程安排表 III</a></li></ul></li></ul><h4 id="③相关博客-19"><a href="#③相关博客-19" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="24-队列"><a href="#24-队列" class="headerlink" title="24.队列"></a>24.队列</h3><h4 id="①知识点整理-20"><a href="#①知识点整理-20" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><h4 id="②LeetCode-必刷题目（6）-1"><a href="#②LeetCode-必刷题目（6）-1" class="headerlink" title="②LeetCode 必刷题目（6）"></a>②LeetCode 必刷题目（6）</h4><ul><li>剑指 Offer（2）<ul><li><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">面试题59 - I. 滑动窗口的最大值</a></li><li><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">面试题59 - II. 队列的最大值</a></li></ul></li><li>简单（2）<ul><li><a href="https://leetcode-cn.com/problems/moving-average-from-data-stream/" target="_blank" rel="noopener">346. 数据流中的移动平均值</a></li><li><a href="https://leetcode-cn.com/problems/number-of-recent-calls/" target="_blank" rel="noopener">933. 最近的请求次数</a> </li></ul></li><li>中等（2）<ul><li><a href="https://leetcode-cn.com/problems/design-circular-queue/" target="_blank" rel="noopener">622. 设计循环队列</a></li><li><a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener">641. 设计循环双端队列</a></li></ul></li></ul><h4 id="③相关博客-20"><a href="#③相关博客-20" class="headerlink" title="③相关博客"></a>③相关博客</h4><hr><h3 id="25-红黑树"><a href="#25-红黑树" class="headerlink" title="25.红黑树"></a>25.红黑树</h3><h4 id="①知识点整理-21"><a href="#①知识点整理-21" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li>左旋和右旋怎么做？</li><li>红黑树的时间复杂度</li><li>红黑树和平衡二叉树的区别</li><li>红黑树的应用</li></ul><h4 id="②相关博客"><a href="#②相关博客" class="headerlink" title="②相关博客"></a>②相关博客</h4><ul><li><a href="https://messi1002.top/2020/03/18/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E8%A7%A3/">红黑树详解</a></li><li><a href="https://blog.csdn.net/WantFlyDaCheng/article/details/100078039?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">腾讯面试题：有了二叉查找树、平衡树为啥还需要红黑树？</a></li><li><a href="https://blog.csdn.net/tang_jin2015/article/details/8535670" target="_blank" rel="noopener">红黑树、AVL树、B树的比较</a></li><li><a href="https://blog.csdn.net/ThinkWon/article/details/102571535" target="_blank" rel="noopener">红黑树详细分析(图文详解)，看了都说好</a></li><li><a href="https://blog.csdn.net/hotdust/article/details/73087962" target="_blank" rel="noopener">红黑树和B树应用场景总结</a></li><li><a href="https://riteme.site/blog/2016-3-12/2-3-tree-and-red-black-tree.html" target="_blank" rel="noopener">2-3树与红黑树</a></li><li><a href="https://mp.weixin.qq.com/s/n_kEvLHGMtMhwyuDdo_0-Q" target="_blank" rel="noopener">红黑树，超强动静图详解，简单易懂 </a></li></ul><hr><h3 id="26-海量数据处理"><a href="#26-海量数据处理" class="headerlink" title="26.海量数据处理"></a>26.海量数据处理</h3><hr><h3 id="27-限流算法"><a href="#27-限流算法" class="headerlink" title="27.限流算法"></a>27.限流算法</h3><h4 id="①计数器算法"><a href="#①计数器算法" class="headerlink" title="①计数器算法"></a>①计数器算法</h4><h4 id="②令牌桶算法"><a href="#②令牌桶算法" class="headerlink" title="②令牌桶算法"></a>②令牌桶算法</h4><h4 id="③漏桶算法"><a href="#③漏桶算法" class="headerlink" title="③漏桶算法"></a>③漏桶算法</h4><hr><h3 id="28-查找算法"><a href="#28-查找算法" class="headerlink" title="28.查找算法"></a>28.查找算法</h3><h4 id="①顺序查找"><a href="#①顺序查找" class="headerlink" title="①顺序查找"></a>①顺序查找</h4><h4 id="②二分查找"><a href="#②二分查找" class="headerlink" title="②二分查找"></a>②二分查找</h4><h4 id="③插值查找"><a href="#③插值查找" class="headerlink" title="③插值查找"></a>③插值查找</h4><h4 id="④斐波那契查找"><a href="#④斐波那契查找" class="headerlink" title="④斐波那契查找"></a>④斐波那契查找</h4><h4 id="⑤树表查找"><a href="#⑤树表查找" class="headerlink" title="⑤树表查找"></a>⑤树表查找</h4><h5 id="a-二叉搜索树"><a href="#a-二叉搜索树" class="headerlink" title="a.二叉搜索树"></a>a.二叉搜索树</h5><h5 id="b-平衡查找树之-2-3-Tree"><a href="#b-平衡查找树之-2-3-Tree" class="headerlink" title="b.平衡查找树之 2-3 Tree"></a>b.平衡查找树之 2-3 Tree</h5><h5 id="c-平衡查找树之红黑树"><a href="#c-平衡查找树之红黑树" class="headerlink" title="c.平衡查找树之红黑树"></a>c.平衡查找树之红黑树</h5><h4 id="⑥分块查找"><a href="#⑥分块查找" class="headerlink" title="⑥分块查找"></a>⑥分块查找</h4><h4 id="⑦哈希查找"><a href="#⑦哈希查找" class="headerlink" title="⑦哈希查找"></a>⑦哈希查找</h4><hr><h3 id="29-多线程"><a href="#29-多线程" class="headerlink" title="29.多线程"></a>29.多线程</h3><h4 id="①知识点整理-22"><a href="#①知识点整理-22" class="headerlink" title="①知识点整理"></a>①知识点整理</h4><ul><li>实现多线程同步的 ATM 存款取款</li><li>生产者—消费者模型</li><li>设计线程安全的阻塞队列（队列空时消费者阻塞、队列满时生产者阻塞）</li><li>死锁代码示例</li><li>设计一个线程池</li></ul><h4 id="②LeetCode-必刷题目（7）-1"><a href="#②LeetCode-必刷题目（7）-1" class="headerlink" title="②LeetCode 必刷题目（7）"></a>②LeetCode 必刷题目（7）</h4><ul><li>简单（1）<ul><li><a href="https://leetcode-cn.com/problems/print-in-order/" target="_blank" rel="noopener">1114. 按序打印</a></li></ul></li><li>中等（6）<ul><li><a href="https://leetcode-cn.com/problems/print-foobar-alternately/" target="_blank" rel="noopener">1115. 交替打印FooBar</a></li><li><a href="https://leetcode-cn.com/problems/print-zero-even-odd/" target="_blank" rel="noopener">1116. 打印零与奇偶数</a></li><li><a href="https://leetcode-cn.com/problems/building-h2o/" target="_blank" rel="noopener">1117. H2O 生成</a></li><li><a href="https://leetcode-cn.com/problems/design-bounded-blocking-queue/" target="_blank" rel="noopener">1118.设计有限阻塞队列</a></li><li><a href="https://leetcode-cn.com/problems/fizz-buzz-multithreaded/" target="_blank" rel="noopener">1195. 交替打印字符串</a></li><li><a href="https://leetcode-cn.com/problems/the-dining-philosophers/" target="_blank" rel="noopener">1226. 哲学家进餐</a></li></ul></li></ul><h4 id="③相关博客-21"><a href="#③相关博客-21" class="headerlink" title="③相关博客"></a>③相关博客</h4><ul><li><a href="https://messi1002.top/2020/02/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/">Java并发编程之基础概念</a></li><li><a href="https://messi1002.top/2020/02/20/Synchronized%E5%85%B3%E9%94%AE%E5%AD%97/">Synchronized关键字</a></li><li><a href="https://messi1002.top/2020/04/10/finnal%E5%85%B3%E9%94%AE%E5%AD%97/">finnal关键字</a></li><li><a href="https://messi1002.top/2020/04/10/volatile%E5%85%B3%E9%94%AE%E5%AD%97/">volatile关键字</a></li><li><a href="https://messi1002.top/2020/04/10/ReentrantLock%E9%94%81/">ReentrantLock锁</a></li><li><a href="https://messi1002.top/2020/04/03/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/">Java并发编程之线程8大核心基础</a></li><li><a href="https://messi1002.top/2020/04/03/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java并发编程之Java内存模型</a></li><li><a href="https://messi1002.top/2020/04/03/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%AD%BB%E9%94%81%E7%9A%84%E5%89%8D%E7%94%9F%E4%BB%8A%E4%B8%96/">Java并发编程之死锁的前生今世</a></li><li><a href="https://messi1002.top/2020/04/03/Java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%AE%80%E4%BB%8B/">Java并发工具类简介</a></li><li><a href="https://messi1002.top/2020/03/01/LeetCode-1114-%E6%8C%89%E5%BA%8F%E6%89%93%E5%8D%B0%EF%BC%88Easy%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/">[LeetCode] 1114. 按序打印（Easy）Java语言题解</a></li><li><a href="https://messi1002.top/2020/03/01/LeetCode-1115-%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0FooBar%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/">[LeetCode] 1115. 交替打印FooBar（Medium）Java语言题解</a></li><li><a href="https://messi1002.top/2020/03/01/LeetCode-1116-%E6%89%93%E5%8D%B0%E9%9B%B6%E4%B8%8E%E5%A5%87%E5%81%B6%E6%95%B0%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/">[LeetCode] 1116. 打印零与奇偶数（Medium）Java语言题解</a></li><li><a href="https://messi1002.top/2020/03/01/LeetCode-1188-%E8%AE%BE%E8%AE%A1%E6%9C%89%E9%99%90%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/">[LeetCode] 1188. 设计有限阻塞队列（Medium）Java语言题</a></li><li><a href="https://messi1002.top/2020/03/01/LeetCode-1195-%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/">[LeetCode] 1195. 交替打印字符串（Medium）Java语言题解</a></li><li><a href="https://messi1002.top/2020/03/01/LeetCode-1226-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/">[LeetCode] 1226. 哲学家进餐（Medium）Java语言题解</a></li></ul><hr><h3 id="30-智力题"><a href="#30-智力题" class="headerlink" title="30.智力题"></a>30.智力题</h3><ul><li><a href="https://leetcode-cn.com/problems/nim-game/" target="_blank" rel="noopener">292. Nim 游戏</a></li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#106;&#121;&#x6d;&#101;&#115;&#115;&#105;&#x40;&#49;&#54;&#51;&#x2e;&#x63;&#x6f;&#109;" target="_blank" rel="noopener">&#x77;&#106;&#121;&#x6d;&#101;&#115;&#115;&#105;&#x40;&#49;&#54;&#51;&#x2e;&#x63;&#x6f;&#109;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-面经相关&quot;&gt;&lt;a href=&quot;#1-面经相关&quot; class=&quot;headerlink&quot; title=&quot;1.面经相关&quot;&gt;&lt;/a&gt;1.面经相关&lt;/h3&gt;&lt;h4 id=&quot;①相关博客&quot;&gt;&lt;a href=&quot;#①相关博客&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="2020秋招" scheme="http://messi1002.top/categories/2020%E7%A7%8B%E6%8B%9B/"/>
    
      <category term="知识点总结" scheme="http://messi1002.top/categories/2020%E7%A7%8B%E6%8B%9B/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="知识点总结" scheme="http://messi1002.top/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>要怎样努力，才能成为很厉害的人？</title>
    <link href="http://messi1002.top/2020/04/15/%E8%A6%81%E6%80%8E%E6%A0%B7%E5%8A%AA%E5%8A%9B%EF%BC%8C%E6%89%8D%E8%83%BD%E6%88%90%E4%B8%BA%E5%BE%88%E5%8E%89%E5%AE%B3%E7%9A%84%E4%BA%BA%EF%BC%9F/"/>
    <id>http://messi1002.top/2020/04/15/要怎样努力，才能成为很厉害的人？/</id>
    <published>2020-04-15T12:35:15.000Z</published>
    <updated>2020-06-08T13:14:24.988Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Q"><a href="#1-Q" class="headerlink" title="1.Q"></a>1.Q</h3><p>转自：<a href="https://www.zhihu.com/question/22921426" target="_blank" rel="noopener">https://www.zhihu.com/question/22921426</a></p><p>「怎样才是很厉害的人？」<br>「自然是 有好看的身材以及容颜 被很多人喜欢 有很多厉害又有趣的朋友 有对的人 嘻嘻哈哈打打闹闹笑笑人生」</p><p>详见：<a href="https://www.zhihu.com/question/22897987/answer/23051749" target="_blank" rel="noopener">你身上发生过什么事情让你觉得上天特别不公平，你是如何面对的？</a></p><p>题主想兑现一个承诺<br>努力了4年 心如死灰</p><p>2014.3.7补充<br>虽然不想说 不过好像有点儿表达不清</p><p>题主是男生 目前在景色优美的某大学念书<br>题主以前很喜欢一个女生 刚好女生也很喜欢题主 所谓真命天女好像就是那样子<br>在一起 甜蜜又青涩 题主觉得自己是被她所成就的</p><p>后来发生不幸的事情 女生去了另外一个世界<br>过了好久 我才回神过来 整个人都不好了<br>后来做了个梦 梦里面题主答应女生 要找到比她更漂亮更有趣的女朋友<br>题主想成为很厉害很厉害的人</p><p>就是这样的故事 告诉了一些亲近之人<br>题主其实很糟糕 不懂如何与人相处 酷到没朋友<br>一生别扭 孩子气 喜欢看热血漫 所以即使大大的颓唐仍然固执的想看到希望<br>一直很努力 一直不认输<br>可是 感觉这样下去 什么也改变不了吧</p><p>诚心请教诸君 因为越长越大 已经快不知道 要怎么办了</p><hr><h3 id="2-A"><a href="#2-A" class="headerlink" title="2.A"></a>2.A</h3><p>朱炫<br>闷骚而近妖 微博：大师兄_朱炫<br>收录于 知乎周刊 •张振衣 等 91165 人赞同<br>谢邀</p><p>首先，少年，答应别人的承诺，就一定要兑现。</p><p>我以前啊，和你一样，很想成为一个很厉害很厉害很厉害的人。</p><p>喜欢看热血的东西，幻想自己是屠龙的勇士，登塔的先锋，我左手有剑，右手有光，没头没脑的燃烧自己，敌人的骑军来了，我说你们何人堪与之战，我的女人在等我。</p><p>后来我现实了一点，我觉得我要成为那种说走就走，说日就日的男人，我梳大背头，流浪在欧洲或者新几内亚的，我拍孩子，拍野兽，拍流浪的雏妓，与罗伯特德尼罗握手，说嘿，我给你写了愤怒的公牛2。</p><p>再后来，我觉得我人生的梦想，是在城市中心买上一间顶层公寓，把一整面墙都改造成钢化玻璃，在灯火通明的夜晚，我就要端着酒站在巨大的窗前，看整个城市在呼吸，然后我的朋友叩门，他带来了一打嫩模，我们就玩一些成年人的游戏</p><p>现在，我发现龙并不存在，我不会骑马，不会用单反，家住2楼，我能做的，就是把眼前的事儿做好，赚到足够的钱，这样我可以给我的姑娘一个地球仪，然后用飞镖扎它，扎到哪儿，就去哪儿玩。</p><p>这样看来，虽然我的想法随着生殖器的发育，始终在变，但那个很厉害很厉害的人，一直离我很远，甚至越来越远。</p><p>我心中曾经执剑的少年，此刻也混迹在市井之间。</p><p>血似乎都凉了。</p><p>我也不是没有惶恐过，是不是我这一生，都不能左手持剑，右手握着罗伯特德尼罗，说这里的嫩模随便你玩但是你他妈别从窗户上掉下去。</p><p>这样一看，我逊得不行，我的朋友都是一些凡人，比我还逊，业余生活就是推塔、中单、跪。</p><p>我心想，我是不是这辈子都要做一个逊逼，直到我的坟墓上写好墓志铭，我甚至都想好了：</p><p>我来，我见，我挂了。</p><p>最后我给了自己一个否定的答复，我不要。</p><p>我喜欢我的朋友们，喜欢我现在的生活，首先我希望你明白，没有厉害与逊逼得区分，只有血的凉与热，有的人觉得生活就这样吧，我算了，现在没什么不好。</p><p>有的人觉得生活这样挺好，但是我还要更好。</p><p>这种只要剧情稍微热血一点就会热泪盈眶的傻逼，已经不多了，一刻也不要停留。</p><p>所以现在，我和你不一样了，我仍然想成为一个很厉害很厉害很厉害的人，像我们这种剧情稍微热血一点就会热泪盈眶的傻逼，要好好珍惜自己。</p><p>很多人坐下来了，跟你说你不行，说你省点儿心吧，说你请静一静。</p><p>汹涌的人群就把你这样的少年淹没了，人群散去的时候，你也不见了，你那些承诺，谁也听不见，这个世界对于你，就再不可能有什么更有趣更漂亮的女朋友。</p><p>你就失约了，小逼崽子。</p><p>这么跟你说。</p><p>虽然随着年龄的增长，我趋于现实，不能像你那样分分钟冲动的燃烧，然而我每时每刻都有想做的事，有想达成的目标。</p><p>不排除以后的某一年，我会握着罗伯特德尼罗的手，他说这是你写得吗，愤怒的公牛2，只要他还没死。</p><p>故事里拳王拉莫塔忍着伤，他举着铁拳，挥汗如雨，要和命运斗争，他说我怎么能失约呢，我是那个要成为很厉害很厉害的拳王拉莫塔！</p><p>小伙儿，成为很厉害很厉害的人，最重要的，就是要热血，永远也不要让你的血凉下去，你凉下去了，就再也不能找到一个更有趣更漂亮的女友，你就失约了，于是那天她踏梦而来，就成了一个彻头彻尾的笑话。</p><p>当有一天你成为你讨厌的那种人，浑浑噩噩，你走在街上，看见那些更有趣更漂亮的女孩，你会不会想起多年以前，你说我答应你，在一个承诺就是永远的年纪。</p><p>读书，交友，美容，都不如你这一腔狗血，滚烫，灼人，你要燃上大半辈子，才对得起你现在说的这些话。</p><p>我听闻最美的故事，是公主死去了，屠龙的少年还在燃烧。</p><p>火苗再小，你都要反复的点燃。</p><p>所谓热血的少年，青涩的爱恋，死亡与梦之约。</p><p>这么好的故事。</p><p>你可别演砸了。</p><p>最后我给你点个人建议：</p><p>1.读书，读到倦，网上有很多方法，但你从来沉不下心看。<br>2.学习，学到疼，网上有很多方法，但你从来沉不下心看。<br>3.开口说话，冷场也要说话，脸皮薄也要说话，挨打也要说话。<br>4.如果你现在不知道做什么，至少你还可以先从做一个牛逼的学生开始。<br>5.更漂亮更有趣的女孩，五年以后再找。<br>6.承诺是鞭子，不是兴奋剂。<br>7.年纪大了，也不要说什么心如死灰。</p><p>改变自己是非常，非常，非常痛苦的，我能看出来你一腔热血的优点，自然知道你孤僻懒散自以为是的缺点，方法很多，不过我不确定你吃不吃得了苦，我和你共勉吧。</p><p>在成为最厉害最厉害最厉害的道路上。</p><p>完</p><hr><h3 id="3-我想说的"><a href="#3-我想说的" class="headerlink" title="3.我想说的"></a>3.我想说的</h3><p>2020/4/17：在复习的时候看到了这篇文章，突然很有感触。从去年九月到现在，我好像一直都在急匆匆地赶路，毫无经验，慢慢的耗尽了自己的一腔热血。无论是过去四年的感情，还是期待了很久的春招，都在赶路的过程中离我远去了。留下的，只有迷茫。学习方法的问题，学习内容的取舍，以及自己想要什么样的伴侣，怎样的未来…… </p><p>我尽力面对，试图解决，最后还是一团糟。</p><p>2020/5/15： 我已经很努力很努力地忽略原生家庭的问题，控制自己的情绪，忘记过去，专注学习，可是还是很失败。</p><p>2020/6/2：每时每刻都有想做的事，有想达成的目标。</p><p>2020/6/8：对于生活的一腔热血还在，我相信只要不断努力，生活总会越来越好的，未来也会越来越顺利的。</p><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#106;&#121;&#x6d;&#x65;&#x73;&#x73;&#x69;&#x40;&#x31;&#x36;&#x33;&#x2e;&#x63;&#111;&#109;" target="_blank" rel="noopener">&#x77;&#106;&#121;&#x6d;&#x65;&#x73;&#x73;&#x69;&#x40;&#x31;&#x36;&#x33;&#x2e;&#x63;&#111;&#109;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Q&quot;&gt;&lt;a href=&quot;#1-Q&quot; class=&quot;headerlink&quot; title=&quot;1.Q&quot;&gt;&lt;/a&gt;1.Q&lt;/h3&gt;&lt;p&gt;转自：&lt;a href=&quot;https://www.zhihu.com/question/22921426&quot; target=&quot;_blan
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://messi1002.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="转载" scheme="http://messi1002.top/categories/%E9%9A%8F%E7%AC%94/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="随笔" scheme="http://messi1002.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>红黑树详解</title>
    <link href="http://messi1002.top/2020/03/18/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E8%A7%A3/"/>
    <id>http://messi1002.top/2020/03/18/红黑树详解/</id>
    <published>2020-03-18T13:47:52.000Z</published>
    <updated>2020-06-12T11:51:08.310Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-相关博客"><a href="#1-相关博客" class="headerlink" title="1.相关博客"></a>1.相关博客</h3><ul><li><a href="https://messi1002.top/2019/02/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%80%A7%E8%B4%A8/">二叉树的定义及性质</a></li><li><a href="https://messi1002.top/2019/02/11/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E9%80%92%E5%BD%92-%E8%BF%AD%E4%BB%A3/">树的遍历（递归加迭代）</a></li><li><a href="https://messi1002.top/2019/02/15/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/">二叉搜索树的常用操作</a></li></ul><hr><h3 id="2-2-3-树"><a href="#2-2-3-树" class="headerlink" title="2.2-3 树"></a>2.2-3 树</h3><h4 id="①定义"><a href="#①定义" class="headerlink" title="①定义"></a>①定义</h4><ul><li>虽然它不是一种二叉树，但是它满足二分搜索树的基本性质。每次操作节点时，都按照二分搜索树的策略查找它的位置。</li></ul><p><img src="./1585224465398.png" alt="Alt text"><br><img src="./1585224858183.png" alt="Alt text"></p><ul><li>它有两种节点，一种节点可以存放一个元素（与普通的二分搜索树的节点一样，有左右两个孩子，左孩子的值小于该节点的值，右孩子的值大于该节点的值），另一种节点可以存放两个元素（有三个孩子，三个孩子分别在第一个元素的左侧、两个元素的中间和第二个元素的右侧。且这个节点左孩子的值小于左侧元素的值，中间孩子的值在两个元素之间，右孩子的值大于右侧元素的值），所以存放两个元素的节点也满足二分搜索树的基本性质。</li><li>2-3 树的每个节点有 2 个或者 3 个孩子，通常将存放一个元素且有两个孩子的节点叫做 2 节点，将存放两个元素且有三个孩子的节点叫做 3 节点。</li></ul><p><img src="./1591155532615.png" alt="Alt text"></p><ul><li>下图为一颗 2-3 树：</li></ul><p><img src="./1585060829837.png" alt="Alt text"></p><h4 id="②性质—绝对平衡性"><a href="#②性质—绝对平衡性" class="headerlink" title="②性质—绝对平衡性"></a>②性质—绝对平衡性</h4><ul><li>2-3 树是一颗绝对平衡的树（与 2-3 树本身插入元素时的构建方法相关）<ul><li>绝对平衡：从根节点到任意一个叶子节点所经过的节点数量一定是相同的（即对于任意一个节点来说，左右子树的高度一定是相同的，可以将 2-3 树类比为满二叉树）</li></ul></li><li>2-3 树如何维持绝对的平衡：添加节点将永远不会添加到一个空的位置，只会和最后找到的叶子节点做融合，若最后找到的叶子节点是 2 节点，则添加进 2 节点，形成一个 3 节点，否则添加进 3 节点，暂时形成一个 4 节点，然后对 4 节点做一个变形处理，形成由三个 2 节点组成的子树。 </li></ul><p><img src="./1591158783683.png" alt="Alt text"><br><img src="./1591158764465.png" alt="Alt text"></p><ul><li>若暂时形成的 4 节点是根节点，则变形处理即可。</li><li>若暂时形成的 4 节点是叶子节点，则在变形处理后，将子树的根节点继续向其父亲节点（即变形处理前 4 节点的父亲节点，简称 A）融合。如果 A 为 2 节点，则融合后 A 变成一个 3 节点，子树中剩下的两个节点变为 A 的左孩子和中孩子（或者中孩子和右孩子）。如果 A 为 3 节点，则暂时形成一个 4 节点，然后对 4 节点做一个变形处理，再形成由三个 2 节点组成的子树，将子树的根节点继续向其父亲节点融合……直到融合到根节点或者 2 节点。</li></ul><p><img src="./1585064434426.png" alt="Alt text"><br><img src="./1585227128943.png" alt="Alt text"></p><h4 id="③模拟添加节点的过程"><a href="#③模拟添加节点的过程" class="headerlink" title="③模拟添加节点的过程"></a>③模拟添加节点的过程</h4><ul><li>下面我们通过向 2-3 树中添加节点，来看看 2-3 树是如何维持绝对平衡的。</li><li>添加第一个节点：作为根节点，形成一个 2 节点。</li></ul><p><img src="./1585061325704.png" alt="Alt text"></p><ul><li>添加第二个节点：和最后找到的叶子节点（42）做融合，形成一个 3 节点。</li></ul><p><img src="./1585062667731.png" alt="Alt text"></p><ul><li>添加第三个节点：和最后找到的叶子节点（37 | 42）做融合，暂时形成一个 4 节点，然后将 4 节点变形成由三个 2 节点组成的平衡的树。</li></ul><p><img src="./1585063161812.png" alt="Alt text"><br><img src="./1585062829673.png" alt="Alt text"></p><ul><li>添加第四个节点：和最后找到的叶子节点（12）做融合，形成一个 3 节点。</li></ul><p><img src="./1585063005182.png" alt="Alt text"></p><ul><li>添加第五个节点：和最后找到的叶子节点（12 | 18）做融合，暂时形成一个 4 节点，然后将 4 节点变形成由三个 2 节点组成的子树，将子树的根节点（12）继续向上融合，融合后形成一个 3 节点。</li></ul><p><img src="./1585063135172.png" alt="Alt text"><br><img src="./1585063188667.png" alt="Alt text"><br><img src="./1585063276086.png" alt="Alt text"></p><ul><li>添加第六个节点：和最后找到的叶子节点（6）做融合，形成一个 3 节点。</li></ul><p><img src="./1585063531640.png" alt="Alt text"></p><ul><li>添加第七个节点：和最后找到的叶子节点（6 | 11）做融合，暂时形成一个 4 节点，然后将 4 节点变形成由三个 2 节点组成的子树，将子树的根节点（6）继续向上融合，融合后又形成一个 4 节点，继续将 4 节点变形成由三个 2 节点组成的子树，此时已经融合到根节点，表示添加成功。</li></ul><p><img src="./1585063585154.png" alt="Alt text"><br><img src="./1585063602258.png" alt="Alt text"><br><img src="./1585063676521.png" alt="Alt text"><br><img src="./1585063783118.png" alt="Alt text"></p><h4 id="④红黑树和-2-3-树的等价性"><a href="#④红黑树和-2-3-树的等价性" class="headerlink" title="④红黑树和 2-3 树的等价性"></a>④红黑树和 2-3 树的等价性</h4><ul><li>红黑树本质上与 2-3 树是等价的<ul><li>2-3 树是包含两种节点（2 节点和 3 节点）的树结构，而红黑树是包含一种节点（每个节点只能存储一个元素）的树结构。虽然红黑树与 2-3 树的数据结构不同，但是它们实现了相同的逻辑。</li></ul></li><li>红黑树是一种自平衡的二分搜索树，在红黑树中，对每一个节点都附着了一个颜色 — 红色或者黑色。<ul><li>黑色节点：普通节点，表示在原来的 2-3 树中的 2 节点。</li><li>红色节点：和其父亲节点（黑色节点）一起表示在原来的 2-3 树中的 3 节点</li><li>左倾红黑树：所有的红色节点都是向左倾斜的。左倾红节点来表示 2-3 树中的 3 节点（2-3 树的 3 节点的左边元素在红黑树中通过红色节点（简称 A）表示，3 节点的右边元素在红黑树中通过黑色节点（简称 B）表示，并且 A 是 B 的左孩子，表示 A 与 B 在原来的 2-3 树中是并列关系，一起存放在一个 3 节点中）。</li><li>右倾红黑树：所有的红色节点都是向右倾斜的。右倾红节点来表示 2-3 树中的 3 节点（2-3 树的 3 节点的左边元素在红黑树中通过黑色节点（简称 A）表示，3 节点的右边元素在红黑树中通过红色节点（简称 B）表示，并且 B 是 A 的右孩子，表示 A 与 B 在原来的 2-3 树中是并列关系，一起存放在一个 3 节点中）。</li></ul></li></ul><p><img src="./1585104517935.png" alt="Alt text"><br><img src="./1585104479733.png" alt="Alt text"></p><blockquote><p><strong>ps：左倾红黑树是红黑树相对标准的一种实现方式，但并不是唯一的实现方式，这篇博客的后续内容都以左倾红黑树为例进行分析。</strong></p></blockquote><ul><li>与 2-3 树等价的红黑树：2-3 树中有三个 3 节点 —&gt; 红黑树中有三个红色节点，每一个 3 节点产生一个红色节点。</li><li>对于任何一颗 2-3 树，我们都可以使用以上规则将之转化成一颗红黑树。</li></ul><p><img src="./1585095199689.png" alt="Alt text"><br><img src="./1585094681384.png" alt="Alt text"></p><hr><h3 id="3-红黑树"><a href="#3-红黑树" class="headerlink" title="3.红黑树"></a>3.红黑树</h3><h4 id="①概念"><a href="#①概念" class="headerlink" title="①概念"></a>①概念</h4><ul><li>红黑树（Red Black Tree）是一种自平衡的二分搜索树，它在每个结点上增加一个存储位来表示结点的颜色，可以是 Red 或 Black。红黑树通过对任意一条从根到叶子的路径上的各个结点着色方式的限制，确保没有一条路径会比其他路径长出两倍，因而是接近平衡的。</li><li>下图为一颗红黑树：</li></ul><p><img src="./1585059312441.png" alt="Alt text"></p><h4 id="②基本性质"><a href="#②基本性质" class="headerlink" title="②基本性质"></a>②基本性质</h4><ul><li>红黑树必须满足如下条件：</li><li>①（定义）每个节点或者是红色的，或者是黑色的。</li><li>②根节点是黑色的<ul><li>在 2-3 树中，根节点或者是 2 节点，或者是 3 节点，而 2 节点和 3 节点在与之等价的红黑树（左倾红黑树）中表示为下图的两种情况。</li><li>由下图可见， 2-3 树中的 2 节点和 3 节点对应到与之等价的红黑树中，根节点都是黑色的。</li></ul></li></ul><p><img src="./1591180272683.png" alt="Alt text"></p><ul><li>③（定义）每一个叶子节点（这里的叶子节点指的是最后的空节点）是黑色的<ul><li>相当于定义空节点本身是黑色的， 一颗空树本身也是一颗红黑树，它的根节点和叶子节点都是空节点（空节点是黑色节点），同时满足 ②、③ 条性质。</li></ul></li><li>④如果一个节点是红色的，那么它的孩子节点都是黑色的。<ul><li>在红黑树中，只有表示原来的 2-3 树中的 3 节点时，才会出现红色节点。此时红色节点的两个孩子节点是原来的 2-3 树中 3 节点的左孩子和中间的孩子，不管两个孩子是 2 节点还是 3 节点，其对应到红黑树中，根结点都是黑色的（具体见 <strong>性质②</strong>）。</li><li>黑色节点的右孩子一定是黑色的节点（对于左倾红黑树来说，这是我们的定义），它的左孩子可能是红色的节点，也可能是黑色的节点。如果是红色的，表示这两个节点是原来的 2-3 树中的一个 3 节点。如果是黑色的，表示这两个节点是原来的 2-3 树中的两个节点。</li></ul></li><li>⑤（核心）从任意一个节点到其每个叶子节点（空节点），经过的黑色节点数量是一样的。<ul><li>2-3 树是一颗绝对平衡的树，从 2-3 树的任意一个节点出发到其每个叶子节点，经过的节点数量是一样的。</li><li>因为 2-3 树的 2 节点或 3 节点转换成红黑树中的节点表示时，都会有一个黑色的节点，所以从红黑树的任意一个节点出发，每经过一个黑色节点，等于一定经过了原来的 2-3 树中的某个节点。</li><li>红黑树是保持 “黑平衡” 的二叉树（黑平衡是指从根节点到任意一个叶子节点，经过的黑色节点数量是一样的）。从严格意义上讲，红黑树不是平衡二叉树，平衡二叉树的定义为左右子树的高度差不能超过 1，红黑树并不符合。</li></ul></li></ul><h4 id="③数据结构"><a href="#③数据结构" class="headerlink" title="③数据结构"></a>③数据结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTree</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> TreeNode left;</span><br><span class="line">        <span class="keyword">public</span> TreeNode right;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> color;</span><br><span class="line">        </span><br><span class="line">        TreeNode(<span class="keyword">int</span> key, <span class="keyword">int</span> value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 默认的节点颜色为红色</span></span><br><span class="line">            <span class="keyword">this</span>.color = RED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为什么默认的节点颜色为红色？<ul><li>在 2-3 树中添加一个节点，永远是和最后找到的叶子节点做融合，融合后或者形成一个 3 节点，或者形成一个临时的 4 节点。在红黑树中，红色节点代表它和它的父亲节点（黑色节点）在原来的 2-3 树中是在一起的，等价于 2-3 树中的一个 3 节点。所以在红黑树中，总是将新添加的节点的颜色设置为红色，等价于在 2-3 树中永远将新节点融合进已有的节点中。</li><li>在红黑树中添加红色节点后，可能会破坏红黑树的基本性质，此时需要再做一些调整工作（具体见下文）。</li></ul></li></ul><h4 id="④保持根节点为黑色"><a href="#④保持根节点为黑色" class="headerlink" title="④保持根节点为黑色"></a>④保持根节点为黑色</h4><blockquote><p><strong>红黑树中添加新元素之保持根节点为黑色</strong></p></blockquote><ul><li>添加根节点：添加第一个红色节点，作为红黑树的根节点。由红黑树的基本性质②（根节点是黑色的）可知，需要将根节点变成黑色。<ul><li>结论：若插入的红色节点是红黑树的根结点，应该将红色节点变为黑色节点。 </li></ul></li></ul><p><img src="./1585136914860.png" alt="Alt text"><br><img src="./1585136939404.png" alt="Alt text"></p><ul><li>添加普通节点：在原来的 2-3 树中添加元素 4 时，元素 4 应该添加到元素 2 和元素 5 组成的 3 节点中，形成一个临时的 4 节点（2 | 4 | 5）。然后将临时的 4 节点变形成由三个 2 节点组成的子树，让子树的根节点（即节点 4） 向上融合（与元素 6 和元素 8 所在的 3 节点进行融合），再形成一个临时的 4 节点（4 | 6 | 8），然后再将它变形成由三个 2 节点组成的子树，此时这颗子树的根节点是整棵 2-3 树的根节点，不再向上融合。由于元素  4 和元素 6 在原来的 2-3 树中是向上融合的，所以在与之等价的红黑树中，它们所在的节点是红色的。由于节点 6 是最后的根节点，所以在与之等价的红黑树中，元素 6 所在的节点是黑色的。<ul><li>结论：对于临时的 4 节点，在 2-3 树的添加过程中每次都要向上融合一个元素，这个元素所在的节点在红黑树的表示中应该是红色的节点。直到它融合到了根节点，再也不能向上走时，变为黑色的节点。</li></ul></li></ul><p><img src="./1585150450933.png" alt="Alt text"></p><ul><li>代码实践：保持根节点为黑色</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能描述: 向红黑树中添加新的节点(key, value)</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>: [key, value]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/3/15 17:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 见⑧添加新元素</span></span><br><span class="line">    node = insert(node, key, value);</span><br><span class="line">    <span class="comment">// 保持根节点为黑色</span></span><br><span class="line">    node.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑤左旋转"><a href="#⑤左旋转" class="headerlink" title="⑤左旋转"></a>⑤左旋转</h4><ul><li><strong>向 2-3 树的 2 节点中添加一个新元素的第一种情况</strong> —&gt; 对应到红黑树中表示：如下图所示。</li></ul><p><img src="./1585150770595.png" alt="Alt text"></p><ul><li>在上图的红黑树中，添加的新元素（红色节点）在黑色节点的左侧：直接添加（对应 2-3 树中的一个 3 节点）<br></li><li><strong>向 2-3 树的 2 节点中添加一个新元素的第二种情况</strong> —&gt; 对应到红黑树中表示：如下图所示。</li></ul><p><img src="./1585150912880.png" alt="Alt text"></p><ul><li>在上图的红黑树中，添加的新元素（红色节点）在黑色节点的右侧：先添加（此时红黑树不满足我们定义的左倾红黑树的性质) 、再调整（进行一次左旋转）。</li></ul><p><img src="./1585150990487.png" alt="Alt text"></p><ul><li>左旋转的过程（注意：旋转前后的红黑树都要满足二分搜索树的性质）<ol><li>让 x 的左子树 T2 变成 node 的右子树</li><li>让 node 变成 x 的左子树</li><li>维护节点的颜色<ul><li>x 的颜色等于 node 的颜色（可能是红色，也可能是黑色）。因为在左旋转之前的树中，node 是根节点，现在 x 变成了根节点，根节点的颜色应该保持一致。</li><li>node 的颜色应该设置为红色。在原来的 2-3 树中，新加入的节点 42 与 37 形成了一个新的 3 节点。通过左旋转之后，并没有改变 3 节点中的两个元素，只是置换了两个元素的位置（在红黑树中）。所以为了表示它们在旋转前后都是原来的 2-3 树中的同一个 3 节点，node 节点要设置为红色。</li></ul></li></ol></li></ul><p><img src="./1585151213731.png" alt="Alt text"><br><img src="./1585151171223.png" alt="Alt text"><br><img src="./1585151276886.png" alt="Alt text"><br><img src="./1585190185726.png" alt="Alt text"><br><img src="./1585151357938.png" alt="Alt text"></p><ul><li>注意：</li></ul><ol><li>左旋转只是一个子过程，在左旋转的过程中并不维持红黑树的性质，我们只需要通过旋转操作让两个元素对应是原来的 2-3 树中的一个 3 节点即可。</li><li>在左旋转之后有可能产生两个连续的红色节点。</li></ol><ul><li>代码实践：左旋转</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能描述: 对传入的node节点进行左旋转</span></span><br><span class="line"><span class="comment"> * 返回旋转之后新的子树的根节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   node                     x</span></span><br><span class="line"><span class="comment"> *  /    \     左旋转(node)  /   \</span></span><br><span class="line"><span class="comment"> * T1     x   ---------&gt;  node  T3</span></span><br><span class="line"><span class="comment"> *       / \              /   \</span></span><br><span class="line"><span class="comment"> *      T2 T3            T1   T2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>: [node]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: tree.redblacktree.RBTree.TreeNode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/3/15 23:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">leftRotate</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录node节点的右孩子x</span></span><br><span class="line">    TreeNode x = node.right;</span><br><span class="line">    <span class="comment">// 左旋转</span></span><br><span class="line">    node.right = x.left;</span><br><span class="line">    x.left = node;</span><br><span class="line">    <span class="comment">// 维持节点的颜色</span></span><br><span class="line">    x.color = node.color;</span><br><span class="line">    node.color = RED;</span><br><span class="line">    <span class="comment">// 返回旋转后子树的新的根节点，在添加元素的操作中会对根节点的颜色做进一步的处理。</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑥颜色翻转"><a href="#⑥颜色翻转" class="headerlink" title="⑥颜色翻转"></a>⑥颜色翻转</h4><ul><li><strong>向 2-3 树的 3 节点中添加一个新元素的第一种情况</strong> —&gt; 对应到红黑树中表示：如下图所示。</li></ul><p><img src="./1585191325921.png" alt="Alt text"><br><img src="./1585191796271.png" alt="Alt text"></p><ul><li>在上图的红黑树中添加一个新元素 66，应该添加到 42 的右孩子。—&gt; 对应到 2-3 树中表示：原来的 2-3 树中有一个 3 节点（37 | 42），添加一个新元素 66，形成一个临时的 4 节点（37 | 42 | 66）。</li><li>然后将临时的 4 节点变形成由 3 个 2 节点组成的子树。 —&gt; 对应到红黑树中表示：三个节点都应该是黑色的节点，我们需要将两个红色节点的颜色翻转成黑色。</li></ul><p><img src="./1585191845084.png" alt="Alt text"></p><ul><li>最后由 3 个 2 节点组成的子树的根节点要继续向上与其父亲节点进行融合。—&gt; 对应到红黑树中表示：需要将根节点的颜色翻转成红色。</li></ul><p><img src="./1585192443861.png" alt="Alt text"></p><ul><li>代码实践：颜色翻转</li></ul><p><img src="./1591323538754.png" alt="Alt text"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 功能描述: 颜色翻转</span></span><br><span class="line"><span class="comment">  * 调用前需要保证以node为根的子树满足翻转条件</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>: [node]</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@date</span>: 2020/3/15 11:16</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    node.color = RED;</span><br><span class="line">    node.left.color = BLACK;</span><br><span class="line">    node.right.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑦右旋转"><a href="#⑦右旋转" class="headerlink" title="⑦右旋转"></a>⑦右旋转</h4><ul><li><strong>向 2-3 树的 3 节点中添加一个新元素的第二种情况</strong> —&gt; 对应到红黑树中表示：如下图所示。</li></ul><p><img src="./1585192749464.png" alt="Alt text"><br><img src="./1585193005457.png" alt="Alt text"></p><ul><li>在上图的红黑树中添加一个新元素 12，应该添加到 37 的左孩子。—&gt; 对应到 2-3 树中表示：原来的 2-3 树中有一个 3 节点（37 | 42），添加一个新元素 12，形成一个临时的 4 节点（12 | 37 | 42）。</li><li>然后将临时的 4 节点变形成由 3 个 2 节点组成的子树 —&gt; 对应到红黑树中表示：需要先对节点 42 进行一次右旋转，右旋转之后，红黑树的结构满足进行颜色翻转的条件，此时再对红黑树进行一次颜色翻转，具体见 <strong>⑥颜色翻转</strong>。</li><li>右旋转的过程（注意：旋转前后的红黑树都要满足二分搜索树的性质）<ol><li>让 x 的右子树 T1 变成 node 的左子树</li><li>让 node 变成 x 的右子树</li><li>维护节点的颜色<ul><li>x 的颜色等于 node 的颜色（可能是红色，也可能是黑色），因为在右旋转之前的树中，node 是根节点，现在 x 变成了根节点，根节点的颜色应该保持一致。</li><li>node 的颜色应该设置为红色。因为在右旋转之后，三个节点对应到原来的 2-3 树中还是临时的 4 节点，所以 node 节点是红色表示它和它的父亲节点在原来的 2-3 树中是融合在一起的。</li></ul></li></ol></li></ul><p><img src="./1585193103904.png" alt="Alt text"><br><img src="./1585193143226.png" alt="Alt text"><br><img src="./1585193182809.png" alt="Alt text"><br><img src="./1585193261795.png" alt="Alt text"><br><img src="./1585193291665.png" alt="Alt text"><br><img src="./1585193369299.png" alt="Alt text"></p><ul><li>代码实践：右旋转</li></ul><p><img src="./1591323448245.png" alt="Alt text"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能描述: 对传入的node节点进行右旋转</span></span><br><span class="line"><span class="comment"> * 返回旋转之后新的子树的根节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *        y                            x</span></span><br><span class="line"><span class="comment"> *       / \                         /   \</span></span><br><span class="line"><span class="comment"> *      x   T4     向右旋转(y)        z     y</span></span><br><span class="line"><span class="comment"> *     / \       - - - - - - - -&gt;   / \   / \</span></span><br><span class="line"><span class="comment"> *    z   T3                      T1  T2 T3 T4</span></span><br><span class="line"><span class="comment"> *   / \</span></span><br><span class="line"><span class="comment"> * T1   T2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>: [node]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: tree.redblacktree.RBTree.TreeNode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/3/15 11:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">rightRotate</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录node节点的左孩子x</span></span><br><span class="line">    TreeNode x = node.left;</span><br><span class="line">    <span class="comment">// 右旋转</span></span><br><span class="line">    node.left = x.right;</span><br><span class="line">    x.right = node;</span><br><span class="line">    <span class="comment">// 维持节点的颜色</span></span><br><span class="line">    x.color = node.color;</span><br><span class="line">    node.color = RED;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li><strong>向 2-3 树的 3 节点中添加一个新元素的第三种情况</strong> —&gt; 对应到红黑树中表示：如下图所示。</li></ul><p><img src="./1585197158785.png" alt="Alt text"><br><img src="./1585197126604.png" alt="Alt text"></p><ul><li>在上图的红黑树中添加一个新元素 40，应该添加到 37 的右孩子。—&gt; 对应到 2-3 树中表示：原来的 2-3 树中有一个 3 节点（37 | 42），添加一个新元素 12，形成一个临时的 4 节点（37 | 40 | 42）。</li><li>然后将临时的 4 节点变形成由 3 个 2 节点组成的子树 —&gt; 对应到红黑树中表示：需要先对节点 37 进行一次左旋转，左旋转之后，红黑树的结构满足进行右旋转的条件，此时再对红黑树进行一次右旋转，具体见 <strong>⑦右旋转</strong>。</li></ul><p><img src="./1585197094171.png" alt="Alt text"><br><img src="./1585197060938.png" alt="Alt text"><br><img src="./1585197212159.png" alt="Alt text"><br><img src="./1585197245720.png" alt="Alt text"><br><img src="./1591323375387.png" alt="Alt text"></p><h4 id="⑧添加新元素"><a href="#⑧添加新元素" class="headerlink" title="⑧添加新元素"></a>⑧添加新元素</h4><ul><li>下图总结了在红黑树中添加新元素的所有情况：</li></ul><p><img src="./1591325370914.png" alt="Alt text"></p><ul><li>添加新元素后维护红黑树性质的方法：使用二分搜索树的策略将新元素添加进红黑树后，按照上图顺序依次判断该子树是否需要左旋转、右旋转和颜色翻转，然后将维护后的新的根节点返回给递归调用的上一层，在上一层继续维护红黑树的性质。</li><li>代码实践：添加新元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能描述: 向以node为根的红黑树中插入新的节点(key, value)</span></span><br><span class="line"><span class="comment"> * 返回插入新节点后红黑树的根</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>: [node, key, value]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: tree.redblacktree.RBTree.TreeNode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/3/15 17:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">insert</span><span class="params">(TreeNode node, <span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 搜索插入位置</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// 默认插入红色节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key == node.key) &#123;</span><br><span class="line">        node.value = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">        node.left = insert(node.left, key, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.right = insert(node.right, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 红黑树性质的维护</span></span><br><span class="line">    <span class="comment">// 是否需要左旋转</span></span><br><span class="line">    <span class="keyword">if</span> (isRed(node.right) &amp;&amp; !isRed(node.left)) &#123;</span><br><span class="line">        node = leftRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否需要右旋转</span></span><br><span class="line">    <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.left.left)) &#123;</span><br><span class="line">        node = rightRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否需要翻转</span></span><br><span class="line">    <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.right)) &#123;</span><br><span class="line">        flipColors(node);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑨删除新元素"><a href="#⑨删除新元素" class="headerlink" title="⑨删除新元素"></a>⑨删除新元素</h4><ul><li><a href="https://blog.csdn.net/ThinkWon/article/details/102571535" target="_blank" rel="noopener">参考链接</a></li></ul><h4 id="⑩代码实现-测试"><a href="#⑩代码实现-测试" class="headerlink" title="⑩代码实现 + 测试"></a>⑩代码实现 + 测试</h4><ul><li>查找方法与二分搜索树（红黑树是一种自平衡的二分搜索树）的查找方法一致</li><li>前序、中序、后序和层序遍历方法与树的遍历方法一致</li><li>红黑树的全部操作如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tree.redblacktree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/3/15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTree</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> TreeNode left;</span><br><span class="line">        <span class="keyword">public</span> TreeNode right;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> color;</span><br><span class="line">        </span><br><span class="line">        TreeNode(<span class="keyword">int</span> key, <span class="keyword">int</span> value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 默认的节点颜色为红色</span></span><br><span class="line">            <span class="keyword">this</span>.color = RED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> TreeNode node;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RBTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 判断节点的颜色</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [node]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: boolean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 12:23</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> BLACK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.color;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 查看以node为根的红黑树中是否包含键值为key的节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [node, key]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: boolean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 17:58</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contain</span><span class="params">(TreeNode node, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key == node.key) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">            <span class="keyword">return</span> contain(node.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> contain(node.right, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对传入的node节点进行左旋转</span></span><br><span class="line"><span class="comment">     * 返回旋转之后新的子树的根节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   node                     x</span></span><br><span class="line"><span class="comment">     *  /    \     左旋转(node)  /   \</span></span><br><span class="line"><span class="comment">     * T1     x   ---------&gt;  node  T3</span></span><br><span class="line"><span class="comment">     *       / \              /   \</span></span><br><span class="line"><span class="comment">     *      T2 T3            T1   T2</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [node]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: tree.redblacktree.RBTree.TreeNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 23:53</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">leftRotate</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录node节点的右孩子x</span></span><br><span class="line">        TreeNode x = node.right;</span><br><span class="line">        <span class="comment">// 左旋转</span></span><br><span class="line">        node.right = x.left;</span><br><span class="line">        x.left = node;</span><br><span class="line">        <span class="comment">// 维持节点的颜色</span></span><br><span class="line">        x.color = node.color;</span><br><span class="line">        node.color = RED;</span><br><span class="line">        <span class="comment">// 返回旋转后子树的新的根节点，在添加元素的操作中会对根节点的颜色做进一步的处理。</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对传入的node节点进行右旋转</span></span><br><span class="line"><span class="comment">     * 返回旋转之后新的子树的根节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *        y                            x</span></span><br><span class="line"><span class="comment">     *       / \                         /   \</span></span><br><span class="line"><span class="comment">     *      x   T4     向右旋转(y)        z     y</span></span><br><span class="line"><span class="comment">     *     / \       - - - - - - - -&gt;   / \   / \</span></span><br><span class="line"><span class="comment">     *    z   T3                      T1  T2 T3 T4</span></span><br><span class="line"><span class="comment">     *   / \</span></span><br><span class="line"><span class="comment">     * T1   T2</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [node]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: tree.redblacktree.RBTree.TreeNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 11:29</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">rightRotate</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录node节点的左孩子x</span></span><br><span class="line">        TreeNode x = node.left;</span><br><span class="line">        <span class="comment">// 右旋转</span></span><br><span class="line">        node.left = x.right;</span><br><span class="line">        x.right = node;</span><br><span class="line">        <span class="comment">// 维持节点的颜色</span></span><br><span class="line">        x.color = node.color;</span><br><span class="line">        node.color = RED;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 颜色翻转</span></span><br><span class="line"><span class="comment">     * 调用前需要保证以node为根的子树满足翻转条件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [node]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 11:16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        node.color = RED;</span><br><span class="line">        node.left.color = BLACK;</span><br><span class="line">        node.right.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 向以node为根的红黑树中插入新的节点(key, value)</span></span><br><span class="line"><span class="comment">     * 返回插入新节点后红黑树的根</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [node, key, value]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: tree.redblacktree.RBTree.TreeNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 17:50</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">insert</span><span class="params">(TreeNode node, <span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 搜索插入位置</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// 默认插入红色节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key == node.key) &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">            node.left = insert(node.left, key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.right = insert(node.right, key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 红黑树性质的维护</span></span><br><span class="line">        <span class="comment">// 是否需要左旋转</span></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.right) &amp;&amp; !isRed(node.left)) &#123;</span><br><span class="line">            node = leftRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否需要右旋转</span></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.left.left)) &#123;</span><br><span class="line">            node = rightRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否需要翻转</span></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.right)) &#123;</span><br><span class="line">            flipColors(node);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对以node为根的红黑树进行层序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [node]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 18:12</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(node);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode treeNode = queue.poll();</span><br><span class="line">            System.out.print(treeNode.key + <span class="string">"("</span> + treeNode.color + <span class="string">") "</span>);</span><br><span class="line">            <span class="keyword">if</span> (treeNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(treeNode.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (treeNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(treeNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对以node为根的红黑树进行前序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [node]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 1:29</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(node.key + <span class="string">" "</span>);</span><br><span class="line">        preOrder(node.left);</span><br><span class="line">        preOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对以node为根的红黑树进行中序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [node]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 17:58</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(node.left);</span><br><span class="line">        System.out.print(node.key + <span class="string">" "</span>);</span><br><span class="line">        inOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对以node为根的红黑树进行后序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [node]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 1:30</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postOrder(node.left);</span><br><span class="line">        postOrder(node.right);</span><br><span class="line">        System.out.print(node.key + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 判断是否包含key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [key]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: boolean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 17:55</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contain</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contain(node, key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 向红黑树中添加新的节点(key, value)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [key, value]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 17:55</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        node = insert(node, key, value);</span><br><span class="line">        <span class="comment">// 保持根节点为黑色</span></span><br><span class="line">        node.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 红黑树的层序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 17:45</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        levelOrder(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 红黑树的前序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 18:05</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        preOrder(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 红黑树的中序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 18:05</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inOrder(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 红黑树的后序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/3/15 18:05</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        postOrder(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试红黑树的代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tree.redblacktree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/3/15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 测试红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">42</span>, <span class="number">37</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="number">6</span>, <span class="number">11</span>&#125;;</span><br><span class="line">        RBTree rbTree = <span class="keyword">new</span> RBTree();</span><br><span class="line">        System.out.println(<span class="string">"红黑树是否为空: "</span> + rbTree.isEmpty());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            rbTree.insert(arr[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"红黑树的节点个数: "</span> + rbTree.size());</span><br><span class="line">        System.out.println(<span class="string">"红黑树的层序遍历: "</span>);</span><br><span class="line">        rbTree.levelOrder();</span><br><span class="line">        System.out.println(<span class="string">"\n红黑树的前序遍历: "</span>);</span><br><span class="line">        rbTree.preOrder();</span><br><span class="line">        System.out.println(<span class="string">"\n红黑树的中序遍历: "</span>);</span><br><span class="line">        rbTree.inOrder();</span><br><span class="line">        System.out.println(<span class="string">"\n红黑树的后序遍历: "</span>);</span><br><span class="line">        rbTree.postOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1591342373714.png" alt="Alt text"></p><ul><li>通过前序、中序、后序和层序遍历的结果可以推算出红黑树的结构：</li></ul><p><img src="./1585218547226.png" alt="Alt text"></p><ul><li>也可以推算出与其等价的 2-3 树的结构：</li></ul><p><img src="./1585218240250.png" alt="Alt text"></p><hr><h3 id="4-常见面试问题"><a href="#4-常见面试问题" class="headerlink" title="4.常见面试问题"></a>4.常见面试问题</h3><h4 id="①红黑树的数据结构是怎么定义的？"><a href="#①红黑树的数据结构是怎么定义的？" class="headerlink" title="①红黑树的数据结构是怎么定义的？"></a>①红黑树的数据结构是怎么定义的？</h4><ul><li>具体见 <strong>3.红黑树—③数据结构</strong></li></ul><h4 id="②红黑树有哪些性质？"><a href="#②红黑树有哪些性质？" class="headerlink" title="②红黑树有哪些性质？"></a>②红黑树有哪些性质？</h4><ul><li>具体见 <strong>3.红黑树—②基本性质</strong></li></ul><h4 id="③红黑树的各种操作的时间复杂度是多少？"><a href="#③红黑树的各种操作的时间复杂度是多少？" class="headerlink" title="③红黑树的各种操作的时间复杂度是多少？"></a>③红黑树的各种操作的时间复杂度是多少？</h4><ul><li>最大高度： <code>2logn</code>（<code>logn</code> 个红色节点 + <code>logn</code> 个黑色节点，此时该条路径上每一个黑色节点的左孩子都是红色节点。）</li><li>增删改查的时间复杂度：<code>O（logn）</code></li></ul><h4 id="④红黑树相比于-BST-和-AVL-树有什么优点？"><a href="#④红黑树相比于-BST-和-AVL-树有什么优点？" class="headerlink" title="④红黑树相比于 BST 和 AVL 树有什么优点？"></a>④红黑树相比于 BST 和 AVL 树有什么优点？</h4><ul><li>BST：最大高度不定，可能会退化为链表。<ul><li>优点：内部实现简单，没有复杂的维持平衡的操作。对于完全随机的数据，并不会退化为链表。</li><li>缺点：极端情况会退化为链表（数据按顺序进入二分搜索树时）或者高度不平衡（数据近乎有序时）</li></ul></li><li>AVL 树：采用了平衡二叉树的策略，最大高度为 <code>logn</code>，且不会退化为链表，对于查询操作（get、set、contain 等方法）性能较高。</li><li>红黑树：并不完全满足平衡二叉树的定义，最大高度为 <code>2logn</code>，它可以保持自平衡而不会退化为链表，对于插入和删除操作（insert、delete 等方法）性能较高。 </li><li>AVL 树和红黑树的对比：<ul><li>它们都是在二分搜索树的基础上添加了一些其他的性质，来保证自己不会退化为链表。</li><li>红黑树的增删操作快于 AVL 树，查找操作慢于 AVL 树（因为 AVL 树的最大高度是 <code>logn</code>，红黑树的最大高度是 <code>2logn</code>，它们是常数级别的差异），所以 AVL 树适用于查询较多的情况，而红黑树适用于插入和删除较多的情况。</li><li>红黑树的统计性能更优，虽然其时间复杂度与 AVL 树是同一个级别的，但是综合增删改查所有的操作，红黑树在平均情况下更好一些。</li><li>总结：红黑树相对于 AVL 树来说，牺牲了部分平衡性以换取插入 / 删除操作时少量的旋转操作，整体性能要优于 AVL 树。</li></ul></li></ul><h4 id="⑤红黑树的应用？"><a href="#⑤红黑树的应用？" class="headerlink" title="⑤红黑树的应用？"></a>⑤红黑树的应用？</h4><ul><li>由于红黑树的统计性能（综合增删改查所有的操作）更优，所以很多语言内部的容器类中的有序映射都是基于红黑树实现的。例如：Java 中的 TreeMap、TreeSet、JDK 1.8 后的 HashMap 和 C++ 的 STL 中的 map 和 set。</li><li><a href="https://messi1002.top/2020/03/04/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Java集合框架总结+源码分析</a></li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#119;&#106;&#x79;&#x6d;&#x65;&#x73;&#x73;&#105;&#64;&#49;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#109;" target="_blank" rel="noopener">&#119;&#106;&#x79;&#x6d;&#x65;&#x73;&#x73;&#105;&#64;&#49;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#109;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-相关博客&quot;&gt;&lt;a href=&quot;#1-相关博客&quot; class=&quot;headerlink&quot; title=&quot;1.相关博客&quot;&gt;&lt;/a&gt;1.相关博客&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://messi1002.top/2019/02/08/%E4%BA
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://messi1002.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法总结" scheme="http://messi1002.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="树" scheme="http://messi1002.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 1115. 交替打印FooBar（Medium）Java语言题解</title>
    <link href="http://messi1002.top/2020/03/01/LeetCode-1115-%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0FooBar%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/"/>
    <id>http://messi1002.top/2020/03/01/LeetCode-1115-交替打印FooBar（Medium）Java语言题解/</id>
    <published>2020-03-01T05:27:27.000Z</published>
    <updated>2020-06-12T12:54:14.632Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目相关"><a href="#1-题目相关" class="headerlink" title="1.题目相关"></a>1.题目相关</h3><h4 id="①题目及示例"><a href="#①题目及示例" class="headerlink" title="①题目及示例"></a>①题目及示例</h4><p><img src="./1583213174374.png" alt="Alt text"><br><img src="./1583213199829.png" alt="Alt text"></p><h4 id="②相关标签"><a href="#②相关标签" class="headerlink" title="②相关标签"></a>②相关标签</h4><ul><li>多线程</li></ul><h4 id="③题目地址"><a href="#③题目地址" class="headerlink" title="③题目地址"></a>③题目地址</h4><ul><li><a href="https://leetcode-cn.com/problems/print-foobar-alternately/" target="_blank" rel="noopener">1115. 交替打印FooBar — 力扣网</a></li></ul><hr><h3 id="2-解题方法"><a href="#2-解题方法" class="headerlink" title="2.解题方法"></a>2.解题方法</h3><h4 id="①synchronized-关键字-this-锁对象"><a href="#①synchronized-关键字-this-锁对象" class="headerlink" title="①synchronized 关键字 + this 锁对象"></a>①synchronized 关键字 + this 锁对象</h4><ul><li>原因：两个线程属于同一个实例，虽然两个线程访问的是一个类的不同的普通同步方法，但是两个普通同步方法默认都是以 this 对象作为同步方法的锁，所以它们会争抢同一把锁（对于同一个实例来讲，两个方法的 this 对象是同一个）。</li><li>结果：两个线程争抢同一把锁，同一时刻只能有一个线程执行该线程对应的同步方法，然后再使用 wait 方法和 notify 方法，使得两个线程交替运行。</li></ul><h4 id="②lock-condition"><a href="#②lock-condition" class="headerlink" title="②lock + condition"></a>②lock + condition</h4><ul><li>lock 代替 synchronized 关键字</li><li>condition 中的 await 方法和 release 方法代替 Object 对象的 wait 方法和 notify 方法</li></ul><h4 id="③信号量"><a href="#③信号量" class="headerlink" title="③信号量"></a>③信号量</h4><ul><li>两个线程第一次执行时，因为 bar 信号量的计数器初始值为 0，所以需要等 foo 线程中释放了 bar 信号量，bar 线程才能开始执行。而 foo 信号量在获取了一个许可后，其计数器值也变为 0，所以 foo 线程在下一次循环开始时需要等 bar 线程中释放了 foo 信号量，foo 线程才能继续执行。</li></ul><h4 id="④CountDownLatch-CyclicBarrier"><a href="#④CountDownLatch-CyclicBarrier" class="headerlink" title="④CountDownLatch + CyclicBarrier"></a>④CountDownLatch + CyclicBarrier</h4><ul><li>CyclicBarrier 用于保证任务按组循环执行</li><li>CounDownLatch 用于保证一个循环内线程执行的先后顺序</li><li>具体实现见代码</li></ul><hr><h3 id="3-代码详解"><a href="#3-代码详解" class="headerlink" title="3.代码详解"></a>3.代码详解</h3><h4 id="①synchronized-关键字-this-锁对象-1"><a href="#①synchronized-关键字-this-锁对象-1" class="headerlink" title="①synchronized 关键字 + this 锁对象"></a>①synchronized 关键字 + this 锁对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.synchronized关键字+this锁对象(两个不同的线程将会共用一个FooBar实例)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                printFoo.run();</span><br><span class="line">                <span class="comment">// 唤醒另一个线程</span></span><br><span class="line">                <span class="keyword">this</span>.notify();</span><br><span class="line">                <span class="comment">// 自己陷入等待</span></span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                printBar.run();</span><br><span class="line">                <span class="comment">// 唤醒另一个线程</span></span><br><span class="line">                <span class="keyword">this</span>.notify();</span><br><span class="line">                <span class="comment">// 防止线程在最后一次打印Bar时睡眠，从而造成死锁。</span></span><br><span class="line">                <span class="keyword">if</span> (i != n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 自己陷入等待</span></span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②lock-condition-1"><a href="#②lock-condition-1" class="headerlink" title="②lock + condition"></a>②lock + condition</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.lock+condition</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            printFoo.run();</span><br><span class="line">            <span class="comment">// 唤醒另一个线程</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">            <span class="comment">// 自己陷入等待</span></span><br><span class="line">            condition.await();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            printBar.run();</span><br><span class="line">            <span class="comment">// 唤醒另一个线程</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">            <span class="comment">// 防止线程在最后一次打印Bar时睡眠，从而造成死锁。</span></span><br><span class="line">            <span class="keyword">if</span> (i != n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 自己陷入等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③信号量-1"><a href="#③信号量-1" class="headerlink" title="③信号量"></a>③信号量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.信号量(Semaphore)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> Semaphore foo = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> Semaphore bar = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 获取foo信号量的一个许可</span></span><br><span class="line">            foo.acquire();</span><br><span class="line">            printFoo.run();</span><br><span class="line">            <span class="comment">// 释放bar信号量的一个许可</span></span><br><span class="line">            bar.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 获取bar信号量的一个许可</span></span><br><span class="line">            bar.acquire();</span><br><span class="line">            printBar.run();</span><br><span class="line">            <span class="comment">// 释放foo信号量的一个许可</span></span><br><span class="line">            foo.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="④CountDownLatch-CyclicBarrier-1"><a href="#④CountDownLatch-CyclicBarrier-1" class="headerlink" title="④CountDownLatch + CyclicBarrier"></a>④CountDownLatch + CyclicBarrier</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.CountDownLatch+CyclicBarrier</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">// CyclicBarrier用于保证任务按组循环执行</span></span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// CounDownLatch用于保证一个循环内线程执行的先后顺序</span></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                printFoo.run();</span><br><span class="line">                <span class="comment">// 触发bar线程执行</span></span><br><span class="line">                latch.countDown();</span><br><span class="line">                <span class="comment">// 等待bar线程执行完成</span></span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span>(Exception e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 等待被触发</span></span><br><span class="line">                latch.await();</span><br><span class="line">                printBar.run();</span><br><span class="line">                latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 触发foo线程和bar线程继续执行(进行下一次循环)</span></span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#106;&#121;&#x6d;&#101;&#x73;&#x73;&#105;&#64;&#49;&#54;&#51;&#x2e;&#99;&#111;&#x6d;" target="_blank" rel="noopener">&#x77;&#106;&#121;&#x6d;&#101;&#x73;&#x73;&#105;&#64;&#49;&#54;&#51;&#x2e;&#99;&#111;&#x6d;</a></li><li>关于 <strong>数据结构与算法</strong> 的更多代码 请查看我的 <a href="https://github.com/messi1002/leetcode" target="_blank" rel="noopener">GitHub仓库</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目相关&quot;&gt;&lt;a href=&quot;#1-题目相关&quot; class=&quot;headerlink&quot; title=&quot;1.题目相关&quot;&gt;&lt;/a&gt;1.题目相关&lt;/h3&gt;&lt;h4 id=&quot;①题目及示例&quot;&gt;&lt;a href=&quot;#①题目及示例&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="LeetCode-多线程题解" scheme="http://messi1002.top/categories/Java/LeetCode-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="LeetCode题解" scheme="http://messi1002.top/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 1188. 设计有限阻塞队列（Medium）Java语言题解</title>
    <link href="http://messi1002.top/2020/03/01/LeetCode-1188-%E8%AE%BE%E8%AE%A1%E6%9C%89%E9%99%90%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/"/>
    <id>http://messi1002.top/2020/03/01/LeetCode-1188-设计有限阻塞队列（Medium）Java语言题解/</id>
    <published>2020-03-01T05:25:08.000Z</published>
    <updated>2020-06-12T12:54:16.794Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目相关"><a href="#1-题目相关" class="headerlink" title="1.题目相关"></a>1.题目相关</h3><h4 id="①题目及示例"><a href="#①题目及示例" class="headerlink" title="①题目及示例"></a>①题目及示例</h4><p><img src="./1583212951968.png" alt="Alt text"><br><img src="./1583213004641.png" alt="Alt text"></p><h4 id="②相关标签"><a href="#②相关标签" class="headerlink" title="②相关标签"></a>②相关标签</h4><ul><li>多线程</li></ul><h4 id="③题目地址"><a href="#③题目地址" class="headerlink" title="③题目地址"></a>③题目地址</h4><ul><li><a href="https://leetcode-cn.com/problems/design-bounded-blocking-queue/" target="_blank" rel="noopener">1188. 设计有限阻塞队列 — 力扣网</a></li></ul><hr><h3 id="2-解题方法"><a href="#2-解题方法" class="headerlink" title="2.解题方法"></a>2.解题方法</h3><ul><li>使用 LinkedList 集合模拟阻塞队列</li><li>存储当前队列元素个数的变量是 AtomicInteger 类型（来保证原子性）</li></ul><h4 id="①synchronized-关键字-this-锁对象"><a href="#①synchronized-关键字-this-锁对象" class="headerlink" title="①synchronized 关键字 + this 锁对象"></a>①synchronized 关键字 + this 锁对象</h4><ul><li>使用 synchronized 关键字对入队和出队操作加锁</li><li>使用 Object 对象的 wait 方法 和 notify 方法控制两个线程的相互等待和唤醒操作</li></ul><h4 id="②lock-condition"><a href="#②lock-condition" class="headerlink" title="②lock + condition"></a>②lock + condition</h4><ul><li>使用 lock 对入队和出队操作加锁</li><li>使用 condition 控制两个线程的相互等待和唤醒操作</li></ul><hr><h3 id="3-代码详解"><a href="#3-代码详解" class="headerlink" title="3.代码详解"></a>3.代码详解</h3><h4 id="①synchronized-关键字-this-锁对象-1"><a href="#①synchronized-关键字-this-锁对象-1" class="headerlink" title="①synchronized 关键字 + this 锁对象"></a>①synchronized 关键字 + this 锁对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.synchronized关键字+this锁对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBlockingQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用线程安全的集合实现一个阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 存储当前队列元素个数</span></span><br><span class="line">    AtomicInteger size = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 存储队列长度上限</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> element)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果队列满，调用线程被阻塞直到队列非满。</span></span><br><span class="line">            <span class="keyword">while</span> (size.get() &gt;= capacity) &#123;</span><br><span class="line">                <span class="comment">// 线程阻塞时会释放锁</span></span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在队首增加一个element</span></span><br><span class="line">            list.addFirst(element);</span><br><span class="line">            <span class="comment">// 当前队列元素个数加一</span></span><br><span class="line">            size.incrementAndGet();</span><br><span class="line">            <span class="comment">// 通知消费者线程可以继续消费了</span></span><br><span class="line">            <span class="keyword">this</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dequeue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果队列空，调用线程被阻塞直到队列非空。</span></span><br><span class="line">            <span class="keyword">while</span> (size.get() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 线程阻塞时会释放锁</span></span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回队尾元素并从队列中将其删除</span></span><br><span class="line">            <span class="keyword">int</span> value = list.getLast();</span><br><span class="line">            list.removeLast();</span><br><span class="line">            <span class="comment">// 当前队列元素个数减一</span></span><br><span class="line">            size.decrementAndGet();</span><br><span class="line">            <span class="comment">// 通知生产者线程可以继续生产了</span></span><br><span class="line">            <span class="keyword">this</span>.notify();</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②lock-condition-1"><a href="#②lock-condition-1" class="headerlink" title="②lock + condition"></a>②lock + condition</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.lock+condition</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBlockingQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用线程安全的集合实现一个阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 存储当前队列元素个数</span></span><br><span class="line">    AtomicInteger size = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 存储队列长度上限</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition procuder = lock.newCondition();</span><br><span class="line">    Condition consumer = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> element)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">// 如果队列满，调用线程被阻塞直到队列非满。</span></span><br><span class="line">            <span class="keyword">while</span> (size.get() &gt;= capacity) &#123;</span><br><span class="line">                <span class="comment">// 线程阻塞时会释放锁</span></span><br><span class="line">                procuder.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在队首增加一个element</span></span><br><span class="line">            list.addFirst(element);</span><br><span class="line">            <span class="comment">// 当前队列元素个数加一</span></span><br><span class="line">            size.incrementAndGet();</span><br><span class="line">            <span class="comment">// 通知消费者线程可以继续消费了</span></span><br><span class="line">            consumer.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dequeue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">// 如果队列空，调用线程被阻塞直到队列非空。</span></span><br><span class="line">            <span class="keyword">while</span> (size.get() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 线程阻塞时会释放锁</span></span><br><span class="line">                consumer.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回队尾元素并从队列中将其删除</span></span><br><span class="line">            <span class="keyword">int</span> value = list.getLast();</span><br><span class="line">            list.removeLast();</span><br><span class="line">            <span class="comment">// 当前队列元素个数减一</span></span><br><span class="line">            size.decrementAndGet();</span><br><span class="line">            <span class="comment">// 通知生产者线程可以继续生产了</span></span><br><span class="line">            procuder.signal();</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#x6a;&#x79;&#x6d;&#101;&#115;&#115;&#105;&#x40;&#49;&#54;&#51;&#x2e;&#x63;&#111;&#x6d;" target="_blank" rel="noopener">&#x77;&#x6a;&#x79;&#x6d;&#101;&#115;&#115;&#105;&#x40;&#49;&#54;&#51;&#x2e;&#x63;&#111;&#x6d;</a></li><li>关于 <strong>数据结构与算法</strong> 的更多代码 请查看我的 <a href="https://github.com/messi1002/leetcode" target="_blank" rel="noopener">GitHub仓库</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目相关&quot;&gt;&lt;a href=&quot;#1-题目相关&quot; class=&quot;headerlink&quot; title=&quot;1.题目相关&quot;&gt;&lt;/a&gt;1.题目相关&lt;/h3&gt;&lt;h4 id=&quot;①题目及示例&quot;&gt;&lt;a href=&quot;#①题目及示例&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="LeetCode-多线程题解" scheme="http://messi1002.top/categories/Java/LeetCode-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="LeetCode题解" scheme="http://messi1002.top/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 1195. 交替打印字符串（Medium）Java语言题解</title>
    <link href="http://messi1002.top/2020/03/01/LeetCode-1195-%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/"/>
    <id>http://messi1002.top/2020/03/01/LeetCode-1195-交替打印字符串（Medium）Java语言题解/</id>
    <published>2020-03-01T05:17:28.000Z</published>
    <updated>2020-06-12T12:54:19.329Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目相关"><a href="#1-题目相关" class="headerlink" title="1.题目相关"></a>1.题目相关</h3><h4 id="①题目及示例"><a href="#①题目及示例" class="headerlink" title="①题目及示例"></a>①题目及示例</h4><p><img src="./1583212471785.png" alt="Alt text"></p><h4 id="②相关标签"><a href="#②相关标签" class="headerlink" title="②相关标签"></a>②相关标签</h4><ul><li>多线程</li></ul><h4 id="③题目地址"><a href="#③题目地址" class="headerlink" title="③题目地址"></a>③题目地址</h4><ul><li><a href="https://leetcode-cn.com/problems/fizz-buzz-multithreaded/" target="_blank" rel="noopener">1195. 交替打印字符串 — 力扣网</a></li></ul><hr><h3 id="2-解题方法"><a href="#2-解题方法" class="headerlink" title="2.解题方法"></a>2.解题方法</h3><h4 id="①synchronized-关键字-this-锁对象"><a href="#①synchronized-关键字-this-锁对象" class="headerlink" title="①synchronized 关键字 + this 锁对象"></a>①synchronized 关键字 + this 锁对象</h4><ul><li>原因：四个线程属于同一个实例，虽然四个线程访问的是一个类的不同的普通同步方法，但是四个普通同步方法默认都是以 this 对象作为同步方法的锁，所以它们会争抢同一把锁（对于同一个实例来讲，四个方法的 this 对象是同一个）。</li><li>结果：四个线程争抢同一把锁，同一时刻只能有一个线程执行该线程对应的同步方法，然后再使用 wait 方法和 notify 方法，使得四个线程交替运行。</li></ul><h4 id="②lock-condition"><a href="#②lock-condition" class="headerlink" title="②lock + condition"></a>②lock + condition</h4><ul><li>lock 代替 synchronized 关键字</li><li>condition 中的 await 方法和 release 方法代替 Object 对象的 wait 方法和 notify 方法</li></ul><h4 id="③信号量"><a href="#③信号量" class="headerlink" title="③信号量"></a>③信号量</h4><ul><li>四个线程第一次执行时，因为只有 number 信号量的计数器初始值为 1，其余都为 0，所以 number 线程先执行，让它不断判断接下来该哪个线程执行，并释放对应线程的信号量，对应线程执行一次循环后，释放 number 信号量，以便 number 线程继续判断。</li></ul><h4 id="④原子变量"><a href="#④原子变量" class="headerlink" title="④原子变量"></a>④原子变量</h4><ul><li>使用一个原子变量控制，把并发调用变成按顺序调用。</li></ul><h4 id="⑤volatile-关键字"><a href="#⑤volatile-关键字" class="headerlink" title="⑤volatile 关键字"></a>⑤volatile 关键字</h4><ul><li>使用 volatile 关键字保证变量的可见性，把并发调用变成按顺序调用。</li></ul><hr><h3 id="3-代码详解"><a href="#3-代码详解" class="headerlink" title="3.代码详解"></a>3.代码详解</h3><h4 id="①synchronized-关键字-this-锁对象-1"><a href="#①synchronized-关键字-this-锁对象-1" class="headerlink" title="①synchronized 关键字 + this 锁对象"></a>①synchronized 关键字 + this 锁对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.synchronized关键字+this锁对象(四个不同的线程将会共用一个FizzBuzz实例)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FizzBuzz</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizz</span><span class="params">(Runnable printFizz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num &lt;= n) &#123;    </span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// 是3的倍数且不是5的倍数</span></span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; num % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                    printFizz.run();</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 唤醒所有线程</span></span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">                <span class="comment">// 防止线程在最后一次打印时睡眠，从而造成死锁。</span></span><br><span class="line">                <span class="keyword">if</span> (num &lt;= n) &#123;</span><br><span class="line">                    <span class="comment">// 自己陷入等待</span></span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buzz</span><span class="params">(Runnable printBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num &lt;= n) &#123;    </span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// 是5的倍数且不是3的倍数</span></span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">5</span> == <span class="number">0</span> &amp;&amp; num % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                    printBuzz.run();</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 唤醒所有线程</span></span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">                <span class="comment">// 防止线程在最后一次打印时睡眠，从而造成死锁。</span></span><br><span class="line">                <span class="keyword">if</span> (num &lt;= n) &#123;</span><br><span class="line">                    <span class="comment">// 自己陷入等待</span></span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span><span class="params">(Runnable printFizzBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">         <span class="keyword">while</span> (num &lt;= n) &#123;    </span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// 是3的倍数且是5的倍数</span></span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; num % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    printFizzBuzz.run();</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 唤醒所有线程</span></span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">                <span class="comment">// 防止线程在最后一次打印时睡眠，从而造成死锁。</span></span><br><span class="line">                <span class="keyword">if</span> (num &lt;= n) &#123;</span><br><span class="line">                    <span class="comment">// 自己陷入等待</span></span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">number</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num &lt;= n) &#123;    </span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// 不是3的倍数且不是5的倍数</span></span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">3</span> != <span class="number">0</span> &amp;&amp; num % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                    printNumber.accept(num);</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 唤醒所有线程</span></span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">                <span class="comment">// 防止线程在最后一次打印时睡眠，从而造成死锁。</span></span><br><span class="line">                <span class="keyword">if</span> (num &lt;= n) &#123;</span><br><span class="line">                    <span class="comment">// 自己陷入等待</span></span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②lock-condition-1"><a href="#②lock-condition-1" class="headerlink" title="②lock + condition"></a>②lock + condition</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.lock+condition</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FizzBuzz</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizz</span><span class="params">(Runnable printFizz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num &lt;= n) &#123;    </span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">// 是3的倍数且不是5的倍数</span></span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; num % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                printFizz.run();</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 唤醒所有线程</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">            <span class="comment">// 防止线程在最后一次打印时睡眠，从而造成死锁。</span></span><br><span class="line">            <span class="keyword">if</span> (num &lt;= n) &#123;</span><br><span class="line">                <span class="comment">// 自己陷入等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buzz</span><span class="params">(Runnable printBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num &lt;= n) &#123; </span><br><span class="line">            lock.lock();   </span><br><span class="line">            <span class="comment">// 是5的倍数且不是3的倍数</span></span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">5</span> == <span class="number">0</span> &amp;&amp; num % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                printBuzz.run();</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 唤醒所有线程</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">            <span class="comment">// 防止线程在最后一次打印时睡眠，从而造成死锁。</span></span><br><span class="line">            <span class="keyword">if</span> (num &lt;= n) &#123;</span><br><span class="line">                <span class="comment">// 自己陷入等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span><span class="params">(Runnable printFizzBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">         <span class="keyword">while</span> (num &lt;= n) &#123;</span><br><span class="line">            lock.lock();    </span><br><span class="line">            <span class="comment">// 是3的倍数且是5的倍数</span></span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; num % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                printFizzBuzz.run();</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 唤醒所有线程</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">            <span class="comment">// 防止线程在最后一次打印时睡眠，从而造成死锁。</span></span><br><span class="line">            <span class="keyword">if</span> (num &lt;= n) &#123;</span><br><span class="line">                <span class="comment">// 自己陷入等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">number</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num &lt;= n) &#123; </span><br><span class="line">            lock.lock();   </span><br><span class="line">            <span class="comment">// 不是3的倍数且不是5的倍数</span></span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">3</span> != <span class="number">0</span> &amp;&amp; num % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                printNumber.accept(num);</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 唤醒所有线程</span></span><br><span class="line">            condition.signalAll();            </span><br><span class="line">            <span class="comment">// 防止线程在最后一次打印时睡眠，从而造成死锁。</span></span><br><span class="line">            <span class="keyword">if</span> (num &lt;= n) &#123;</span><br><span class="line">                <span class="comment">// 自己陷入等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③信号量-1"><a href="#③信号量-1" class="headerlink" title="③信号量"></a>③信号量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.信号量(Semaphore)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FizzBuzz</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> Semaphore fizz = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> Semaphore buzz = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> Semaphore fizzbuzz = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> Semaphore number = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizz</span><span class="params">(Runnable printFizz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i += <span class="number">3</span>) &#123;     </span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取fizz信号量的一个许可</span></span><br><span class="line">                fizz.acquire();</span><br><span class="line">                printFizz.run();</span><br><span class="line">                <span class="comment">// 释放number信号量的一个许可</span></span><br><span class="line">                number.release();</span><br><span class="line">            &#125;             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buzz</span><span class="params">(Runnable printBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= n; i += <span class="number">5</span>) &#123;      </span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取buzz信号量的一个许可</span></span><br><span class="line">                buzz.acquire();</span><br><span class="line">                printBuzz.run();</span><br><span class="line">                <span class="comment">// 释放number信号量的一个许可</span></span><br><span class="line">                number.release();</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span><span class="params">(Runnable printFizzBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">15</span>; i &lt;= n; i += <span class="number">15</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取fizzbuzz信号量的一个许可</span></span><br><span class="line">            fizzbuzz.acquire();</span><br><span class="line">            printFizzBuzz.run();</span><br><span class="line">            <span class="comment">// 释放number信号量的一个许可</span></span><br><span class="line">            number.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">number</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 获取number信号量的一个许可</span></span><br><span class="line">            number.acquire();</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 释放fizzbuzz信号量的一个许可</span></span><br><span class="line">                fizzbuzz.release();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 释放fizz信号量的一个许可</span></span><br><span class="line">                fizz.release();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 释放buzz信号量的一个许可</span></span><br><span class="line">                buzz.release();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                printNumber.accept(i);</span><br><span class="line">                <span class="comment">// 释放number信号量的一个许可</span></span><br><span class="line">                number.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="④原子变量-1"><a href="#④原子变量-1" class="headerlink" title="④原子变量"></a>④原子变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.原子变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FizzBuzz</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger num = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizz</span><span class="params">(Runnable printFizz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num.get() &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = num.get();</span><br><span class="line">            <span class="comment">// 是3的倍数且不是5的倍数</span></span><br><span class="line">            <span class="keyword">if</span> (temp % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; temp % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                printFizz.run();</span><br><span class="line">                num.getAndIncrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buzz</span><span class="params">(Runnable printBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num.get() &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = num.get();</span><br><span class="line">            <span class="comment">// 不是3的倍数且是5的倍数</span></span><br><span class="line">            <span class="keyword">if</span> (temp % <span class="number">3</span> != <span class="number">0</span> &amp;&amp; temp % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                printBuzz.run();</span><br><span class="line">                num.getAndIncrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span><span class="params">(Runnable printFizzBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num.get() &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = num.get();</span><br><span class="line">            <span class="comment">// 是3的倍数且是5的倍数</span></span><br><span class="line">            <span class="keyword">if</span> (temp % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; temp % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                printFizzBuzz.run();</span><br><span class="line">                num.getAndIncrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">number</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num.get() &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = num.get();</span><br><span class="line">            <span class="comment">// 不是3的倍数且不是5的倍数</span></span><br><span class="line">            <span class="keyword">if</span> (temp % <span class="number">3</span> != <span class="number">0</span> &amp;&amp; temp % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                printNumber.accept(temp);</span><br><span class="line">                num.getAndIncrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑤volatile-关键字-1"><a href="#⑤volatile-关键字-1" class="headerlink" title="⑤volatile 关键字"></a>⑤volatile 关键字</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.volatile关键字</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FizzBuzz</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizz</span><span class="params">(Runnable printFizz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i += <span class="number">3</span>) &#123;   </span><br><span class="line">            <span class="comment">// 是3的倍数且不是5的倍数</span></span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (flag != <span class="number">1</span>) &#123; Thread.sleep(<span class="number">1</span>);&#125;</span><br><span class="line">                printFizz.run();</span><br><span class="line">                <span class="comment">// 将控制权交还给number()方法</span></span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buzz</span><span class="params">(Runnable printBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= n; i += <span class="number">5</span>) &#123; </span><br><span class="line">            <span class="comment">// 不是3的倍数且是5的倍数</span></span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (flag != <span class="number">2</span>) &#123; Thread.sleep(<span class="number">1</span>);&#125;</span><br><span class="line">                printBuzz.run();</span><br><span class="line">                <span class="comment">// 控制权交还给number()方法</span></span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span><span class="params">(Runnable printFizzBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">15</span>; i &lt;= n; i += <span class="number">15</span>) &#123;</span><br><span class="line">            <span class="comment">// 是3的倍数且是5的倍数</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">3</span>) &#123; Thread.sleep(<span class="number">1</span>);&#125;</span><br><span class="line">            printFizzBuzz.run();</span><br><span class="line">            <span class="comment">// 控制权交还给number()方法</span></span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">number</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">0</span>) &#123; Thread.sleep(<span class="number">1</span>);&#125;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不是3的倍数且不是5的倍数</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                printNumber.accept(i);</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#119;&#106;&#121;&#x6d;&#101;&#x73;&#x73;&#x69;&#x40;&#49;&#54;&#51;&#46;&#x63;&#x6f;&#109;" target="_blank" rel="noopener">&#119;&#106;&#121;&#x6d;&#101;&#x73;&#x73;&#x69;&#x40;&#49;&#54;&#51;&#46;&#x63;&#x6f;&#109;</a></li><li>关于 <strong>数据结构与算法</strong> 的更多代码 请查看我的 <a href="https://github.com/messi1002/leetcode" target="_blank" rel="noopener">GitHub仓库</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目相关&quot;&gt;&lt;a href=&quot;#1-题目相关&quot; class=&quot;headerlink&quot; title=&quot;1.题目相关&quot;&gt;&lt;/a&gt;1.题目相关&lt;/h3&gt;&lt;h4 id=&quot;①题目及示例&quot;&gt;&lt;a href=&quot;#①题目及示例&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="LeetCode-多线程题解" scheme="http://messi1002.top/categories/Java/LeetCode-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="LeetCode题解" scheme="http://messi1002.top/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 1116. 打印零与奇偶数（Medium）Java语言题解</title>
    <link href="http://messi1002.top/2020/03/01/LeetCode-1116-%E6%89%93%E5%8D%B0%E9%9B%B6%E4%B8%8E%E5%A5%87%E5%81%B6%E6%95%B0%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/"/>
    <id>http://messi1002.top/2020/03/01/LeetCode-1116-打印零与奇偶数（Medium）Java语言题解/</id>
    <published>2020-03-01T05:13:37.000Z</published>
    <updated>2020-06-12T12:54:15.704Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目相关"><a href="#1-题目相关" class="headerlink" title="1.题目相关"></a>1.题目相关</h3><h4 id="①题目及示例"><a href="#①题目及示例" class="headerlink" title="①题目及示例"></a>①题目及示例</h4><p><img src="./1583212287951.png" alt="Alt text"><br><img src="./1583212316793.png" alt="Alt text"></p><h4 id="②相关标签"><a href="#②相关标签" class="headerlink" title="②相关标签"></a>②相关标签</h4><ul><li>多线程</li></ul><h4 id="③题目地址"><a href="#③题目地址" class="headerlink" title="③题目地址"></a>③题目地址</h4><ul><li><a href="https://leetcode-cn.com/problems/print-zero-even-odd/" target="_blank" rel="noopener">1116. 打印零与奇偶数 — 力扣网</a></li></ul><hr><h3 id="2-解题方法"><a href="#2-解题方法" class="headerlink" title="2.解题方法"></a>2.解题方法</h3><h4 id="①synchronized-关键字-this-锁对象"><a href="#①synchronized-关键字-this-锁对象" class="headerlink" title="①synchronized 关键字 + this 锁对象"></a>①synchronized 关键字 + this 锁对象</h4><ul><li>原因：三个线程属于同一个实例，虽然三个线程访问的是一个类的不同的普通同步方法，但是三个普通同步方法默认都是以 this 对象作为同步方法的锁，所以它们会争抢同一把锁（对于同一个实例来讲，三个方法的 this 对象是同一个）。</li><li>结果：三个线程争抢同一把锁，同一时刻只能有一个线程执行该线程对应的同步方法，然后再使用 wait 方法和 notify 方法，使得三个线程按题意顺序运行。</li></ul><h4 id="②lock-condition"><a href="#②lock-condition" class="headerlink" title="②lock + condition"></a>②lock + condition</h4><ul><li>lock 代替 synchronized 关键字</li><li>condition 中的 await 方法和 release 方法代替 Object 对象的 wait 方法和 notify 方法</li></ul><h4 id="③信号量"><a href="#③信号量" class="headerlink" title="③信号量"></a>③信号量</h4><ul><li>三个线程第一次执行时，因为只有 zero 信号量的计数器初始值为 1，其余都为 0，所以 zero 线程先执行，让它不断判断接下来该哪个线程执行，并释放对应线程的信号量，对应线程执行一次循环后，释放 zero 信号量，以便 zero 线程继续判断。</li></ul><h4 id="④volatile-关键字"><a href="#④volatile-关键字" class="headerlink" title="④volatile 关键字"></a>④volatile 关键字</h4><ul><li>直接使用 volatile 关键字控制三个线程的执行顺序</li><li>具体实现见代码</li></ul><hr><h3 id="3-代码详解"><a href="#3-代码详解" class="headerlink" title="3.代码详解"></a>3.代码详解</h3><h4 id="①synchronized-关键字-this-锁对象-1"><a href="#①synchronized-关键字-this-锁对象-1" class="headerlink" title="①synchronized 关键字 + this 锁对象"></a>①synchronized 关键字 + this 锁对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.synchronized关键字+this锁对象(三个不同的线程将会共用一个ZeroEvenOdd实例)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZeroEvenOdd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 自己陷入等待</span></span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                printNumber.accept(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    flag = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 唤醒所有线程</span></span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (flag != <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="comment">// 自己陷入等待</span></span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                printNumber.accept(i);</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 唤醒所有线程</span></span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (flag != <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 自己陷入等待</span></span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                printNumber.accept(i);</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 唤醒所有线程</span></span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②lock-condition-1"><a href="#②lock-condition-1" class="headerlink" title="②lock + condition"></a>②lock + condition</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.lock+condition</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZeroEvenOdd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 自己陷入等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            printNumber.accept(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 唤醒所有线程</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 自己陷入等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            printNumber.accept(i);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 唤醒所有线程</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 自己陷入等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            printNumber.accept(i);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 唤醒所有线程</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③信号量-1"><a href="#③信号量-1" class="headerlink" title="③信号量"></a>③信号量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.信号量(Semaphore)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> Semaphore zero = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);    </span><br><span class="line">    <span class="keyword">private</span> Semaphore even = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> Semaphore odd = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZeroEvenOdd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 获取zero信号量的一个许可</span></span><br><span class="line">            zero.acquire();</span><br><span class="line">            printNumber.accept(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 释放odd信号量的一个许可</span></span><br><span class="line">                odd.release();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 释放even信号量的一个许可</span></span><br><span class="line">                even.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取even信号量的一个许可</span></span><br><span class="line">            even.acquire();</span><br><span class="line">            printNumber.accept(i);</span><br><span class="line">            <span class="comment">// 释放zero信号量的一个许可</span></span><br><span class="line">            zero.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取odd信号量的一个许可</span></span><br><span class="line">            odd.acquire();</span><br><span class="line">            printNumber.accept(i);</span><br><span class="line">            <span class="comment">// 释放zero信号量的一个许可</span></span><br><span class="line">            zero.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="④volatile-关键字-1"><a href="#④volatile-关键字-1" class="headerlink" title="④volatile 关键字"></a>④volatile 关键字</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.volatile</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZeroEvenOdd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            printNumber.accept(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">2</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            printNumber.accept(i);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">1</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            printNumber.accept(i);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#119;&#106;&#121;&#109;&#x65;&#115;&#x73;&#x69;&#x40;&#x31;&#x36;&#51;&#x2e;&#x63;&#111;&#109;" target="_blank" rel="noopener">&#119;&#106;&#121;&#109;&#x65;&#115;&#x73;&#x69;&#x40;&#x31;&#x36;&#51;&#x2e;&#x63;&#111;&#109;</a></li><li>关于 <strong>数据结构与算法</strong> 的更多代码 请查看我的 <a href="https://github.com/messi1002/leetcode" target="_blank" rel="noopener">GitHub仓库</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目相关&quot;&gt;&lt;a href=&quot;#1-题目相关&quot; class=&quot;headerlink&quot; title=&quot;1.题目相关&quot;&gt;&lt;/a&gt;1.题目相关&lt;/h3&gt;&lt;h4 id=&quot;①题目及示例&quot;&gt;&lt;a href=&quot;#①题目及示例&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="LeetCode-多线程题解" scheme="http://messi1002.top/categories/Java/LeetCode-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="LeetCode题解" scheme="http://messi1002.top/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 1226. 哲学家进餐（Medium）Java语言题解</title>
    <link href="http://messi1002.top/2020/03/01/LeetCode-1226-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%EF%BC%88Medium%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/"/>
    <id>http://messi1002.top/2020/03/01/LeetCode-1226-哲学家进餐（Medium）Java语言题解/</id>
    <published>2020-03-01T05:05:45.000Z</published>
    <updated>2020-06-12T12:54:20.568Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目相关"><a href="#1-题目相关" class="headerlink" title="1.题目相关"></a>1.题目相关</h3><h4 id="①题目及示例"><a href="#①题目及示例" class="headerlink" title="①题目及示例"></a>①题目及示例</h4><p><img src="./1583212242316.png" alt="Alt text"><br><img src="./1583212055232.png" alt="Alt text"></p><h4 id="②相关标签"><a href="#②相关标签" class="headerlink" title="②相关标签"></a>②相关标签</h4><ul><li>多线程</li></ul><h4 id="③题目地址"><a href="#③题目地址" class="headerlink" title="③题目地址"></a>③题目地址</h4><ul><li><a href="https://leetcode-cn.com/problems/the-dining-philosophers/" target="_blank" rel="noopener">1226. 哲学家进餐 — 力扣网</a></li></ul><hr><h3 id="2-解题方法"><a href="#2-解题方法" class="headerlink" title="2.解题方法"></a>2.解题方法</h3><ul><li>哲学家进餐问题有死锁和资源耗尽的风险：每个哲学家同时拿着左边的筷子，永远都在等右边的筷子。</li><li>所以本题的重点在于如何避免死锁，我们采用两种常用的解决方法：<ol><li>改变一个哲学家拿叉子的顺序</li><li>餐票策略</li></ol></li></ul><h4 id="①synchronized-关键字-改变一个哲学家拿叉子的顺序"><a href="#①synchronized-关键字-改变一个哲学家拿叉子的顺序" class="headerlink" title="①synchronized 关键字 + 改变一个哲学家拿叉子的顺序"></a>①synchronized 关键字 + 改变一个哲学家拿叉子的顺序</h4><ul><li>改变一个哲学家拿叉子的顺序：要想发生死锁，必须所有人同时拿起左边的筷子，但是如果这时有一个哲学家先拿右边再拿左边，就不会发生死锁。即避免发生环路，属于避免策略。</li><li>使用 synchronized 关键字对拿起的筷子加锁</li></ul><h4 id="②lock-改变一个哲学家拿叉子的顺序"><a href="#②lock-改变一个哲学家拿叉子的顺序" class="headerlink" title="②lock + 改变一个哲学家拿叉子的顺序"></a>②lock + 改变一个哲学家拿叉子的顺序</h4><ul><li>改变一个哲学家拿叉子的顺序：要想发生死锁，必须所有人同时拿起左边的筷子，但是如果这时有一个哲学家先拿右边再拿左边，就不会发生死锁。即避免发生环路，属于避免策略。</li><li>使用 lock 对拿起的筷子加锁</li></ul><h4 id="③synchronized-关键字-信号量-餐票策略"><a href="#③synchronized-关键字-信号量-餐票策略" class="headerlink" title="③synchronized 关键字 + 信号量 + 餐票策略"></a>③synchronized 关键字 + 信号量 + 餐票策略</h4><ul><li>餐票策略：要求必须拿到餐票才能吃饭，而我们为了避免死锁，总共只发三张餐票，这样可以避免五个人同时准备吃饭的情况，也属于避免策略。</li><li>使用 synchronized 关键字对拿起的筷子加锁</li><li>使用信号量模拟餐票</li></ul><h4 id="④lock-信号量-餐票策略"><a href="#④lock-信号量-餐票策略" class="headerlink" title="④lock + 信号量 + 餐票策略"></a>④lock + 信号量 + 餐票策略</h4><ul><li>餐票策略：要求必须拿到餐票才能吃饭，而我们为了避免死锁，总共只发三张餐票，这样可以避免五个人同时准备吃饭的情况，也属于避免策略。</li><li>使用 lock 对拿起的筷子加锁</li><li>使用信号量模拟餐票</li></ul><hr><h3 id="3-代码详解"><a href="#3-代码详解" class="headerlink" title="3.代码详解"></a>3.代码详解</h3><h4 id="①synchronized-关键字-改变一个哲学家拿叉子的顺序-1"><a href="#①synchronized-关键字-改变一个哲学家拿叉子的顺序-1" class="headerlink" title="①synchronized 关键字 + 改变一个哲学家拿叉子的顺序"></a>①synchronized 关键字 + 改变一个哲学家拿叉子的顺序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.synchronized+改变一个哲学家拿叉子的顺序来避免死锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] locks = <span class="keyword">new</span> Object[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            locks[i] = <span class="keyword">new</span> Object();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickRightFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable eat,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putRightFork)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 改变0号哲学家拿叉子的顺序 </span></span><br><span class="line">        <span class="keyword">int</span> leftForkNumber = philosopher == <span class="number">0</span>? (philosopher + <span class="number">1</span>) % <span class="number">5</span>: philosopher;</span><br><span class="line">        <span class="keyword">int</span> rightForkNumber = philosopher == <span class="number">0</span>? philosopher: (philosopher + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (locks[leftForkNumber]) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (locks[rightForkNumber]) &#123;</span><br><span class="line">                pickLeftFork.run();</span><br><span class="line">                pickRightFork.run();</span><br><span class="line">                eat.run();</span><br><span class="line">                putLeftFork.run();</span><br><span class="line">                putRightFork.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②lock-改变一个哲学家拿叉子的顺序-1"><a href="#②lock-改变一个哲学家拿叉子的顺序-1" class="headerlink" title="②lock + 改变一个哲学家拿叉子的顺序"></a>②lock + 改变一个哲学家拿叉子的顺序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.lock+改变一个哲学家拿叉子的顺序来避免死锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock[] locks = &#123;<span class="keyword">new</span> ReentrantLock(), <span class="keyword">new</span> ReentrantLock(), <span class="keyword">new</span> ReentrantLock(), <span class="keyword">new</span> ReentrantLock(), <span class="keyword">new</span> ReentrantLock()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickRightFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable eat,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putRightFork)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 改变0号哲学家拿叉子的顺序</span></span><br><span class="line">        <span class="keyword">int</span> leftForkNumber = philosopher == <span class="number">0</span>? (philosopher + <span class="number">1</span>) % <span class="number">5</span>: philosopher;</span><br><span class="line">        <span class="keyword">int</span> rightForkNumber = philosopher == <span class="number">0</span>? philosopher: (philosopher + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">        locks[leftForkNumber].lock();</span><br><span class="line">        locks[rightForkNumber].lock();</span><br><span class="line">        pickLeftFork.run();</span><br><span class="line">        pickRightFork.run();</span><br><span class="line">        eat.run();</span><br><span class="line">        putLeftFork.run();</span><br><span class="line">        putRightFork.run();</span><br><span class="line">        locks[rightForkNumber].unlock();</span><br><span class="line">        locks[leftForkNumber].unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③synchronized-关键字-信号量-餐票策略-1"><a href="#③synchronized-关键字-信号量-餐票策略-1" class="headerlink" title="③synchronized 关键字 + 信号量 + 餐票策略"></a>③synchronized 关键字 + 信号量 + 餐票策略</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.synchronized+信号量+餐票策略来避免死锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] locks = <span class="keyword">new</span> Object[<span class="number">5</span>];    </span><br><span class="line">    <span class="keyword">private</span> Semaphore limit = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            locks[i] = <span class="keyword">new</span> Object();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickRightFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable eat,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putRightFork)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftForkNumber = philosopher;</span><br><span class="line">        <span class="keyword">int</span> rightForkNumber = (philosopher + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 规定最多有三个哲学家同时拿起叉子</span></span><br><span class="line">        limit.acquire();</span><br><span class="line">        <span class="keyword">synchronized</span> (locks[leftForkNumber]) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (locks[rightForkNumber]) &#123;</span><br><span class="line">                pickLeftFork.run();</span><br><span class="line">                pickRightFork.run();</span><br><span class="line">                eat.run();</span><br><span class="line">                putLeftFork.run();</span><br><span class="line">                putRightFork.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        limit.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="④lock-信号量-餐票策略-1"><a href="#④lock-信号量-餐票策略-1" class="headerlink" title="④lock + 信号量 + 餐票策略"></a>④lock + 信号量 + 餐票策略</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.lock+信号量+餐票策略来避免死锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock[] locks = &#123;<span class="keyword">new</span> ReentrantLock(), <span class="keyword">new</span> ReentrantLock(), <span class="keyword">new</span> ReentrantLock(), <span class="keyword">new</span> ReentrantLock(), <span class="keyword">new</span> ReentrantLock()&#125;;</span><br><span class="line">    <span class="keyword">private</span> Semaphore limit = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickRightFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable eat,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putRightFork)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftForkNumber = philosopher;</span><br><span class="line">        <span class="keyword">int</span> rightForkNumber = (philosopher + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 规定最多有三个哲学家同时拿起叉子</span></span><br><span class="line">        limit.acquire();</span><br><span class="line">        locks[leftForkNumber].lock();</span><br><span class="line">        locks[rightForkNumber].lock();</span><br><span class="line">        pickLeftFork.run();</span><br><span class="line">        pickRightFork.run();</span><br><span class="line">        eat.run();</span><br><span class="line">        putLeftFork.run();</span><br><span class="line">        putRightFork.run();</span><br><span class="line">        locks[rightForkNumber].unlock();</span><br><span class="line">        locks[leftForkNumber].unlock();</span><br><span class="line">        limit.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#119;&#106;&#x79;&#109;&#101;&#115;&#115;&#x69;&#x40;&#49;&#54;&#x33;&#46;&#x63;&#x6f;&#109;" target="_blank" rel="noopener">&#119;&#106;&#x79;&#109;&#101;&#115;&#115;&#x69;&#x40;&#49;&#54;&#x33;&#46;&#x63;&#x6f;&#109;</a></li><li>关于 <strong>数据结构与算法</strong> 的更多代码 请查看我的 <a href="https://github.com/messi1002/leetcode" target="_blank" rel="noopener">GitHub仓库</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目相关&quot;&gt;&lt;a href=&quot;#1-题目相关&quot; class=&quot;headerlink&quot; title=&quot;1.题目相关&quot;&gt;&lt;/a&gt;1.题目相关&lt;/h3&gt;&lt;h4 id=&quot;①题目及示例&quot;&gt;&lt;a href=&quot;#①题目及示例&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="LeetCode-多线程题解" scheme="http://messi1002.top/categories/Java/LeetCode-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="LeetCode题解" scheme="http://messi1002.top/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 1114. 按序打印（Easy）Java语言题解</title>
    <link href="http://messi1002.top/2020/03/01/LeetCode-1114-%E6%8C%89%E5%BA%8F%E6%89%93%E5%8D%B0%EF%BC%88Easy%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/"/>
    <id>http://messi1002.top/2020/03/01/LeetCode-1114-按序打印（Easy）Java语言题解/</id>
    <published>2020-03-01T05:04:48.000Z</published>
    <updated>2020-06-12T12:54:12.921Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目相关"><a href="#1-题目相关" class="headerlink" title="1.题目相关"></a>1.题目相关</h3><h4 id="①题目及示例"><a href="#①题目及示例" class="headerlink" title="①题目及示例"></a>①题目及示例</h4><p><img src="./1583211789594.png" alt="Alt text"><br><img src="./1583211834605.png" alt="Alt text"></p><h4 id="②相关标签"><a href="#②相关标签" class="headerlink" title="②相关标签"></a>②相关标签</h4><ul><li>多线程</li></ul><h4 id="③题目地址"><a href="#③题目地址" class="headerlink" title="③题目地址"></a>③题目地址</h4><ul><li><a href="https://leetcode-cn.com/problems/print-in-order/" target="_blank" rel="noopener">1114. 按序打印 — 力扣网</a></li></ul><hr><h3 id="2-解题方法"><a href="#2-解题方法" class="headerlink" title="2.解题方法"></a>2.解题方法</h3><h4 id="①原子变量"><a href="#①原子变量" class="headerlink" title="①原子变量"></a>①原子变量</h4><ul><li>使用一个原子变量控制，把并发调用变成按顺序调用。</li></ul><h4 id="②volatile-关键字"><a href="#②volatile-关键字" class="headerlink" title="②volatile 关键字"></a>②volatile 关键字</h4><ul><li>使用 volatile 关键字保证变量的可见性，把并发调用变成按顺序调用。</li></ul><h4 id="③信号量"><a href="#③信号量" class="headerlink" title="③信号量"></a>③信号量</h4><ul><li>三个线程第一次执行时，因为 flag1 信号量和 flag2 信号量的计数器初始值都为 0，所以需要等 first 线程中释放了 flag1 信号量，second 线程才能开始执行，需要等 second 线程中释放了 flag2 信号量，third 线程才能开始执行。</li></ul><h4 id="④CountDownLatch"><a href="#④CountDownLatch" class="headerlink" title="④CountDownLatch"></a>④CountDownLatch</h4><ul><li>两个 CountDownLatch 实例可以控制三个线程执行的先后顺序</li><li>具体实现见代码</li></ul><h4 id="⑤CyclicBarrier"><a href="#⑤CyclicBarrier" class="headerlink" title="⑤CyclicBarrier"></a>⑤CyclicBarrier</h4><ul><li>两个 CyclicBarrier 实例可以控制三个线程执行的先后顺序</li><li>具体实现见代码</li></ul><hr><h3 id="3-代码详解"><a href="#3-代码详解" class="headerlink" title="3.代码详解"></a>3.代码详解</h3><h4 id="①原子变量-1"><a href="#①原子变量-1" class="headerlink" title="①原子变量"></a>①原子变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.使用一个原子变量控制，把并发调用变成按顺序调用。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger n = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        printFirst.run();</span><br><span class="line">        n.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 等待第一个线程执行完毕</span></span><br><span class="line">        <span class="keyword">while</span> (n.get() != <span class="number">1</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        printSecond.run();</span><br><span class="line">        n.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 等待第二个线程执行完毕</span></span><br><span class="line">        <span class="keyword">while</span> (n.get() != <span class="number">2</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        printThird.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②volatile-关键字-1"><a href="#②volatile-关键字-1" class="headerlink" title="②volatile 关键字"></a>②volatile 关键字</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.volatile关键字</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        printFirst.run();</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 等待第一个线程执行完毕</span></span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">1</span>) &#123;&#125;</span><br><span class="line">        printSecond.run();</span><br><span class="line">        flag = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 等待第二个线程执行完毕</span></span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">2</span>) &#123;&#125;</span><br><span class="line">        printThird.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③信号量-1"><a href="#③信号量-1" class="headerlink" title="③信号量"></a>③信号量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.信号量(Semaphore)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Semaphore flag1 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> Semaphore flag2 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        printFirst.run();</span><br><span class="line">        <span class="comment">// 释放flag1信号量的一个许可</span></span><br><span class="line">        flag1.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取flag1信号量的一个许可</span></span><br><span class="line">        flag1.acquire();</span><br><span class="line">        printSecond.run();</span><br><span class="line">        <span class="comment">// 释放flag2信号量的一个许可</span></span><br><span class="line">        flag2.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取flag2信号量的一个许可</span></span><br><span class="line">        flag2.acquire();</span><br><span class="line">        printThird.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="④CountDownLatch-1"><a href="#④CountDownLatch-1" class="headerlink" title="④CountDownLatch"></a>④CountDownLatch</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.CountDownLatch</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch1 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch2 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        printFirst.run();</span><br><span class="line">        <span class="comment">// 触发second线程执行</span></span><br><span class="line">        latch1.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 等待被触发</span></span><br><span class="line">        latch1.await();</span><br><span class="line">        printSecond.run();</span><br><span class="line">        <span class="comment">// 触发third线程执行</span></span><br><span class="line">        latch2.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 等待被触发</span></span><br><span class="line">        latch2.await();</span><br><span class="line">        printThird.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑤CyclicBarrier-1"><a href="#⑤CyclicBarrier-1" class="headerlink" title="⑤CyclicBarrier"></a>⑤CyclicBarrier</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.CyclicBarrier</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier barrier1 = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier barrier2 = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            printFirst.run();</span><br><span class="line">            barrier1.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 等待fisrt线程执行完printFirst.run();</span></span><br><span class="line">            barrier1.await();</span><br><span class="line">            printSecond.run();</span><br><span class="line">            barrier2.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;&#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 等待second线程执行完printSecond.run();</span></span><br><span class="line">            barrier2.await();</span><br><span class="line">            printThird.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;&#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#106;&#x79;&#109;&#x65;&#x73;&#x73;&#105;&#x40;&#x31;&#x36;&#51;&#x2e;&#99;&#x6f;&#109;" target="_blank" rel="noopener">&#x77;&#106;&#x79;&#109;&#x65;&#x73;&#x73;&#105;&#x40;&#x31;&#x36;&#51;&#x2e;&#99;&#x6f;&#109;</a></li><li>关于 <strong>数据结构与算法</strong> 的更多代码 请查看我的 <a href="https://github.com/messi1002/leetcode" target="_blank" rel="noopener">GitHub仓库</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目相关&quot;&gt;&lt;a href=&quot;#1-题目相关&quot; class=&quot;headerlink&quot; title=&quot;1.题目相关&quot;&gt;&lt;/a&gt;1.题目相关&lt;/h3&gt;&lt;h4 id=&quot;①题目及示例&quot;&gt;&lt;a href=&quot;#①题目及示例&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="LeetCode-多线程题解" scheme="http://messi1002.top/categories/Java/LeetCode-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="LeetCode题解" scheme="http://messi1002.top/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之基础概念</title>
    <link href="http://messi1002.top/2020/02/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://messi1002.top/2020/02/25/Java并发编程之基础概念/</id>
    <published>2020-02-25T04:30:32.000Z</published>
    <updated>2020-03-25T13:26:17.609Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1.进程和线程"></a>1.进程和线程</h3><h4 id="①与操作系统的关系"><a href="#①与操作系统的关系" class="headerlink" title="①与操作系统的关系"></a>①与操作系统的关系</h4><ul><li>一个操作系统可以拥有多个进程（process）</li><li>一个进程可以拥有多个线程（thread）</li><li>即操作系统是包含多个进程的容器，而每个进程又都是容纳多个线程的容器。</li></ul><p><img src="./1582653441280.png" alt="Alt text"></p><h4 id="②进程定义"><a href="#②进程定义" class="headerlink" title="②进程定义"></a>②进程定义</h4><ul><li>Oracle 的官方定义：<ul><li>进程：使用 fork 系统调用创建的 UNIX 环境（包括文件描述符、用户 ID 、CPU 使用时间、存储器、IO 设备、内存等），它被设置为运行程序。</li><li>线程：在进程上下文中执行的一系列指令</li></ul></li><li>通俗理解进程：<ul><li>进程指的是程序的一次执行。在用户下达运行程序的命令后，就会产生进程。没有运行的程序占用的空间大部分是磁盘空间，将程序运行起来时就变成了一个进程。</li><li>比喻：进程是对代码的实例化</li><li>在任务管理器中可以查看正在运行的进程：</li></ul></li></ul><p><img src="./1582626838174.png" alt="Alt text"></p><ul><li>总结进程：进程是程序的真正运行实例，是资源分配的基本单位。内存、CPU 等资源都是以进程为单位进行分配的。</li></ul><h4 id="③线程定义"><a href="#③线程定义" class="headerlink" title="③线程定义"></a>③线程定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 创建100个线程，用任务管理器可以看到Java线程数量的变化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Create100Threads</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建100个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 睡眠10s</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序运行前：</li></ul><p><img src="./1582627116360.png" alt="Alt text"></p><ul><li>程序运行过程：</li></ul><p><img src="./1582627170456.png" alt="Alt text"></p><ul><li>程序运行结束：</li></ul><p><img src="./1582627247395.png" alt="Alt text"></p><ul><li>通俗理解线程：<ul><li>线程是 CPU 的基本调度单位，每个线程执行的都是进程代码的某个片段。</li><li>进程是线程的容器，让线程利用进程中的资源执行代码。进程的线程数量若是大于 1，则是多线程的情况，多个线程帮助同一进程执行代码。</li></ul></li></ul><h4 id="④两者的异同"><a href="#④两者的异同" class="headerlink" title="④两者的异同"></a>④两者的异同</h4><ol><li>起源不同<ul><li>回顾操作系统的历史，先有进程后有线程。</li><li>由于处理器的速度往往比外设（键盘、硬盘等）快，所以为了提高 CPU 的利用率，才诞生了线程，目的是提高程序的执行效率。</li></ul></li><li>概念不同<ul><li>进程是具有独立功能的程序运行起来的一个活动，是一个实例，也是系统分配资源和调度的独立单位。</li><li>线程是 CPU 的基本调度单位</li></ul></li><li>内存共享方式不同<ul><li>对于进程而言，每个进程都会被操作系统分配到一定的内存，不同进程之间的内存通常是不共享的。例如：浏览器无法访问正在播放的 qq 音乐，它们之间想要通讯的话，需要使用进程间通讯 RPC。</li><li>线程与线程之间服务于同一个进程，需要合作，所以两个线程之间通讯很容易，可以共享由操作系统分配给其父进程的相同内存块。</li></ul></li><li>拥有的资源不用<ul><li>线程本身是进程的一部分，拥有的资源一定少于进程。</li><li>不同的线程之间共享的内容：①进程代码段（重点）、②进程的公有数据（利用这些共享的数据，线程很容易实现互相通讯）、③进程打开的文件描述符、④信号的处理器、⑤进程的当前目录、⑥进程用户 ID 与进程组 ID</li><li>不同的线程之间独有的内容：①线程 ID、②寄存器组的值、③线程的堆栈（重点）、④错误返回码、⑤线程的信号屏蔽码</li></ul></li><li>进程和线程的数量不同<ul><li>进程只有一个，线程可以有多个。</li><li>一个进程至少拥有一个线程，否则没有办法执行。</li></ul></li><li>开销不同<ul><li>因为进程和线程本身不是一个数量级的东西，所以线程始终比进程更轻量级。</li><li>线程的创建、终止时间比进程短。</li><li>同一进程内的线程切换时间比进程切换时间短</li><li>同一进程的各个线程间共享内存和文件资源，可以不通过内核进行通信。而进程间想要通信，需要借助内核帮忙。</li></ul></li><li>相同点：从生命周期 / 状态上来看，进程和线程从创建到结束都有就绪、等待、运行等状态。</li></ol><h4 id="⑤Java-语言和多线程的关系"><a href="#⑤Java-语言和多线程的关系" class="headerlink" title="⑤Java 语言和多线程的关系"></a>⑤Java 语言和多线程的关系</h4><ul><li>Java 语言的显著优势：在设计之初就支持多线程（当时大部分编程语言不支持多线程）。</li><li>Java 语言可以将我们创建的线程一对一映射到操作系统的内核线程中。而有些语言的线程是虚拟线程，不会在操作系统中对应的建立线程。</li></ul><p><img src="./1582636089900.png" alt="Alt text"></p><ul><li>JVM 自动启动线程：即使在代码中不显式的创建线程，在运行 main 函数时，JVM 也会自动地启动其他线程，这些线程都有特定的含义。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 即使在代码中不显式的创建线程，在运行main函数时，JVM也会自动地启动其他线程。</span></span><br><span class="line"><span class="comment"> * 并且这些线程都有特定的含义和作用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaAndThreads</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello Threads!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582628395824.png" alt="Alt text"></p><ul><li>Signal Dispatcher：把操作系统发来的信号分发给适当的处理程序，用于连接操作系统和应用程序。</li><li>Finalizer：负责对象的 finalize() 方法。在每个对象结束的时候，可能会实现 finalize() 方法，主要是为了处理该方法。但是随着 Java 语言的发展，不再推荐使用该方法。</li><li>Reference Handler：和 GC、引用相关的线程。将每一个对象的引用记录在案，以便配合 GC 进行垃圾回收。</li><li>main：主线程，用户程序的主入口，编写的代码从这里开始执行。</li><li>以上线程都是 JVM 自动创建的，由此可以看出 Java 语言和多线程息息相关。</li></ul><hr><h3 id="2-多线程"><a href="#2-多线程" class="headerlink" title="2.多线程"></a>2.多线程</h3><h4 id="①定义"><a href="#①定义" class="headerlink" title="①定义"></a>①定义</h4><ul><li>多线程：在单个进程中运行多个线程</li><li>多线程程序：如果一个程序允许运行两个或两个以上的线程，那么它就是多线程程序。<ul><li>现在绝大部分的程序都是多线程程序。例如：在浏览器中可以同时打开几个网页、同时下载几个文件，以及服务端可以同时处理多个请求。</li></ul></li><li>每个线程拥有自己的独立资源（ID、堆栈等），进程的内存空间对每个线程敞开，每个线程都可以到进程的内存空间中获取想要的资源并且互相通信。</li><li>相互独立的任务：没必要使用多线程</li><li>数据和资源共享的任务：需要使用多线程，并且要考虑线程的同步，确保线程的安全。</li></ul><h4 id="②多线程实例"><a href="#②多线程实例" class="headerlink" title="②多线程实例"></a>②多线程实例</h4><ul><li>多线程实例：抢火车票</li><li>最开始在火车站买火车票，是全国统一进行放票。假设全国使用同一个服务器（类比为一个进程）进行放票，而多个售票窗口就可以类比为多个线程。不同的线程之间互相配合或竞争。</li></ul><p><img src="./1582653407376.png" alt="Alt text"></p><ul><li>不断迭代后：<ul><li>增加放票时间段（分散压力），不同的车次有自己的放票时间。</li><li>增加候补功能</li><li>增加买票限制</li></ul></li><li>以上都是为了减少服务器的并发压力</li></ul><h4 id="③为什么需要多线程？"><a href="#③为什么需要多线程？" class="headerlink" title="③为什么需要多线程？"></a>③为什么需要多线程？</h4><ol><li>提高 CPU 的利用率（最主要的目的）<ul><li>目前大部分 CPU 都是两核或者两核以上，如果不发挥多线程的优势，始终使用单线程，就会浪费计算资源。多线程程序可以充分发挥多核 CPU 的优势，提高计算机的运行效率。</li><li>①提高了处理速度（CPU 的运行效率远远超过内存、磁盘、外设等） </li><li>②避免了无效等待（在读取磁盘 IO 的时候，CPU 没有必要等待，而应该去做其他的事情。）</li><li>③提高了用户体验：避免卡顿、缩短等待时间（并行处理，提高性能，例如 Tomcat 服务器用多个线程去接收 HTTP 请求，可以同时服务于多个用户。）</li></ul></li><li>便于编程建模（简化任务）<ul><li>将大任务拆解为 A、B、C、D 并建立模型，类似的任务都可以使用模型处理。然后用多线程分别执行这 4 个任务，就简单很多。因为每个子任务的目的明确、功能单一。</li></ul></li><li>计算机性能定律：摩尔定律失效，阿姆达尔定律登上舞台。<ul><li>摩尔定律：当价格不变时，集成电路上可容纳的晶体管数目约每隔 18 个月便会增加一倍，意味着 CPU 的性能可以提高一倍。这个定律告诉我们长期以来 CPU 的性能都是以指数型快速增长的。但是，近年来陷入了瓶颈。</li><li>阿姆达尔定律：处理器（CPU）越多，程序的执行速度就越快。但是执行速度也有上限，取决于程序中串行部分的比例，并行的比例越高，多处理器的效果越明显。对于串行任务，无论有多少 CPU 资源，都没有办法提高速度。</li><li>并行比例与提升速度的关系：</li></ul></li></ol><p><img src="./1582653374893.png" alt="Alt text"></p><ul><li>在未来，CPU 的性能的提升速度放缓了，这就要求我们把程序中更多可并行的部分并行化，以提高程序的性能。</li></ul><h4 id="④什么场景中会用到多线程？"><a href="#④什么场景中会用到多线程？" class="headerlink" title="④什么场景中会用到多线程？"></a>④什么场景中会用到多线程？</h4><ol><li>执行耗时任务（IO、磁盘读写、网络通信等）新开线程，不但不会影响主程序的运行，也不会因为耗时任务执行时间过慢而影响其他任务的运行。</li><li>为了同时做多件不同的事：①使用浏览器的同时听音乐、②后台定时任务等</li><li>提高工作效率、处理能力<ul><li>①Tomcat 可以同时并行处理多个线程进来的请求</li><li>②下载文件时可以选择线程数，多线程并行下载（每个线程都去和服务器通信，都去做独立的下载任务，并且把下载的任务进行分割，最后再把下载到的文件拼接起来），以提高下载效率。</li><li>③NIO：将 IO 操作升级为多线程操作，提高了 IO 的处理能力。</li></ul></li><li>需要同时有很大并发量的时候（比如进行服务器承受压力的能力的测试时，需要多线程并行请求）</li></ol><h4 id="⑤多线程的局限"><a href="#⑤多线程的局限" class="headerlink" title="⑤多线程的局限"></a>⑤多线程的局限</h4><ol><li>性能问题：上下文切换带来的消耗<ul><li>线程之间切换时会有上下文切换，会保存一些 CPU 所需要的数据，如当前运行到哪一行代码等。</li></ul></li><li>异构化任务很难高效并行<ul><li>每个任务之间的结构都不一样，很难总结为多个任务的拆解。</li></ul></li><li>带来线程安全问题：包括数据安全问题（例如 <code>i++</code> 总数不一致）以及线程带来的活跃性问题（线程饥饿、死锁等）<ul><li>线程饥饿：某个线程想要执行任务，但是被其他线程强先，这个线程始终没有事干。</li><li>死锁：两个线程相互拥有对方所需要的资源但都不肯放手，于是陷入无穷等待。</li></ul></li></ol><hr><h3 id="3-串行、并行、并发"><a href="#3-串行、并行、并发" class="headerlink" title="3.串行、并行、并发"></a>3.串行、并行、并发</h3><h4 id="①串行、并行、并发"><a href="#①串行、并行、并发" class="headerlink" title="①串行、并行、并发"></a>①串行、并行、并发</h4><ul><li>串行：大家排队一个个来<ul><li>左图：线程 A -&gt; B -&gt; C 依次执行</li><li>右图：将数据一位一位发送</li></ul></li><li>并行：大家一起来<ul><li>左图：线程 A / B / C 同时执行</li><li>右图：将 8 个数据一次性发送出去</li></ul></li></ul><p><img src="./1582653345934.png" alt="Alt text"></p><ul><li>并发（Concurrency）：单核就能实现并发、属于逻辑上的同时运行（由于处理器的处理速度很快，所以线程之间的切换肉眼是感知不到的，感觉它是在同时执行多个程序，实际某一时间只有一个程序执行（单处理器））。<ul><li>在物理层面并发就是串行，只不过是在多个程序上快速的来回切换而不是一个个依次执行，所以在用户看来相当于三个程序同时执行。</li></ul></li><li>并行（Parallelism）：多核处理器，物理上的同时运行，多个处理器都在同时执行任务。</li></ul><p><img src="./1582653313196.png" alt="Alt text"><br><img src="./1582086357063.png" alt="Alt text"></p><ul><li>并行是真正的 “同时” 运行：在同一时刻，有多个任务同时执行。<ul><li>单核处理器是无法实现并行的，因为单核处理器无法在同一时刻执行多个任务。</li></ul></li><li>并发可以对应到两个不同的概念</li><li>①形容多个任务的执行状态：<ul><li>两个或多个任务可以在重叠的时间段（不是指真正重叠的同一时刻，而是一段时间内交替运行）内启动，运行和完成。</li><li>并行（两个线程同时执行）一定是并发，两者是包含关系。</li><li>并发 + 多核 + 同一时刻执行同一段代码 = 并行</li><li>并发：不同的线程交替给一个 CPU 执行（蓝色竖线：CPU 的时间片）</li><li>并行：多个线程同时被多个 CPU 执行</li></ul></li></ul><p><img src="./1582653247372.png" alt="Alt text"><br><img src="./1582653213782.png" alt="Alt text"></p><ul><li>②对 “并发性” 的简称：<ul><li>如果一个程序具有并发性，指的是程序不同的部分可以无序或同时执行，且不影响最终的执行结果。</li><li>在不同核心数的计算机上的表现不同：</li><li>在多核 CPU 上，可以并行执行并发性程序。</li><li>在单核 CPU 上，可以并发执行并发性程序，串行执行非并发性程序。</li><li>此时，并行和并发的概念并不在同一维度上。并发指的是并发性，并行指的是多个程序在同一时刻同时执行。一个程序如果想要并发 / 并行执行，前提条件是它具有并发性。并发性是并发执行和并行执行的前提条件和必要条件。如果一个程序可以并行执行，就代表它一定具有并发性。</li></ul></li></ul><h4 id="②是什么让并发和并行成为可能？"><a href="#②是什么让并发和并行成为可能？" class="headerlink" title="②是什么让并发和并行成为可能？"></a>②是什么让并发和并行成为可能？</h4><ol><li>CPU 升级<ul><li>CPU 之前一直遵循摩尔定律，性能提升的很快，它的处理速度远远比其他部件快。但是每个 CPU 同一时刻只能执行一个指令，出于这个原因，操作系统开发出了新的技术，可以让用户同时运行多个进程或者多个线程。</li></ul></li><li>操作系统的升级<ul><li>升级之后将 CPU 完美的调度了起来，即便是单核 CPU，也能让不同的进程使用时间片的方式（抢占式的方式）不停地切换。</li><li>抢占式多任务处理：现代 CPU 最主要的一种处理方式，即操作系统有权利中断正在执行的任务。</li><li>诞生多核处理器后，操作系统可以自动检测 CPU 核心的数量，为每个核心分配不同的任务，以实现真正地同一时刻运行多个程序。</li></ul></li><li>编程语言的升级<ul><li>Java 语言诞生之前，很多编程语言不支持多线程。随着 Java 的诞生，多线程编程开始逐渐火热并且发展成熟。</li></ul></li></ol><hr><h3 id="4-高并发"><a href="#4-高并发" class="headerlink" title="4.高并发"></a>4.高并发</h3><h4 id="①定义-1"><a href="#①定义-1" class="headerlink" title="①定义"></a>①定义</h4><ul><li>高并发：同时有很多个请求发送给服务器系统，服务器会并行处理。</li><li>高并发场景：天猫双十一、春晚微信摇一摇、12306 卖火车票</li><li>一般将系统的承受能力设计为目前系统访问量的十倍比较合适</li></ul><h4 id="②高并发和多线程的异同？"><a href="#②高并发和多线程的异同？" class="headerlink" title="②高并发和多线程的异同？"></a>②高并发和多线程的异同？</h4><ul><li>高并发：指大量的请求同时到达服务器所带来的结果（结果指服务器需要同时处理很多请求），它是一种状态。系统需要应对高并发这种状态所带来的后果，如果处理不当，会导致请求的响应速度慢、无响应甚至服务器死机。</li><li>多线程并不意味着高并发，多线程编程是一种编程方式，是一种解决方案，不仅可以解决高并发所带来的线程安全问题 / 性能问题，还可以提高硬件的利用率，以便获取到更多的资源，从而解决高并发带来的服务器死机、响应慢等问题。<ul><li>多线程编程是我们应对高并发场景的一种重要的解决方案。</li></ul></li><li>高并发并不一定要通过多线程的方式解决<ul><li>例如：解决数据库的高并发问题可以利用 Redis 缓存层（可能带来缓存不一致的问题，但不会带来线程安全问题）</li></ul></li><li>总结：高并发并不意味着多线程（例如：Redis 底层是用单线程处理的）。高并发是一种状态，作为服务器开发者，最好用多线程的方式解决，这样可以提高 CPU 等资源的利用率，加快用户的响应速度。但是在场景不同，资源不同的情况下，也可以选择其他的解决方案。</li></ul><h4 id="③高并发有哪些指标？"><a href="#③高并发有哪些指标？" class="headerlink" title="③高并发有哪些指标？"></a>③高并发有哪些指标？</h4><ul><li>QPS（Queries Per Second）：每秒钟的查询（请求）数</li><li>PV（Page View）：24 小时内的页面点击量（综合浏览量）</li><li>UV（Unique Visitor）：24 小时内访问的用户数量（根据 Cookie）、UV &lt;= PV</li><li>并发连接数：某个时刻服务器所接受的请求的数目。<ul><li>对于同一个用户而言，可以同时产生很多个会话 / 连接，所以数目 &gt; 同时在线的用户数量。</li><li>对服务器来说，这个连接有一个上限</li></ul></li><li>服务器平均请求等待时间：服务器处理一个请求所花费的时间</li></ul><hr><h3 id="5-同步与异步、阻塞与非阻塞"><a href="#5-同步与异步、阻塞与非阻塞" class="headerlink" title="5.同步与异步、阻塞与非阻塞"></a>5.同步与异步、阻塞与非阻塞</h3><h4 id="①同步与异步"><a href="#①同步与异步" class="headerlink" title="①同步与异步"></a>①同步与异步</h4><ul><li>同步与异步：被调用方是否主动告诉调用方结果。<ul><li>同步与异步是被调用方（即服务端）的行为，而不是调用方的行为。</li><li>同步：在没有得到结果之前，服务端不返回任何结果。</li><li>异步：调用在发出之后，服务端会立刻返回，告诉调用方 “我收到你的请求了，我会马上处理的”，等服务器处理完成以后，会再次告诉调用方 “我已经处理完了”。</li></ul></li></ul><p><img src="./1582653108706.png" alt="Alt text"><br><img src="./1582653143245.png" alt="Alt text"><br><img src="./1582653156676.png" alt="Alt text"><br><img src="./1582653175803.png" alt="Alt text"></p><h4 id="②阻塞与非阻塞"><a href="#②阻塞与非阻塞" class="headerlink" title="②阻塞与非阻塞"></a>②阻塞与非阻塞</h4><ul><li>站在线程状态的角度：阻塞指当前线程不能继续执行，需要等待一段时间或者被唤醒。</li><li>站在线程发出请求的角度：我是调用方，我调用一个东西后，在返回结果前是否还能做其他事情。</li><li>阻塞与非阻塞是调用方的行为，而不是被调用方的行为。<ul><li>阻塞：调用一个东西后，返回结果前什么也不做。</li><li>非阻塞：调用一个东西后，返回结果前做其他事情。</li></ul></li></ul><h4 id="③同步阻塞、同步非阻塞、异步阻塞、异步非阻塞"><a href="#③同步阻塞、同步非阻塞、异步阻塞、异步非阻塞" class="headerlink" title="③同步阻塞、同步非阻塞、异步阻塞、异步非阻塞"></a>③同步阻塞、同步非阻塞、异步阻塞、异步非阻塞</h4><ul><li>同步不一定是阻塞，阻塞也不一定是同步。</li><li>异步不一定是非阻塞，非阻塞也不一定是异步。</li><li>同步阻塞：（被调用方）执行完成后才返回结果、（调用方）在返回结果前什么也不做。</li><li>同步非阻塞：（被调用方）执行完成后才返回结果、（调用方）在返回结果前做其他事情，不时地检查一下被调用方是否返回结果。</li><li>异步阻塞：调用方在发出请求之后，被调用方会立刻告诉调用方已经收到请求，当被调用方处理完成以后，会再次告诉调用方已经处理完了、但是（调用方）在返回结果前什么也不做。</li><li>异步非阻塞：调用方在发出请求之后，被调用方会立刻告诉调用方已经收到请求，当被调用方处理完成以后，会再次告诉调用方已经处理完了、（调用方）在返回结果前做其他事情，等待被调用方主动返回结果。</li></ul><hr><h3 id="6-常见面试问题"><a href="#6-常见面试问题" class="headerlink" title="6.常见面试问题"></a>6.常见面试问题</h3><h4 id="①进程和线程的异同？"><a href="#①进程和线程的异同？" class="headerlink" title="①进程和线程的异同？"></a>①进程和线程的异同？</h4><ul><li>不同：起源、概念、内存共享方式、拥有的资源、数量、开销</li><li>相同：生命周期（状态）</li><li>具体见 <strong>1.进程和线程——④两者的异同</strong></li></ul><h4 id="②并行和并发的异同？"><a href="#②并行和并发的异同？" class="headerlink" title="②并行和并发的异同？"></a>②并行和并发的异同？</h4><ul><li>都在形容一个程序的运行状态时：并行一定是并发。</li><li>并发也可以形容一个程序的属性，即程序是否具有并发性。若是程序没有并发性，表示程序只能串行执行。</li></ul><h4 id="③多线程就是高并发吗？有什么反例？"><a href="#③多线程就是高并发吗？有什么反例？" class="headerlink" title="③多线程就是高并发吗？有什么反例？"></a>③多线程就是高并发吗？有什么反例？</h4><ul><li>高并发指服务器同时接受很多请求，受到极大压力。</li><li>多线程是针对高并发的一个解决方案，可以使用多线程将这个压力迅速化解。</li><li>反例：Redis 本身是单线程的，但是同样可以支持高并发的场景。</li><li>应对高并发时，不仅可以通过多线程的方式解决，也可以从整体架构、缓存层的设计、MQ 队列等地方着手解决。</li></ul><h4 id="④多线程可以提高程序的执行效率，你知不知道有哪些弊端？"><a href="#④多线程可以提高程序的执行效率，你知不知道有哪些弊端？" class="headerlink" title="④多线程可以提高程序的执行效率，你知不知道有哪些弊端？"></a>④多线程可以提高程序的执行效率，你知不知道有哪些弊端？</h4><ol><li>性能问题（上下文切换、保存 CPU cache）</li><li>异构化任务或不能并行执行的任务用多线程反而不如用单线程合适</li><li>线程安全问题</li></ol><h4 id="⑤什么是同步？什么是异步？什么是阻塞？什么是非阻塞？"><a href="#⑤什么是同步？什么是异步？什么是阻塞？什么是非阻塞？" class="headerlink" title="⑤什么是同步？什么是异步？什么是阻塞？什么是非阻塞？"></a>⑤什么是同步？什么是异步？什么是阻塞？什么是非阻塞？</h4><ul><li>同步、异步指的是被调用方在调用结束后是否主动返回结果</li><li>阻塞、非阻塞指的是调用方在调用后是否可以去做其他事情</li><li>具体见 <strong>5.同步与异步、阻塞与非阻塞</strong></li></ul><h4 id="⑥在单核-CPU-上运行多线程程序有意义吗？"><a href="#⑥在单核-CPU-上运行多线程程序有意义吗？" class="headerlink" title="⑥在单核 CPU 上运行多线程程序有意义吗？"></a>⑥在单核 CPU 上运行多线程程序有意义吗？</h4><ul><li>有意义，虽然在单核 CPU 上执行真正的并行是不可能的，因为只有一个处理器，但是对于应用程序而言，我们不知道它未来会运行在单核 CPU 还是多核 CPU 上，所以在编写时肯定以多核 CPU 为准。其次，对于多线程程序，当其中一个线程执行缓慢或者被阻塞时，其他线程可以利用这些时间（如读取磁盘的时间）做其他事情，让程序保持高效运转。</li><li>如果 CPU 被挤满，并不是说在单核 CPU 上运行多线程程序没有意义，而是说线程的数量设置不合理，应该减少线程的数量。</li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#119;&#x6a;&#121;&#109;&#101;&#x73;&#115;&#105;&#x40;&#49;&#54;&#x33;&#x2e;&#x63;&#x6f;&#109;" target="_blank" rel="noopener">&#119;&#x6a;&#121;&#109;&#101;&#x73;&#115;&#105;&#x40;&#49;&#54;&#x33;&#x2e;&#x63;&#x6f;&#109;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-进程和线程&quot;&gt;&lt;a href=&quot;#1-进程和线程&quot; class=&quot;headerlink&quot; title=&quot;1.进程和线程&quot;&gt;&lt;/a&gt;1.进程和线程&lt;/h3&gt;&lt;h4 id=&quot;①与操作系统的关系&quot;&gt;&lt;a href=&quot;#①与操作系统的关系&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="并发编程" scheme="http://messi1002.top/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized关键字</title>
    <link href="http://messi1002.top/2020/02/20/Synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://messi1002.top/2020/02/20/Synchronized关键字/</id>
    <published>2020-02-20T04:21:51.000Z</published>
    <updated>2020-03-25T13:25:45.605Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><h4 id="①作用"><a href="#①作用" class="headerlink" title="①作用"></a>①作用</h4><ul><li>Oracle 的官方解释：synchronized 关键字的同步方法支持一种简单的策略来防止线程干扰和内存一致性错误。<ul><li>如果一个对象对多个线程可见，则对该对象变量的所有读取或写入都是通过同步方法完成的。</li></ul></li><li>一句话总结 synchronized 的作用：能够保证在同一时刻最多只有一个线程执行该段代码，以达到保证并发安全的效果。<ul><li>被 synchronized 关键字修饰的代码会以原子的方式执行，即多个线程不会同时执行这段代码，同一时刻最多只有一个线程执行该段代码。</li><li>如何控制同一时刻只有一个线程执行该段代码？有一把锁，当第一个线程执行这段代码时拿到这把锁，直到方法执行结束或一定条件后才会释放这把锁。在这把锁释放前，其他线程想要执行这段代码，只能等待或者阻塞。直到锁释放后，其他线程才能执行这段代码。</li></ul></li></ul><h4 id="②地位"><a href="#②地位" class="headerlink" title="②地位"></a>②地位</h4><ul><li>synchronized 是 Java 的关键字，被 Java 语言原生支持。<ul><li><strong>volatile</strong> 也是 Java 的关键字（它们都是 Java 并发编程中的重要关键字）</li></ul></li><li>它是最基本的互斥同步手段<ul><li>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。　　</li><li>同步：指程序用于控制不同线程之间操作发生相对顺序的机制。</li></ul></li><li>它是并发编程中的元老级角色，是并发编程的必学内容。</li></ul><h4 id="③不使用并发（同步方法）的后果"><a href="#③不使用并发（同步方法）的后果" class="headerlink" title="③不使用并发（同步方法）的后果"></a>③不使用并发（同步方法）的后果</h4><ul><li>代码实战：两个线程同时执行 <code>a++</code>，最后结果会被预计的少。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 不使用并发手段，建立两个线程一起执行a++。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoUseConcurrency</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建类的实例</span></span><br><span class="line">    <span class="keyword">static</span> NoUseConcurrency instance = <span class="keyword">new</span> NoUseConcurrency();</span><br><span class="line">    <span class="comment">// 初始化a的值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 建立两个线程，利用同一个实例，共用实例中的方法。</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待两个子线程都执行完成</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>连续运行三次程序，打印的结果各不相同。</li></ul><p><img src="./1582533268242.png" alt="Alt text"><br><img src="./1582533337941.png" alt="Alt text"><br><img src="./1582533388383.png" alt="Alt text"></p><ul><li>原因：<code>a++</code> 看上去只是一个操作，实际上包含了三个步骤：<ul><li>①读取 a</li><li>②将 a 的值加 1</li><li>③将 a 的值写入到内存中</li></ul></li><li>而在多线程的情况下任何一步执行完成后都有可能被打断，都有可能轮到另一个线程去执行，即线程不安全。</li></ul><h4 id="④使用并发（同步方法）"><a href="#④使用并发（同步方法）" class="headerlink" title="④使用并发（同步方法）"></a>④使用并发（同步方法）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 使用并发手段，建立两个线程一起执行a++。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseConcurrency</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> UseConcurrency instance = <span class="keyword">new</span> UseConcurrency();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 建立两个线程，利用同一个实例，共用实例中的方法。</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待两个子线程都执行完成</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对象锁-方法锁</span></span><br><span class="line">    <span class="comment">// 将关键字加在普通方法上</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重复运行多次程序，打印结果都是 <code>a = 200000</code>。</li></ul><hr><h3 id="2-用法"><a href="#2-用法" class="headerlink" title="2.用法"></a>2.用法</h3><blockquote><p>synchronized 关键字也叫做同步修饰符<br>音标：[ˈsɪŋkrənaɪzd]</p></blockquote><h4 id="①对象锁"><a href="#①对象锁" class="headerlink" title="①对象锁"></a>①对象锁</h4><ul><li>对象锁的两种形式：</li><li>同步代码块锁<ul><li>手动指定锁对象（this 或自定义对象）</li></ul></li><li>方法锁<ul><li>synchronized 修饰普通方法（不能修饰静态方法），锁对象默认为 this。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 对象锁实例1之同步代码块形式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectLock1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObjectLock1 instance = <span class="keyword">new</span> SynchronizedObjectLock1();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 默认用this(当前对象)作为锁对象</span></span><br><span class="line">        <span class="comment">// 保护以下代码块串行执行</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"开始执行"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 建立两个线程，利用同一个实例，共用实例中的方法。</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待两个子线程都执行完成</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码线程 0 先执行，执行完成后线程 1 再执行。</li></ul><p><img src="./1582534624946.png" alt="Alt text"><br><img src="./1582534690028.png" alt="Alt text"><br><img src="./1582534597454.png" alt="Alt text"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 对象锁实例1之同步代码块形式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectLock1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObjectLock1 instance = <span class="keyword">new</span> SynchronizedObjectLock1();</span><br><span class="line">    <span class="comment">// 创建自定义锁对象，lock1和lock2保护的时机不相同。</span></span><br><span class="line">    Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">    Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义锁对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"开始执行(lock1)"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行结束(lock1)"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"开始执行(lock2)"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行结束(lock2)"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 建立两个线程，利用同一个实例，共用实例中的方法。</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待两个子线程都执行完成</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码线程 0 拿到第 2 把锁的同时，线程 1 拿到第 1 把锁，并行执行（第一把锁和第二把锁不相同，互不影响）。</li></ul><p><img src="./1582536037312.png" alt="Alt text"><br><img src="./1582536127382.png" alt="Alt text"><br><img src="./1582536195719.png" alt="Alt text"><br><img src="./1582535365421.png" alt="Alt text"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 对象锁示例2之方法锁形式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectLock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObjectLock2 instance = <span class="keyword">new</span> SynchronizedObjectLock2();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对普通方法加上synchronized修饰符，保护以下代码块串行执行。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"对象锁的方法修饰符形式"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"执行结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 建立两个线程，利用同一个实例，共用实例中的方法。</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待两个子线程都执行完成</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码线程 0 先执行，执行完成后线程 1 再执行。</li></ul><p><img src="./1582537941538.png" alt="Alt text"><br><img src="./1582537977048.png" alt="Alt text"><br><img src="./1582538009150.png" alt="Alt text"></p><h4 id="②类锁"><a href="#②类锁" class="headerlink" title="②类锁"></a>②类锁</h4><ul><li>Java 类可能有很多个对象，但是只有 1 个 Class 对象。</li><li>本质：所谓的类锁，就是 Class 对象的锁。</li><li>效果：类锁在同一时刻只能被一个对象拥有</li><li>类锁的两种形式：</li><li>静态锁<ul><li>synchronized 加在 static 方法上 </li></ul></li><li>Class 对象<ul><li>synchronized 代码块（锁对象默认为 Class 对象） </li><li>指定锁为 Class 对象</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 类锁示例1之静态锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedClassLock1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedClassLock1 instance1 = <span class="keyword">new</span> SynchronizedClassLock1();</span><br><span class="line">    <span class="keyword">static</span> SynchronizedClassLock1 instance2 = <span class="keyword">new</span> SynchronizedClassLock1();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// synchronized修饰符修饰静态方法</span></span><br><span class="line">    <span class="comment">// 在全局情况下保护以下代码块串行执行(不是对象的层面)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 建立两个线程，两个线程分别引用同一个类的不同实例。</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待两个子线程都执行完成</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码线程 0 先执行，执行完成后线程 1 再执行。</li></ul><p><img src="./1582539304996.png" alt="Alt text"><br><img src="./1582539337288.png" alt="Alt text"><br><img src="./1582539375670.png" alt="Alt text"></p><ul><li>若是将 <code>method()</code> 方法变为非静态方法，此时就算加了 synchronized 关键字，线程 0 和线程 1 也会同时执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 类锁示例1之静态锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedClassLock1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedClassLock1 instance1 = <span class="keyword">new</span> SynchronizedClassLock1();</span><br><span class="line">    <span class="keyword">static</span> SynchronizedClassLock1 instance2 = <span class="keyword">new</span> SynchronizedClassLock1();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// synchronized修饰符修饰非静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 建立两个线程，两个线程分别引用同一个类的不同实例</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待两个子线程都执行完成</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">      System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582540371493.png" alt="Alt text"><br><img src="./1582540395219.png" alt="Alt text"></p><ul><li>因为静态方法属于整个类，当多个线程（类的不同实例）访问这个类的静态方法时，实际访问的是同一个方法。所以给这个静态方法上锁之后，同一时刻只能由一个线程执行该方法。</li><li>而非静态方法属于调用它的实例对象，当两个线程分别调用其实例对象的非静态方法时，相当于各自执行自己的方法，这时加或不加锁都不影响各自方法的执行。</li><li>所以类锁适用于在全局情况下同步方法，而不仅仅在对象层面。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 类锁示例2之Class对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedClassLock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedClassLock2 instance1 = <span class="keyword">new</span> SynchronizedClassLock2();</span><br><span class="line">    <span class="keyword">static</span> SynchronizedClassLock2 instance2 = <span class="keyword">new</span> SynchronizedClassLock2();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 锁对象是SynchronizedClassLock2.class</span></span><br><span class="line">        <span class="comment">// 无论是类的哪个实例用的都是同一个锁对象(串行执行)</span></span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedClassLock2.class) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 建立两个线程，两个线程分别引用同一个类的不同实例</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待两个子线程都执行完成</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码线程 0 先执行，执行完成后线程 1 再执行。</li></ul><p><img src="./1582541802253.png" alt="Alt text"><br><img src="./1582541826775.png" alt="Alt text"><br><img src="./1582541841546.png" alt="Alt text"></p><ul><li>若是将 synchronized 代码块中的 <code>SynchronizedClassLock2.class</code> 改为 <code>this</code>，此时就算是加了 synchronized 关键字，线程 0 和线程 1 也会同时执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 类锁示例2之Class对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedClassLock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedClassLock2 instance1 = <span class="keyword">new</span> SynchronizedClassLock2();</span><br><span class="line">    <span class="keyword">static</span> SynchronizedClassLock2 instance2 = <span class="keyword">new</span> SynchronizedClassLock2();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 锁对象是this</span></span><br><span class="line">        <span class="comment">// 不同实例的锁对象不同，多个线程并行执行。</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 建立两个线程，两个线程分别引用同一个类的不同实例</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待两个子线程都执行完成</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582542407010.png" alt="Alt text"><br><img src="./1582542460177.png" alt="Alt text"></p><ul><li>原因：不同实例的锁对象不同，多个线程并行执行。</li></ul><hr><h3 id="3-多线程访问同步方法的-7-种情况（面试常考）"><a href="#3-多线程访问同步方法的-7-种情况（面试常考）" class="headerlink" title="3.多线程访问同步方法的 7 种情况（面试常考）"></a>3.多线程访问同步方法的 7 种情况（面试常考）</h3><blockquote><p>同步方法：被 synchronized 关键字所修饰的方法<br>非同步方法：没有被 synchronized 关键字所修饰的方法<br>普通方法：指非静态方法</p></blockquote><h4 id="①两个线程同时访问一个对象的同步方法"><a href="#①两个线程同时访问一个对象的同步方法" class="headerlink" title="①两个线程同时访问一个对象的同步方法"></a>①两个线程同时访问一个对象的同步方法</h4><ul><li>原因：两个线程属于同一个实例，所以两个线程访问的是同一个方法，而这个方法被 synchronized 关键字修饰后默认以 this 对象作为同步方法的锁，所以它们会争抢同一把锁。</li><li>结果：两个线程争抢同一把锁，同一时刻只能有一个线程执行该同步方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 两个线程同时访问一个对象的同步方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Situation1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Situation1 instance = <span class="keyword">new</span> Situation1();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Situation1.class finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582547849811.png" alt="Alt text"><br><img src="./1582547871624.png" alt="Alt text"><br><img src="./1582547896299.png" alt="Alt text"></p><h4 id="②两个线程访问的是两个对象的同步方法"><a href="#②两个线程访问的是两个对象的同步方法" class="headerlink" title="②两个线程访问的是两个对象的同步方法"></a>②两个线程访问的是两个对象的同步方法</h4><ul><li>原因：两个线程属于不同的实例，所以两个线程访问的是不同的方法，而每个方法被 synchronized 关键字修饰后默认以 this 对象作为同步方法的锁，所以它们的锁对象不是同一个。</li><li>结果：两个线程的锁对象不是同一个，并行执行，互不干扰。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 两个线程访问的是两个对象的同步方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Situation2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Situation2 instance1 = <span class="keyword">new</span> Situation2();</span><br><span class="line">    <span class="keyword">static</span> Situation2 instance2 = <span class="keyword">new</span> Situation2();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Situation2.class finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582548056867.png" alt="Alt text"><br><img src="./1582548075858.png" alt="Alt text"></p><h4 id="③两个线程访问的是-synchronized-的静态方法"><a href="#③两个线程访问的是-synchronized-的静态方法" class="headerlink" title="③两个线程访问的是 synchronized 的静态方法"></a>③两个线程访问的是 synchronized 的静态方法</h4><ul><li>原因：虽然两个线程属于类的不同实例，但是两个线程访问的方法是类的静态方法，即它们实际访问的是同一个方法。给这个静态方法上锁之后，同一时刻只能有一个线程执行该方法。</li><li>结果：两个线程争抢同一把锁，同一时刻只能有一个线程执行该同步方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 两个线程访问的是synchronized的静态方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Situation3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Situation3 instance1 = <span class="keyword">new</span> Situation3();</span><br><span class="line">    <span class="keyword">static</span> Situation3 instance2 = <span class="keyword">new</span> Situation3();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Situation3.class finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582548260523.png" alt="Alt text"><br><img src="./1582548289256.png" alt="Alt text"><br><img src="./1582548315931.png" alt="Alt text"></p><h4 id="④同时访问同步方法与非同步方法"><a href="#④同时访问同步方法与非同步方法" class="headerlink" title="④同时访问同步方法与非同步方法"></a>④同时访问同步方法与非同步方法</h4><ul><li>原因：synchronized 关键字只作用于其指定的方法中，其他非同步方法不受到影响。</li><li>结果：当线程 0 访问同步方法，线程 1 访问非同步方法时，两个线程并行执行，互不干扰。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 同时访问同步和非同步方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Situation4</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Situation4 instance = <span class="keyword">new</span> Situation4();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 让线程0运行method1()方法，线程1运行method2()方法。</span></span><br><span class="line">        <span class="comment">// 线程的默认名是从Thread-0(Thread-1、Thread-2、...)开始。</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread().getName().equals(<span class="string">"Thread-0"</span>)) &#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            method2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行(加锁的方法)"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行(加锁的方法)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行(没加锁的方法)"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行(没加锁的方法)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Situation4.class finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582548882215.png" alt="Alt text"><br><img src="./1582548895883.png" alt="Alt text"></p><h4 id="⑤同时访问一个类的不同的普通同步方法"><a href="#⑤同时访问一个类的不同的普通同步方法" class="headerlink" title="⑤同时访问一个类的不同的普通同步方法"></a>⑤同时访问一个类的不同的普通同步方法</h4><ul><li>原因：两个线程属于同一个实例，虽然两个线程访问的是一个类的不同的普通同步方法，但是被 synchronized 关键字修饰的普通方法默认都是以 this 对象作为同步方法的锁，所以它们会争抢同一把锁（对于同一个实例来讲，两个方法的 this 对象是同一个）。</li><li>结果：两个线程争抢同一把锁，同一时刻只能有一个线程执行该线程对应的同步方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 同时访问一个类的不同的普通同步方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Situation5</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Situation5 instance = <span class="keyword">new</span> Situation5();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread().getName().equals(<span class="string">"Thread-0"</span>)) &#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            method2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行(加锁的方法)"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行(加锁的方法)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行(加锁的方法)"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行(加锁的方法)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Situation5.class finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582549226682.png" alt="Alt text"><br><img src="./1582549274126.png" alt="Alt text"><br><img src="./1582549286842.png" alt="Alt text"></p><h4 id="⑥同时访问静态-synchronized-和非静态-synchronized-方法"><a href="#⑥同时访问静态-synchronized-和非静态-synchronized-方法" class="headerlink" title="⑥同时访问静态 synchronized 和非静态 synchronized 方法"></a>⑥同时访问静态 synchronized 和非静态 synchronized 方法</h4><ul><li>原因：<ul><li>synchronized 关键字修饰静态方法：类锁，锁住的是 .class 对象。</li><li>synchronized 关键字修饰非静态方法：方法锁，锁住的是实例本身 this。</li><li>两个线程的锁对象不是同一个，所以两个线程可以同时运行。</li></ul></li><li>结果：两个线程的锁对象不是同一个，并行执行，互不干扰。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 同时访问静态synchronized和非静态synchronized方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Situation6</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Situation6 instance = <span class="keyword">new</span> Situation6();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread().getName().equals(<span class="string">"Thread-0"</span>)) &#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            method2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行(静态加锁的方法)"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行(静态加锁的方法)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行(非静态加锁的方法)"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行(非静态加锁的方法)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Situation6.class finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582549897829.png" alt="Alt text"><br><img src="./1582549910266.png" alt="Alt text"></p><h4 id="⑦方法抛出异常后会释放锁"><a href="#⑦方法抛出异常后会释放锁" class="headerlink" title="⑦方法抛出异常后会释放锁"></a>⑦方法抛出异常后会释放锁</h4><ul><li>synchronized：方法抛出异常后会主动释放锁。</li><li>Lock 类：方法抛出异常后不会主动释放锁，必须显式地释放锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 方法抛出异常后会释放锁</span></span><br><span class="line"><span class="comment"> * 展示不抛出异常前和抛出异常后的对比: 一旦第一个线程抛出异常，第二个线程会立刻进入同步方法，意味着锁已经释放。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Situation7</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Situation7 instance = <span class="keyword">new</span> Situation7();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 方法抛出异常后，JVM帮我们释放了锁，不需要手动释放锁。</span></span><br><span class="line">        <span class="comment">// 抛出运行时异常，不强制要求捕获。</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Situation7.class finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582550356233.png" alt="Alt text"><br><img src="./1582550465567.png" alt="Alt text"></p><h4 id="⑧总结"><a href="#⑧总结" class="headerlink" title="⑧总结"></a>⑧总结</h4><ol><li>一把锁只能同时被一个线程获取，没有拿到锁的线程必须等待（对应①、⑤）。</li><li>每个实例都对应有自己的一把锁，不同的实例之间对应不同的锁，所以不同的实例之间互不影响。<ul><li>例外：锁对象是 .class 以及 synchronized 修饰的是 static 方法的时候，所有对象共用同一把类锁（对应②、③、④、⑥） 。</li></ul></li><li>无论是方法正常执行完毕或者方法抛出异常，都会释放锁（对应⑦）。</li><li>在被 synchronized 修饰的方法中调用没有被 synchronized 修饰的方法时，不是线程安全的，因为没有被 synchronized 修饰的方法是可以被多个线程同时访问的。</li></ol><hr><h3 id="4-性质"><a href="#4-性质" class="headerlink" title="4.性质"></a>4.性质</h3><h4 id="①可重入性（递归锁）"><a href="#①可重入性（递归锁）" class="headerlink" title="①可重入性（递归锁）"></a>①可重入性（递归锁）</h4><ul><li><p>这是它区别于其他锁的关键特点</p></li><li><p>可重入性：指的是同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁。</p><ul><li>ReentrantLock 也是可重入锁</li></ul></li><li><p>好处：</p><ul><li>避免死锁（假设方法 1 和方法 2 都被 synchronized 关键字修饰，此时某线程执行方法 1 和方法 2 时都需要同一把锁。假如线程 A 执行了方法 1 并且获得了这把锁，此时方法 1 要想访问方法 2，假设 synchronized 关键字没有可重入性，相当于线程 A 没有方法 2 的锁，不能直接使用本身已经获得的锁。既想要拿到方法 2 的锁又不释放方法 1 的锁<br>（方法 1 和方法 2 是同一把锁），就开始了永久等待，变成了死锁。）</li><li>提升封装性（避免一次次解锁、加锁，提高了封装性，简化了并发编程的难度。）</li></ul></li><li><p>粒度：即范围，默认加锁的范围是线程而非调用。</p><ul><li>情况1：访问同一个方法是可重入的</li><li>情况2：可重入不要求是同一个方法（即证明在一个同步方法中调用另一个同步方法是可行的）</li><li>情况3：可重入不要求是同一个类中的</li><li>以上三种情况证明了可重入的粒度不是调用范围的，而是线程范围的。所以在同一个线程中，如果已经拿到了一把锁，又想继续使用这把锁访问其他（类的）方法时，只要锁是同一把锁，就可以访问。</li></ul></li><li><p>证明情况1：访问同一个方法是可重入的</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 可重入粒度测试1——递归调用本方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantGranularityTest1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a = "</span> + a);</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">            a++;</span><br><span class="line">            <span class="comment">// 调用方法本身</span></span><br><span class="line">            method();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantGranularityTest1 test1 = <span class="keyword">new</span> ReentrantGranularityTest1();</span><br><span class="line">        test1.method();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582552644697.png" alt="Alt text"></p><ul><li>证明情况2：可重入不要求是同一个方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 可重入粒度测试2——调用类内其他的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantGranularityTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是方法一"</span>);</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是方法二"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantGranularityTest2 test2 = <span class="keyword">new</span> ReentrantGranularityTest2();</span><br><span class="line">        test2.method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582552602807.png" alt="Alt text"></p><ul><li>证明情况3：可重入不要求是同一个类中的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 可重入粒度测试3——父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantGranularityTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是父类方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 可重入粒度测试3——调用父类的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantGranularityTest3</span> <span class="keyword">extends</span> <span class="title">ReentrantGranularityTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 重写父类方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/20 22:30</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是子类方法"</span>);</span><br><span class="line">        <span class="comment">// 调用父类方法</span></span><br><span class="line">        <span class="keyword">super</span>.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantGranularityTest3 test3 = <span class="keyword">new</span> ReentrantGranularityTest3();</span><br><span class="line">        <span class="comment">// 执行子类方法</span></span><br><span class="line">        test3.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582552861324.png" alt="Alt text"></p><h4 id="②不可中断性"><a href="#②不可中断性" class="headerlink" title="②不可中断性"></a>②不可中断性</h4><ul><li>这个性质是 synchronized 关键字的劣势</li><li>不可中断性：一旦这个锁已经被别人获得了，如果我还想获取，我只能选择等待或者阻塞，直到别的线程释放这个锁。如果别人永远不释放锁，那么我只能永远等待下去。</li><li>而 Lock 类拥有可以中断的能力<ul><li>如果我觉得我等待的时间太长了，有权中断现在已经获取到锁的那个线程的执行。</li><li>如果我觉得我等待的时间太长了不想再等了，也可以直接退出。</li></ul></li></ul><hr><h3 id="5-原理"><a href="#5-原理" class="headerlink" title="5.原理"></a>5.原理</h3><h4 id="①加锁和释放锁的原理"><a href="#①加锁和释放锁的原理" class="headerlink" title="①加锁和释放锁的原理"></a>①加锁和释放锁的原理</h4><ul><li>每一个类的实例对应着一把锁，而每一个被 synchronized 关键字修饰的方法都必须首先获得调用该方法的类的实例的锁才能执行，否则线程就会阻塞。而方法一旦执行，就会独占这把锁，直到该方法返回或者抛出异常，才会将锁释放。释放之后，其他被阻塞的线程就能获得这把锁，重新进入到可执行的状态。</li><li>即当一个对象中有 synchronized 关键字修饰的方法或者代码块时，要想执行这段代码，就必须先获得对象锁。如果此对象的对象锁已经被其他调用者占用了，就必须等待它被释放。所有的 Java 对象都含有一个互斥锁，这个锁由 JVM 自动去获取和释放，我们只需要指定这个对象就可以了。</li><li>获取和释放锁的时机：内置锁<ul><li>每个 Java 对象都可以用作一个实现同步的锁，这个锁被称为内置锁或监视器锁。线程在进入到同步代码块之前，会自动获得这个锁，并且在退出同步代码块的时候，会自动释放。</li><li>获得内置锁的唯一途径，就是进入到锁所保护的同步代码块或方法中。</li></ul></li><li>下面用 Lock 模拟 synchronized 加锁和释放锁的时机：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 用lock模拟synchronized加锁和释放锁的时机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockAndUnlock</span> </span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 进入方法时隐形地获取一把锁</span></span><br><span class="line">        System.out.println(<span class="string">"我是synchronized形式的锁"</span>);</span><br><span class="line">        <span class="comment">// 退出方法时隐形地释放一把锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"我是lock形式的锁"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// synchronized和lock在底层可以相互类比和配合</span></span><br><span class="line">        <span class="comment">// method1方法和method2方法等价</span></span><br><span class="line">        <span class="comment">// 将method1中synchronized锁住和解锁的时机用method2中拆分的形式表达</span></span><br><span class="line">        LockAndUnlock l = <span class="keyword">new</span> LockAndUnlock();</span><br><span class="line">        l.method1();</span><br><span class="line">        l.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582555202885.png" alt="Alt text"></p><h4 id="③反编译看-monitor-指令"><a href="#③反编译看-monitor-指令" class="headerlink" title="③反编译看 monitor 指令"></a>③反编译看 monitor 指令</h4><ul><li><p>synchronized 是如何工作的</p><ul><li>synchronized 用的锁是 Java 对象头里的一个字段（每一个对象都有一个对象头，对象头可以存储很多信息，其中有一个部分就是用来存储 synchronize 关键字的锁的，表明是否被锁住。）</li><li>细节：当线程访问一个同步代码块时，必须要得到这把锁，退出整个代码块或者抛出异常的时候必须释放锁，而锁存储在 Java 对象头中。在 JVM 规范中对于 synchronized 的实现原理已经有了说明，它的进入锁和释放锁是基于 Moniter 对象来实现同步方法和同步代码块的。Monditor 对象主要有两个指令：Monditorenter（插入到同步代码块开始的位置）和 Monditorexit（插入到方法结束的时候和退出的时候）。JVM 规范保证每一个 enter 之后必须要有 exit 和它对应，但是可能有多个 exit 和同一个 enter 对应，因为退出的时机包括方法结束和抛出异常。每一个对象都有一个 Monditor 和它关联，并且一旦一个 Monditor 被持有后，就会处于锁定状态，当线程执行到 Monditorenter 指令时，会尝试获取这个对象对应的 Monditor 的所有权，也就是尝试获取这个对象锁。</li></ul></li><li><p>编译：<code>javac 类名.java</code></p><ul><li>将 Java 类编译为 .class 文件</li></ul></li><li><p>反编译：<code>javap -verbose class文件名.class</code></p><ul><li>将 .class 文件反编译为字节码文件</li></ul></li><li><p>反编译结果：</p></li></ul><p><img src="./1582444077456.png" alt="Alt text"></p><ul><li>详细解读 Monditorenter 和 Monditorexit 指令：Monditorenter 和 Monditorexit 指令在执行的时候会使对象的锁计数加 1 或者减 1。每一个对象都和一个 Monditor 相关联，一个 Moditor 的 lock 锁只能被一个线程在同一时间获得，一个线程在尝试获得与这个对象关联的 Monditor 的所有权的时候，只会发生以下三种情况之一（即 Monditorenter 指令的三种情况）：<ul><li>成功获得锁：Monditor 计数器为 0，意味着目前还没有被获得，这个线程就会立刻获得，然后把计数器加 1，之后别人再想进来就会看到信号，知道它已经被其他线程所持有，所以加 1 意味着当前线程是这个 Moditor 的持有者。</li><li>已经拿到这把锁的所有权再次重入时：计数器随着重入次数的增加而增加（每次加 1）。</li><li>Monditor 已经被其他线程所持有了：当前线程再次获取就会得到现在无法获取的信号，就会进入阻塞状态，直到 Moditor 的计数器变为0，才会再次尝试获取这个锁。</li></ul></li><li>Monditorexit：释放 Monditor 的所有权（可以将 Monditor 理解为锁）<ul><li>前提是已经拥有了锁的所有权</li><li>释放的过程：将 Monditor 的计数器减 1，如果减完之后变成 0 就意味着当前线程不再拥有对 Monditor 的所有权，即解锁。如果减完之后不是 0，意味着刚才是可重入进来的，所以还是继续持有这把锁。最终计数器减到 0 之后，不仅意味着释放锁了，还意味着刚才被阻塞的线程会再次尝试获取对这把锁的所有权。</li></ul></li></ul><h4 id="③可重入原理"><a href="#③可重入原理" class="headerlink" title="③可重入原理"></a>③可重入原理</h4><ul><li>可重入性：一个线程拿到一把锁之后，如果还想再次进入由这把锁所控制的方法，可以直接进入。</li><li>可重入原理：利用加锁次数计数器<ul><li>每个对象自动地含有一把锁，JVM 负责跟踪对象被加锁的次数。 线程第一次给对象加锁的时候，计数变为 1。每当这个相同的线程在此对象上再次获得锁时，计数递增。每当任务结束离开时，计数递减，当计数为 0 的时候，锁被完全释放。</li></ul></li></ul><h4 id="④可见性原理"><a href="#④可见性原理" class="headerlink" title="④可见性原理"></a>④可见性原理</h4><ul><li>保证可见性的原理：Java 内存模型<ul><li>共享变量的副本：将主内存的变量复制一份，放在自己的本地内存。原因：加速程序的运行，因为线程所使用的内存速度比主存中的速度快。</li><li>两个线程要想互相通信-要怎么做：线程 A 将共享变量的副本写到主内存中，因为主内存是它们相互沟通的桥梁，然后线程 B 再去主内存中读取。</li><li>这个过程是 JMM（Java 内存模型的缩写）控制的，JMM 通过控制主内存与每个线程的本地内存的交互来提供内存可见性的保证。</li></ul></li></ul><p><img src="./1582445087616.png" alt="Alt text"></p><ul><li>synchronized 是如何做到可见性的实现的？<ul><li>一旦代码块或者方法被 synchronized 关键字所修饰，那么它在执行完毕之后，被锁住的对象所做的任何修改，都要在释放锁之前，从线程内存写回到主内存中（不会存在线程内存和主内存不一致的情况）。</li><li>同样，在进入代码块获得锁之后，被锁定对象的数据也是直接从主内存中读取出来的。</li></ul></li></ul><hr><h3 id="6-缺陷"><a href="#6-缺陷" class="headerlink" title="6.缺陷"></a>6.缺陷</h3><ol><li>效率低<ul><li>锁的释放情况少：当一个线程获取到锁并在执行过程中，其他线程也想要获得该锁时，只能等待当前线程释放。而当前线程只有在两种情况下才会释放锁：①线程执行完该段代码、②执行过程中发生异常（JVM 将锁释放）。如果要等待 IO 这种耗时操作或者线程 sleep 时，不会主动释放锁，其他线程只能等待，非常影响程序执行的效率。这时需要一种机制，遏制这些情况。（Lock 类可以做到）</li><li>试图获得锁时不能设定超时时间，只能等待。（Lock 类可以做到）</li><li>不能中断一个正在试图获得锁的线程（Lock 类可以做到）</li></ul></li><li>不够灵活（读写锁更灵活）<ul><li>加锁和释放锁的时机单一，每个锁仅有单一的条件（某个对象）。锁住某个对象，某个对象就是这把锁。释放这个对象，才意味着解了这把锁。</li></ul></li><li>无法知道是否成功获取到锁（Lock 类可以做到）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 展示Lock的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="comment">// 通过这两个方法灵活得控制这把锁，且可以配置自定义的锁。</span></span><br><span class="line">        <span class="comment">// 锁住</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">        <span class="comment">// 在规定的超时时间内等待获得锁。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 不设置超时时间的tryLock()</span></span><br><span class="line">            lock.tryLock();</span><br><span class="line">            <span class="comment">// 若是10s拿不到锁，会主动放弃。</span></span><br><span class="line">            lock.tryLock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="7-常见面试问题"><a href="#7-常见面试问题" class="headerlink" title="7.常见面试问题"></a>7.常见面试问题</h3><h4 id="①synchronized-关键字有哪些使用注意点？"><a href="#①synchronized-关键字有哪些使用注意点？" class="headerlink" title="①synchronized 关键字有哪些使用注意点？"></a>①synchronized 关键字有哪些使用注意点？</h4><ol><li>锁对象不能为空<ul><li>指定一个对象作为锁对象时，必须是一个实例对象被 new 过，或者使用其他方法创建好的，而不是空对象。这是因为锁的信息保存在对象头中的，如果对象都没有，就没有对象头，所以这个锁是不能工作的。</li></ul></li><li>作用域不宜过大<ul><li>将尽可能多的代码使用 synchronized 包裹，虽然会降低出并发问题的可能性（大部分线程都是串行工作），但是没有达到多线程编程的目的，影响程序执行的效率。</li></ul></li><li>避免死锁</li></ol><h4 id="②如何选择-Lock-和-synchronized-关键字？"><a href="#②如何选择-Lock-和-synchronized-关键字？" class="headerlink" title="②如何选择 Lock 和 synchronized 关键字？"></a>②如何选择 Lock 和 synchronized 关键字？</h4><ol><li>如果可以的话，两者都不要使用，应该使用 JUC 中的各种类（更方便，不容易出错）。</li><li>如果 synchronized 关键字在程序中适用，那么就优先使用（可以减少所需要编写的代码，也就减少了出错的几率）。</li><li>如果需要使用到 Lock 类独有的特性（如灵活的加解锁机制），再使用 Lock。</li></ol><h4 id="③多线程访问同步方法的各种具体情况"><a href="#③多线程访问同步方法的各种具体情况" class="headerlink" title="③多线程访问同步方法的各种具体情况"></a>③多线程访问同步方法的各种具体情况</h4><ul><li>具体见 <strong>3.多线程访问同步方法的 7 种情况</strong></li></ul><hr><h3 id="8-思考"><a href="#8-思考" class="headerlink" title="8.思考"></a>8.思考</h3><ol><li>多个线程等待同一个 synchronized 锁的时候，JVM 如何选择下一个获取锁的是哪个线程？<ul><li>有内部锁调度机制有关</li><li>持有锁的线程在运行完成或抛出异常后，就会释放这把锁。线程释放锁之后，竞争锁的对象有：等待中的线程、刚刚申请这把锁的线程。内部锁调度机制实现细节和 JVM 的版本、具体实现相关，不能依赖算法。</li><li>目前是处于随机的，不公平的状态。</li><li>synchronized 是非公平锁，ReentrantLock 可以设置是否是公平锁。</li></ul></li><li>synchronized 使得同时只有一个线程可以执行，性能较差，有什么方法可以提升性能？<ul><li>优化使用范围（临界区在符合要求的情况下尽可能得小）</li><li>使用其他类型的锁（如读写锁）</li><li>自己实现 Lock 接口，自由设定锁持有时间</li></ul></li><li>想灵活的控制锁的获取和释放怎么办（现在释放锁的时机都被规定死了）？<ul><li>自己实现一个锁</li></ul></li><li>什么是锁的升级和降级？什么是 JVM 里的偏斜锁、轻量级锁、重量级锁？</li></ol><p><img src="./1582467175893.png" alt="Alt text"></p><hr><h3 id="9-总结"><a href="#9-总结" class="headerlink" title="9.总结"></a>9.总结</h3><ul><li>一句话介绍 synchronized：JVM 会自动通过使用 monitor 来自动加锁和解锁，保证了同时只有一个线程可以执行指定代码，从而保证了线程安全，同时具有可重入和不可中断的性质。</li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#x6a;&#x79;&#x6d;&#101;&#115;&#x73;&#105;&#64;&#x31;&#54;&#51;&#x2e;&#99;&#x6f;&#x6d;" target="_blank" rel="noopener">&#x77;&#x6a;&#x79;&#x6d;&#101;&#115;&#x73;&#105;&#64;&#x31;&#54;&#51;&#x2e;&#99;&#x6f;&#x6d;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.简介&quot;&gt;&lt;/a&gt;1.简介&lt;/h3&gt;&lt;h4 id=&quot;①作用&quot;&gt;&lt;a href=&quot;#①作用&quot; class=&quot;headerlink&quot; title=&quot;①作用&quot;&gt;&lt;/a&gt;①作
      
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="并发编程" scheme="http://messi1002.top/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb相关软件安装包分享</title>
    <link href="http://messi1002.top/2020/02/18/JavaWeb%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8C%85%E5%88%86%E4%BA%AB/"/>
    <id>http://messi1002.top/2020/02/18/JavaWeb相关软件安装包分享/</id>
    <published>2020-02-18T09:32:45.000Z</published>
    <updated>2020-06-12T12:59:06.895Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Linux-版本（JavaWeb-程序）"><a href="#1-Linux-版本（JavaWeb-程序）" class="headerlink" title="1.Linux 版本（JavaWeb 程序）"></a>1.Linux 版本（JavaWeb 程序）</h3><ul><li>链接：<a href="https://pan.baidu.com/s/1BHFbs0_sMzfBdQGIOCrQ-w" target="_blank" rel="noopener">https://pan.baidu.com/s/1BHFbs0_sMzfBdQGIOCrQ-w</a> </li><li>提取码：wvtt </li><li></li><li>jdk-8u201-linux-x64.tar.gz</li><li>apache-tomcat-8.5.39.tar.gz</li><li>apache-maven-3.6.0-bin.tar.gz</li><li>nginx-1.8.0.tar.gz</li><li>redis-5.0.4.tar.gz</li><li>thrift-0.13.0.tar.gz</li></ul><hr><h3 id="2-Windows-版本（JavaWeb-程序）"><a href="#2-Windows-版本（JavaWeb-程序）" class="headerlink" title="2.Windows 版本（JavaWeb 程序）"></a>2.Windows 版本（JavaWeb 程序）</h3><ul><li>链接：<a href="https://pan.baidu.com/s/1H4o8uCxwYVn_x0wn7aNvpg" target="_blank" rel="noopener">https://pan.baidu.com/s/1H4o8uCxwYVn_x0wn7aNvpg</a> </li><li>提取码：9h05</li><li></li><li>jdk-8u65-windows-x64.zip</li><li>mysql-5.7.24-winx64.zip</li><li>Redis-x64-3.0.504.msi</li><li>gradle-5.2.1-all.zip</li><li>elasticsearch-7.1.1-windows-x86_64.zip</li><li>elasticsearch-head-master.zip</li><li>Docker Community Edition 18.06.1-ce-win73 2018-08-29.exe</li></ul><hr><h3 id="3-其他工具（Windows）"><a href="#3-其他工具（Windows）" class="headerlink" title="3.其他工具（Windows）"></a>3.其他工具（Windows）</h3><ul><li>链接：<a href="https://pan.baidu.com/s/1LnO1znY4nlDuu8QvC957bQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1LnO1znY4nlDuu8QvC957bQ</a> </li><li>提取码：ihaf</li><li></li><li>谷歌访问助手_v2.3.0.crx（翻墙）</li><li>Git-2.19.1-64-bit.exe</li><li>GitHubDesktopSetup.exe</li><li>redis-desktop-manager-0.8.8.384.exe</li><li>Xftp.6.0.0105.v2.7z（Xftp.exe）</li><li>Xshell.6.0.0111.v2.7z（Xshell.exe）</li><li>notepad++.exe</li><li>VMware-workstation-full-15.0.0-10134415.exe</li><li>CentOS-7-x86_64-Minimal-1908.iso（CentOS 镜像 在 VMware 中使用）</li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#x6a;&#121;&#x6d;&#101;&#115;&#115;&#x69;&#64;&#49;&#x36;&#51;&#46;&#x63;&#x6f;&#x6d;" target="_blank" rel="noopener">&#x77;&#x6a;&#121;&#x6d;&#101;&#115;&#115;&#x69;&#64;&#49;&#x36;&#51;&#46;&#x63;&#x6f;&#x6d;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Linux-版本（JavaWeb-程序）&quot;&gt;&lt;a href=&quot;#1-Linux-版本（JavaWeb-程序）&quot; class=&quot;headerlink&quot; title=&quot;1.Linux 版本（JavaWeb 程序）&quot;&gt;&lt;/a&gt;1.Linux 版本（JavaWeb 程
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://messi1002.top/categories/JavaWeb/"/>
    
      <category term="总结&amp;其他" scheme="http://messi1002.top/categories/JavaWeb/%E6%80%BB%E7%BB%93-%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="资源分享" scheme="http://messi1002.top/tags/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>八种排序算法的总结及性能分析</title>
    <link href="http://messi1002.top/2020/02/12/%E5%85%AB%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <id>http://messi1002.top/2020/02/12/八种排序算法的总结及性能分析/</id>
    <published>2020-02-12T13:12:59.000Z</published>
    <updated>2020-03-25T13:18:55.479Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-排序基础"><a href="#1-排序基础" class="headerlink" title="1.排序基础"></a>1.排序基础</h3><h4 id="①基础知识"><a href="#①基础知识" class="headerlink" title="①基础知识"></a>①基础知识</h4><ul><li>稳定性：任意两个相等的数据，排序前后的相对位置不发生改变。</li><li>内排序：在排序期间数据对象全部存放在内存中的排序。</li><li>原地排序：在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序。</li><li>非原地排序：需要利用额外的空间来辅助排序。</li><li>逆序对：对于下标 <code>i &lt; j</code>，如果 <code>A[i] &gt; A[j]</code>，则称 <code>(i, j)</code> 是一对逆序对。<ul><li>交换 2 个相邻元素正好可以消去 1 个逆序对。</li></ul></li><li>讨论规则：<ul><li>只讨论升序的整数排序</li><li>只讨论基于比较的排序</li><li>只讨论内部排序</li></ul></li><li>排序算法一览（图片来源于网络）：</li></ul><p><img src="./1584493999606.png" alt="Alt text"></p><h4 id="②自定义辅助函数"><a href="#②自定义辅助函数" class="headerlink" title="②自定义辅助函数"></a>②自定义辅助函数</h4><ul><li>排序接口（所有排序类都会实现这个接口）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 排序接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对长度为n的数组中的元素进行升序排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [arr, n]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/12 20:24</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ascendSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造待排序的数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort.util;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 构造待排序的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomArray</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 生成长度为n的数组，并且数组元素的范围在rangeL~rangeR之间。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [n, rangeL, rangeR]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: int[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/12 20:27</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] generateRandomArray(<span class="keyword">int</span> n, <span class="keyword">int</span> rangeL, <span class="keyword">int</span> rangeR) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">if</span> (rangeL &lt;= rangeR) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                arr[i] = (<span class="keyword">int</span>) (Math.random() * (rangeR - rangeL + <span class="number">1</span>) + rangeL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"rangeL &gt; rangeR"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 生成近乎有序的长度为n的数组，并且可以自定义逆序对个数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [n, swapTimes]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: int[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/12 20:28</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] generateNearlyRandomArray(<span class="keyword">int</span> n, <span class="keyword">int</span> swapTimes) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; swapTimes; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = (<span class="keyword">int</span>) (Math.random() * n);</span><br><span class="line">            <span class="keyword">int</span> y = (<span class="keyword">int</span>) (Math.random() * n);</span><br><span class="line">            SortHelper.swap(arr, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>排序辅助函数<ul><li>方法一：验证数组是否有序（升序）</li><li>方法二：打印数组</li><li>方法三：交换数组中的元素</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort.util;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 排序辅助函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortHelper</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 验证数组是否有序(升序)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [arr, n]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: boolean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/12 22:31</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAscendingOrder</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 打印数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [arr, n]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/12 22:30</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 交换数组中的元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [arr, i, j]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/12 22:31</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试排序算法的性能<ul><li>函数入参：排序算法的名称、排序算法的实例、待排数组、待排数组的长度 </li><li>方法内部：调用对应的排序算法，并打印执行用时及排序算法的正确性。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sort.util.SortHelper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 测试排序算法的性能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 测试排序算法的性能，打印执行用时及排序的正确性。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [name, sort, arr, n]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/12 20:41</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSort</span><span class="params">(String name, Sort sort, <span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = Instant.now().toEpochMilli();</span><br><span class="line">        sort.ascendSort(arr, n);</span><br><span class="line">        <span class="keyword">long</span> end = Instant.now().toEpochMilli();</span><br><span class="line">        System.out.println(name + <span class="string">"用时: "</span> + (end - start) + <span class="string">"ms"</span>);</span><br><span class="line">        System.out.println(<span class="string">"排序后数组是否升序: "</span> +  SortHelper.isAscendingOrder(arr, n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③为什么要学习-O（n-2）-的排序算法？"><a href="#③为什么要学习-O（n-2）-的排序算法？" class="headerlink" title="③为什么要学习 O（n^2） 的排序算法？"></a>③为什么要学习 <code>O（n^2）</code> 的排序算法？</h4><blockquote><p><code>O（n^2）</code> 的排序算法：所消耗的时间和数据之间成平方关系。</p></blockquote><ol><li>基础。先用最简单的方法解决问题，能加深对问题本身的理解，进而优化或者衍生出更复杂的解法（希尔排序就是通过插入排序的思想进行优化衍生而来的）。</li><li>并不是所有场合都需要写 <code>O（n*logn）</code> 复杂度的排序算法。<code>O（n^2）</code> 复杂度的排序算法编码简单，易于实现，是一些简单情景的首选。</li><li>在一些特殊情况下，简单的排序算法更有效。</li><li>作为子过程，可以改进更复杂的排序算法。</li></ol><hr><h3 id="2-交换排序类-—-简单交换排序"><a href="#2-交换排序类-—-简单交换排序" class="headerlink" title="2.交换排序类 — 简单交换排序"></a>2.交换排序类 — 简单交换排序</h3><h4 id="①排序思路"><a href="#①排序思路" class="headerlink" title="①排序思路"></a>①排序思路</h4><ul><li>方法：每一个位置的关键字与其后的所有关键字依次做比较，大则交换。</li><li>结果：执行第 i 次外层 for 循环后，第 i - 1 个位置上的关键字一定小于其后的所有关键字，并且其后的其他关键字还保持着未排序前的相对顺序。</li><li>缺点：每执行一次外层 for 循环，虽然进行了很多次的交换操作，但是只能消除一个逆序对。</li></ul><h4 id="②代码演示"><a href="#②代码演示" class="headerlink" title="②代码演示"></a>②代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort.swapsort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sort.Sort;</span><br><span class="line"><span class="keyword">import</span> sort.util.SortHelper;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 交换排序类-简单交换排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSwapSort</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ascendSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 将索引i处的元素与其后的元素依次比较，若大于其后的元素就交换位置。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">                    SortHelper.swap(arr, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③性能分析"><a href="#③性能分析" class="headerlink" title="③性能分析"></a>③性能分析</h4><ul><li>稳定性：不稳定</li><li>是否是原地排序：是</li><li>平均时间复杂度：<code>O（n^2）</code></li><li>最好的情况：<code>O（n^2）</code>（顺序）</li><li>最坏的情况：<code>O（n^2）</code>（逆序）</li><li>空间复杂度：<code>O（1）</code></li></ul><hr><h3 id="3-交换排序类-—-冒泡排序"><a href="#3-交换排序类-—-冒泡排序" class="headerlink" title="3.交换排序类 — 冒泡排序"></a>3.交换排序类 — 冒泡排序</h3><h4 id="①排序思路-1"><a href="#①排序思路-1" class="headerlink" title="①排序思路"></a>①排序思路</h4><ul><li>方法：（从后向前）依次比较两个相邻的元素，前一个元素大则交换位置，这样较小的元素就如同气泡般慢慢浮到上面，所以称之为冒泡排序法。</li><li>传统的冒泡排序<ul><li>方法：依次两两比较（从后向前）并交换位置后，<code>arr[i]</code> 变为 <code>[i, n-1]</code> 区间里的最小值。若某次循环全程无交换，表明数组已经有序，提前退出循环。</li></ul></li><li>改进的冒泡排序<ul><li>方法： 记录最后一次的交换位置，在此之前的元素（已经有序）在下一轮扫描中均不考虑。</li></ul></li><li>优点：排序链表较为方便</li></ul><h4 id="②代码演示-1"><a href="#②代码演示-1" class="headerlink" title="②代码演示"></a>②代码演示</h4><ul><li>传统的冒泡排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort.swapsort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sort.Sort;</span><br><span class="line"><span class="keyword">import</span> sort.util.SortHelper;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 交换排序类-传统的冒泡排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ascendSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 依次两两比较并交换位置后，arr[i]变为[i, n-1]区间里的最小值。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    SortHelper.swap(arr, j, j - <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 标识一趟冒泡排序中发生了交换。</span></span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 全程无交换，表明数组已经有序。</span></span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>改进的冒泡排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort.swapsort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sort.Sort;</span><br><span class="line"><span class="keyword">import</span> sort.util.SortHelper;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 交换排序类-改进的冒泡排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvancedBubbleSort</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ascendSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 依次两两比较并交换位置后，arr[i]变为[i, n-1]区间里的最小值。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    SortHelper.swap(arr, j, j - <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 记录最后一次的交换位置，在此之前的元素(已经有序)在下一轮扫描中均不考虑。</span></span><br><span class="line">                    index = j - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③性能分析-1"><a href="#③性能分析-1" class="headerlink" title="③性能分析"></a>③性能分析</h4><ul><li>稳定性：稳定</li><li>是否是原地排序：是</li><li>平均时间复杂度：<code>O（n^2）</code></li><li>最好情况：<code>O（n）</code>（顺序）</li><li>最坏情况：<code>O（n^2）</code>（逆序）</li><li>空间复杂度：<code>O（1）</code></li><li>冒泡排序在各种情况下的性能都没有插入排序好</li></ul><hr><h3 id="4-选择排序类-—-简单选择排序"><a href="#4-选择排序类-—-简单选择排序" class="headerlink" title="4.选择排序类 — 简单选择排序"></a>4.选择排序类 — 简单选择排序</h3><h4 id="①排序思路-2"><a href="#①排序思路-2" class="headerlink" title="①排序思路"></a>①排序思路</h4><ul><li>方法：首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后再从剩余未排序序列中继续寻找最小元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</li><li>优点：所需移动元素的次数比较少</li><li>可以看做是简单交换排序的优化（每次找到最小值再交换）</li></ul><h4 id="②代码演示-2"><a href="#②代码演示-2" class="headerlink" title="②代码演示"></a>②代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort.selectsort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sort.Sort;</span><br><span class="line"><span class="keyword">import</span> sort.util.SortHelper;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 选择排序类-简单选择排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSelectSort</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ascendSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 寻找[i, n)区间里的最小值，其索引为minIndex。</span></span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            SortHelper.swap(arr, i, minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③性能分析-2"><a href="#③性能分析-2" class="headerlink" title="③性能分析"></a>③性能分析</h4><ul><li>稳定性：不稳定</li><li>是否是原地排序：是</li><li>平均时间复杂度：<code>O（n^2）</code></li><li>最好情况：<code>O（n^2）</code>（顺序）</li><li>最坏情况：<code>O（n^2）</code>（逆序）</li><li>空间复杂度：<code>O（1）</code></li></ul><hr><h3 id="5-插入排序类-—-直接插入排序"><a href="#5-插入排序类-—-直接插入排序" class="headerlink" title="5.插入排序类 — 直接插入排序"></a>5.插入排序类 — 直接插入排序</h3><h4 id="①排序思路-3"><a href="#①排序思路-3" class="headerlink" title="①排序思路"></a>①排序思路</h4><ul><li>方法：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。（类比整理扑克牌的思想）。</li><li>特点：<ul><li>在数组基本有序的情况下性能会非常高，远远优于选择排序，甚至比 <code>O（n*logn）</code> 级别的排序算法还要快，有重要的实际意义。</li><li>可以在更加复杂的排序算法中作为子过程来进行优化</li></ul></li><li>插入排序和选择排序的最大区别：对于内层循环，当找到插入位置时，插入排序可以提前结束。</li><li>插入排序和冒泡排序都需要消除逆序对，交换次数是一样的。</li></ul><h4 id="②代码演示-3"><a href="#②代码演示-3" class="headerlink" title="②代码演示"></a>②代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort.insertsort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sort.Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 插入排序类-直接插入排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectInsertSort</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ascendSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第1个元素(索引为0)默认有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 寻找元素e合适的插入位置</span></span><br><span class="line">            <span class="keyword">int</span> e = arr[i], j = i;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt; <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; e; j--) &#123;</span><br><span class="line">                <span class="comment">// 向后移出空位</span></span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到了合适的插入位置</span></span><br><span class="line">            arr[j] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③性能分析-3"><a href="#③性能分析-3" class="headerlink" title="③性能分析"></a>③性能分析</h4><ul><li>稳定性：稳定</li><li>是否是原地排序：是</li><li>平均时间复杂度：<code>O（n^2）</code></li><li>最好情况：<code>O（n）</code>（顺序）</li><li>最坏情况：<code>O（n^2）</code>（逆序）</li><li>空间复杂度：<code>O（1）</code></li></ul><hr><h3 id="6-插入排序类-—-希尔排序"><a href="#6-插入排序类-—-希尔排序" class="headerlink" title="6.插入排序类 — 希尔排序"></a>6.插入排序类 — 希尔排序</h3><h4 id="①排序思路-4"><a href="#①排序思路-4" class="headerlink" title="①排序思路"></a>①排序思路</h4><ul><li>定理 1：任意 n 个不同元素组成的序列平均具有 <code>n * (n - 1) / 4</code> 个逆序对。</li><li>定理 2：任何仅以交换相邻两个元素进行排序的算法（每次只能消去一个逆序对），其平均时间复杂度都为 <code>O（n^2）</code>。</li><li>这意味着想要提高排序算法的效率，我们每次必须消去不止一个逆序对，所以我们需要每次交换相隔较远的两个元素，此时就可以一次消去多个逆序对（希尔排序的思想）。</li><li>方法：先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。</li><li>步骤：<ol><li>定义增量序列（递减到 1）</li><li>对每个增量进行增量间隔的直接插入排序</li></ol></li><li>注意：<ul><li><code>&quot;Dk-间隔&quot;</code> 有序的序列，在执行 <code>&quot;Dk-1-间隔&quot;</code> 排序后，其 <code>&quot;Dk-间隔&quot;</code> 仍然是有序的。</li><li>为了保证结果有序，最后必须进行一次 1 间隔的排序（在进行 1 间隔的排序前，整个数组已经基本有序）。</li></ul></li><li>Hibbard 增量：<code>Dk = 2 ^ k - 1</code><ul><li>增量元素不互质，则小增量可能根本不起作用。</li><li>递推公式为：<code>D1 = 1、D2 = 3、D3 = 7、Dk = 2 * D(k − 1) + 1、D (k - 1) = (Dk - 1) / 2</code></li></ul></li><li>特点：<ul><li>是插入排序的改进版本，克服了插入排序每次只交换相邻两个元素的缺点。</li><li>实现起来比 <code>O（n*logn）</code> 级别的排序算法简单</li></ul></li></ul><h4 id="②代码演示-4"><a href="#②代码演示-4" class="headerlink" title="②代码演示"></a>②代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort.insertsort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sort.Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 插入排序类-希尔排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ascendSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Hibbard增量: Dk=2^k-1</span></span><br><span class="line">        <span class="comment">// 递推公式为: D1=1、D2=3、D3=7、Dk=2D(k−1)+1、D(k-1)=(Dk-1)/2</span></span><br><span class="line">        <span class="comment">// k     1 2 3 5  6</span></span><br><span class="line">        <span class="comment">// Dk(d) 1 3 7 15 31</span></span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (d &lt; n / <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">// D(k-1)-&gt;D(k)</span></span><br><span class="line">            d = d * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (d &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// d间隔的插入排序</span></span><br><span class="line">            <span class="comment">// 第1个元素(索引为0)默认有序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = d; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="comment">// 寻找元素e合适的插入位置</span></span><br><span class="line">                <span class="keyword">int</span> e = arr[i], j = i;</span><br><span class="line">                <span class="keyword">for</span> (; j &gt;= d &amp;&amp; arr[j - d] &gt; e; j -= d) &#123;</span><br><span class="line">                    <span class="comment">// 向后移出空位</span></span><br><span class="line">                    arr[j] = arr[j - d];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 找到了合适的插入位置</span></span><br><span class="line">                arr[j] = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// D(k)-&gt;D(k-1)</span></span><br><span class="line">            d = (d - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③性能分析-4"><a href="#③性能分析-4" class="headerlink" title="③性能分析"></a>③性能分析</h4><ul><li>稳定性：不稳定</li><li>是否是原地排序：是</li><li>平均时间复杂度：<code>O（n^5/4）</code></li><li>最好情况：<code>O（n^5/4）</code>（顺序）</li><li>最坏情况：<code>O（n^3/2）</code>（逆序）</li><li>空间复杂度：<code>O（1）</code></li></ul><hr><h3 id="7-归并排序类-—-归并排序"><a href="#7-归并排序类-—-归并排序" class="headerlink" title="7.归并排序类 — 归并排序"></a>7.归并排序类 — 归并排序</h3><h4 id="①排序思路-5"><a href="#①排序思路-5" class="headerlink" title="①排序思路"></a>①排序思路</h4><ul><li>方法：</li></ul><p><img src="./1584984701725.png" alt="Alt text"><br><img src="./1585049688207.png" alt="Alt text"></p><ul><li>归并排序（递归）<ul><li>归并层数：<code>logn</code> 层（二分法），每层要处理的元素个数是一样的。</li><li>每层的归并过程的时间复杂度为 <code>O（n）</code></li></ul></li><li>改进的归并排序（递归）<ul><li>优化 1：当 n 小到一定程度的时候，插入排序比归并排序快，此时用插入排序代替归并排序（元素很少时，数组近乎有序的可能性变大，插入排序有优势，排序的高级算法都可如此优化）。</li><li>优化 2：如果两部分各自有序，就不需要继续归并了。</li></ul></li><li>自底向上的归并排序（迭代）</li><li>改进的自底向上的归并排序（迭代）<ul><li>优化方法同 <strong>改进的归并排序（递归）</strong></li></ul></li><li>优点：<ul><li>适用于排序链表 </li><li>优化后的归并排序在排序近乎有序的数组时，速度也很快。</li></ul></li><li>缺点：空间复杂度为 <code>O（n）</code><ul><li>现代计算机中时间效率比空间效率重要的多，设计算法优先考虑时间复杂度，除非数据存储的空间是算法的重要瓶颈。</li></ul></li></ul><h4 id="②代码演示-5"><a href="#②代码演示-5" class="headerlink" title="②代码演示"></a>②代码演示</h4><ul><li>归并排序        </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort.mergesort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sort.Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 归并排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 归并两个有序部分(arr[l...mid]和arr[mid+1...r])</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [arr, l, mid, r]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/13 3:10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用临时空间辅助我们完成归并过程</span></span><br><span class="line">        <span class="keyword">int</span>[] aux = <span class="keyword">new</span> <span class="keyword">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            aux[i - l] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i和j分别指向两个有序部分的元素，k指向两个元素比较后小的那个元素的存储位置。</span></span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; k++) &#123;</span><br><span class="line">            <span class="comment">// 第一个有序部分已经遍历完成</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">                arr[k] = aux[j++ - l];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第二个有序部分已经遍历完成</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; r) &#123;</span><br><span class="line">                arr[k] = aux[i++ - l];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (aux[i - l] &gt; aux[j - l]) &#123;</span><br><span class="line">                arr[k] = aux[j++ - l];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[k] = aux[i++ - l];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对arr[l...r]部分进行归并排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [arr, l, r]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/13 3:10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 避免发生溢出，使用位运算。</span></span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        recursion(arr, l, mid);</span><br><span class="line">        recursion(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="comment">// 归并两个有序部分(arr[l...mid]和arr[mid+1...r])</span></span><br><span class="line">        merge(arr, l, mid, r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ascendSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        recursion(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>改进的归并排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort.mergesort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sort.Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 归并排序-改进的归并排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvancedMergeSort</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对arr[l...r]部分进行插入排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [arr, l, r]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/13 0:10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第1个元素(索引为l)默认有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="comment">// 寻找元素e合适的插入位置</span></span><br><span class="line">            <span class="keyword">int</span> e = arr[i], j = i;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt; l &amp;&amp; arr[j - <span class="number">1</span>] &gt; e; j--) &#123;</span><br><span class="line">                <span class="comment">// 向后移出空位</span></span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到了合适的插入位置</span></span><br><span class="line">            arr[j] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 归并两个有序部分(arr[l...mid]和arr[mid+1...r])</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [arr, l, mid, r]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/13 3:10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用临时空间辅助我们完成归并过程</span></span><br><span class="line">        <span class="keyword">int</span>[] aux = <span class="keyword">new</span> <span class="keyword">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            aux[i - l] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i和j分别指向两个有序部分的元素，k指向两个元素比较后小的那个元素的存储位置。</span></span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; k++) &#123;</span><br><span class="line">            <span class="comment">// 第一个有序部分已经遍历完成</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">                arr[k] = aux[j++ - l];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第二个有序部分已经遍历完成</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; r) &#123;</span><br><span class="line">                arr[k] = aux[i++ - l];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (aux[i - l] &gt; aux[j - l]) &#123;</span><br><span class="line">                arr[k] = aux[j++ - l];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[k] = aux[i++ - l];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对arr[l...r]部分进行归并排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [arr, l, r]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/13 10:16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 优化1: 当n小到一定程度时，插入排序比归并排序快，此时用插入排序代替归并排序。</span></span><br><span class="line">        <span class="keyword">if</span> (r - l &lt;= <span class="number">15</span>) &#123;</span><br><span class="line">            sort(arr, l, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 避免发生溢出，使用位运算。</span></span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        recursion(arr, l, mid);</span><br><span class="line">        recursion(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="comment">// 优化2: 如果两部分各自有序，就不需要继续归并了。</span></span><br><span class="line">        <span class="keyword">if</span> (arr[mid + <span class="number">1</span>] &lt; arr[mid]) &#123;</span><br><span class="line">            merge(arr, l, mid, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ascendSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        recursion(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自底向上的归并排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort.mergesort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sort.Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 归并排序-自底向上的归并排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IterationMergeSort</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ascendSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// i: 1、2、4、8...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + i &lt; n; j += i + i) &#123;</span><br><span class="line">                <span class="comment">// 对arr[j...j+i-1]和arr[j+i...j+i+i-1]进行归并</span></span><br><span class="line">                AdvancedMergeSort.merge(arr, j, j + i - <span class="number">1</span>, Math.min(j + i + i - <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>改进的自底向上的归并排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort.mergesort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sort.Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/3/13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 归并排序-改进的自底向上的归并排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvancedIterationMergeSort</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对arr[l...r]部分进行插入排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [arr, l, r]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/13 0:10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第1个元素(索引为l)默认有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="comment">// 寻找元素e合适的插入位置</span></span><br><span class="line">            <span class="keyword">int</span> e = arr[i], j = i;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt; l &amp;&amp; arr[j - <span class="number">1</span>] &gt; e; j--) &#123;</span><br><span class="line">                <span class="comment">// 向后移出空位</span></span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到了合适的插入位置</span></span><br><span class="line">            arr[j] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ascendSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 优化1: 当n小到一定程度时，插入排序比归并排序快，此时用插入排序代替归并排序。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">16</span>) &#123;</span><br><span class="line">            sort(arr, i, Math.min(i + <span class="number">15</span>, n - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i: 16、32、64...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">16</span>; i &lt;= n; i += i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + i &lt; n; j += i + i) &#123;</span><br><span class="line">                <span class="comment">// 优化2: 如果两部分各自有序，就不需要继续归并了。</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j + i - <span class="number">1</span>] &gt; arr[j + i]) &#123;</span><br><span class="line">                    AdvancedMergeSort.merge(arr, j, j + i - <span class="number">1</span>, Math.min(j + i + i - <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③性能分析-5"><a href="#③性能分析-5" class="headerlink" title="③性能分析"></a>③性能分析</h4><ul><li>稳定性：稳定</li><li>是否是原地排序：否</li><li>平均时间复杂度：<code>O（n*logn）</code></li><li>最好情况：<code>O（n*logn）</code>（顺序）</li><li>最坏情况：<code>O（n*logn）</code>（逆序）</li><li>空间复杂度：<code>O（n）</code></li></ul><h4 id="④衍生问题-—-求一个数组中逆序对的数量"><a href="#④衍生问题-—-求一个数组中逆序对的数量" class="headerlink" title="④衍生问题 — 求一个数组中逆序对的数量"></a>④衍生问题 — 求一个数组中逆序对的数量</h4><ul><li>我们再来复习一下什么是逆序对：对于下标 <code>i &lt; j</code>，如果 <code>A[i] &gt; A[j]</code>，则称 <code>(i, j)</code> 是一个逆序对。</li><li>数组中逆序对的数量可以衡量一个数组的有序程度。</li><li>方法一（<code>O（n^2）</code>）：使用双重循环考察每一个数对，暴力解法。</li><li>方法二（<code>O（n*logn）</code>）：归并排序的思路求逆序对的个数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort.derivedquestion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sort.util.RandomArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 归并排序的思路求逆序对的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReversePairsNumber</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 求出在arr[l...mid]和arr[mid+1...r]有序的基础上，arr[l...r]的逆序数对个数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [arr, l, mid, r]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: long</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/13 11:42</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化逆序对个数</span></span><br><span class="line">        <span class="keyword">long</span> number = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 使用临时空间辅助我们完成归并过程</span></span><br><span class="line">        <span class="keyword">int</span>[] aux = <span class="keyword">new</span> <span class="keyword">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            aux[i - l] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i和j分别指向两个有序部分的元素，k指向两个元素比较后小的那个元素的存储位置。</span></span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; k++) &#123;</span><br><span class="line">            <span class="comment">// 第一个有序部分已经遍历完成</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">                arr[k] = aux[j++ - l];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第二个有序部分已经遍历完成</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; r) &#123;</span><br><span class="line">                arr[k] = aux[i++ - l];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (aux[i - l] &gt; aux[j - l]) &#123;</span><br><span class="line">                <span class="comment">// aux[j-l]&lt;aux[i-l]，说明aux[i-l...mid]之间的所有元素都与aux[j-1]构成了逆序对。</span></span><br><span class="line">                arr[k] = aux[j++ - l];</span><br><span class="line">                number += (<span class="keyword">long</span>) (mid - i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[k] = aux[i++ - l];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对arr[l...r]部分进行归并排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [arr, l, r]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: long</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/13 11:14</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 避免发生溢出，使用位运算。</span></span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> number1 = recursion(arr, l, mid);</span><br><span class="line">        <span class="keyword">long</span> number2 = recursion(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> number1 + number2 + merge(arr, l, mid, r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">ascendSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recursion(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1000</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.测试完全有序的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = RandomArray.generateNearlyRandomArray(n, <span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">"测试完全有序的数组: "</span> + <span class="keyword">new</span> ReversePairsNumber().ascendSort(arr, n));</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 2.测试逆序的数组(正确答案: n*(n-1)/2)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[n - i - <span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"测试逆序的数组: "</span> + <span class="keyword">new</span> ReversePairsNumber().ascendSort(arr, n));</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 3.测试随机数组</span></span><br><span class="line">        arr = RandomArray.generateNearlyRandomArray(n, <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"测试随机数组: "</span> + <span class="keyword">new</span> ReversePairsNumber().ascendSort(arr, n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1584073399794.png" alt="Alt text"></p><hr><h3 id="8-交换排序类-—-快速排序"><a href="#8-交换排序类-—-快速排序" class="headerlink" title="8.交换排序类 — 快速排序"></a>8.交换排序类 — 快速排序</h3><h4 id="①排序思路-6"><a href="#①排序思路-6" class="headerlink" title="①排序思路"></a>①排序思路</h4><ul><li>快速排序<ul><li>20 世纪对世界影响最大的算法之一</li><li>方法：</li></ul></li></ul><p><img src="./1585011313908.png" alt="Alt text"></p><ul><li>普通快速排序<ul><li>所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的元素可以放到任何一边）</li><li>基准值如何选取：选择数列中的第一个元素 </li><li>未优化的快速排序在排序随机数组时就已经快于归并排序，但是在排序近乎有序的数组时会非常慢。</li></ul></li></ul><p><img src="./1585049592057.png" alt="Alt text"></p><ul><li>改进的快速排序<ul><li>优化 1：当 n 小到一定程度时，插入排序比快速排序快，此时用插入排序代替快速排序。</li><li>优化 2：每次随机选择数列中的一个元素作为基准。此时快速排序的最坏情况的时间复杂度依然是 <code>O（n^2）</code> ，但是退化到 <code>O（n^2）</code> 的概率极低。优化后，针对数字范围很小的数组，依然会非常慢（递归树不平衡，当数组有大量重复键值时，很大概率会将数组分成极不平衡的两部分）。</li></ul></li><li>双路快速排序<ul><li>方法：将与基准值相等的元素分散到左右两部分</li><li>优化后在排序近乎有序的数组时也会比归并排序快</li></ul></li></ul><p><img src="./1585049759801.png" alt="Alt text"></p><ul><li>三路快速排序<ul><li>方法：将与基准值相等的元素放在中间，下次递归时直接不用处理等于基准值的元素（它们已经在正确的位置上了）。</li><li>在存在大量重复键值的情况下，远远快于其他排序，其他情况稍微慢于二路快速排序。</li></ul></li></ul><p><img src="./1585049835421.png" alt="Alt text"></p><ul><li>归并排序与快速排序的比较<ul><li>都使用了分治算法的基本思想（分治算法：顾名思义，分而治之，就是将原问题分割成同等结构的子问题，再将子问题逐一解决后，原问题也就得到了解决。）</li><li>归并排序的重点在于治，快速排序的重点在于分。</li><li>归并排序可以保证每次都将数组平均一分为二，快速排序则无法保证。所以快速排序调用递归的过程所生成的递归树比归并排序的差，且不能完全保证递归树的高度是 <code>logn</code>，最坏情况下递归树的高度是 <code>O（n）</code>（当数组近乎有序时）。 </li><li><code>nlogn</code> 级别的排序算法也有常数上的差异，快速排序相对占优。</li></ul></li><li>归并排序与快速排序的选择<ul><li>一般系统级别的排序，都是使用快速排序实现的。</li><li>如果一个系统对空间相对敏感，归并排序就不适合。</li><li>在系统级别的类库中，若想实现稳定的排序，通常选择的是归并排序。但是也可以通过自定义比较函数，使排序算法不存在稳定性的问题。</li></ul></li><li>缺点：空间复杂度为 <code>O（logn）</code>，有 <code>logn</code> 层栈空间来保存每一层递归过程中的临时变量，以供递归返回时调用。</li></ul><h4 id="②代码演示-6"><a href="#②代码演示-6" class="headerlink" title="②代码演示"></a>②代码演示</h4><ul><li>快速排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort.swapsort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sort.Sort;</span><br><span class="line"><span class="keyword">import</span> sort.util.SortHelper;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 交换排序类-快速排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对arr[l...r]部分进行partition操作</span></span><br><span class="line"><span class="comment">     * 返回index，使得arr[l...index-1] &lt; arr[index]、arr[index+1...r] &gt;= arr[index]。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [arr, l, r]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: int</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/13 11:10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用数组的第一个元素作为分界的标志点</span></span><br><span class="line">        <span class="keyword">int</span> value = arr[l], j = l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; value) &#123;</span><br><span class="line">                SortHelper.swap(arr, i, ++j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将value移到分界处</span></span><br><span class="line">        SortHelper.swap(arr, l, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对arr[l...r]部分进行快速排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [arr, l, r]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/13 11:10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = partition(arr, l, r);</span><br><span class="line">        recursion(arr, l, index - <span class="number">1</span>);</span><br><span class="line">        recursion(arr, index + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ascendSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        recursion(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>改进的快速排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort.swapsort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sort.Sort;</span><br><span class="line"><span class="keyword">import</span> sort.util.SortHelper;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 交换排序类-改进的快速排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvancedQuickSort</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对arr[l...r]部分进行插入排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [arr, l, r]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/13 0:10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第1个元素(索引为l)默认有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="comment">// 寻找元素e合适的插入位置</span></span><br><span class="line">            <span class="keyword">int</span> e = arr[i], j = i;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt; l &amp;&amp; arr[j - <span class="number">1</span>] &gt; e; j--) &#123;</span><br><span class="line">                <span class="comment">// 向后移出空位</span></span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到了合适的插入位置</span></span><br><span class="line">            arr[j] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对arr[l...r]部分进行partition操作</span></span><br><span class="line"><span class="comment">     * 返回index，使得arr[l...index-1] &lt; arr[index]、arr[index+1...r] &gt;= arr[index]。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [arr, l, r]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: int</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/13 11:05</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 优化2: 使用数组中的随机元素作为分界的标志点</span></span><br><span class="line">        SortHelper.swap(arr, l, (<span class="keyword">int</span>) (Math.random() * (r - l + <span class="number">1</span>) + l));</span><br><span class="line">        <span class="keyword">int</span> value = arr[l], j = l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; value) &#123;</span><br><span class="line">                SortHelper.swap(arr, i, ++j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将value移到分界处</span></span><br><span class="line">        SortHelper.swap(arr, l, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对arr[l...r]部分进行快速排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [arr, l, r]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/13 11:04</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 优化1: 当n小到一定程度时，插入排序比快速排序快，此时用插入排序代替快速排序。</span></span><br><span class="line">        <span class="keyword">if</span> (r - l &lt;= <span class="number">15</span>) &#123;</span><br><span class="line">            sort(arr, l, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = partition(arr, l, r);</span><br><span class="line">        recursion(arr, l, index - <span class="number">1</span>);</span><br><span class="line">        recursion(arr, index + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ascendSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        recursion(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>双路快速排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort.swapsort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sort.Sort;</span><br><span class="line"><span class="keyword">import</span> sort.util.SortHelper;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 交换排序类-双路快速排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort2Ways</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对arr[l...r]部分进行插入排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [arr, l, r]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/13 0:10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第1个元素(索引为l)默认有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="comment">// 寻找元素e合适的插入位置</span></span><br><span class="line">            <span class="keyword">int</span> e = arr[i], j = i;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt; l &amp;&amp; arr[j - <span class="number">1</span>] &gt; e; j--) &#123;</span><br><span class="line">                <span class="comment">// 向后移出空位</span></span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到了合适的插入位置</span></span><br><span class="line">            arr[j] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 返回index，使得arr[l...index-1] &lt;= arr[index]、arr[index+1...r] &gt;= arr[index]。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [arr, l, r]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: int</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/13 22:34</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        SortHelper.swap(arr, l, (<span class="keyword">int</span>) (Math.random() * (r - l + <span class="number">1</span>) + l));</span><br><span class="line">        <span class="keyword">int</span> value = arr[l];</span><br><span class="line">        <span class="comment">// arr[l...i) &lt;= v、arr[j...r] &gt;= v</span></span><br><span class="line">        <span class="keyword">int</span> i = l + <span class="number">1</span>, j = r;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= r &amp;&amp; arr[i] &lt; value) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; l &amp;&amp; arr[j] &gt; value) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 此时arr[i] &gt; value &amp;&amp; arr[j] &lt; value，所以直接交换它们的位置。</span></span><br><span class="line">                SortHelper.swap(arr, i++, j--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将value移到分界处</span></span><br><span class="line">        SortHelper.swap(arr, l, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对arr[l...r]部分进行双路快速排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [arr, l, r]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/13 11:08</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r - l &lt;= <span class="number">15</span>) &#123;</span><br><span class="line">            sort(arr, l, r);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = partition(arr, l, r);</span><br><span class="line">        recursion(arr, l, index - <span class="number">1</span>);</span><br><span class="line">        recursion(arr, index + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ascendSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        recursion(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>三路快速排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort.swapsort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sort.Sort;</span><br><span class="line"><span class="keyword">import</span> sort.util.SortHelper;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 交换排序类-三路快速排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort3Ways</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对arr[l...r]部分进行插入排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [arr, l, r]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/13 0:10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第1个元素(索引为l)默认有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="comment">// 寻找元素e合适的插入位置</span></span><br><span class="line">            <span class="keyword">int</span> e = arr[i], j = i;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt; l &amp;&amp; arr[j - <span class="number">1</span>] &gt; e; j--) &#123;</span><br><span class="line">                <span class="comment">// 向后移出空位</span></span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到了合适的插入位置</span></span><br><span class="line">            arr[j] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对arr[l...r]部分进行三路快速排序</span></span><br><span class="line"><span class="comment">     * 将arr[l...r]分为 &lt; value、== value、&gt; value 三部分。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [arr, l, r]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/13 11:09</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r - l &lt;= <span class="number">15</span>) &#123;</span><br><span class="line">            sort(arr, l, r);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// partition</span></span><br><span class="line">        SortHelper.swap(arr, l, (<span class="keyword">int</span>) (Math.random() * (r - l + <span class="number">1</span>) + l));</span><br><span class="line">        <span class="comment">// arr[l+1...lt] &lt; v、arr[lt+1...gt-1] == v、arr[gt...r] &gt; v。</span></span><br><span class="line">        <span class="keyword">int</span> value = arr[l], lt = l, gt = r + <span class="number">1</span>, i = l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; gt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; value) &#123;</span><br><span class="line">                <span class="comment">// 交换过来的arr[++lt]已经处理过，需要i++。</span></span><br><span class="line">                SortHelper.swap(arr, i++, ++lt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; value) &#123;</span><br><span class="line">                <span class="comment">// 交换过来的arr[--gt]没有处理过，不需要i++。</span></span><br><span class="line">                SortHelper.swap(arr, i, --gt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将value移到分界处</span></span><br><span class="line">        SortHelper.swap(arr, l, lt);</span><br><span class="line">        recursion(arr, l, lt - <span class="number">1</span>);</span><br><span class="line">        recursion(arr, gt, r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ascendSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        recursion(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③性能分析-6"><a href="#③性能分析-6" class="headerlink" title="③性能分析"></a>③性能分析</h4><ul><li>稳定性：不稳定</li><li>是否是原地排序：否</li><li>平均时间复杂度：<code>O（n*logn）</code></li><li>最好情况：<code>O（n*logn）</code>（顺序）</li><li>最坏情况：<code>O（n^2）</code>（逆序）</li><li>空间复杂度：<code>O（logn）</code>（递归）</li></ul><h4 id="④衍生问题-—-取数组中第-N-小的元素"><a href="#④衍生问题-—-取数组中第-N-小的元素" class="headerlink" title="④衍生问题 — 取数组中第 N 小的元素"></a>④衍生问题 — 取数组中第 N 小的元素</h4><p>方法一（<code>O（n^2）</code>）：排序后求解<br>方法二（<code>O（n*logn）</code>）：快速排序的思路求解数组中第 N 小的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort.derivedquestion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sort.util.RandomArray;</span><br><span class="line"><span class="keyword">import</span> sort.util.SortHelper;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 求解数组中第N小的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopNByQuickSort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对arr[l...r]部分进行partition操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [arr, l, r]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: int</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/13 23:30</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        SortHelper.swap(arr, l, (<span class="keyword">int</span>) (Math.random() * (r - l + <span class="number">1</span>) + l));</span><br><span class="line">        <span class="keyword">int</span> value = arr[l], j = l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; value) &#123;</span><br><span class="line">                SortHelper.swap(arr, i, ++j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将value移到分界处</span></span><br><span class="line">        SortHelper.swap(arr, l, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 对arr[l...r]部分进行快速排序，并寻找数组中第N小的元素。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [arr, l, r, N]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: int</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/13 23:31</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = partition(arr, l, r), number = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (index == N) &#123;</span><br><span class="line">            number = arr[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; N) &#123;</span><br><span class="line">            number = recursion(arr, l, index - <span class="number">1</span>, N);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            number = recursion(arr, index + <span class="number">1</span>, r, N);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">5</span>, N = (<span class="keyword">int</span>) (Math.random() * n) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr = RandomArray.generateRandomArray(n, <span class="number">0</span>, n);</span><br><span class="line">        SortHelper.printArray(arr, n);</span><br><span class="line">        System.out.println(<span class="string">"数组中第"</span> + N + <span class="string">"小的元素是: "</span> + recursion(arr, <span class="number">0</span>, n - <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1584114251505.png" alt="Alt text"><br><img src="./1584114278671.png" alt="Alt text"><br><img src="./1584114302853.png" alt="Alt text"></p><hr><h3 id="9-选择排序类-—-堆排序"><a href="#9-选择排序类-—-堆排序" class="headerlink" title="9.选择排序类 — 堆排序"></a>9.选择排序类 — 堆排序</h3><ul><li>基础的最大堆的构建和使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> heap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sort.util.SortHelper;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 最大堆(arr[1]处存储最大堆的第一个元素)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 向上调整最大堆(入队时调用)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [index]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/14 7:44</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 防止越界</span></span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">1</span> &amp;&amp; arr[index / <span class="number">2</span>] &lt; arr[index]) &#123;</span><br><span class="line">            SortHelper.swap(arr, index / <span class="number">2</span>, index);</span><br><span class="line">            index /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 向下调整最大堆(出队时调用)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [index]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/14 7:44</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否有左孩子</span></span><br><span class="line">        <span class="keyword">while</span> (index * <span class="number">2</span> &lt;= count) &#123;</span><br><span class="line">            <span class="comment">// 哪个孩子大，就和哪个孩子交换。</span></span><br><span class="line">            <span class="keyword">int</span> lc = index * <span class="number">2</span>, rc = lc + <span class="number">1</span>, res = lc;</span><br><span class="line">            <span class="keyword">if</span> (rc &lt;= count &amp;&amp; arr[rc] &gt; arr[lc]) &#123;</span><br><span class="line">                res = rc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[index] &gt;= arr[res]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            SortHelper.swap(arr, index, res);</span><br><span class="line">            index = res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 判断最大堆是否为空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: boolean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/14 7:49</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 打印最大堆</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/14 7:50</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printArr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 入队</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [e]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/14 10:14</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count + <span class="number">1</span> &gt; capacity) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[++count] = e;</span><br><span class="line">        shiftUp(count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 出队</span></span><br><span class="line"><span class="comment">     * 最大堆中只能取出根节点</span></span><br><span class="line"><span class="comment">     * 为了维持完全二叉树的性质，将堆中最后一个元素移到根节点的位置，然后向下调整最大堆。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: int</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/14 7:44</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">1</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出根节点</span></span><br><span class="line">        <span class="keyword">int</span> e = arr[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 将堆中最后一个元素移到根节点的位置</span></span><br><span class="line">        SortHelper.swap(arr, <span class="number">1</span>, count--);</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>改进的最大堆的构建和使用 1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> heap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sort.util.SortHelper;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 改进的最大堆1(arr[1]处存储最大堆的第一个元素)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvancedMaxHeap1</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AdvancedMaxHeap1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 向上调整最大堆(入队时调用)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [index]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/14 7:44</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> e = arr[index];</span><br><span class="line">        <span class="comment">// 防止越界</span></span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">1</span> &amp;&amp; arr[index / <span class="number">2</span>] &lt; e) &#123;</span><br><span class="line">            <span class="comment">// 优化1: 使用赋值操作代替交换操作</span></span><br><span class="line">            arr[index] = arr[index / <span class="number">2</span>];</span><br><span class="line">            index /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[index] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 向下调整最大堆(出队时调用)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [index]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/14 7:44</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> e = arr[index];</span><br><span class="line">        <span class="comment">// 判断是否有左孩子</span></span><br><span class="line">        <span class="keyword">while</span> (index * <span class="number">2</span> &lt;= count) &#123;</span><br><span class="line">            <span class="comment">// 哪个孩子大，就和哪个孩子交换。</span></span><br><span class="line">            <span class="keyword">int</span> lc = index * <span class="number">2</span>, rc = lc + <span class="number">1</span>, res = lc;</span><br><span class="line">            <span class="keyword">if</span> (rc &lt;= count &amp;&amp; arr[rc] &gt; arr[lc]) &#123;</span><br><span class="line">                res = rc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e &gt;= arr[res]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 优化1: 使用赋值操作代替交换操作</span></span><br><span class="line">            arr[index] = arr[res];</span><br><span class="line">            index = res;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[index] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 判断最大堆是否为空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: boolean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/14 7:49</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 打印最大堆</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/14 7:50</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printArr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 入队</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [e]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/14 10:14</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count + <span class="number">1</span> &gt; capacity) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[++count] = e;</span><br><span class="line">        shiftUp(count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 出队</span></span><br><span class="line"><span class="comment">     * 最大堆中只能取出根节点</span></span><br><span class="line"><span class="comment">     * 为了维持完全二叉树的性质，将堆中最后一个元素移到根节点的位置，然后向下调整最大堆。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: int</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/14 7:44</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">1</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出根节点</span></span><br><span class="line">        <span class="keyword">int</span> e = arr[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 将堆中最后一个元素移到根节点的位置</span></span><br><span class="line">        SortHelper.swap(arr, <span class="number">1</span>, count--);</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>改进的最大堆的构建和使用 2</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> heap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sort.util.SortHelper;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 改进的最大堆2(arr[1]处存储最大堆的第一个元素)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvancedMaxHeap2</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 优化2: 修改构造函数，直接向下调整最大堆。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AdvancedMaxHeap2</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[i + <span class="number">1</span>] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        count = n;</span><br><span class="line">        <span class="comment">// heapify: 将数组原地构建成最大堆</span></span><br><span class="line">        <span class="comment">// 所有的叶子节点本身就是一个最大堆，所以我们从第一个不是叶子节点的节点开始调整堆。</span></span><br><span class="line">        <span class="comment">// 对于一颗完全二叉树来说，第一个非叶子节点的索引: count/2。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = count / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            shiftDown(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 向下调整最大堆(出队时调用)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [index]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/14 7:44</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> e = arr[index];</span><br><span class="line">        <span class="comment">// 判断是否有左孩子</span></span><br><span class="line">        <span class="keyword">while</span> (index * <span class="number">2</span> &lt;= count) &#123;</span><br><span class="line">            <span class="comment">// 哪个孩子大，就和哪个孩子交换。</span></span><br><span class="line">            <span class="keyword">int</span> lc = index * <span class="number">2</span>, rc = lc + <span class="number">1</span>, res = lc;</span><br><span class="line">            <span class="keyword">if</span> (rc &lt;= count &amp;&amp; arr[rc] &gt; arr[lc]) &#123;</span><br><span class="line">                res = rc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e &gt;= arr[res]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 优化1: 使用赋值操作代替交换操作</span></span><br><span class="line">            arr[index] = arr[res];</span><br><span class="line">            index = res;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[index] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 判断最大堆是否为空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: boolean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/14 7:49</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 打印最大堆</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/14 7:50</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printArr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 出队</span></span><br><span class="line"><span class="comment">     * 最大堆中只能取出根节点</span></span><br><span class="line"><span class="comment">     * 为了维持完全二叉树的性质，将堆中最后一个元素移到根节点的位置，然后向下调整最大堆。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: int</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/14 7:44</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">1</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出根节点</span></span><br><span class="line">        <span class="keyword">int</span> e = arr[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 将堆中最后一个元素移到根节点的位置</span></span><br><span class="line">        SortHelper.swap(arr, <span class="number">1</span>, count--);</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试最大堆的构建和使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> heap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 测试最大堆的构建和使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMaxHeap</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">"----------测试MaxHeap类----------"</span>);</span><br><span class="line">        MaxHeap maxHeap = <span class="keyword">new</span> MaxHeap(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            maxHeap.insert((<span class="keyword">int</span>) (Math.random() * <span class="number">20</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!maxHeap.isEmpty()) &#123;</span><br><span class="line">            System.out.print(maxHeap.removeMax() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">"----------测试AdvancedMaxHeap1类----------"</span>);</span><br><span class="line">        AdvancedMaxHeap1 advancedMaxHeap1 = <span class="keyword">new</span> AdvancedMaxHeap1(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            advancedMaxHeap1.insert((<span class="keyword">int</span>) (Math.random() * <span class="number">20</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!advancedMaxHeap1.isEmpty()) &#123;</span><br><span class="line">            System.out.print(advancedMaxHeap1.removeMax() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">"----------测试AdvancedMaxHeap2类----------"</span>);</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[i] = ((<span class="keyword">int</span>) (Math.random() * <span class="number">20</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        AdvancedMaxHeap2 advancedMaxHeap2 = <span class="keyword">new</span> AdvancedMaxHeap2(arr, n);</span><br><span class="line">        <span class="keyword">while</span> (!advancedMaxHeap2.isEmpty()) &#123;</span><br><span class="line">            System.out.print(advancedMaxHeap2.removeMax() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1584161928720.png" alt="Alt text"></p><h4 id="①排序思路-7"><a href="#①排序思路-7" class="headerlink" title="①排序思路"></a>①排序思路</h4><ul><li>堆最重要的应用是对动态数据的维护</li><li>方法：</li></ul><p><img src="./1585011996003.png" alt="Alt text"><br><img src="./1585011877182.png" alt="Alt text"></p><ul><li>堆排序：<ul><li>方法：将 n 个元素逐个插入到一个空堆（最大堆，<code>arr[1]</code> 处存储最大堆的第一个元素）中，算法的时间复杂度是 <code>O（n*logn）</code>，然后将堆中的元素逐个移出，使用额外的空间从后向前存放取出的元素。</li><li>未优化的堆排序慢于快速排序和归并排序</li><li>缺点：空间复杂度为 <code>O（n）</code></li></ul></li></ul><p><img src="./1585049905871.png" alt="Alt text"></p><ul><li>改进的堆排序 1：<ul><li>优化 1：使用赋值操作代替交换操作</li><li>优化 2：将数组原地构建成最大堆（只需要处理 n / 2 个元素）</li><li>优化建堆的堆排序整体速度慢于快速排序和归并排序。</li></ul></li><li>改进的堆排序 2：<ul><li>原地堆排序，<code>arr[0]</code> 处存储最大堆的第一个元素。</li><li>不占用额外空间的堆排序比占用额外空间的堆排序快一点</li></ul></li></ul><p><img src="./1585050001526.png" alt="Alt text"></p><h4 id="②代码演示-7"><a href="#②代码演示-7" class="headerlink" title="②代码演示"></a>②代码演示</h4><ul><li>堆排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort.selectsort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> heap.AdvancedMaxHeap1;</span><br><span class="line"><span class="keyword">import</span> sort.Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 选择排序类-堆排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ascendSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        AdvancedMaxHeap1 advancedMaxHeap1 = <span class="keyword">new</span> AdvancedMaxHeap1(n);</span><br><span class="line">        <span class="comment">// 构建最大堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            advancedMaxHeap1.insert(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 堆排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            arr[i] = advancedMaxHeap1.removeMax();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>改进的堆排序 1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort.selectsort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> heap.AdvancedMaxHeap2;</span><br><span class="line"><span class="keyword">import</span> sort.Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 选择排序类-改进的堆排序1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvancedHeapSort1</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ascendSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        AdvancedMaxHeap2 advancedMaxHeap2 = <span class="keyword">new</span> AdvancedMaxHeap2(arr, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            arr[i] = advancedMaxHeap2.removeMax();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>改进的堆排序 2</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort.selectsort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sort.Sort;</span><br><span class="line"><span class="keyword">import</span> sort.util.SortHelper;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 选择排序类-改进的堆排序2(原地堆排序、arr[0]处存储最大堆的第一个元素)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvancedHeapSort2</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 向下调整最大堆(出队时调用)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [arr, n, index]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/14 11:17</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> e = arr[index];</span><br><span class="line">        <span class="comment">// 判断是否有左孩子</span></span><br><span class="line">        <span class="keyword">while</span> (index * <span class="number">2</span> + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 哪个孩子大，就和哪个孩子交换。</span></span><br><span class="line">            <span class="keyword">int</span> lc = index * <span class="number">2</span> + <span class="number">1</span>, rc = lc + <span class="number">1</span>, res = lc;</span><br><span class="line">            <span class="keyword">if</span> (rc &lt; n &amp;&amp; arr[rc] &gt; arr[lc]) &#123;</span><br><span class="line">                res = rc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e &gt;= arr[res]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[index] = arr[res];</span><br><span class="line">            index = res;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[index] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ascendSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// heapify: 将数组原地构建成最大堆</span></span><br><span class="line">        <span class="comment">// 最后一个非叶子节点的索引计算: (最后一个元素索引值-1)/2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (n - <span class="number">1</span> - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            shiftDown(arr, n, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最大堆中第一个元素即是数组中的最大值，每次将堆中第一个元素与数组末尾的元素交换，再动态维护堆(数组长度-1)。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 将当前最大堆中的最大值移到数组末尾</span></span><br><span class="line">            SortHelper.swap(arr, <span class="number">0</span>, i);</span><br><span class="line">            <span class="comment">// 重新构建最大堆</span></span><br><span class="line">            shiftDown(arr, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③性能分析-7"><a href="#③性能分析-7" class="headerlink" title="③性能分析"></a>③性能分析</h4><ul><li>稳定性：不稳定</li><li>是否是原地排序：是</li><li>平均时间复杂度：<code>O（n*logn）</code></li><li>最好的情况：<code>O（n*logn）</code>（顺序）</li><li>最坏的情况：<code>O（n*logn）</code>（逆序）</li><li>空间复杂度：<code>O（1）</code></li></ul><hr><h3 id="10-性能比较"><a href="#10-性能比较" class="headerlink" title="10.性能比较"></a>10.性能比较</h3><h4 id="①排序随机数组"><a href="#①排序随机数组" class="headerlink" title="①排序随机数组"></a>①排序随机数组</h4><ul><li>测试各个排序算法针对随机数组的排序性能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sort.insertsort.DirectInsertSort;</span><br><span class="line"><span class="keyword">import</span> sort.insertsort.ShellSort;</span><br><span class="line"><span class="keyword">import</span> sort.mergesort.AdvancedIterationMergeSort;</span><br><span class="line"><span class="keyword">import</span> sort.mergesort.AdvancedMergeSort;</span><br><span class="line"><span class="keyword">import</span> sort.mergesort.IterationMergeSort;</span><br><span class="line"><span class="keyword">import</span> sort.mergesort.MergeSort;</span><br><span class="line"><span class="keyword">import</span> sort.selectsort.AdvancedHeapSort1;</span><br><span class="line"><span class="keyword">import</span> sort.selectsort.AdvancedHeapSort2;</span><br><span class="line"><span class="keyword">import</span> sort.selectsort.HeapSort;</span><br><span class="line"><span class="keyword">import</span> sort.selectsort.SimpleSelectSort;</span><br><span class="line"><span class="keyword">import</span> sort.swapsort.*;</span><br><span class="line"><span class="keyword">import</span> sort.util.RandomArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 测试各个排序算法针对随机数组的排序性能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRandomArray</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----------随机数组的长度是1000，范围是0~1000。----------"</span>);</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 随机数组的长度是1000，范围是0~1000。</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = RandomArray.generateRandomArray(n, <span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">        TestSort.testSort(<span class="string">"简单交换排序"</span>, <span class="keyword">new</span> SimpleSwapSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"传统的冒泡排序"</span>, <span class="keyword">new</span> BubbleSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"改进的冒泡排序"</span>, <span class="keyword">new</span> AdvancedBubbleSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"简单选择排序"</span>, <span class="keyword">new</span> SimpleSelectSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"直接插入排序"</span>, <span class="keyword">new</span> DirectInsertSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"希尔排序"</span>, <span class="keyword">new</span> ShellSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"归并排序"</span>, <span class="keyword">new</span> MergeSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"改进的归并排序"</span>, <span class="keyword">new</span> AdvancedMergeSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"自底向上的归并排序"</span>, <span class="keyword">new</span> IterationMergeSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"改进的自底向上的归并排序"</span>, <span class="keyword">new</span> AdvancedIterationMergeSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"快速排序"</span>, <span class="keyword">new</span> QuickSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"改进的快速排序"</span>, <span class="keyword">new</span> AdvancedQuickSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"双路快速排序"</span>, <span class="keyword">new</span> QuickSort2Ways(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"三路快速排序"</span>, <span class="keyword">new</span> QuickSort3Ways(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"堆排序"</span>, <span class="keyword">new</span> HeapSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"改进的堆排序1"</span>, <span class="keyword">new</span> AdvancedHeapSort1(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"改进的堆排序2"</span>, <span class="keyword">new</span> AdvancedHeapSort2(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"----------随机数组的长度是100000，范围是0~100000。----------"</span>);</span><br><span class="line">        n = <span class="number">100000</span>;</span><br><span class="line">        <span class="comment">// 随机数组的长度是100000，范围是0~100000。</span></span><br><span class="line">        arr = RandomArray.generateRandomArray(n, <span class="number">0</span>, <span class="number">100000</span>);</span><br><span class="line">        TestSort.testSort(<span class="string">"简单交换排序"</span>, <span class="keyword">new</span> SimpleSwapSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"传统的冒泡排序"</span>, <span class="keyword">new</span> BubbleSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"改进的冒泡排序"</span>, <span class="keyword">new</span> AdvancedBubbleSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"简单选择排序"</span>, <span class="keyword">new</span> SimpleSelectSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"直接插入排序"</span>, <span class="keyword">new</span> DirectInsertSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"希尔排序"</span>, <span class="keyword">new</span> ShellSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"归并排序"</span>, <span class="keyword">new</span> MergeSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"改进的归并排序"</span>, <span class="keyword">new</span> AdvancedMergeSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"自底向上的归并排序"</span>, <span class="keyword">new</span> IterationMergeSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"改进的自底向上的归并排序"</span>, <span class="keyword">new</span> AdvancedIterationMergeSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"快速排序"</span>, <span class="keyword">new</span> QuickSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"改进的快速排序"</span>, <span class="keyword">new</span> AdvancedQuickSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"双路快速排序"</span>, <span class="keyword">new</span> QuickSort2Ways(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"三路快速排序"</span>, <span class="keyword">new</span> QuickSort3Ways(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"堆排序"</span>, <span class="keyword">new</span> HeapSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"改进的堆排序1"</span>, <span class="keyword">new</span> AdvancedHeapSort1(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"改进的堆排序2"</span>, <span class="keyword">new</span> AdvancedHeapSort2(), Arrays.copyOf(arr, n), n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1584161536035.png" alt="Alt text"><br><img src="./1584161575035.png" alt="Alt text"><br><img src="./1584161626089.png" alt="Alt text"></p><h4 id="②排序近乎有序的数组"><a href="#②排序近乎有序的数组" class="headerlink" title="②排序近乎有序的数组"></a>②排序近乎有序的数组</h4><ul><li>测试各个排序算法针对近乎有序的数组的排序性能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sort.insertsort.DirectInsertSort;</span><br><span class="line"><span class="keyword">import</span> sort.insertsort.ShellSort;</span><br><span class="line"><span class="keyword">import</span> sort.mergesort.AdvancedIterationMergeSort;</span><br><span class="line"><span class="keyword">import</span> sort.mergesort.AdvancedMergeSort;</span><br><span class="line"><span class="keyword">import</span> sort.mergesort.IterationMergeSort;</span><br><span class="line"><span class="keyword">import</span> sort.mergesort.MergeSort;</span><br><span class="line"><span class="keyword">import</span> sort.selectsort.AdvancedHeapSort1;</span><br><span class="line"><span class="keyword">import</span> sort.selectsort.AdvancedHeapSort2;</span><br><span class="line"><span class="keyword">import</span> sort.selectsort.HeapSort;</span><br><span class="line"><span class="keyword">import</span> sort.selectsort.SimpleSelectSort;</span><br><span class="line"><span class="keyword">import</span> sort.swapsort.*;</span><br><span class="line"><span class="keyword">import</span> sort.util.RandomArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 测试各个排序算法针对近乎有序的数组的排序性能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNearlyRandomArray</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----------随机数组的长度是1000，并且定义逆序对个数为10。----------"</span>);</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 随机数组的长度是1000，并且定义逆序对个数为10。</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = RandomArray.generateNearlyRandomArray(n, <span class="number">10</span>);</span><br><span class="line">        TestSort.testSort(<span class="string">"简单交换排序"</span>, <span class="keyword">new</span> SimpleSwapSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"传统的冒泡排序"</span>, <span class="keyword">new</span> BubbleSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"改进的冒泡排序"</span>, <span class="keyword">new</span> AdvancedBubbleSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"简单选择排序"</span>, <span class="keyword">new</span> SimpleSelectSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"直接插入排序"</span>, <span class="keyword">new</span> DirectInsertSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"希尔排序"</span>, <span class="keyword">new</span> ShellSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"归并排序"</span>, <span class="keyword">new</span> MergeSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"改进的归并排序"</span>, <span class="keyword">new</span> AdvancedMergeSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"自底向上的归并排序"</span>, <span class="keyword">new</span> IterationMergeSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"改进的自底向上的归并排序"</span>, <span class="keyword">new</span> AdvancedIterationMergeSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"快速排序"</span>, <span class="keyword">new</span> QuickSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"改进的快速排序"</span>, <span class="keyword">new</span> AdvancedQuickSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"双路快速排序"</span>, <span class="keyword">new</span> QuickSort2Ways(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"三路快速排序"</span>, <span class="keyword">new</span> QuickSort3Ways(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"堆排序"</span>, <span class="keyword">new</span> HeapSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"改进的堆排序1"</span>, <span class="keyword">new</span> AdvancedHeapSort1(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"改进的堆排序2"</span>, <span class="keyword">new</span> AdvancedHeapSort2(), Arrays.copyOf(arr, n), n);</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">"----------随机数组的长度是100000，并且定义逆序对个数为1000。----------"</span>);</span><br><span class="line">        n = <span class="number">100000</span>;</span><br><span class="line">        <span class="comment">// 随机数组的长度是100000，并且定义逆序对个数为1000。</span></span><br><span class="line">        arr = RandomArray.generateNearlyRandomArray(n, <span class="number">1000</span>);</span><br><span class="line">        TestSort.testSort(<span class="string">"简单交换排序"</span>, <span class="keyword">new</span> SimpleSwapSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"传统的冒泡排序"</span>, <span class="keyword">new</span> BubbleSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"改进的冒泡排序"</span>, <span class="keyword">new</span> AdvancedBubbleSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"简单选择排序"</span>, <span class="keyword">new</span> SimpleSelectSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"直接插入排序"</span>, <span class="keyword">new</span> DirectInsertSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"希尔排序"</span>, <span class="keyword">new</span> ShellSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"归并排序"</span>, <span class="keyword">new</span> MergeSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"改进的归并排序"</span>, <span class="keyword">new</span> AdvancedMergeSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"自底向上的归并排序"</span>, <span class="keyword">new</span> IterationMergeSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"改进的自底向上的归并排序"</span>, <span class="keyword">new</span> AdvancedIterationMergeSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"快速排序"</span>, <span class="keyword">new</span> QuickSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"改进的快速排序"</span>, <span class="keyword">new</span> AdvancedQuickSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"双路快速排序"</span>, <span class="keyword">new</span> QuickSort2Ways(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"三路快速排序"</span>, <span class="keyword">new</span> QuickSort3Ways(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"堆排序"</span>, <span class="keyword">new</span> HeapSort(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"改进的堆排序1"</span>, <span class="keyword">new</span> AdvancedHeapSort1(), Arrays.copyOf(arr, n), n);</span><br><span class="line">        TestSort.testSort(<span class="string">"改进的堆排序2"</span>, <span class="keyword">new</span> AdvancedHeapSort2(), Arrays.copyOf(arr, n), n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1584161693798.png" alt="Alt text"><br><img src="./1584161745305.png" alt="Alt text"><br><img src="./1584161774836.png" alt="Alt text"></p><h4 id="③总结"><a href="#③总结" class="headerlink" title="③总结"></a>③总结</h4><ul><li>每一种排序算法都有它存在的理由，没有一种排序算法在任何情况下的表现都是最好的，排序算法的具体性能依赖于待排数据的特点。</li><li>排序算法对比（图片来源于网络）：</li></ul><p><img src="./1583370675598.png" alt="Alt text"><br><img src="./1584962800748.png" alt="Alt text"></p><ul><li>排序算法的应用场景（图片来源于网络）：</li></ul><p><img src="./1584977001248.png" alt="Alt text"></p><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#119;&#106;&#x79;&#109;&#101;&#115;&#x73;&#105;&#x40;&#x31;&#54;&#x33;&#x2e;&#x63;&#111;&#109;" target="_blank" rel="noopener">&#119;&#106;&#x79;&#109;&#101;&#115;&#x73;&#105;&#x40;&#x31;&#54;&#x33;&#x2e;&#x63;&#111;&#109;</a></li><li>关于 <strong>数据结构与算法</strong> 的更多代码 请查看我的 <a href="https://github.com/messi1002/DataStructure" target="_blank" rel="noopener">GitHub仓库</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-排序基础&quot;&gt;&lt;a href=&quot;#1-排序基础&quot; class=&quot;headerlink&quot; title=&quot;1.排序基础&quot;&gt;&lt;/a&gt;1.排序基础&lt;/h3&gt;&lt;h4 id=&quot;①基础知识&quot;&gt;&lt;a href=&quot;#①基础知识&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://messi1002.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法总结" scheme="http://messi1002.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="排序" scheme="http://messi1002.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL入门之性能优化</title>
    <link href="http://messi1002.top/2020/01/09/JavaWeb%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/MySQL%E5%85%A5%E9%97%A8%E4%B9%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://messi1002.top/2020/01/09/JavaWeb开发总结/MySQL入门之性能优化/</id>
    <published>2020-01-09T02:39:25.000Z</published>
    <updated>2020-03-26T08:48:53.713Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据库" scheme="http://messi1002.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="http://messi1002.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://messi1002.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat+Nginx配置HTTPS</title>
    <link href="http://messi1002.top/2019/09/13/Tomcat-Nginx%E9%85%8D%E7%BD%AEHTTPS/"/>
    <id>http://messi1002.top/2019/09/13/Tomcat-Nginx配置HTTPS/</id>
    <published>2019-09-13T08:37:51.000Z</published>
    <updated>2020-06-12T12:47:55.423Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ps：每次修改配置后，需要重启 Nginx。<br>命令：<strong>systemctl restart nginx</strong>。<br>Nginx 的配置文件：<strong>/etc/nginx/nginx.conf</strong>。</p></blockquote><hr><h3 id="1-相关博客"><a href="#1-相关博客" class="headerlink" title="1.相关博客"></a>1.相关博客</h3><ul><li><a href="https://messi1002.top/2019/05/07/%E9%98%BF%E9%87%8C%E4%BA%91CentOS7%E5%AE%89%E8%A3%85Nginx/">阿里云CentOS7安装Nginx</a></li><li><a href="https://messi1002.top/2019/09/12/Nginx%E4%B9%8B%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/">Nginx之访问服务器静态资源</a></li><li><a href="https://messi1002.top/2019/09/12/Nginx%E4%B9%8Brewrite%E9%85%8D%E7%BD%AE%E5%9F%9F%E5%90%8D%E8%B7%B3%E8%BD%AC/#more">Nginx之rewrite配置域名跳转</a></li></ul><hr><h3 id="2-准备SSL证书"><a href="#2-准备SSL证书" class="headerlink" title="2.准备SSL证书"></a>2.准备SSL证书</h3><blockquote><p>在域名备案的前提下，我们需要购买 SSL 证书。<br>一般情况下，购买免费版即可。</p></blockquote><h4 id="①什么是SSL证书"><a href="#①什么是SSL证书" class="headerlink" title="①什么是SSL证书"></a>①什么是SSL证书</h4><p><img src="./1568361392033.png" alt="Alt text"><br><img src="./1568361434320.png" alt="Alt text"></p><h4 id="②准备过程"><a href="#②准备过程" class="headerlink" title="②准备过程"></a>②准备过程</h4><ul><li>进入阿里云控制台 购买免费版 SSL 证书 </li><li>然后在签发后下载 Nginx 服务器类型的证书并上传到服务器</li></ul><p><img src="./1568361492288.png" alt="Alt text"><br><img src="./1568361516967.png" alt="Alt text"><br><img src="./1568361531993.png" alt="Alt text"><br><img src="./1568361548330.png" alt="Alt text"><br><img src="./1568361629734.png" alt="Alt text"></p><hr><h3 id="3-具体配置"><a href="#3-具体配置" class="headerlink" title="3.具体配置"></a>3.具体配置</h3><h4 id="①强制HTTPS（可选）"><a href="#①强制HTTPS（可选）" class="headerlink" title="①强制HTTPS（可选）"></a>①强制HTTPS（可选）</h4><ul><li>把 HTTP 的域名请求转成 HTTPS</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  a.com;  # 使用证书绑定的域名替换localhost</span><br><span class="line">    return       301 https://$server_name$request_uri; </span><br><span class="line">    # 返回301状态码进行跳转被Google认为是将网站地址由HTTP迁移到HTTPS的最佳方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②开启HTTPS"><a href="#②开启HTTPS" class="headerlink" title="②开启HTTPS"></a>②开启HTTPS</h4><p><img src="./1568364999187.png" alt="Alt text"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl; # 监听433端口</span><br><span class="line">    server_name a.com; # 证书绑定的域名</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate /usr/local/javaweb/cert/2557101_a.com.pem; # 证书的文件名</span><br><span class="line">    ssl_certificate_key /usr/local/javaweb/cert/2557101_a.com.key; # 证书的密钥文件名</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:8080; # 对应tomcat的端口号</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto https;</span><br><span class="line">    proxy_redirect off;</span><br><span class="line">    proxy_connect_timeout 240;</span><br><span class="line">    proxy_send_timeout 240;</span><br><span class="line">    proxy_read_timeout 240;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置成功</li></ul><p><img src="./1568365113022.png" alt="Alt text"></p><hr><h3 id="4-工作原理"><a href="#4-工作原理" class="headerlink" title="4.工作原理"></a>4.工作原理</h3><blockquote><p>浏览器发送的请求是发送到 Nginx 的，Nginx 作为代理服务器再转发到 Tomcat，浏览器和 Nginx 之间以 HTTPS 协议传输数据，而 Nginx 和 Tomcat 之间通过 proxy_pass 以 HTTP 协议传输数据。<br>Nginx 是中间的代理服务器。</p></blockquote><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#119;&#106;&#x79;&#x6d;&#101;&#115;&#115;&#105;&#64;&#49;&#54;&#x33;&#46;&#99;&#x6f;&#109;" target="_blank" rel="noopener">&#119;&#106;&#x79;&#x6d;&#101;&#115;&#115;&#105;&#64;&#49;&#54;&#x33;&#46;&#99;&#x6f;&#109;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;ps：每次修改配置后，需要重启 Nginx。&lt;br&gt;命令：&lt;strong&gt;systemctl restart nginx&lt;/strong&gt;。&lt;br&gt;Nginx 的配置文件：&lt;strong&gt;/etc/nginx/nginx.conf&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://messi1002.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="服务器相关" scheme="http://messi1002.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Nginx" scheme="http://messi1002.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx之rewrite配置域名跳转</title>
    <link href="http://messi1002.top/2019/09/12/Nginx%E4%B9%8Brewrite%E9%85%8D%E7%BD%AE%E5%9F%9F%E5%90%8D%E8%B7%B3%E8%BD%AC/"/>
    <id>http://messi1002.top/2019/09/12/Nginx之rewrite配置域名跳转/</id>
    <published>2019-09-12T03:22:31.000Z</published>
    <updated>2020-06-12T12:48:37.313Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ps：每次修改配置后，需要重启 Nginx。<br>命令：<strong>systemctl restart nginx</strong>。<br>Nginx 的配置文件：<strong>/etc/nginx/nginx.conf</strong>。</p></blockquote><hr><h3 id="1-相关博客"><a href="#1-相关博客" class="headerlink" title="1.相关博客"></a>1.相关博客</h3><ul><li><a href="https://messi1002.top/2019/05/07/%E9%98%BF%E9%87%8C%E4%BA%91CentOS7%E5%AE%89%E8%A3%85Nginx/">阿里云CentOS7安装Nginx</a></li><li><a href="https://messi1002.top/2019/09/12/Nginx%E4%B9%8B%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/">Nginx之访问服务器静态资源</a></li><li><a href="https://messi1002.top/2019/09/13/Tomcat-Nginx%E9%85%8D%E7%BD%AEHTTPS/">Tomcat+Nginx配置HTTPS</a></li></ul><hr><h3 id="2-语法格式"><a href="#2-语法格式" class="headerlink" title="2.语法格式"></a>2.语法格式</h3><ul><li>rewrite 作用：将某个 URL 重写为特定的 URL</li><li>语法格式：<code>rewrite</code>（关键字） <code>&lt;regex&gt;</code>（正则表达式） <code>&lt;replacement&gt;</code>（替代内容）<ul><li>根据 <code>正则表达式</code> 重定向到 <code>replacement</code></li></ul></li></ul><hr><h3 id="3-对a域名的访问全部redirect到b域名"><a href="#3-对a域名的访问全部redirect到b域名" class="headerlink" title="3.对a域名的访问全部redirect到b域名"></a>3.对a域名的访问全部redirect到b域名</h3><ul><li>配置前 <code>server</code> 中不允许存在 <code>location / { ... }</code></li><li>配置示例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    rewrite ^/(.*) http://1000.xidian.edu.cn/$1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>跳转前：<a href="http://a.com/index.php/Request/" target="_blank" rel="noopener">http://a.com/index.php/Request/</a>…</li><li>跳转后：</li></ul><p><img src="./1568295962831.png" alt="Alt text"></p><ul><li>通过 <code>location /</code> 匹配所有以 <code>/</code> 开头的请求（即所有请求）</li><li><code>rewrite</code> 为固定关键字 </li><li><code>regex</code> 部分表示匹配完整的域名和之后的路径</li><li><code>replacement</code> 部分中的 <code>$1</code> 取自 <code>regex</code> 部分 <code>( )</code> 中的内容</li><li>即 nginx 将 <code>a.com/</code> 之后的路径拼接到了 <code>http://1000.xidian.edu.cn/</code> 后</li></ul><hr><h3 id="4-对a域名的不同访问redirect到不同域名"><a href="#4-对a域名的不同访问redirect到不同域名" class="headerlink" title="4.对a域名的不同访问redirect到不同域名"></a>4.对a域名的不同访问redirect到不同域名</h3><h4 id="①应用场景"><a href="#①应用场景" class="headerlink" title="①应用场景"></a>①应用场景</h4><ul><li>同一个域名下的不同 URL 需要跳转到不同的域名下</li></ul><h4 id="②示例一"><a href="#②示例一" class="headerlink" title="②示例一"></a>②示例一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /xiaoyuan/ &#123;</span><br><span class="line">    rewrite ^/xiaoyuan(.*) http://ehall.xidian.edu.cn$1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>跳转前：<code>http://a.com/xiaoyuan/jwapp/sys/cjcx</code></li><li>跳转后：</li></ul><p><img src="./1568261314056.png" alt="Alt text"></p><ul><li>通过 <code>location /xiaoyuan/</code> 匹配所有以 <code>/xiaoyuan/</code> 开头的请求</li><li><code>rewrite</code> 为固定关键字 </li><li><code>regex</code> 部分表示匹配完整的域名和之后的路径</li><li><code>replacement</code> 部分中的 <code>$1</code> 取自 <code>regex</code> 部分 <code>( )</code> 中的内容</li><li>即 nginx 将 <code>a.com/xiaoyuan</code> 之后的路径拼接到了 <code>http://ehall.xidian.edu.cn</code> 后</li></ul><h4 id="③示例二"><a href="#③示例二" class="headerlink" title="③示例二"></a>③示例二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /houqin/ &#123;</span><br><span class="line">    rewrite ^/houqin(.*) http://1000.xidian.edu.cn$1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>跳转前：<code>http://a.com/houqin/index.php/Request/...</code></li><li>跳转后：</li></ul><p><img src="./1568259929117.png" alt="Alt text"></p><ul><li>通过 <code>location /houqin/</code> 匹配所有以 <code>/houqin/</code> 开头的请求</li><li><code>rewrite</code> 为固定关键字 </li><li><code>regex</code> 部分表示匹配完整的域名和之后的路径</li><li><code>replacement</code> 部分中的 <code>$1</code> 取自 <code>regex</code> 部分 <code>( )</code> 中的内容</li><li>即 nginx 将 <code>a.com/houqin</code> 之后的路径拼接到了 <code>http://1000.xidian.edu.cn</code> 后</li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#106;&#121;&#109;&#x65;&#x73;&#x73;&#105;&#64;&#49;&#54;&#51;&#46;&#x63;&#x6f;&#x6d;" target="_blank" rel="noopener">&#x77;&#106;&#121;&#109;&#x65;&#x73;&#x73;&#105;&#64;&#49;&#54;&#51;&#46;&#x63;&#x6f;&#x6d;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;ps：每次修改配置后，需要重启 Nginx。&lt;br&gt;命令：&lt;strong&gt;systemctl restart nginx&lt;/strong&gt;。&lt;br&gt;Nginx 的配置文件：&lt;strong&gt;/etc/nginx/nginx.conf&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://messi1002.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="服务器相关" scheme="http://messi1002.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Nginx" scheme="http://messi1002.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx之访问服务器静态资源</title>
    <link href="http://messi1002.top/2019/09/12/Nginx%E4%B9%8B%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/"/>
    <id>http://messi1002.top/2019/09/12/Nginx之访问服务器静态资源/</id>
    <published>2019-09-12T03:19:49.000Z</published>
    <updated>2020-06-12T12:48:25.208Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ps：每次修改配置后，需要重启 Nginx。<br>命令：<strong>systemctl restart nginx</strong>。<br>Nginx 的配置文件：<strong>/etc/nginx/nginx.conf</strong>。</p></blockquote><hr><h3 id="1-相关博客"><a href="#1-相关博客" class="headerlink" title="1.相关博客"></a>1.相关博客</h3><ul><li><a href="https://messi1002.top/2019/05/07/%E9%98%BF%E9%87%8C%E4%BA%91CentOS7%E5%AE%89%E8%A3%85Nginx/">阿里云CentOS7安装Nginx</a></li><li><a href="https://messi1002.top/2019/09/13/Tomcat-Nginx%E9%85%8D%E7%BD%AEHTTPS/">Tomcat+Nginx配置HTTPS</a></li><li><a href="https://messi1002.top/2019/09/12/Nginx%E4%B9%8Brewrite%E9%85%8D%E7%BD%AE%E5%9F%9F%E5%90%8D%E8%B7%B3%E8%BD%AC/#more">Nginx之rewrite配置域名跳转</a></li></ul><hr><h3 id="2-通过域名-文件名-文件类型的URL格式访问"><a href="#2-通过域名-文件名-文件类型的URL格式访问" class="headerlink" title="2.通过域名/文件名.文件类型的URL格式访问"></a>2.通过<code>域名/文件名.文件类型</code>的URL格式访问</h3><blockquote><p>应用场景：小程序业务域名的验证。</p></blockquote><h4 id="①方法一"><a href="#①方法一" class="headerlink" title="①方法一"></a>①方法一</h4><ul><li>当 <code>server</code> 的配置中不存在 <code>location / { ... }</code> 时</li><li>配置示例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80 default_server; # 监听80端口</span><br><span class="line">    server_name  localhost; # 可自定义域名</span><br><span class="line">    root /usr; # 注意：/usr为文件所在目录,可任意设置</span><br><span class="line">    # root /; # 当文件在根目录时如此配置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②方法二"><a href="#②方法二" class="headerlink" title="②方法二"></a>②方法二</h4><ul><li>当 <code>server</code> 的配置中存在 <code>location / { ... }</code> 时</li><li>配置示例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在server中添加：</span><br><span class="line">location /文件名.文件类型 &#123;</span><br><span class="line">    root /usr; # 注意：/usr为文件所在目录,可任意设置</span><br><span class="line">    # root /; # 当文件在根目录时如此配置</span><br><span class="line">    expires 30d;</span><br><span class="line">    access_log off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 <code>/文件名.文件类型</code> 匹配以 <code>/文件名.文件类型</code> 开头的请求</li></ul><h4 id="③验证配置"><a href="#③验证配置" class="headerlink" title="③验证配置"></a>③验证配置</h4><p><img src="./1568213380744.png" alt="Alt text"><br><img src="./1568213790446.png" alt="Alt text"></p><hr><h3 id="3-通过域名-自定义-文件名-文件类型的URL格式访问"><a href="#3-通过域名-自定义-文件名-文件类型的URL格式访问" class="headerlink" title="3.通过域名/自定义/文件名.文件类型的URL格式访问"></a>3.通过<code>域名/自定义/文件名.文件类型</code>的URL格式访问</h3><blockquote><p>应用场景：搭建 Nginx 图片服务器。</p></blockquote><ul><li>配置示例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location /images/ &#123;</span><br><span class="line">    root  /usr/local/javaweb/xdxlb/; </span><br><span class="line">    # 将/images/映射到/usr/local/javaweb/xdxlb/images/</span><br><span class="line">    autoindex on; # 打开浏览功能</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 <code>location /images/</code> 匹配所有以 <code>/images/</code> 开头的请求</li><li>验证配置：</li></ul><p><img src="./1568252577331.png" alt="Alt text"><br><img src="./1568252491321.png" alt="Alt text"></p><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#119;&#x6a;&#x79;&#x6d;&#x65;&#115;&#115;&#105;&#64;&#49;&#x36;&#51;&#x2e;&#99;&#111;&#109;" target="_blank" rel="noopener">&#119;&#x6a;&#x79;&#x6d;&#x65;&#115;&#115;&#105;&#64;&#49;&#x36;&#51;&#x2e;&#99;&#111;&#109;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;ps：每次修改配置后，需要重启 Nginx。&lt;br&gt;命令：&lt;strong&gt;systemctl restart nginx&lt;/strong&gt;。&lt;br&gt;Nginx 的配置文件：&lt;strong&gt;/etc/nginx/nginx.conf&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://messi1002.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="服务器相关" scheme="http://messi1002.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Nginx" scheme="http://messi1002.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Java发起HTTP请求的工具类</title>
    <link href="http://messi1002.top/2019/08/15/Java%E5%8F%91%E8%B5%B7HTTP%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://messi1002.top/2019/08/15/Java发起HTTP请求的工具类/</id>
    <published>2019-08-15T02:42:54.000Z</published>
    <updated>2020-06-12T12:52:25.489Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ps：CloseableHttpClient 是 HttpClient 接口的实现类</p></blockquote><h3 id="1-发起GET请求"><a href="#1-发起GET请求" class="headerlink" title="1.发起GET请求"></a>1.发起GET请求</h3><h4 id="①无参数的GET请求"><a href="#①无参数的GET请求" class="headerlink" title="①无参数的GET请求"></a>①无参数的GET请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能描述: 无参数的GET请求</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>: [url]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: java.lang.String</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/5/31 22:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doGet</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> doGet(url, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②有参数的GET请求"><a href="#②有参数的GET请求" class="headerlink" title="②有参数的GET请求"></a>②有参数的GET请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 功能描述: 有参数的GET请求</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>: [url, param]</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>: java.lang.String</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@date</span>: 2019/5/31 22:05</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doGet</span><span class="params">(String url, LinkedHashMap&lt;String, String&gt; param)</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 创建HttpClient对象</span></span><br><span class="line">     CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line">     CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">// GET请求的返回内容</span></span><br><span class="line">     String resultString = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         URIBuilder builder = <span class="keyword">new</span> URIBuilder(url);</span><br><span class="line">         <span class="comment">// 设置请求参数</span></span><br><span class="line">         <span class="keyword">if</span> (param != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">for</span> (String key : param.keySet()) &#123;</span><br><span class="line">                 builder.addParameter(key, param.get(key));</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 构建一个URI对象</span></span><br><span class="line">         URI uri = builder.build();</span><br><span class="line">         <span class="comment">// 创建GET请求</span></span><br><span class="line">         HttpGet httpGet = <span class="keyword">new</span> HttpGet(uri);</span><br><span class="line">         <span class="comment">// 执行GET请求</span></span><br><span class="line">         response = httpClient.execute(httpGet);</span><br><span class="line">         <span class="comment">// 获取响应状态码</span></span><br><span class="line">         <span class="keyword">if</span> (response.getStatusLine().getStatusCode() == <span class="number">200</span>) &#123;</span><br><span class="line">             resultString = EntityUtils.toString(response.getEntity(), <span class="string">"UTF-8"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         log.error(<span class="string">"GET Method Catch Unexception Hanlder:&#123;&#125;, message:&#123;&#125;"</span>, e, e.getMessage());</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ServiceException(e.getMessage());</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 response.close();</span><br><span class="line">             &#125;</span><br><span class="line">             httpClient.close();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> resultString;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-发起POST请求"><a href="#2-发起POST请求" class="headerlink" title="2.发起POST请求"></a>2.发起POST请求</h3><h4 id="①参数为Map对象的POST请求"><a href="#①参数为Map对象的POST请求" class="headerlink" title="①参数为Map对象的POST请求"></a>①参数为Map对象的POST请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 功能描述: 有参数(Map对象)的POST请求</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>: [url, param]</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>: java.lang.String</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@date</span>: 2019/5/31 22:06</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doPost</span><span class="params">(String url, Map&lt;String, String&gt; param)</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 创建HttpClient对象</span></span><br><span class="line">     CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line">     CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">// POST请求的返回内容</span></span><br><span class="line">     String resultString = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 创建POST请求</span></span><br><span class="line">         HttpPost httpPost = <span class="keyword">new</span> HttpPost(url);</span><br><span class="line">         <span class="comment">// 创建请求参数列表</span></span><br><span class="line">         <span class="keyword">if</span> (param != <span class="keyword">null</span>) &#123;</span><br><span class="line">             List&lt;NameValuePair&gt; paramList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">             <span class="keyword">for</span> (String key : param.keySet()) &#123;</span><br><span class="line">                 paramList.add(<span class="keyword">new</span> BasicNameValuePair(key, param.get(key)));</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 构造form表单式的实体</span></span><br><span class="line">             UrlEncodedFormEntity entity = <span class="keyword">new</span> UrlEncodedFormEntity(paramList);</span><br><span class="line">             httpPost.setEntity(entity);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 执行POST请求</span></span><br><span class="line">         response = httpClient.execute(httpPost);</span><br><span class="line">         <span class="comment">// 获取响应状态码</span></span><br><span class="line">         <span class="keyword">if</span> (response.getStatusLine().getStatusCode() == <span class="number">200</span>) &#123;</span><br><span class="line">             resultString = EntityUtils.toString(response.getEntity(), <span class="string">"UTF-8"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         log.error(<span class="string">"POST Method Catch Unexception Hanlder:&#123;&#125;, message:&#123;&#125;"</span>, e, e.getMessage());</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ServiceException(e.getMessage());</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 response.close();</span><br><span class="line">             &#125;</span><br><span class="line">             httpClient.close();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> resultString;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="②参数为JSON字符串的POST请求"><a href="#②参数为JSON字符串的POST请求" class="headerlink" title="②参数为JSON字符串的POST请求"></a>②参数为JSON字符串的POST请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能描述: 有参数(Json字符串)的POST请求</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>: [url, jsonData]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: java.lang.String</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/6/25 17:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doPost</span><span class="params">(String url, String jsonData)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建HttpClient对象</span></span><br><span class="line">    CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line">    CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// POST请求的返回内容</span></span><br><span class="line">    String resultString = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建POST请求</span></span><br><span class="line">        HttpPost httpPost = <span class="keyword">new</span> HttpPost(url);</span><br><span class="line">        <span class="comment">// 解析Json数据并构造实体</span></span><br><span class="line">        StringEntity stringEntity = <span class="keyword">new</span> StringEntity(jsonData, ContentType.APPLICATION_JSON);</span><br><span class="line">        httpPost.setEntity(stringEntity);</span><br><span class="line">        <span class="comment">// 执行POST请求</span></span><br><span class="line">        response = httpClient.execute(httpPost);</span><br><span class="line">        <span class="comment">// 获取响应状态码</span></span><br><span class="line">        <span class="keyword">if</span> (response.getStatusLine().getStatusCode() == <span class="number">200</span>) &#123;</span><br><span class="line">            resultString = EntityUtils.toString(response.getEntity(), <span class="string">"UTF-8"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">"POST Method Catch Exception Handler:&#123;&#125;, message:&#123;&#125;"</span>, e, e.getMessage());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                response.close();</span><br><span class="line">            &#125;</span><br><span class="line">            httpClient.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resultString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#x6a;&#x79;&#x6d;&#x65;&#x73;&#115;&#x69;&#64;&#x31;&#x36;&#51;&#46;&#99;&#111;&#109;" target="_blank" rel="noopener">&#x77;&#x6a;&#x79;&#x6d;&#x65;&#x73;&#115;&#x69;&#64;&#x31;&#x36;&#51;&#46;&#99;&#111;&#109;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;ps：CloseableHttpClient 是 HttpClient 接口的实现类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-发起GET请求&quot;&gt;&lt;a href=&quot;#1-发起GET请求&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
      <category term="进阶内容" scheme="http://messi1002.top/categories/Java/%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/"/>
    
    
      <category term="Java进阶" scheme="http://messi1002.top/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb开发总结</title>
    <link href="http://messi1002.top/2019/08/12/JavaWeb%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    <id>http://messi1002.top/2019/08/12/JavaWeb开发总结/</id>
    <published>2019-08-12T07:00:40.000Z</published>
    <updated>2020-06-12T12:59:43.385Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-开发环境"><a href="#1-开发环境" class="headerlink" title="1.开发环境"></a>1.开发环境</h3><h4 id="①开发必备"><a href="#①开发必备" class="headerlink" title="①开发必备"></a>①开发必备</h4><ul><li>Java 版本：JDK8</li><li>Web 服务器：Tomcat9（运行后端）、Nginx（前端请求转发和搭建图片服务器）</li><li>工程框架：Spring Boot 2.0</li><li>操作数据库：Spring Boot Jpa（优先） / Mybatis</li><li>其他：Lombok 插件、JSON（fastjson / jackson）</li></ul><h4 id="②数据库"><a href="#②数据库" class="headerlink" title="②数据库"></a>②数据库</h4><ul><li>MySQL（主 db）</li><li>Redis（处理缓存）</li><li>MongoDB （特殊需求使用）</li></ul><h4 id="③编译器-amp-构建工具-amp-测试工具"><a href="#③编译器-amp-构建工具-amp-测试工具" class="headerlink" title="③编译器&amp;构建工具&amp;测试工具"></a>③编译器&amp;构建工具&amp;测试工具</h4><ul><li>IDEA</li><li>maven（优先） / gradle</li><li>Postman </li></ul><hr><h3 id="2-框架分层"><a href="#2-框架分层" class="headerlink" title="2.框架分层"></a>2.框架分层</h3><h4 id="①总览"><a href="#①总览" class="headerlink" title="①总览"></a>①总览</h4><ul><li>common（公共包）<ul><li>enums（枚举类）</li><li>exception（全局异常处理）</li><li>interceptor（拦截器）</li><li>jpa（jpa 配置）</li><li>log（AOP 方式的日志埋点）</li><li>utils（工具类）</li></ul></li><li>controller（控制层）</li><li>model（DAO 层）<ul><li>dto（数据传输对象）</li><li>entity（数据库实体类）</li></ul></li><li>repository / mapper（数据库操作层）</li><li>service（服务层)<ul><li>base（基础服务）</li><li>impl（业务服务实现类）</li></ul></li><li>resources（资源目录）<ul><li>application.yml（切换配置文件）</li><li>application-dev.yml（本地配置文件）</li><li>application-pro.yml （服务器配置文件）</li></ul></li></ul><h4 id="②common层"><a href="#②common层" class="headerlink" title="②common层"></a>②common层</h4><ul><li>ResultEnum 类：用于存放前端请求的响应 / 执行结果<ul><li>注意枚举类定义格式 私有变量名不能定义为 name</li></ul></li></ul><h4 id="③controller层"><a href="#③controller层" class="headerlink" title="③controller层"></a>③controller层</h4><ul><li>调用 service 层方法</li><li>提供对外暴露的接口</li></ul><h4 id="④model层"><a href="#④model层" class="headerlink" title="④model层"></a>④model层</h4><ul><li>ResultDTO 类：统一使用此类将数据封装好返回给前端</li><li>关于使用 DTO：从数据库中查出的是一个完整的对象，而大多数时候只会用到某些字段，这时候需要 DTO。</li></ul><hr><h3 id="3-代码规范"><a href="#3-代码规范" class="headerlink" title="3.代码规范"></a>3.代码规范</h3><h4 id="①注释"><a href="#①注释" class="headerlink" title="①注释"></a>①注释</h4><ul><li>类注释（配置模板）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @功能名称: HttpClient(举例)</span><br><span class="line"> * @文件名称: HttpUtil.java(举例)</span><br><span class="line"> * @Date: $date$ $time$</span><br><span class="line"> * @Author: 自定义</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><ul><li>方法注释（配置模板）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 功能描述: </span><br><span class="line"> *</span><br><span class="line"> * @param: $param$</span><br><span class="line"> * @return: $return$</span><br><span class="line"> * @auther: 自定义</span><br><span class="line"> * @date: $date$ $time$</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><ul><li>变量注释</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 文字</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><ul><li>方法内注释</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 文字</span><br></pre></td></tr></table></figure><h4 id="②注解"><a href="#②注解" class="headerlink" title="②注解"></a>②注解</h4><ul><li>自动装配用 @Autowired 注解 其 byType 注入 注解在字段上</li><li>@component：泛指组件 把普通 POJO 实例化到 spring 容器中</li><li>@Service：用于标注业务层组件</li><li>@RestController：用于标注控制层组件</li><li>@Repository：用于标注数据访问组件 即 DAO 组件</li><li>@RequestMapping(value = “/URI”)：标注控制层组件中的方法</li><li>@GetMapping(value = “/URI”)：标注控制层组件中的方法 </li><li>@PostMapping(value = “/URI”)：标注控制层组件中的方法</li><li>@RequestParam：用于标注控制层组件的方法的参数<ul><li>参数名与前端传来的必须吻合 若是不吻合 需要加 value = “…” 使参数名一一对应</li></ul></li></ul><h4 id="③配置文件"><a href="#③配置文件" class="headerlink" title="③配置文件"></a>③配置文件</h4><ul><li>application.yml：总控制文件 可随时切换为本地 / 服务器的配置文件 便于开发</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">dev/pro</span></span><br></pre></td></tr></table></figure><ul><li>application-dev.yml</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="string">本地访问端口号</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># MySQL数据库配置</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    driverClass:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://localhost:3306/数据库名?characterEncoding=utf-8&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">自定义</span></span><br><span class="line">  <span class="comment"># Redis配置</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    database:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">自定义</span></span><br><span class="line">  <span class="comment"># MongoDB配置</span></span><br><span class="line"><span class="attr">  data:</span></span><br><span class="line"><span class="attr">    mongodb:</span></span><br><span class="line"><span class="attr">      uri:</span> <span class="attr">mongodb://用户名:密码@localhost:27017/数据库名</span></span><br><span class="line">  <span class="comment"># jpa配置</span></span><br><span class="line"><span class="attr">  jpa:</span></span><br><span class="line"><span class="attr">    hibernate:</span></span><br><span class="line">      <span class="comment"># 在程序启动时更新实体类对应的表</span></span><br><span class="line"><span class="attr">      ddl-auto:</span> <span class="string">update</span></span><br><span class="line">    <span class="comment"># 在日志中打印出执行的SQL语句信息</span></span><br><span class="line"><span class="attr">    show-sql:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    naming:</span></span><br><span class="line"><span class="attr">      physical-strategy:</span> <span class="string">org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy</span></span><br><span class="line">  <span class="comment"># mybatis配置</span></span><br><span class="line"><span class="attr">  mybatis:</span></span><br><span class="line"><span class="attr">    type-aliases-package:</span> <span class="string">数据库实体类所在包</span></span><br><span class="line">    <span class="comment"># 下划线自动转驼峰</span></span><br><span class="line"><span class="attr">    configuration:</span></span><br><span class="line"><span class="attr">      map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      use-generated-keys:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># jackson配置</span></span><br><span class="line"><span class="attr">  jackson:</span></span><br><span class="line"><span class="attr">    serialization:</span></span><br><span class="line"><span class="attr">      indent-output:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>application-pro.yml</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="string">服务器端口号</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># MySQL数据库配置</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    driverClass:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://服务器公网ip:3306/数据库名?characterEncoding=utf-8&amp;serverTimezone=GMT%2B8&amp;useSSL=true</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">自定义</span></span><br><span class="line">  <span class="comment"># Redis配置</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    database:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">    host:</span> <span class="string">服务器公网ip</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">自定义</span></span><br><span class="line">  <span class="comment"># MongoDB配置</span></span><br><span class="line"><span class="attr">  data:</span></span><br><span class="line"><span class="attr">    mongodb:</span></span><br><span class="line"><span class="attr">      uri:</span> <span class="attr">mongodb://用户名:密码@服务器ip:27017/数据库名</span></span><br><span class="line">  <span class="string">...其他如上</span></span><br></pre></td></tr></table></figure><h4 id="④pom-xml（maven）"><a href="#④pom-xml（maven）" class="headerlink" title="④pom.xml（maven）"></a>④pom.xml（maven）</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- MySQL --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Redis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- MongoDB --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- jpa --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- lombok插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- httpclient --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- maven插件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 解决项目启动bug --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="⑤其他"><a href="#⑤其他" class="headerlink" title="⑤其他"></a>⑤其他</h4><ul><li>将私有常量值单独定义在类的开头 公有常量值定义在公有枚举类中</li><li>工具类一般不需要被注入或构造 只包含普通的类方法</li><li>所有需要注入的类，都应该放到 Service 目录下</li><li>除 db 对象外 尽量使用全参构造对象</li><li>尽量消除魔法值 可使用枚举类封装</li><li>遵循《阿里巴巴Java代码开发规范》进行开发</li></ul><hr><h3 id="4-安装插件"><a href="#4-安装插件" class="headerlink" title="4.安装插件"></a>4.安装插件</h3><ul><li>安装插件：<strong>Settings —&gt; Plugins —&gt; Marketplace —&gt; 查找所需插件 —&gt; Install</strong></li><li>查看安装的所有插件：</li></ul><p><img src="./1563267874950.png" alt="Alt text"></p><ul><li>安装后需要重启 IDEA</li></ul><h4 id="①Lombok"><a href="#①Lombok" class="headerlink" title="①Lombok"></a>①Lombok</h4><blockquote><p>以简单的注解形式来简化 Java 代码，提高开发人员的开发效率。</p></blockquote><ul><li>@Getter：注解在类上 为类提供 get 方法 </li><li>@Setter：注解在类上 为类提供 set 方法</li><li>@Data：注解在类上 为类提供读写属性 此外还提供了equals()、hashCode()、toString() 方法</li><li>@AllArgsConstructor：注解在类上 为类提供一个全参的构造方法</li><li>@NoArgsConstructor：注解在类上 为类提供一个无参的构造方法</li><li>@Slf4j：注解在类上 为类提供一个属性名为 log 的 log4j 日志对象</li><li><strong>@Slf4j 相当于 private static final Logger log = LoggerFactory.getLogger(CategoryServiceImpl.class);</strong></li></ul><h4 id="②Alibaba-Java-Coding-Guidelines"><a href="#②Alibaba-Java-Coding-Guidelines" class="headerlink" title="②Alibaba Java Coding Guidelines"></a>②Alibaba Java Coding Guidelines</h4><blockquote><p>阿里巴巴 Java 代码规约检测</p></blockquote><ul><li>使用插件：</li></ul><p><img src="./1563265527020.png" alt="Alt text"></p><h4 id="③Grep-Console"><a href="#③Grep-Console" class="headerlink" title="③Grep Console"></a>③Grep Console</h4><blockquote><p>可以将不同级别的日志通过颜色区分，便于查看。</p></blockquote><ul><li>配置各级日志的颜色：</li></ul><p><img src="./1563850702962.png" alt="Alt text"></p><hr><h3 id="5-前后端交互"><a href="#5-前后端交互" class="headerlink" title="5.前后端交互"></a>5.前后端交互</h3><h4 id="①交互流程"><a href="#①交互流程" class="headerlink" title="①交互流程"></a>①交互流程</h4><p>1.通过原型图确定产品功能（明确每个细节）<br>2.后端撰写 API 文档及建表<br>3.前后端按照 API 文档各自开发<br>4.测试</p><h4 id="②API文档"><a href="#②API文档" class="headerlink" title="②API文档"></a>②API文档</h4><ul><li><a href="https://www.showdoc.cc/" target="_blank" rel="noopener">ShowDoc</a></li><li>举例：</li></ul><p><img src="./1563442671800.png" alt="Alt text"></p><h4 id="③RESTful-API"><a href="#③RESTful-API" class="headerlink" title="③RESTful API"></a>③RESTful API</h4><ul><li>后端撰写请求 URL 时 必须遵守 <a href="https://github.com/godruoyi/restful-api-specification" target="_blank" rel="noopener">RESTful API 设计规范</a></li></ul><p><img src="./1562896136514.png" alt="Alt text"></p><ul><li>举例：</li></ul><p><img src="./1562896118142.png" alt="Alt text"></p><hr><h3 id="6-关于团队协作（git）"><a href="#6-关于团队协作（git）" class="headerlink" title="6.关于团队协作（git）"></a>6.关于团队协作（git）</h3><blockquote><p>GitHub 客户端每次只能 commit 一个文件，不利于版本回滚和团队协作，所以尽量使用 git 命令行。</p></blockquote><h4 id="①git同步流程"><a href="#①git同步流程" class="headerlink" title="①git同步流程"></a>①git同步流程</h4><ol><li>一般开发完成、但还没有测试的文件都会被提交到暂存区</li><li>将暂存区的文件（测试好的）提交到本地仓库</li><li>通过 git push 提交修改到远程仓库</li></ol><h4 id="②git常用命令"><a href="#②git常用命令" class="headerlink" title="②git常用命令"></a>②git常用命令</h4><ul><li>git add 文件名：将本地某个文件添加到暂存区</li><li>git add *：将本地所有文件添加到暂存区</li><li>git commit -m “本次提交说明（自定义）”：将暂存区文件提交到本地仓库</li><li>git push -u origin master：使用本地 master 分支来更新远程 master 分支（远程仓库）</li><li>git reset HEAD 文件名（将暂存区的内容还原为最后一次提交的内容）</li><li>git checkout – 文件名（将工作区的内容还原为最后一次提交的内容）</li><li>git tag -a name -m “comment”：新建标签并指定提交信息</li><li>git tag -d  name：删除标签</li><li>git branch：查看当前所有分支</li><li>git branch name：创建分支</li><li>git checkout name：进入分支</li><li>通过两种方式克隆仓库：<ul><li>Clone with SSH：git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:messi1002/leetcode.git</li><li>Clone with HTTPS：git clone <a href="https://github.com/messi1002/leetcode.git" target="_blank" rel="noopener">https://github.com/messi1002/leetcode.git</a></li></ul></li></ul><p><img src="./1563441995129.png" alt="Alt text"><br><img src="./1563442009700.png" alt="Alt text"></p><h4 id="③git高级操作"><a href="#③git高级操作" class="headerlink" title="③git高级操作"></a>③git高级操作</h4><ul><li>git stash save “注释”：将工作区和暂存区的新内容暂时保存在栈中</li><li>git stash list：显示缓存堆栈中的内容</li><li>git stash pop：将缓存堆栈中的第一个 stash 内容恢复到工作区后删除</li><li>git commit –amend：将缓存区的内容补充到上次 commit 并可以修改上次 commit 的描述（用来修复最近一次 commit）</li><li>git rebase -i  [startpoint]  [endpoint]：每一个功能开发完成后 对多个 commit 进行合并处理（变基）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[startpoint] 和 [endpoint] 指定了一个编辑区间，前开后闭。</span><br><span class="line">如果不指定 [endpoint]，则该区间的终点默认是当前分支 HEAD 所指向的 commit。</span><br><span class="line">进入编辑页面后，按照指令说明修改指令即可。</span><br></pre></td></tr></table></figure><hr><h3 id="7-入门博客汇总"><a href="#7-入门博客汇总" class="headerlink" title="7.入门博客汇总"></a>7.入门博客汇总</h3><ul><li><a href="https://blog.csdn.net/baidu_31071595/article/details/51320622" target="_blank" rel="noopener">StringUtils用法+StringUtils详细介绍</a></li><li><a href="https://blog.csdn.net/anhuoren/article/details/41313213" target="_blank" rel="noopener">Java 枚举类Enum的用法总结</a></li><li><a href="http://www.ityouknow.com/springboot/2016/03/06/spring-boot-redis.html" target="_blank" rel="noopener">Spring Boot 中 Redis 的使用</a></li><li><a href="https://www.jianshu.com/p/7bf5dc61ca06" target="_blank" rel="noopener">如何使用RedisTemplate访问Redis数据结构</a></li><li><a href="http://blog.didispace.com/springbootredis/" target="_blank" rel="noopener">Spring Boot中使用Redis数据库</a></li><li><a href="https://juejin.im/post/5afb9de8518825426c690307" target="_blank" rel="noopener">Spring Boot中快速操作Mongodb</a></li><li><a href="http://www.ityouknow.com/springboot/2017/05/08/spring-boot-mongodb.html" target="_blank" rel="noopener">Spring Boot 中 MongoDB 的使用</a></li><li><a href="https://www.cnblogs.com/ityouknow/p/5891443.html" target="_blank" rel="noopener">Spring Boot Jpa 的使用</a></li><li><a href="http://www.ityouknow.com/springboot/2016/11/06/spring-boot-mybatis.html" target="_blank" rel="noopener">如何优雅的使用 Mybatis</a></li><li><a href="https://w6513017.iteye.com/blog/1512761" target="_blank" rel="noopener">MyBatis中Like语句使用方式</a></li><li><a href="https://blog.csdn.net/lonelymanontheway/article/details/78221296" target="_blank" rel="noopener">Java 开发工具–Lombok 介绍</a></li><li><a href="https://blog.51cto.com/7308310/2310930" target="_blank" rel="noopener">Spring Boot中Jackson应用详解</a></li><li><a href="https://blog.csdn.net/xzp_12345/article/details/80272981" target="_blank" rel="noopener">JSON框架之阿里fastjson的介绍</a></li><li><a href="https://github.com/godruoyi/restful-api-specification" target="_blank" rel="noopener">RESTful API 设计规范</a></li><li><a href="https://blog.csdn.net/qq_41979043/article/details/89319160#3Git__74" target="_blank" rel="noopener">Git—版本控制工具</a></li><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">Git教程</a></li><li><a href="https://blog.csdn.net/Code_shadow/article/details/81454334" target="_blank" rel="noopener">上传图片到七牛云（前端和后端）</a></li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#x6a;&#x79;&#x6d;&#101;&#115;&#x73;&#105;&#x40;&#49;&#x36;&#51;&#x2e;&#x63;&#x6f;&#x6d;" target="_blank" rel="noopener">&#x77;&#x6a;&#x79;&#x6d;&#101;&#115;&#x73;&#105;&#x40;&#49;&#x36;&#51;&#x2e;&#x63;&#x6f;&#x6d;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-开发环境&quot;&gt;&lt;a href=&quot;#1-开发环境&quot; class=&quot;headerlink&quot; title=&quot;1.开发环境&quot;&gt;&lt;/a&gt;1.开发环境&lt;/h3&gt;&lt;h4 id=&quot;①开发必备&quot;&gt;&lt;a href=&quot;#①开发必备&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://messi1002.top/categories/JavaWeb/"/>
    
      <category term="总结&amp;其他" scheme="http://messi1002.top/categories/JavaWeb/%E6%80%BB%E7%BB%93-%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="JavaWeb" scheme="http://messi1002.top/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门</title>
    <link href="http://messi1002.top/2019/07/20/Docker%E5%85%A5%E9%97%A8/"/>
    <id>http://messi1002.top/2019/07/20/Docker入门/</id>
    <published>2019-07-20T00:46:31.000Z</published>
    <updated>2020-06-12T13:11:33.394Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是-Docker"><a href="#1-什么是-Docker" class="headerlink" title="1.什么是 Docker"></a>1.什么是 Docker</h3><h4 id="①作用"><a href="#①作用" class="headerlink" title="①作用"></a>①作用</h4><ul><li>解决了大部分企业的痛点：快速的持续集成、服务的弹性伸缩、部署简单、解放运维、为企业节省了机器资源。</li><li>目前京东、阿里、腾讯等公司已经在生产环境中大规模的使用 Docker。</li></ul><h4 id="②概念"><a href="#②概念" class="headerlink" title="②概念"></a>②概念</h4><ul><li>概念：Docker 是一个用来装应用的容器，就像杯子可以放水，笔筒可以放笔，书包可以放书一样。你可以把 “Hello World！” 放到 Docker 中，也可以把网站放到 Docker 中，也可以把任何你想到的程序放到 Docker 中。</li><li>官网：<a href="http://www.docker.com" target="_blank" rel="noopener">www.docker.com</a> <ul><li>对 Docker 的介绍：Docker is the world’s leading software containerization platform.（Docker 是世界领先的软件容器化平台）</li></ul></li><li>总结：Docker 是一个使用 Go 语言开发的开源的应用容器引擎，可以让开发者打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的机器上。</li></ul><h4 id="③特点"><a href="#③特点" class="headerlink" title="③特点"></a>③特点</h4><ul><li>Docker 是一个用来装应用的容器，由 Docker 公司开发。</li><li>开源的，托管在 github 上（<code>docker/docker</code> 已改名为 <code>moby/moby</code>）。</li></ul><p><img src="./1584173231287.png" alt="Alt text"></p><ul><li>跨平台的，支持 Windows、Macos、Linux。</li><li>Docker 是在 ubuntu 系统上开发的，所以推荐在 Linux 上使用 Docker。</li></ul><hr><h3 id="2-了解-Docker"><a href="#2-了解-Docker" class="headerlink" title="2.了解 Docker"></a>2.了解 Docker</h3><h4 id="①Docker-思想"><a href="#①Docker-思想" class="headerlink" title="①Docker 思想"></a>①Docker 思想</h4><ol><li>集装箱思想：把程序的运行环境和部署细节进行整体封装并密封，不容易丢失或损坏。<ul><li>保证我们的程序放在任何地方运行时，都不会缺少东西。</li></ul></li><li>标准化思想：<ol><li>运输方式的标准化：Docker 有一个超级码头，任何一个地方需要货物时都由鲸鱼先将货物送到超级码头，再由鲸鱼从超级码头把货物送到目的地去。</li></ol><ul><li>例如：把台式机上的应用部署到笔记本上，可以在台式机上执行 docker 命令，让鲸鱼把程序送到超级码头，然后在笔记本上执行 docker 命令，让鲸鱼把程序从超级码头送到笔记本上。</li><li>即是执行固定命令发送代码到超级码头，执行固定命令将超级码头中的代码运送到部署地的标准化。</li></ul><ol start="2"><li>存储方式的标准化：程序员不需要关心应用存储在什么地方，docker 会自动进行标准化处理，我们只需要通过 docker 命令来启动或停止程序。</li><li>API 接口的标准化：提供了一系列的 RestAPI 接口包含了对应用的启动、停止、查看和删除等控制。</li></ol><ul><li>例如：能够实现执行同样的 docker 命令，来控制不同的 Web 应用服务器，例如 Tomcat、Nginx 等。</li><li>即提供了一系列的 RestAPI 接口，包含了对不同应用的统一控制的标准化。</li></ul></li><li>隔离思想：使用虚拟机时，有独立的内存、CPU、硬盘，使得使用者完全感觉不到外面主机的存在。Docker 也是类似，但是 Docker 技术更加轻量，可以实现快速的创建和销毁。创建虚拟机可能需要几分钟，而创建 Docker 只需要 1 秒。<ul><li>最底层的技术是 Linux 的一种内核限制机制 LXC。</li><li>LXC 是一种轻量级的容器虚拟化技术，最大效率的隔离了进程和资源，通过 cgroup 、namespace 等限制隔离进程组所使用的物理资源，如 CPU、I / O、Memory 等等。</li><li>这个机制早在多年前就已经加入到 Linux 内核了，直到 2013 年 Docker 出世的时候它才火起来。</li><li>Docker 也是随着云计算、敏捷开发、弹性服务等大环境的变迁而变火的，时势造英雄。</li></ul></li></ol><h4 id="②Docker-解决了什么问题"><a href="#②Docker-解决了什么问题" class="headerlink" title="②Docker 解决了什么问题"></a>②Docker 解决了什么问题</h4><ol><li>问题：程序在自己的环境中运行完全没有问题，而在其他人的环境中出问题。<ul><li>Java Web 程序正常运行依赖于：操作系统、JDK、Tomcat、源代码、配置文件等。</li><li>在不同的环境下部署程序时，如果出现操作系统环境的改变、JDK 和 Tomcat 的版本差异、代码依赖于本地环境、配置文件丢失或者与本地系统相关等都可能会导致程序运行不起来。</li><li>解决方案：程序员运行 docker 命令，把操作系统、JDK、Tomcat、源代码、配置文件都封装在集装箱中，然后打包交给鲸鱼，由鲸鱼送到服务器上。</li><li>Docker 解决了运行环境不一致所带来的问题。</li></ul></li><li>问题：系统好卡，谁又写死循环了，把资源都占用了。<ul><li>当多个程序员共用一台服务器的时候，由于某一个人的程序失误，可能会导致其他人的程序内存耗尽、程序挂掉，或者程序运行越来越慢，甚至终端变卡顿。</li><li>解决方案：Docker 的隔离机制，在每个程序启动时都限制了最大可启用的 CPU、内存和硬盘等，如果超过这个限制，就会杀掉这个进程。</li></ul></li><li>问题：客户数量激增（例如：双 11），原有的服务器撑不住了，需要扩展服务器数量。<ul><li>一到某些节日，运维需要对每一台服务器进行安装软件、部署应用、调试测试等工作，等高峰过了再将多余的节点下线（缺点：工作量太大）。</li><li>解决方案：只要在每台机器上执行几个 docker 命令，分分钟就可以扩展成千上万台，并且运行不会出现任何问题。</li><li>Docker 让快速扩展、弹性伸缩变得简单。</li></ul></li></ol><hr><h3 id="3-走进-Docker"><a href="#3-走进-Docker" class="headerlink" title="3.走进 Docker"></a>3.走进 Docker</h3><h4 id="①核心技术"><a href="#①核心技术" class="headerlink" title="①核心技术"></a>①核心技术</h4><ul><li>三个核心词汇：镜像（集装箱）、仓库（超级码头）和容器（运行程序的地方）</li><li>用 Docker 运行一个程序的过程：去仓库把镜像拉到本地（Ship），然后用一条命令把镜像运行（Build）起来变成容器（Run）。<ul><li>Build：构建镜像</li><li>Ship：运输镜像（在仓库和主机之间运输）</li><li>Run：运行的镜像就是一个容器</li></ul></li></ul><h4 id="②镜像"><a href="#②镜像" class="headerlink" title="②镜像"></a>②镜像</h4><ul><li>英文名：image</li><li>鲸鱼驮着的所有的集装箱就是一个镜像</li><li>从本质上来说，镜像就是一系列的文件（可以包括应用程序的文件，也可以包括应用的运行环境的文件）。Docker 利用 Linux 的联合文件系统（UnionFS）存储镜像文件，将之保存在本地。<ul><li>联合文件系统是一种分层的文件系统，它可以将不同的目录挂载到同一个虚拟文件系统下面。可以在同一个文件夹下看到 test1 文件夹和 test2 文件夹的内容集合。通过这样一种方式，联合文件系统就可以实现文件的分层，比如 test1 可以看做是第一层，test2 可以看做是第二层，每一层有每一层自己的文件，Docker 镜像就是利用了这种分层的概念来实现了镜像存储。</li></ul></li><li>暂且忽视 writable 层，Docker 镜像的每一层文件系统都是只读的，把每一层加载完成之后，这些文件都会被看成是同一个目录，相对于只有一个文件系统，Docker 的这种文件系统就被称为镜像。<ul><li>Image 层：相关软件（JDK、Tomcat、应用代码等），每一层都是我们自己可以控制的。</li><li>Debian 层：具体的一个 Linux 操作系统</li><li>最底层：操作系统的引导</li></ul></li><li>镜像的存储格式（可以看成是一个个集装箱摞在一起）：</li></ul><p><img src="./1583416142815.png" alt="Alt text"></p><h4 id="③容器"><a href="#③容器" class="headerlink" title="③容器"></a>③容器</h4><ul><li>容器的本质就是一个进程，可以将它想象成是一个虚拟机，但是这个 “虚拟机” 的文件系统是一层一层的，并且只有最上面一层是可写的，其他层都是只读的。</li><li>为什么有可写层：大部分程序在运行起来后，都会有写日志、修改文件等需求，所以容器在最高层创建了一个可读可写的文件系统。如果想对镜像文件进行修改操作，那么可读层内容会拷贝到最顶层（可写层），然后再进行修改操作。当我们的应用读取镜像文件时，会从最顶层（可写层）查找，如果没有相应文件，才会去可读层查找。</li><li>即容器是可以修改的，而镜像是不能修改的。这样保证同一个镜像可以生成多个容器，它们之间独立运行，互不干扰。</li></ul><h4 id="④仓库"><a href="#④仓库" class="headerlink" title="④仓库"></a>④仓库</h4><ul><li>构建镜像的目的：为了在其他的环境中运行我们的程序。<ul><li>为了在其他的环境中运行程序，我们需要将构建的镜像传递到目的地，Docker 仓库可以帮助我们传输。</li></ul></li><li>镜像的传输过程：先将构建的镜像传到 Docker 仓库中，再由目的地去 Docker 仓库将镜像拉取到本地。<ul><li>Docker 提供了 Docker 仓库（一个中央服务器，地址是 <a href="http://hub.docker.com）" target="_blank" rel="noopener">http://hub.docker.com）</a></li><li>如果自己的镜像比较私密，不想让别人看到，Docker 也支持自己（在内网中）搭建一个镜像中心。</li></ul></li></ul><hr><h3 id="4-Docker-初体验"><a href="#4-Docker-初体验" class="headerlink" title="4.Docker 初体验"></a>4.Docker 初体验</h3><h4 id="①安装-Docker"><a href="#①安装-Docker" class="headerlink" title="①安装 Docker"></a>①安装 Docker</h4><ul><li>Docker 下载地址：<ul><li>win10 专业版：<a href="http://www.docker.com/products/docker#/windows" target="_blank" rel="noopener">官网下载</a>（Docker 对 win 10 做了原生的支持）</li><li>windows 其他版本：<a href="http://www.docker.com/products/docker-toolbox" target="_blank" rel="noopener">官网下载</a>（在 windows 上虚拟了一个 Linux 的运行环境）</li><li>国内下载地址：<a href="http://get.daocloud.io" target="_blank" rel="noopener">http://get.daocloud.io</a></li><li>boot2docker.iso 下载地址：<a href="http://pan.baidu.com/s/1qYyc0ag" target="_blank" rel="noopener">http://pan.baidu.com/s/1qYyc0ag</a></li></ul></li><li>安装教程：<ul><li><a href="https://www.cnblogs.com/samwu/p/10360943.html" target="_blank" rel="noopener">Win10家庭版安装Docker</a></li><li><a href="https://www.shuijingwanwq.com/2017/10/11/1958/" target="_blank" rel="noopener">配置镜像加速器为阿里云加速器</a></li><li><a href="https://www.cnblogs.com/wang-yaz/p/10429899.html" target="_blank" rel="noopener">CentOS7上安装Docker</a></li><li><a href="https://www.jianshu.com/p/09d53c822cf8" target="_blank" rel="noopener">[docker][win10]安装的坑</a></li></ul></li></ul><h4 id="②第一个-Docker-镜像"><a href="#②第一个-Docker-镜像" class="headerlink" title="②第一个 Docker 镜像"></a>②第一个 Docker 镜像</h4><ul><li><strong>docker pull [OPTIONS] NAME[:TAG]</strong>：从 Docker 的远程仓库拉取镜像到本地<ul><li><code>NAME</code> 表示要拉取的镜像的名称</li><li>默认拉取地址为 Docker 官方提供的默认仓库（<a href="http://hub.docker.com）" target="_blank" rel="noopener">http://hub.docker.com）</a></li><li><code>TAG</code> 表示要拉取的镜像的版本，默认版本为 <code>:latest</code>，表示为最新版本。</li></ul></li><li><strong>docker images [OPTIONS] [REPOSITORY[:TAG]]</strong>：查看本机所有的镜像列表<ul><li>可以用于验证 <strong>docker pull</strong> 命令是否执行成功</li><li><code>REPOSITORY</code>：镜像名称</li><li><code>TAG</code>：镜像版本</li><li><code>IMAGE ID</code>：64 位字符串，用于唯一标识镜像。</li></ul></li></ul><p><img src="./1584208108508.png" alt="Alt text"></p><ul><li>其他操作<ul><li><a href="https://www.cnblogs.com/huanhuaqingfeng/p/11100995.html" target="_blank" rel="noopener">Docker删除本地镜像</a></li><li><a href="https://blog.51cto.com/sky9896/2475966" target="_blank" rel="noopener">Error response from daemon: conflict: unable to delete fd2aef058105 (must be</a></li></ul></li></ul><h4 id="③第一个-Docker-容器"><a href="#③第一个-Docker-容器" class="headerlink" title="③第一个 Docker 容器"></a>③第一个 Docker 容器</h4><ul><li><strong>docker run [OPTIONS] IMAGE[:TAG] [COMMAND] [ARG…]</strong>：运行镜像<ul><li><code>command</code>：镜像在运行起来时需要执行什么命令</li><li><code>ARG</code>：<code>command</code> 命令所依赖的参数</li></ul></li></ul><p><img src="./1584208909662.png" alt="Alt text"><br><img src="./1584208947997.png" alt="Alt text"></p><ul><li>Client：本机执行命令的客户端</li><li>DOCKER_HOST：本机的 Docker 服务</li><li>Registry：Docker 的远程仓库</li><li><strong>docker pull</strong> 流程：Docker Client 向 Docker daemon 发送 <strong>docker pull</strong> 命令，Docker daemon 会先在本机中寻找是否有相应的镜像，如果存在且版本一致则不做任何操作，如果不存在则会从 Docker 的远程仓库中将相应的镜像拉取到本地。</li><li><strong>docker run</strong> 流程：Docker Client 向 Docker daemon 发送 <strong>docker run</strong> 命令，Docker daemon 会先在本机中寻找是否有相应的镜像，如果不存在则会从 Docker 的远程仓库中将相应的镜像拉取到本地（相当于执行 <strong>docker pull</strong> 命令），然后将镜像通过一定方式运行起来变成 Docker 的容器。</li></ul><hr><h3 id="5-Docker-运行-Nginx-服务器"><a href="#5-Docker-运行-Nginx-服务器" class="headerlink" title="5.Docker 运行 Nginx 服务器"></a>5.Docker 运行 Nginx 服务器</h3><h4 id="①运行-nginx-镜像"><a href="#①运行-nginx-镜像" class="headerlink" title="①运行 nginx 镜像"></a>①运行 nginx 镜像</h4><ul><li>Nginx（web 服务器）镜像特点：持久运行的容器<ul><li>前台运行镜像：<strong>docker run NAME</strong>（Ctrl + C 结束进程）</li><li>后台运行镜像：<strong>docker run -d NAME</strong> （返回容器 id）</li><li><strong>docker ps</strong>：查看正在运行的容器</li><li><strong>docker run –help</strong>：查看 <strong>docker run</strong> 命令的相关参数</li></ul></li></ul><p><img src="./1584237612757.png" alt="Alt text"><br><img src="./1584237672068.png" alt="Alt text"></p><ul><li><strong>docker exec [OPTIONS] CONTAINER COMMAND [ARG…]</strong>：在一个运行的容器中运行一个命令<ul><li><code>CONTAINER</code>：容器名称 / 容器 id（不需要写全 id，写到能够唯一确定一个容器即可）</li><li><code>-i</code>：保证输入有效</li><li><code>-t</code>：分配一个伪终端</li></ul></li></ul><p><img src="./1584238788610.png" alt="Alt text"></p><ul><li><strong>docker exec  -it id / name bash</strong>：进入容器<ul><li>其实就是一个Linux，因为 Nginx 要运行在 Linux 容器上。</li><li><strong>ps -ef</strong>：查看当前运行的进程</li><li><strong>exit</strong>：退出容器</li></ul></li></ul><p><img src="./1584238388036.png" alt="Alt text"><br><img src="./1584242035857.png" alt="Alt text"></p><h4 id="②Docker-网络"><a href="#②Docker-网络" class="headerlink" title="②Docker 网络"></a>②Docker 网络</h4><blockquote><p>Docker 使用了 Linux 的 Namespace （命名空间）技术来进行资源的隔离，如 PID Namespace -&gt; 隔离进程，Mount Namespace -&gt; 隔离文件系统，Network Namespace -&gt; 隔离网络等。每一个 Network Namespace 都提供了一份独立的网络环境（网卡、路由、iptable 规则等都与其他的 Network Namespace 隔离）。</p></blockquote><ul><li>Docker 的网络类型<ol><li>bridge 模式（桥接）：Docker 默认的网络设置，此模式会为每一个容器分配一个独立的 Network Namespace、设置 IP 和端口等。一个虚拟网桥（docker0）与主机的网卡（eth0）相连，在启动容器时，容器中会虚拟一个容器的虚拟网卡，与网桥相连，然后通过网桥与主机进行通讯。</li><li>host 模式：容器不会获得一个独立的 Network Namespace，而是和主机共同使用一个。这时容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是会使用宿主机上的 IP 和端口。即在 Docker 中使用网络和在主机上使用网络是一样的（容器直接连在主机的网卡上，与主机使用同一块网卡）。</li><li>none 模式：Docker 将不会和外界进行通讯</li></ol></li><li>Docker 的端口映射：在使用 bridge 模式的时候，因为 bridge 模式所使用的网络有独立的 Namespace，这就需要一种技术使容器内的端口可以在主机上访问到，这种技术就是端口映射。Docker 可以将容器内的某一个端口与容器所在主机上的某一个端口之间做一个映射，当你在访问主机上的端口时，其实就是在访问容器内的端口，虚拟网桥会进行请求转发（端口映射）并将响应按原路返回。</li></ul><p><img src="./1584239949145.png" alt="Alt text"></p><ul><li><strong>docker stop id</strong>：停止容器</li><li><strong>docker restart id</strong>：重启容器</li><li><strong>docker run -d -p 主机端口:容器端口 容器名称</strong>：开放容器的一个端口到主机上的一个端口</li></ul><p><img src="./1584242372342.png" alt="Alt text"><br><img src="./1584242269412.png" alt="Alt text"></p><ul><li><strong>docker run -d -P 容器名称</strong>：开放容器的所有监听端口到主机上的随机端口（批量端口的映射方式）<ul><li><strong>netstat -na | grep 8080</strong>：查看 8080 端口的状态</li></ul></li></ul><p><img src="./1584242579503.png" alt="Alt text"><br><img src="./1584243862238.png" alt="Alt text"></p><blockquote><p>注意：使用云服务器操作时，记得让安全组开放对应的端口号，否则会访问失败。</p></blockquote><hr><h3 id="6-Docker-化的-JavaWeb-应用"><a href="#6-Docker-化的-JavaWeb-应用" class="headerlink" title="6.Docker 化的 JavaWeb 应用"></a>6.Docker 化的 JavaWeb 应用</h3><h4 id="①制作自己的镜像"><a href="#①制作自己的镜像" class="headerlink" title="①制作自己的镜像"></a>①制作自己的镜像</h4><ul><li>我们之前所下载的镜像都是由其他人做好后传到镜像仓库中的，我们也可以制作自己的镜像。</li><li><code>Dockerfile</code>：告诉 Docker 要怎么制作自己的镜像</li><li><strong>docker build</strong>：执行 <code>Dockerfile</code> 中所描述的每一件事情，最终把 Docker 镜像构建出来。</li><li>下面演示使用 jpress 来制作自己的镜像：</li></ul><ol><li><p>下载 <code>jpress-web-newest.war</code> 并上传到服务器<br>链接：<a href="https://pan.baidu.com/s/1j8gBluzagoOIl1Th_ntXqA" target="_blank" rel="noopener">https://pan.baidu.com/s/1j8gBluzagoOIl1Th_ntXqA</a><br>提取码：fcqd</p></li><li><p>编写 <code>Dockerfile</code> 文件</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from tomcat # 继承自tomcat这个基础镜像</span><br><span class="line">MAINTAINER wjy wjymessi@163.com # 镜像所有者的个人信息</span><br><span class="line">COPY /usr/local/javaweb/jpress-web-newest.war /usr/local/tomcat/webapps # 将本地的web应用放在tomcat镜像中，让web应用随着tomcat一起启动。</span><br></pre></td></tr></table></figure><ol start="3"><li>下载基础镜像</li></ol><p><img src="./1583637018290.png" alt="Alt text"><br><img src="./1583638502779.png" alt="Alt text"></p><ol start="4"><li>构建镜像：<strong>docker build Dokerfile文件所在的目录（若是当前目录则默认为 .）</strong><ul><li><strong>docker build -t  REPOSITORY:TAG Dokerfile文件所在的目录</strong>：给镜像指定名称和版本</li></ul></li></ol><p><img src="./1584247362450.png" alt="Alt text"><br><img src="./1584247382596.png" alt="Alt text"></p><h4 id="②运行自己的容器"><a href="#②运行自己的容器" class="headerlink" title="②运行自己的容器"></a>②运行自己的容器</h4><ul><li>下面我们开始运行自己创建的镜像：</li></ul><p><img src="./1584259479913.png" alt="Alt text"></p><ul><li>如果出现下图问题，可以尝试此 <a href="https://blog.csdn.net/mah666/article/details/104055180" target="_blank" rel="noopener">解决方法</a>。</li></ul><p><img src="./1584248361438.png" alt="Alt text"></p><ul><li>成功运行镜像</li></ul><p><img src="./1584248617247.png" alt="Alt text"><br><img src="./1584248828557.png" alt="Alt text"><br><img src="./1584254881080.png" alt="Alt text"></p><hr><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h3><ul><li>Docker 思想：集装箱思想、标准化思想、隔离思想（网络隔离、磁盘隔离、进程隔离）</li><li>Docker 核心内容：镜像（Build：构建镜像）、容器（Run：运行容器）、仓库（SHIP：镜像通过仓库传输）</li><li>Docker 命令：pull（下拉镜像）、build（构建镜像）、run（运行容器）、stop（停止容器）、restart（重启容器）、exec（进入容器内部）…</li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#x6a;&#121;&#109;&#101;&#115;&#115;&#x69;&#x40;&#49;&#54;&#51;&#x2e;&#99;&#x6f;&#109;" target="_blank" rel="noopener">&#x77;&#x6a;&#121;&#109;&#101;&#115;&#115;&#x69;&#x40;&#49;&#54;&#51;&#x2e;&#99;&#x6f;&#109;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-什么是-Docker&quot;&gt;&lt;a href=&quot;#1-什么是-Docker&quot; class=&quot;headerlink&quot; title=&quot;1.什么是 Docker&quot;&gt;&lt;/a&gt;1.什么是 Docker&lt;/h3&gt;&lt;h4 id=&quot;①作用&quot;&gt;&lt;a href=&quot;#①作用&quot; class
      
    
    </summary>
    
    
      <category term="项目" scheme="http://messi1002.top/categories/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="微服务基础" scheme="http://messi1002.top/categories/%E9%A1%B9%E7%9B%AE/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Docker" scheme="http://messi1002.top/tags/Docker/"/>
    
  </entry>
  
</feed>
