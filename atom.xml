<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wjy&#39;s blog</title>
  
  <subtitle>行到水穷处，坐看云起时。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://messi1002.top/"/>
  <updated>2020-02-25T18:06:26.015Z</updated>
  <id>http://messi1002.top/</id>
  
  <author>
    <name>围巾一</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java并发编程之基础概念</title>
    <link href="http://messi1002.top/2020/02/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://messi1002.top/2020/02/25/Java并发编程之基础概念/</id>
    <published>2020-02-25T04:30:32.000Z</published>
    <updated>2020-02-25T18:06:26.015Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1.进程和线程"></a>1.进程和线程</h3><h4 id="①与操作系统的关系"><a href="#①与操作系统的关系" class="headerlink" title="①与操作系统的关系"></a>①与操作系统的关系</h4><ul><li>一个操作系统可以拥有多个进程（process）</li><li>一个进程可以拥有多个线程（thread）</li><li>即操作系统是包含多个进程的容器，而每个进程又都是容纳多个线程的容器。</li></ul><p><img src="./1582653441280.png" alt="Alt text"></p><h4 id="②进程定义"><a href="#②进程定义" class="headerlink" title="②进程定义"></a>②进程定义</h4><ul><li>Oracle 的官方定义：<ul><li>进程：使用 fork 系统调用创建的 UNIX 环境（包括文件描述符、用户 ID 、CPU 使用时间、存储器、IO 设备、内存等），它被设置为运行程序。</li><li>线程：在进程上下文中执行的一系列指令</li></ul></li><li>通俗理解进程：<ul><li>进程指的是程序的一次执行。在用户下达运行程序的命令后，就会产生进程。没有运行的程序占用的空间大部分是磁盘空间，将程序运行起来时就变成了一个进程。</li><li>比喻：进程是对代码的实例化</li><li>在任务管理器中可以查看正在运行的进程：</li></ul></li></ul><p><img src="./1582626838174.png" alt="Alt text"></p><ul><li>总结进程：进程是程序的真正运行实例，是资源分配的基本单位。内存、CPU 等资源都是以进程为单位进行分配的。</li></ul><h4 id="③线程定义"><a href="#③线程定义" class="headerlink" title="③线程定义"></a>③线程定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 创建100个线程，用任务管理器可以看到Java线程数量的变化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Create100Threads</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建100个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 睡眠10s</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序运行前：</li></ul><p><img src="./1582627116360.png" alt="Alt text"></p><ul><li>程序运行过程：</li></ul><p><img src="./1582627170456.png" alt="Alt text"></p><ul><li>程序运行结束：</li></ul><p><img src="./1582627247395.png" alt="Alt text"></p><ul><li>通俗理解线程：<ul><li>线程是 CPU 的基本调度单位，每个线程执行的都是进程代码的某个片段。</li><li>进程是线程的容器，让线程利用进程中的资源执行代码。进程的线程数量若是大于 1，则是多线程的情况，多个线程帮助同一进程执行代码。</li></ul></li></ul><h4 id="④两者的异同"><a href="#④两者的异同" class="headerlink" title="④两者的异同"></a>④两者的异同</h4><ol><li>起源不同<ul><li>回顾操作系统的历史，先有进程后有线程。</li><li>由于处理器的速度往往比外设（键盘、硬盘等）快，所以为了提高 CPU 的利用率，才诞生了线程，目的是提高程序的执行效率。</li></ul></li><li>概念不同<ul><li>进程是具有独立功能的程序运行起来的一个活动，是一个实例，也是系统分配资源和调度的独立单位。</li><li>线程是 CPU 的基本调度单位</li></ul></li><li>内存共享方式不同<ul><li>对于进程而言，每个进程都会被操作系统分配到一定的内存，不同进程之间的内存通常是不共享的。例如：浏览器无法访问正在播放的 qq 音乐，它们之间想要通讯的话，需要使用进程间通讯 RPC。</li><li>线程与线程之间服务于同一个进程，需要合作，所以两个线程之间通讯很容易，可以共享由操作系统分配给其父进程的相同内存块。</li></ul></li><li>拥有的资源不用<ul><li>线程本身是进程的一部分，拥有的资源一定少于进程。</li><li>不同的线程之间共享的内容：①进程代码段（重点）、②进程的公有数据（利用这些共享的数据，线程很容易实现互相通讯）、③进程打开的文件描述符、④信号的处理器、⑤进程的当前目录、⑥进程用户 ID 与进程组 ID</li><li>不同的线程之间独有的内容：①线程 ID、②寄存器组的值、③线程的堆栈（重点）、④错误返回码、⑤线程的信号屏蔽码</li></ul></li><li>进程和线程的数量不同<ul><li>进程只有一个，线程可以有多个。</li><li>一个进程至少拥有一个线程，否则没有办法执行。</li></ul></li><li>开销不同<ul><li>因为进程和线程本身不是一个数量级的东西，所以线程始终比进程更轻量级。</li><li>线程的创建、终止时间比进程短。</li><li>同一进程内的线程切换时间比进程切换时间短</li><li>同一进程的各个线程间共享内存和文件资源，可以不通过内核进行通信。而进程间想要通信，需要借助内核帮忙。</li></ul></li><li>相同点：从生命周期 / 状态上来看，进程和线程从创建到结束都有就绪、等待、运行等状态。</li></ol><h4 id="⑤Java-语言和多线程的关系"><a href="#⑤Java-语言和多线程的关系" class="headerlink" title="⑤Java 语言和多线程的关系"></a>⑤Java 语言和多线程的关系</h4><ul><li>Java 语言的显著优势：在设计之初就支持多线程（当时大部分编程语言不支持多线程）。</li><li>Java 语言可以将我们创建的线程一对一映射到操作系统的内核线程中。而有些语言的线程是虚拟线程，不会在操作系统中对应的建立线程。</li></ul><p><img src="./1582636089900.png" alt="Alt text"></p><ul><li>JVM 自动启动线程：即使在代码中不显式的创建线程，在运行 main 函数时，JVM 也会自动地启动其他线程，这些线程都有特定的含义。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 即使在代码中不显式的创建线程，在运行main函数时，JVM也会自动地启动其他线程。</span></span><br><span class="line"><span class="comment"> * 并且这些线程都有特定的含义和作用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaAndThreads</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello Threads!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582628395824.png" alt="Alt text"></p><ul><li>Signal Dispatcher：把操作系统发来的信号分发给适当的处理程序，用于连接操作系统和应用程序。</li><li>Finalizer：负责对象的 finalize() 方法。在每个对象结束的时候，可能会实现 finalize() 方法，主要是为了处理该方法。但是随着 Java 语言的发展，不再推荐使用该方法。</li><li>Reference Handler：和 GC、引用相关的线程。将每一个对象的引用记录在案，以便配合 GC 进行垃圾回收。</li><li>main：主线程，用户程序的主入口，编写的代码从这里开始执行。</li><li>以上线程都是 JVM 自动创建的，由此可以看出 Java 语言和多线程息息相关。</li></ul><hr><h3 id="2-多线程"><a href="#2-多线程" class="headerlink" title="2.多线程"></a>2.多线程</h3><h4 id="①定义"><a href="#①定义" class="headerlink" title="①定义"></a>①定义</h4><ul><li>多线程：在单个进程中运行多个线程</li><li>多线程程序：如果一个程序允许运行两个或两个以上的线程，那么它就是多线程程序。<ul><li>现在绝大部分的程序都是多线程程序。例如：在浏览器中可以同时打开几个网页、同时下载几个文件，以及服务端可以同时处理多个请求。</li></ul></li><li>每个线程拥有自己的独立资源（ID、堆栈等），进程的内存空间对每个线程敞开，每个线程都可以到进程的内存空间中获取想要的资源并且互相通信。</li><li>相互独立的任务：没必要使用多线程</li><li>数据和资源共享的任务：需要使用多线程，并且要考虑线程的同步，确保线程的安全。</li></ul><h4 id="②多线程实例"><a href="#②多线程实例" class="headerlink" title="②多线程实例"></a>②多线程实例</h4><ul><li>多线程实例：抢火车票</li><li>最开始在火车站买火车票，是全国统一进行放票。假设全国使用同一个服务器（类比为一个进程）进行放票，而多个售票窗口就可以类比为多个线程。不同的线程之间互相配合或竞争。</li></ul><p><img src="./1582653407376.png" alt="Alt text"></p><ul><li>不断迭代后：<ul><li>增加放票时间段（分散压力），不同的车次有自己的放票时间。</li><li>增加候补功能</li><li>增加买票限制</li></ul></li><li>以上都是为了减少服务器的并发压力</li></ul><h4 id="③为什么需要多线程？"><a href="#③为什么需要多线程？" class="headerlink" title="③为什么需要多线程？"></a>③为什么需要多线程？</h4><ol><li>提高 CPU 的利用率（最主要的目的）<ul><li>目前大部分 CPU 都是两核或者两核以上，如果不发挥多线程的优势，始终使用单线程，就会浪费计算资源。多线程程序可以充分发挥多核 CPU 的优势，提高计算机的运行效率。</li><li>①提高了处理速度（CPU 的运行效率远远超过内存、磁盘、外设等） </li><li>②避免了无效等待（在读取磁盘 IO 的时候，CPU 没有必要等待，而应该去做其他的事情。）</li><li>③提高了用户体验：避免卡顿、缩短等待时间（并行处理，提高性能，例如 Tomcat 服务器用多个线程去接收 HTTP 请求，可以同时服务于多个用户。）</li></ul></li><li>便于编程建模（简化任务）<ul><li>将大任务拆解为 A、B、C、D 并建立模型，类似的任务都可以使用模型处理。然后用多线程分别执行这 4 个任务，就简单很多。因为每个子任务的目的明确、功能单一。</li></ul></li><li>计算机性能定律：摩尔定律失效，阿姆达尔定律登上舞台。<ul><li>摩尔定律：当价格不变时，集成电路上可容纳的晶体管数目约每隔 18 个月便会增加一倍，意味着 CPU 的性能可以提高一倍。这个定律告诉我们长期以来 CPU 的性能都是以指数型快速增长的。但是，近年来陷入了瓶颈。</li><li>阿姆达尔定律：处理器（CPU）越多，程序的执行速度就越快。但是执行速度也有上限，取决于程序中串行部分的比例，并行的比例越高，多处理器的效果越明显。对于串行任务，无论有多少 CPU 资源，都没有办法提高速度。</li><li>并行比例与提升速度的关系：</li></ul></li></ol><p><img src="./1582653374893.png" alt="Alt text"></p><ul><li>在未来，CPU 的性能的提升速度放缓了，这就要求我们把程序中更多可并行的部分并行化，以提高程序的性能。</li></ul><h4 id="④什么场景中会用到多线程？"><a href="#④什么场景中会用到多线程？" class="headerlink" title="④什么场景中会用到多线程？"></a>④什么场景中会用到多线程？</h4><ol><li>执行耗时任务（IO、磁盘读写、网络通信等）新开线程，不但不会影响主程序的运行，也不会因为耗时任务执行时间过慢而影响其他任务的运行。</li><li>为了同时做多件不同的事：①使用浏览器的同时听音乐、②后台定时任务等</li><li>提高工作效率、处理能力<ul><li>①Tomcat 可以同时并行处理多个线程进来的请求</li><li>②下载文件时可以选择线程数，多线程并行下载（每个线程都去和服务器通信，都去做独立的下载任务，并且把下载的任务进行分割，最后再把下载到的文件拼接起来），以提高下载效率。</li><li>③NIO：将 IO 操作升级为多线程操作，提高了 IO 的处理能力。</li></ul></li><li>需要同时有很大并发量的时候（比如进行服务器承受压力的能力的测试时，需要多线程并行请求）</li></ol><h4 id="⑤多线程的局限"><a href="#⑤多线程的局限" class="headerlink" title="⑤多线程的局限"></a>⑤多线程的局限</h4><ol><li>性能问题：上下文切换带来的消耗<ul><li>线程之间切换时会有上下文切换，会保存一些 CPU 所需要的数据，如当前运行到哪一行代码等。</li></ul></li><li>异构化任务很难高效并行<ul><li>每个任务之间的结构都不一样，很难总结为多个任务的拆解。</li></ul></li><li>带来线程安全问题：包括数据安全问题（例如 <code>i++</code> 总数不一致）以及线程带来的活跃性问题（线程饥饿、死锁等）<ul><li>线程饥饿：某个线程想要执行任务，但是被其他线程强先，这个线程始终没有事干。</li><li>死锁：两个线程相互拥有对方所需要的资源但都不肯放手，于是陷入无穷等待。</li></ul></li></ol><hr><h3 id="3-串行、并行、并发"><a href="#3-串行、并行、并发" class="headerlink" title="3.串行、并行、并发"></a>3.串行、并行、并发</h3><h4 id="①串行、并行、并发"><a href="#①串行、并行、并发" class="headerlink" title="①串行、并行、并发"></a>①串行、并行、并发</h4><ul><li>串行：大家排队一个个来<ul><li>左图：线程 A -&gt; B -&gt; C 依次执行</li><li>右图：将数据一位一位发送</li></ul></li><li>并行：大家一起来<ul><li>左图：线程 A / B / C 同时执行</li><li>右图：将 8 个数据一次性发送出去</li></ul></li></ul><p><img src="./1582653345934.png" alt="Alt text"></p><ul><li>并发（Concurrency）：单核就能实现并发、属于逻辑上的同时运行（由于处理器的处理速度很快，所以线程之间的切换肉眼是感知不到的，感觉它是在同时执行多个程序，实际某一时间只有一个程序执行（单处理器））。<ul><li>在物理层面并发就是串行，只不过是在多个程序上快速的来回切换而不是一个个依次执行，所以在用户看来相当于三个程序同时执行。</li></ul></li><li>并行（Parallelism）：多核处理器，物理上的同时运行，多个处理器都在同时执行任务。</li></ul><p><img src="./1582653313196.png" alt="Alt text"><br><img src="./1582086357063.png" alt="Alt text"></p><ul><li>并行是真正的 “同时” 运行：在同一时刻，有多个任务同时执行。<ul><li>单核处理器是无法实现并行的，因为单核处理器无法在同一时刻执行多个任务。</li></ul></li><li>并发可以对应到两个不同的概念</li><li>①形容多个任务的执行状态：<ul><li>两个或多个任务可以在重叠的时间段（不是指真正重叠的同一时刻，而是一段时间内交替运行）内启动，运行和完成。</li><li>并行（两个线程同时执行）一定是并发，两者是包含关系。</li><li>并发 + 多核 + 同一时刻执行同一段代码 = 并行</li><li>并发：不同的线程交替给一个 CPU 执行（蓝色竖线：CPU 的时间片）</li><li>并行：多个线程同时被多个 CPU 执行</li></ul></li></ul><p><img src="./1582653247372.png" alt="Alt text"><br><img src="./1582653213782.png" alt="Alt text"></p><ul><li>②对 “并发性” 的简称：<ul><li>如果一个程序具有并发性，指的是程序不同的部分可以无序或同时执行，且不影响最终的执行结果。</li><li>在不同核心数的计算机上的表现不同：</li><li>在多核 CPU 上，可以并行执行并发性程序。</li><li>在单核 CPU 上，可以并发执行并发性程序，串行执行非并发性程序。</li><li>此时，并行和并发的概念并不在同一维度上。并发指的是并发性，并行指的是多个程序在同一时刻同时执行。一个程序如果想要并发 / 并行执行，前提条件是它具有并发性。并发性是并发执行和并行执行的前提条件和必要条件。如果一个程序可以并行执行，就代表它一定具有并发性。</li></ul></li></ul><h4 id="②是什么让并发和并行成为可能？"><a href="#②是什么让并发和并行成为可能？" class="headerlink" title="②是什么让并发和并行成为可能？"></a>②是什么让并发和并行成为可能？</h4><ol><li>CPU 升级<ul><li>CPU 之前一直遵循摩尔定律，性能提升的很快，它的处理速度远远比其他部件快。但是每个 CPU 同一时刻只能执行一个指令，出于这个原因，操作系统开发出了新的技术，可以让用户同时运行多个进程或者多个线程。</li></ul></li><li>操作系统的升级<ul><li>升级之后将 CPU 完美的调度了起来，即便是单核 CPU，也能让不同的进程使用时间片的方式（抢占式的方式）不停地切换。</li><li>抢占式多任务处理：现代 CPU 最主要的一种处理方式，即操作系统有权利中断正在执行的任务。</li><li>诞生多核处理器后，操作系统可以自动检测 CPU 核心的数量，为每个核心分配不同的任务，以实现真正地同一时刻运行多个程序。</li></ul></li><li>编程语言的升级<ul><li>Java 语言诞生之前，很多编程语言不支持多线程。随着 Java 的诞生，多线程编程开始逐渐火热并且发展成熟。</li></ul></li></ol><hr><h3 id="4-高并发"><a href="#4-高并发" class="headerlink" title="4.高并发"></a>4.高并发</h3><h4 id="①定义-1"><a href="#①定义-1" class="headerlink" title="①定义"></a>①定义</h4><ul><li>高并发：同时有很多个请求发送给服务器系统，服务器会并行处理。</li><li>高并发场景：天猫双十一、春晚微信摇一摇、12306 卖火车票</li><li>一般将系统的承受能力设计为目前系统访问量的十倍比较合适</li></ul><h4 id="②高并发和多线程的异同？"><a href="#②高并发和多线程的异同？" class="headerlink" title="②高并发和多线程的异同？"></a>②高并发和多线程的异同？</h4><ul><li>高并发：指大量的请求同时到达服务器所带来的结果（结果指服务器需要同时处理很多请求），它是一种状态。系统需要应对高并发这种状态所带来的后果，如果处理不当，会导致请求的响应速度慢、无响应甚至服务器死机。</li><li>多线程并不意味着高并发，多线程编程是一种编程方式，是一种解决方案，不仅可以解决高并发所带来的线程安全问题 / 性能问题，还可以提高硬件的利用率，以便获取到更多的资源，从而解决高并发带来的服务器死机、响应慢等问题。<ul><li>多线程编程是我们应对高并发场景的一种重要的解决方案。</li></ul></li><li>高并发并不一定要通过多线程的方式解决<ul><li>例如：解决数据库的高并发问题可以利用 Redis 缓存层（可能带来缓存不一致的问题，但不会带来线程安全问题）</li></ul></li><li>总结：高并发并不意味着多线程（例如：Redis 底层是用单线程处理的）。高并发是一种状态，作为服务器开发者，最好用多线程的方式解决，这样可以提高 CPU 等资源的利用率，加快用户的响应速度。但是在场景不同，资源不同的情况下，也可以选择其他的解决方案。</li></ul><h4 id="③高并发有哪些指标？"><a href="#③高并发有哪些指标？" class="headerlink" title="③高并发有哪些指标？"></a>③高并发有哪些指标？</h4><ul><li>QPS（Queries Per Second）：每秒钟的查询（请求）数</li><li>PV（Page View）：24 小时内的页面点击量（综合浏览量）</li><li>UV（Unique Visitor）：24 小时内访问的用户数量（根据 Cookie）、UV &lt;= PV</li><li>并发连接数：某个时刻服务器所接受的请求的数目。<ul><li>对于同一个用户而言，可以同时产生很多个会话 / 连接，所以数目 &gt; 同时在线的用户数量。</li><li>对服务器来说，这个连接有一个上限</li></ul></li><li>服务器平均请求等待时间：服务器处理一个请求所花费的时间</li></ul><hr><h3 id="5-同步与异步、阻塞与非阻塞"><a href="#5-同步与异步、阻塞与非阻塞" class="headerlink" title="5.同步与异步、阻塞与非阻塞"></a>5.同步与异步、阻塞与非阻塞</h3><h4 id="①同步与异步"><a href="#①同步与异步" class="headerlink" title="①同步与异步"></a>①同步与异步</h4><ul><li>同步与异步：被调用方是否主动告诉调用方结果。<ul><li>同步与异步是被调用方（即服务端）的行为，而不是调用方的行为。</li><li>同步：在没有得到结果之前，服务端不返回任何结果。</li><li>异步：调用在发出之后，服务端会立刻返回，告诉调用方 “我收到你的请求了，我会马上处理的”，等服务器处理完成以后，会再次告诉调用方 “我已经处理完了”。</li></ul></li></ul><p><img src="./1582653108706.png" alt="Alt text"><br><img src="./1582653143245.png" alt="Alt text"><br><img src="./1582653156676.png" alt="Alt text"><br><img src="./1582653175803.png" alt="Alt text"></p><h4 id="②阻塞与非阻塞"><a href="#②阻塞与非阻塞" class="headerlink" title="②阻塞与非阻塞"></a>②阻塞与非阻塞</h4><ul><li>站在线程状态的角度：阻塞指当前线程不能继续执行，需要等待一段时间或者被唤醒。</li><li>站在线程发出请求的角度：我是调用方，我调用一个东西后，在返回结果前是否还能做其他事情。</li><li>阻塞与非阻塞是调用方的行为，而不是被调用方的行为。<ul><li>阻塞：调用一个东西后，返回结果前什么也不做。</li><li>非阻塞：调用一个东西后，返回结果前做其他事情。</li></ul></li></ul><h4 id="③同步阻塞、同步非阻塞、异步阻塞、异步非阻塞"><a href="#③同步阻塞、同步非阻塞、异步阻塞、异步非阻塞" class="headerlink" title="③同步阻塞、同步非阻塞、异步阻塞、异步非阻塞"></a>③同步阻塞、同步非阻塞、异步阻塞、异步非阻塞</h4><ul><li>同步不一定是阻塞，阻塞也不一定是同步。</li><li>异步不一定是非阻塞，非阻塞也不一定是异步。</li><li>同步阻塞：（被调用方）执行完成后才返回结果、（调用方）在返回结果前什么也不做。</li><li>同步非阻塞：（被调用方）执行完成后才返回结果、（调用方）在返回结果前做其他事情，不时地检查一下被调用方是否返回结果。</li><li>异步阻塞：调用方在发出请求之后，被调用方会立刻告诉调用方已经收到请求，当被调用方处理完成以后，会再次告诉调用方已经处理完了、但是（调用方）在返回结果前什么也不做。</li><li>异步非阻塞：调用方在发出请求之后，被调用方会立刻告诉调用方已经收到请求，当被调用方处理完成以后，会再次告诉调用方已经处理完了、（调用方）在返回结果前做其他事情，等待被调用方主动返回结果。</li></ul><hr><h3 id="6-常见面试问题"><a href="#6-常见面试问题" class="headerlink" title="6.常见面试问题"></a>6.常见面试问题</h3><h4 id="①进程和线程的异同？"><a href="#①进程和线程的异同？" class="headerlink" title="①进程和线程的异同？"></a>①进程和线程的异同？</h4><ul><li>不同：起源、概念、内存共享方式、拥有的资源、数量、开销</li><li>相同：生命周期（状态）</li><li>具体见 <strong>1.进程和线程——④两者的异同</strong></li></ul><h4 id="②并行和并发的异同？"><a href="#②并行和并发的异同？" class="headerlink" title="②并行和并发的异同？"></a>②并行和并发的异同？</h4><ul><li>都在形容一个程序的运行状态时：并行一定是并发。</li><li>并发也可以形容一个程序的属性，即程序是否具有并发性。若是程序没有并发性，表示程序只能串行执行。</li></ul><h4 id="③多线程就是高并发吗？有什么反例？"><a href="#③多线程就是高并发吗？有什么反例？" class="headerlink" title="③多线程就是高并发吗？有什么反例？"></a>③多线程就是高并发吗？有什么反例？</h4><ul><li>高并发指服务器同时接受很多请求，受到极大压力。</li><li>多线程是针对高并发的一个解决方案，可以使用多线程将这个压力迅速化解。</li><li>反例：Redis 本身是单线程的，但是同样可以支持高并发的场景。</li><li>应对高并发时，不仅可以通过多线程的方式解决，也可以从整体架构、缓存层的设计、MQ 队列等地方着手解决。</li></ul><h4 id="④多线程可以提高程序的执行效率，你知不知道有哪些弊端？"><a href="#④多线程可以提高程序的执行效率，你知不知道有哪些弊端？" class="headerlink" title="④多线程可以提高程序的执行效率，你知不知道有哪些弊端？"></a>④多线程可以提高程序的执行效率，你知不知道有哪些弊端？</h4><ol><li>性能问题（上下文切换、保存 CPU cache）</li><li>异构化任务或不能并行执行的任务用多线程反而不如用单线程合适</li><li>线程安全问题</li></ol><h4 id="⑤什么是同步？什么是异步？什么是阻塞？什么是非阻塞？"><a href="#⑤什么是同步？什么是异步？什么是阻塞？什么是非阻塞？" class="headerlink" title="⑤什么是同步？什么是异步？什么是阻塞？什么是非阻塞？"></a>⑤什么是同步？什么是异步？什么是阻塞？什么是非阻塞？</h4><ul><li>同步、异步指的是被调用方在调用结束后是否主动返回结果</li><li>阻塞、非阻塞指的是调用方在调用后是否可以去做其他事情</li><li>具体见 <strong>5.同步与异步、阻塞与非阻塞</strong></li></ul><h4 id="⑥在单核-CPU-上运行多线程程序有意义吗？"><a href="#⑥在单核-CPU-上运行多线程程序有意义吗？" class="headerlink" title="⑥在单核 CPU 上运行多线程程序有意义吗？"></a>⑥在单核 CPU 上运行多线程程序有意义吗？</h4><ul><li>有意义，虽然在单核 CPU 上执行真正的并行是不可能的，因为只有一个处理器，但是对于应用程序而言，我们不知道它未来会运行在单核 CPU 还是多核 CPU 上，所以在编写时肯定以多核 CPU 为准。其次，对于多线程程序，当其中一个线程执行缓慢或者被阻塞时，其他线程可以利用这些时间（如读取磁盘的时间）做其他事情，让程序保持高效运转。</li><li>如果 CPU 被挤满，并不是说在单核 CPU 上运行多线程程序没有意义，而是说线程的数量设置不合理，应该减少线程的数量。</li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#x6a;&#121;&#109;&#101;&#x73;&#x73;&#105;&#64;&#49;&#54;&#51;&#46;&#99;&#x6f;&#109;" target="_blank" rel="noopener">&#x77;&#x6a;&#121;&#109;&#101;&#x73;&#x73;&#105;&#64;&#49;&#54;&#51;&#46;&#99;&#x6f;&#109;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-进程和线程&quot;&gt;&lt;a href=&quot;#1-进程和线程&quot; class=&quot;headerlink&quot; title=&quot;1.进程和线程&quot;&gt;&lt;/a&gt;1.进程和线程&lt;/h3&gt;&lt;h4 id=&quot;①与操作系统的关系&quot;&gt;&lt;a href=&quot;#①与操作系统的关系&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized关键字</title>
    <link href="http://messi1002.top/2020/02/20/Synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://messi1002.top/2020/02/20/Synchronized关键字/</id>
    <published>2020-02-20T04:21:51.000Z</published>
    <updated>2020-02-25T04:45:17.641Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><h4 id="①作用"><a href="#①作用" class="headerlink" title="①作用"></a>①作用</h4><ul><li>Oracle 的官方解释：synchronized 关键字的同步方法支持一种简单的策略来防止线程干扰和内存一致性错误。<ul><li>如果一个对象对多个线程可见，则对该对象变量的所有读取或写入都是通过同步方法完成的。</li></ul></li><li>一句话总结 synchronized 的作用：能够保证在同一时刻最多只有一个线程执行该段代码，以达到保证并发安全的效果。<ul><li>被 synchronized 关键字修饰的代码会以原子的方式执行，即多个线程不会同时执行这段代码，同一时刻最多只有一个线程执行该段代码。</li><li>如何控制同一时刻只有一个线程执行该段代码？有一把锁，当第一个线程执行这段代码时拿到这把锁，直到方法执行结束或一定条件后才会释放这把锁。在这把锁释放前，其他线程想要执行这段代码，只能等待或者阻塞。直到锁释放后，其他线程才能执行这段代码。</li></ul></li></ul><h4 id="②地位"><a href="#②地位" class="headerlink" title="②地位"></a>②地位</h4><ul><li>synchronized 是 Java 的关键字，被 Java 语言原生支持。<ul><li><strong>volatile</strong> 也是 Java 的关键字（它们都是 Java 并发编程中的重要关键字）</li></ul></li><li>它是最基本的互斥同步手段<ul><li>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。　　</li><li>同步：指程序用于控制不同线程之间操作发生相对顺序的机制。</li></ul></li><li>它是并发编程中的元老级角色，是并发编程的必学内容。</li></ul><h4 id="③不使用并发（同步方法）的后果"><a href="#③不使用并发（同步方法）的后果" class="headerlink" title="③不使用并发（同步方法）的后果"></a>③不使用并发（同步方法）的后果</h4><ul><li>代码实战：两个线程同时执行 <code>a++</code>，最后结果会被预计的少。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 不使用并发手段，建立两个线程一起执行a++。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoUseConcurrency</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建类的实例</span></span><br><span class="line">    <span class="keyword">static</span> NoUseConcurrency instance = <span class="keyword">new</span> NoUseConcurrency();</span><br><span class="line">    <span class="comment">// 初始化a的值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 建立两个线程，利用同一个实例，共用实例中的方法。</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待两个子线程都执行完成</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>连续运行三次程序，打印的结果各不相同。</li></ul><p><img src="./1582533268242.png" alt="Alt text"><br><img src="./1582533337941.png" alt="Alt text"><br><img src="./1582533388383.png" alt="Alt text"></p><ul><li>原因：<code>a++</code> 看上去只是一个操作，实际上包含了三个步骤：<ul><li>①读取 a</li><li>②将 a 的值加 1</li><li>③将 a 的值写入到内存中</li></ul></li><li>而在多线程的情况下任何一步执行完成后都有可能被打断，都有可能轮到另一个线程去执行，即线程不安全。</li></ul><h4 id="④使用并发（同步方法）"><a href="#④使用并发（同步方法）" class="headerlink" title="④使用并发（同步方法）"></a>④使用并发（同步方法）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 使用并发手段，建立两个线程一起执行a++。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseConcurrency</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> UseConcurrency instance = <span class="keyword">new</span> UseConcurrency();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 建立两个线程，利用同一个实例，共用实例中的方法。</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待两个子线程都执行完成</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对象锁-方法锁</span></span><br><span class="line">    <span class="comment">// 将关键字加在普通方法上</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重复运行多次程序，打印结果都是 <code>a = 200000</code>。</li></ul><hr><h3 id="2-用法"><a href="#2-用法" class="headerlink" title="2.用法"></a>2.用法</h3><blockquote><p>synchronized 关键字也叫做同步修饰符<br>音标：[ˈsɪŋkrənaɪzd]</p></blockquote><h4 id="①对象锁"><a href="#①对象锁" class="headerlink" title="①对象锁"></a>①对象锁</h4><ul><li>对象锁的两种形式：</li><li>同步代码块锁<ul><li>手动指定锁对象（this 或自定义对象）</li></ul></li><li>方法锁<ul><li>synchronized 修饰普通方法（不能修饰静态方法），锁对象默认为 this。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 对象锁实例1之同步代码块形式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectLock1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObjectLock1 instance = <span class="keyword">new</span> SynchronizedObjectLock1();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 默认用this(当前对象)作为锁对象</span></span><br><span class="line">        <span class="comment">// 保护以下代码块串行执行</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"开始执行"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 建立两个线程，利用同一个实例，共用实例中的方法。</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待两个子线程都执行完成</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码线程 0 先执行，执行完成后线程 1 再执行。</li></ul><p><img src="./1582534624946.png" alt="Alt text"><br><img src="./1582534690028.png" alt="Alt text"><br><img src="./1582534597454.png" alt="Alt text"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 对象锁实例1之同步代码块形式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectLock1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObjectLock1 instance = <span class="keyword">new</span> SynchronizedObjectLock1();</span><br><span class="line">    <span class="comment">// 创建自定义锁对象，lock1和lock2保护的时机不相同。</span></span><br><span class="line">    Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">    Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义锁对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"开始执行(lock1)"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行结束(lock1)"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"开始执行(lock2)"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行结束(lock2)"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 建立两个线程，利用同一个实例，共用实例中的方法。</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待两个子线程都执行完成</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码线程 0 拿到第 2 把锁的同时，线程 1 拿到第 1 把锁，并行执行（第一把锁和第二把锁不相同，互不影响）。</li></ul><p><img src="./1582536037312.png" alt="Alt text"><br><img src="./1582536127382.png" alt="Alt text"><br><img src="./1582536195719.png" alt="Alt text"><br><img src="./1582535365421.png" alt="Alt text"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 对象锁示例2之方法锁形式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectLock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObjectLock2 instance = <span class="keyword">new</span> SynchronizedObjectLock2();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对普通方法加上synchronized修饰符，保护以下代码块串行执行。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"对象锁的方法修饰符形式"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"执行结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 建立两个线程，利用同一个实例，共用实例中的方法。</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待两个子线程都执行完成</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码线程 0 先执行，执行完成后线程 1 再执行。</li></ul><p><img src="./1582537941538.png" alt="Alt text"><br><img src="./1582537977048.png" alt="Alt text"><br><img src="./1582538009150.png" alt="Alt text"></p><h4 id="②类锁"><a href="#②类锁" class="headerlink" title="②类锁"></a>②类锁</h4><ul><li>Java 类可能有很多个对象，但是只有 1 个 Class 对象。</li><li>本质：所谓的类锁，就是 Class 对象的锁。</li><li>效果：类锁在同一时刻只能被一个对象拥有</li><li>类锁的两种形式：</li><li>静态锁<ul><li>synchronized 加在 static 方法上 </li></ul></li><li>Class 对象<ul><li>synchronized 代码块（锁对象默认为 Class 对象） </li><li>指定锁为 Class 对象</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 类锁示例1之静态锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedClassLock1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedClassLock1 instance1 = <span class="keyword">new</span> SynchronizedClassLock1();</span><br><span class="line">    <span class="keyword">static</span> SynchronizedClassLock1 instance2 = <span class="keyword">new</span> SynchronizedClassLock1();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// synchronized修饰符修饰静态方法</span></span><br><span class="line">    <span class="comment">// 在全局情况下保护以下代码块串行执行(不是对象的层面)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 建立两个线程，两个线程分别引用同一个类的不同实例。</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待两个子线程都执行完成</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码线程 0 先执行，执行完成后线程 1 再执行。</li></ul><p><img src="./1582539304996.png" alt="Alt text"><br><img src="./1582539337288.png" alt="Alt text"><br><img src="./1582539375670.png" alt="Alt text"></p><ul><li>若是将 <code>method()</code> 方法变为非静态方法，此时就算加了 synchronized 关键字，线程 0 和线程 1 也会同时执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 类锁示例1之静态锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedClassLock1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedClassLock1 instance1 = <span class="keyword">new</span> SynchronizedClassLock1();</span><br><span class="line">    <span class="keyword">static</span> SynchronizedClassLock1 instance2 = <span class="keyword">new</span> SynchronizedClassLock1();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// synchronized修饰符修饰非静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 建立两个线程，两个线程分别引用同一个类的不同实例</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待两个子线程都执行完成</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">      System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582540371493.png" alt="Alt text"><br><img src="./1582540395219.png" alt="Alt text"></p><ul><li>因为静态方法属于整个类，当多个线程（类的不同实例）访问这个类的静态方法时，实际访问的是同一个方法。所以给这个静态方法上锁之后，同一时刻只能由一个线程执行该方法。</li><li>而非静态方法属于调用它的实例对象，当两个线程分别调用其实例对象的非静态方法时，相当于各自执行自己的方法，这时加或不加锁都不影响各自方法的执行。</li><li>所以类锁适用于在全局情况下同步方法，而不仅仅在对象层面。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 类锁示例2之Class对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedClassLock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedClassLock2 instance1 = <span class="keyword">new</span> SynchronizedClassLock2();</span><br><span class="line">    <span class="keyword">static</span> SynchronizedClassLock2 instance2 = <span class="keyword">new</span> SynchronizedClassLock2();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 锁对象是SynchronizedClassLock2.class</span></span><br><span class="line">        <span class="comment">// 无论是类的哪个实例用的都是同一个锁对象(串行执行)</span></span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedClassLock2.class) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 建立两个线程，两个线程分别引用同一个类的不同实例</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待两个子线程都执行完成</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码线程 0 先执行，执行完成后线程 1 再执行。</li></ul><p><img src="./1582541802253.png" alt="Alt text"><br><img src="./1582541826775.png" alt="Alt text"><br><img src="./1582541841546.png" alt="Alt text"></p><ul><li>若是将 synchronized 代码块中的 <code>SynchronizedClassLock2.class</code> 改为 <code>this</code>，此时就算是加了 synchronized 关键字，线程 0 和线程 1 也会同时执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 类锁示例2之Class对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedClassLock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedClassLock2 instance1 = <span class="keyword">new</span> SynchronizedClassLock2();</span><br><span class="line">    <span class="keyword">static</span> SynchronizedClassLock2 instance2 = <span class="keyword">new</span> SynchronizedClassLock2();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 锁对象是this</span></span><br><span class="line">        <span class="comment">// 不同实例的锁对象不同，多个线程并行执行。</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 建立两个线程，两个线程分别引用同一个类的不同实例</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待两个子线程都执行完成</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582542407010.png" alt="Alt text"><br><img src="./1582542460177.png" alt="Alt text"></p><ul><li>原因：不同实例的锁对象不同，多个线程并行执行。</li></ul><hr><h3 id="3-多线程访问同步方法的-7-种情况（面试常考）"><a href="#3-多线程访问同步方法的-7-种情况（面试常考）" class="headerlink" title="3.多线程访问同步方法的 7 种情况（面试常考）"></a>3.多线程访问同步方法的 7 种情况（面试常考）</h3><blockquote><p>同步方法：被 synchronized 关键字所修饰的方法<br>非同步方法：没有被 synchronized 关键字所修饰的方法<br>普通方法：指非静态方法</p></blockquote><h4 id="①两个线程同时访问一个对象的同步方法"><a href="#①两个线程同时访问一个对象的同步方法" class="headerlink" title="①两个线程同时访问一个对象的同步方法"></a>①两个线程同时访问一个对象的同步方法</h4><ul><li>原因：两个线程属于同一个实例，所以两个线程访问的是同一个方法，而这个方法被 synchronized 关键字修饰后默认以 this 对象作为同步方法的锁，所以它们会争抢同一把锁。</li><li>结果：两个线程争抢同一把锁，同一时刻只能有一个线程执行该同步方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 两个线程同时访问一个对象的同步方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Situation1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Situation1 instance = <span class="keyword">new</span> Situation1();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Situation1.class finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582547849811.png" alt="Alt text"><br><img src="./1582547871624.png" alt="Alt text"><br><img src="./1582547896299.png" alt="Alt text"></p><h4 id="②两个线程访问的是两个对象的同步方法"><a href="#②两个线程访问的是两个对象的同步方法" class="headerlink" title="②两个线程访问的是两个对象的同步方法"></a>②两个线程访问的是两个对象的同步方法</h4><ul><li>原因：两个线程属于不同的实例，所以两个线程访问的是不同的方法，而每个方法被 synchronized 关键字修饰后默认以 this 对象作为同步方法的锁，所以它们的锁对象不是同一个。</li><li>结果：两个线程的锁对象不是同一个，并行执行，互不干扰。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 两个线程访问的是两个对象的同步方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Situation2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Situation2 instance1 = <span class="keyword">new</span> Situation2();</span><br><span class="line">    <span class="keyword">static</span> Situation2 instance2 = <span class="keyword">new</span> Situation2();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Situation2.class finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582548056867.png" alt="Alt text"><br><img src="./1582548075858.png" alt="Alt text"></p><h4 id="③两个线程访问的是-synchronized-的静态方法"><a href="#③两个线程访问的是-synchronized-的静态方法" class="headerlink" title="③两个线程访问的是 synchronized 的静态方法"></a>③两个线程访问的是 synchronized 的静态方法</h4><ul><li>原因：虽然两个线程属于类的不同实例，但是两个线程访问的方法是类的静态方法，即它们实际访问的是同一个方法。给这个静态方法上锁之后，同一时刻只能有一个线程执行该方法。</li><li>结果：两个线程争抢同一把锁，同一时刻只能有一个线程执行该同步方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 两个线程访问的是synchronized的静态方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Situation3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Situation3 instance1 = <span class="keyword">new</span> Situation3();</span><br><span class="line">    <span class="keyword">static</span> Situation3 instance2 = <span class="keyword">new</span> Situation3();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Situation3.class finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582548260523.png" alt="Alt text"><br><img src="./1582548289256.png" alt="Alt text"><br><img src="./1582548315931.png" alt="Alt text"></p><h4 id="④同时访问同步方法与非同步方法"><a href="#④同时访问同步方法与非同步方法" class="headerlink" title="④同时访问同步方法与非同步方法"></a>④同时访问同步方法与非同步方法</h4><ul><li>原因：synchronized 关键字只作用于其指定的方法中，其他非同步方法不受到影响。</li><li>结果：当线程 0 访问同步方法，线程 1 访问非同步方法时，两个线程并行执行，互不干扰。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 同时访问同步和非同步方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Situation4</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Situation4 instance = <span class="keyword">new</span> Situation4();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 让线程0运行method1()方法，线程1运行method2()方法。</span></span><br><span class="line">        <span class="comment">// 线程的默认名是从Thread-0(Thread-1、Thread-2、...)开始。</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread().getName().equals(<span class="string">"Thread-0"</span>)) &#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            method2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行(加锁的方法)"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行(加锁的方法)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行(没加锁的方法)"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行(没加锁的方法)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Situation4.class finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582548882215.png" alt="Alt text"><br><img src="./1582548895883.png" alt="Alt text"></p><h4 id="⑤同时访问一个类的不同的普通同步方法"><a href="#⑤同时访问一个类的不同的普通同步方法" class="headerlink" title="⑤同时访问一个类的不同的普通同步方法"></a>⑤同时访问一个类的不同的普通同步方法</h4><ul><li>原因：两个线程属于同一个实例，虽然两个线程访问的是一个类的不同的普通同步方法，但是被 synchronized 关键字修饰的普通方法默认都是以 this 对象作为同步方法的锁，所以它们会争抢同一把锁（对于同一个实例来讲，两个方法的 this 对象是同一个）。</li><li>结果：两个线程争抢同一把锁，同一时刻只能有一个线程执行该线程对应的同步方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 同时访问一个类的不同的普通同步方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Situation5</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Situation5 instance = <span class="keyword">new</span> Situation5();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread().getName().equals(<span class="string">"Thread-0"</span>)) &#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            method2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行(加锁的方法)"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行(加锁的方法)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行(加锁的方法)"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行(加锁的方法)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Situation5.class finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582549226682.png" alt="Alt text"><br><img src="./1582549274126.png" alt="Alt text"><br><img src="./1582549286842.png" alt="Alt text"></p><h4 id="⑥同时访问静态-synchronized-和非静态-synchronized-方法"><a href="#⑥同时访问静态-synchronized-和非静态-synchronized-方法" class="headerlink" title="⑥同时访问静态 synchronized 和非静态 synchronized 方法"></a>⑥同时访问静态 synchronized 和非静态 synchronized 方法</h4><ul><li>原因：<ul><li>synchronized 关键字修饰静态方法：类锁，锁住的是 .class 对象。</li><li>synchronized 关键字修饰非静态方法：方法锁，锁住的是实例本身 this。</li><li>两个线程的锁对象不是同一个，所以两个线程可以同时运行。</li></ul></li><li>结果：两个线程的锁对象不是同一个，并行执行，互不干扰。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 同时访问静态synchronized和非静态synchronized方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Situation6</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Situation6 instance = <span class="keyword">new</span> Situation6();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread().getName().equals(<span class="string">"Thread-0"</span>)) &#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            method2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行(静态加锁的方法)"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行(静态加锁的方法)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行(非静态加锁的方法)"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束运行(非静态加锁的方法)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Situation6.class finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582549897829.png" alt="Alt text"><br><img src="./1582549910266.png" alt="Alt text"></p><h4 id="⑦方法抛出异常后会释放锁"><a href="#⑦方法抛出异常后会释放锁" class="headerlink" title="⑦方法抛出异常后会释放锁"></a>⑦方法抛出异常后会释放锁</h4><ul><li>synchronized：方法抛出异常后会主动释放锁。</li><li>Lock 类：方法抛出异常后不会主动释放锁，必须显式地释放锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 方法抛出异常后会释放锁</span></span><br><span class="line"><span class="comment"> * 展示不抛出异常前和抛出异常后的对比: 一旦第一个线程抛出异常，第二个线程会立刻进入同步方法，意味着锁已经释放。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Situation7</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Situation7 instance = <span class="keyword">new</span> Situation7();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 方法抛出异常后，JVM帮我们释放了锁，不需要手动释放锁。</span></span><br><span class="line">        <span class="comment">// 抛出运行时异常，不强制要求捕获。</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Situation7.class finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582550356233.png" alt="Alt text"><br><img src="./1582550465567.png" alt="Alt text"></p><h4 id="⑧总结"><a href="#⑧总结" class="headerlink" title="⑧总结"></a>⑧总结</h4><ol><li>一把锁只能同时被一个线程获取，没有拿到锁的线程必须等待（对应①、⑤）。</li><li>每个实例都对应有自己的一把锁，不同的实例之间对应不同的锁，所以不同的实例之间互不影响。<ul><li>例外：锁对象是 .class 以及 synchronized 修饰的是 static 方法的时候，所有对象共用同一把类锁（对应②、③、④、⑥） 。</li></ul></li><li>无论是方法正常执行完毕或者方法抛出异常，都会释放锁（对应⑦）。</li><li>在被 synchronized 修饰的方法中调用没有被 synchronized 修饰的方法时，不是线程安全的，因为没有被 synchronized 修饰的方法是可以被多个线程同时访问的。</li></ol><hr><h3 id="4-性质"><a href="#4-性质" class="headerlink" title="4.性质"></a>4.性质</h3><h4 id="①可重入性（递归锁）"><a href="#①可重入性（递归锁）" class="headerlink" title="①可重入性（递归锁）"></a>①可重入性（递归锁）</h4><ul><li><p>这是它区别于其他锁的关键特点</p></li><li><p>可重入性：指的是同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁。</p><ul><li>ReentrantLock 也是可重入锁</li></ul></li><li><p>好处：</p><ul><li>避免死锁（假设方法 1 和方法 2 都被 synchronized 关键字修饰，此时某线程执行方法 1 和方法 2 时都需要同一把锁。假如线程 A 执行了方法 1 并且获得了这把锁，此时方法 1 要想访问方法 2，假设 synchronized 关键字没有可重入性，相当于线程 A 没有方法 2 的锁，不能直接使用本身已经获得的锁。既想要拿到方法 2 的锁又不释放方法 1 的锁<br>（方法 1 和方法 2 是同一把锁），就开始了永久等待，变成了死锁。）</li><li>提升封装性（避免一次次解锁、加锁，提高了封装性，简化了并发编程的难度。）</li></ul></li><li><p>粒度：即范围，默认加锁的范围是线程而非调用。</p><ul><li>情况1：访问同一个方法是可重入的</li><li>情况2：可重入不要求是同一个方法（即证明在一个同步方法中调用另一个同步方法是可行的）</li><li>情况3：可重入不要求是同一个类中的</li><li>以上三种情况证明了可重入的粒度不是调用范围的，而是线程范围的。所以在同一个线程中，如果已经拿到了一把锁，又想继续使用这把锁访问其他（类的）方法时，只要锁是同一把锁，就可以访问。</li></ul></li><li><p>证明情况1：访问同一个方法是可重入的</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 可重入粒度测试1——递归调用本方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantGranularityTest1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a = "</span> + a);</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">            a++;</span><br><span class="line">            <span class="comment">// 调用方法本身</span></span><br><span class="line">            method();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantGranularityTest1 test1 = <span class="keyword">new</span> ReentrantGranularityTest1();</span><br><span class="line">        test1.method();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582552644697.png" alt="Alt text"></p><ul><li>证明情况2：可重入不要求是同一个方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 可重入粒度测试2——调用类内其他的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantGranularityTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是方法一"</span>);</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是方法二"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantGranularityTest2 test2 = <span class="keyword">new</span> ReentrantGranularityTest2();</span><br><span class="line">        test2.method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582552602807.png" alt="Alt text"></p><ul><li>证明情况3：可重入不要求是同一个类中的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 可重入粒度测试3——父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantGranularityTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是父类方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 可重入粒度测试3——调用父类的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantGranularityTest3</span> <span class="keyword">extends</span> <span class="title">ReentrantGranularityTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 重写父类方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/20 22:30</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是子类方法"</span>);</span><br><span class="line">        <span class="comment">// 调用父类方法</span></span><br><span class="line">        <span class="keyword">super</span>.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantGranularityTest3 test3 = <span class="keyword">new</span> ReentrantGranularityTest3();</span><br><span class="line">        <span class="comment">// 执行子类方法</span></span><br><span class="line">        test3.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582552861324.png" alt="Alt text"></p><h4 id="②不可中断性"><a href="#②不可中断性" class="headerlink" title="②不可中断性"></a>②不可中断性</h4><ul><li>这个性质是 synchronized 关键字的劣势</li><li>不可中断性：一旦这个锁已经被别人获得了，如果我还想获取，我只能选择等待或者阻塞，直到别的线程释放这个锁。如果别人永远不释放锁，那么我只能永远等待下去。</li><li>而 Lock 类拥有可以中断的能力<ul><li>如果我觉得我等待的时间太长了，有权中断现在已经获取到锁的那个线程的执行。</li><li>如果我觉得我等待的时间太长了不想再等了，也可以直接退出。</li></ul></li></ul><hr><h3 id="5-原理"><a href="#5-原理" class="headerlink" title="5.原理"></a>5.原理</h3><h4 id="①加锁和释放锁的原理"><a href="#①加锁和释放锁的原理" class="headerlink" title="①加锁和释放锁的原理"></a>①加锁和释放锁的原理</h4><ul><li>每一个类的实例对应着一把锁，而每一个被 synchronized 关键字修饰的方法都必须首先获得调用该方法的类的实例的锁才能执行，否则线程就会阻塞。而方法一旦执行，就会独占这把锁，直到该方法返回或者抛出异常，才会将锁释放。释放之后，其他被阻塞的线程就能获得这把锁，重新进入到可执行的状态。</li><li>即当一个对象中有 synchronized 关键字修饰的方法或者代码块时，要想执行这段代码，就必须先获得对象锁。如果此对象的对象锁已经被其他调用者占用了，就必须等待它被释放。所有的 Java 对象都含有一个互斥锁，这个锁由 JVM 自动去获取和释放，我们只需要指定这个对象就可以了。</li><li>获取和释放锁的时机：内置锁<ul><li>每个 Java 对象都可以用作一个实现同步的锁，这个锁被称为内置锁或监视器锁。线程在进入到同步代码块之前，会自动获得这个锁，并且在退出同步代码块的时候，会自动释放。</li><li>获得内置锁的唯一途径，就是进入到锁所保护的同步代码块或方法中。</li></ul></li><li>下面用 Lock 模拟 synchronized 加锁和释放锁的时机：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 用lock模拟synchronized加锁和释放锁的时机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockAndUnlock</span> </span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 进入方法时隐形地获取一把锁</span></span><br><span class="line">        System.out.println(<span class="string">"我是synchronized形式的锁"</span>);</span><br><span class="line">        <span class="comment">// 退出方法时隐形地释放一把锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"我是lock形式的锁"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// synchronized和lock在底层可以相互类比和配合</span></span><br><span class="line">        <span class="comment">// method1方法和method2方法等价</span></span><br><span class="line">        <span class="comment">// 将method1中synchronized锁住和解锁的时机用method2中拆分的形式表达</span></span><br><span class="line">        LockAndUnlock l = <span class="keyword">new</span> LockAndUnlock();</span><br><span class="line">        l.method1();</span><br><span class="line">        l.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582555202885.png" alt="Alt text"></p><h4 id="③反编译看-monitor-指令"><a href="#③反编译看-monitor-指令" class="headerlink" title="③反编译看 monitor 指令"></a>③反编译看 monitor 指令</h4><ul><li><p>synchronized 是如何工作的</p><ul><li>synchronized 用的锁是 Java 对象头里的一个字段（每一个对象都有一个对象头，对象头可以存储很多信息，其中有一个部分就是用来存储 synchronize 关键字的锁的，表明是否被锁住。）</li><li>细节：当线程访问一个同步代码块时，必须要得到这把锁，退出整个代码块或者抛出异常的时候必须释放锁，而锁存储在 Java 对象头中。在 JVM 规范中对于 synchronized 的实现原理已经有了说明，它的进入锁和释放锁是基于 Moniter 对象来实现同步方法和同步代码块的。Monditor 对象主要有两个指令：Monditorenter（插入到同步代码块开始的位置）和 Monditorexit（插入到方法结束的时候和退出的时候）。JVM 规范保证每一个 enter 之后必须要有 exit 和它对应，但是可能有多个 exit 和同一个 enter 对应，因为退出的时机包括方法结束和抛出异常。每一个对象都有一个 Monditor 和它关联，并且一旦一个 Monditor 被持有后，就会处于锁定状态，当线程执行到 Monditorenter 指令时，会尝试获取这个对象对应的 Monditor 的所有权，也就是尝试获取这个对象锁。</li></ul></li><li><p>编译：<code>javac 类名.java</code></p><ul><li>将 Java 类编译为 .class 文件</li></ul></li><li><p>反编译：<code>javap -verbose class文件名.class</code></p><ul><li>将 .class 文件反编译为字节码文件</li></ul></li><li><p>反编译结果：</p></li></ul><p><img src="./1582444077456.png" alt="Alt text"></p><ul><li>详细解读 Monditorenter 和 Monditorexit 指令：Monditorenter 和 Monditorexit 指令在执行的时候会使对象的锁计数加 1 或者减 1。每一个对象都和一个 Monditor 相关联，一个 Moditor 的 lock 锁只能被一个线程在同一时间获得，一个线程在尝试获得与这个对象关联的 Monditor 的所有权的时候，只会发生以下三种情况之一（即 Monditorenter 指令的三种情况）：<ul><li>成功获得锁：Monditor 计数器为 0，意味着目前还没有被获得，这个线程就会立刻获得，然后把计数器加 1，之后别人再想进来就会看到信号，知道它已经被其他线程所持有，所以加 1 意味着当前线程是这个 Moditor 的持有者。</li><li>已经拿到这把锁的所有权再次重入时：计数器随着重入次数的增加而增加（每次加 1）。</li><li>Monditor 已经被其他线程所持有了：当前线程再次获取就会得到现在无法获取的信号，就会进入阻塞状态，直到 Moditor 的计数器变为0，才会再次尝试获取这个锁。</li></ul></li><li>Monditorexit：释放 Monditor 的所有权（可以将 Monditor 理解为锁）<ul><li>前提是已经拥有了锁的所有权</li><li>释放的过程：将 Monditor 的计数器减 1，如果减完之后变成 0 就意味着当前线程不再拥有对 Monditor 的所有权，即解锁。如果减完之后不是 0，意味着刚才是可重入进来的，所以还是继续持有这把锁。最终计数器减到 0 之后，不仅意味着释放锁了，还意味着刚才被阻塞的线程会再次尝试获取对这把锁的所有权。</li></ul></li></ul><h4 id="③可重入原理"><a href="#③可重入原理" class="headerlink" title="③可重入原理"></a>③可重入原理</h4><ul><li>可重入性：一个线程拿到一把锁之后，如果还想再次进入由这把锁所控制的方法，可以直接进入。</li><li>可重入原理：利用加锁次数计数器<ul><li>每个对象自动地含有一把锁，JVM 负责跟踪对象被加锁的次数。 线程第一次给对象加锁的时候，计数变为 1。每当这个相同的线程在此对象上再次获得锁时，计数递增。每当任务结束离开时，计数递减，当计数为 0 的时候，锁被完全释放。</li></ul></li></ul><h4 id="④可见性原理"><a href="#④可见性原理" class="headerlink" title="④可见性原理"></a>④可见性原理</h4><ul><li>保证可见性的原理：Java 内存模型<ul><li>共享变量的副本：将主内存的变量复制一份，放在自己的本地内存。原因：加速程序的运行，因为线程所使用的内存速度比主存中的速度快。</li><li>两个线程要想互相通信-要怎么做：线程 A 将共享变量的副本写到主内存中，因为主内存是它们相互沟通的桥梁，然后线程 B 再去主内存中读取。</li><li>这个过程是 JMM（Java 内存模型的缩写）控制的，JMM 通过控制主内存与每个线程的本地内存的交互来提供内存可见性的保证。</li></ul></li></ul><p><img src="./1582445087616.png" alt="Alt text"></p><ul><li>synchronized 是如何做到可见性的实现的？<ul><li>一旦代码块或者方法被 synchronized 关键字所修饰，那么它在执行完毕之后，被锁住的对象所做的任何修改，都要在释放锁之前，从线程内存写回到主内存中（不会存在线程内存和主内存不一致的情况）。</li><li>同样，在进入代码块获得锁之后，被锁定对象的数据也是直接从主内存中读取出来的。</li></ul></li></ul><hr><h3 id="6-缺陷"><a href="#6-缺陷" class="headerlink" title="6.缺陷"></a>6.缺陷</h3><ol><li>效率低<ul><li>锁的释放情况少：当一个线程获取到锁并在执行过程中，其他线程也想要获得该锁时，只能等待当前线程释放。而当前线程只有在两种情况下才会释放锁：①线程执行完该段代码、②执行过程中发生异常（JVM 将锁释放）。如果要等待 IO 这种耗时操作或者线程 sleep 时，不会主动释放锁，其他线程只能等待，非常影响程序执行的效率。这时需要一种机制，遏制这些情况。（Lock 类可以做到）</li><li>试图获得锁时不能设定超时时间，只能等待。（Lock 类可以做到）</li><li>不能中断一个正在试图获得锁的线程（Lock 类可以做到）</li></ul></li><li>不够灵活（读写锁更灵活）<ul><li>加锁和释放锁的时机单一，每个锁仅有单一的条件（某个对象）。锁住某个对象，某个对象就是这把锁。释放这个对象，才意味着解了这把锁。</li></ul></li><li>无法知道是否成功获取到锁（Lock 类可以做到）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 展示Lock的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="comment">// 通过这两个方法灵活得控制这把锁，且可以配置自定义的锁。</span></span><br><span class="line">        <span class="comment">// 锁住</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">        <span class="comment">// 在规定的超时时间内等待获得锁。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 不设置超时时间的tryLock()</span></span><br><span class="line">            lock.tryLock();</span><br><span class="line">            <span class="comment">// 若是10s拿不到锁，会主动放弃。</span></span><br><span class="line">            lock.tryLock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="7-常见面试问题"><a href="#7-常见面试问题" class="headerlink" title="7.常见面试问题"></a>7.常见面试问题</h3><h4 id="①synchronized-关键字有哪些使用注意点？"><a href="#①synchronized-关键字有哪些使用注意点？" class="headerlink" title="①synchronized 关键字有哪些使用注意点？"></a>①synchronized 关键字有哪些使用注意点？</h4><ol><li>锁对象不能为空<ul><li>指定一个对象作为锁对象时，必须是一个实例对象被 new 过，或者使用其他方法创建好的，而不是空对象。这是因为锁的信息保存在对象头中的，如果对象都没有，就没有对象头，所以这个锁是不能工作的。</li></ul></li><li>作用域不宜过大<ul><li>将尽可能多的代码使用 synchronized 包裹，虽然会降低出并发问题的可能性（大部分线程都是串行工作），但是没有达到多线程编程的目的，影响程序执行的效率。</li></ul></li><li>避免死锁</li></ol><h4 id="②如何选择-Lock-和-synchronized-关键字？"><a href="#②如何选择-Lock-和-synchronized-关键字？" class="headerlink" title="②如何选择 Lock 和 synchronized 关键字？"></a>②如何选择 Lock 和 synchronized 关键字？</h4><ol><li>如果可以的话，两者都不要使用，应该使用 JUC 中的各种类（更方便，不容易出错）。</li><li>如果 synchronized 关键字在程序中适用，那么就优先使用（可以减少所需要编写的代码，也就减少了出错的几率）。</li><li>如果需要使用到 Lock 类独有的特性（如灵活的加解锁机制），再使用 Lock。</li></ol><h4 id="③多线程访问同步方法的各种具体情况"><a href="#③多线程访问同步方法的各种具体情况" class="headerlink" title="③多线程访问同步方法的各种具体情况"></a>③多线程访问同步方法的各种具体情况</h4><ul><li>具体见 <strong>3.多线程访问同步方法的 7 种情况</strong></li></ul><hr><h3 id="8-思考"><a href="#8-思考" class="headerlink" title="8.思考"></a>8.思考</h3><ol><li>多个线程等待同一个 synchronized 锁的时候，JVM 如何选择下一个获取锁的是哪个线程？<ul><li>有内部锁调度机制有关</li><li>持有锁的线程在运行完成或抛出异常后，就会释放这把锁。线程释放锁之后，竞争锁的对象有：等待中的线程、刚刚申请这把锁的线程。内部锁调度机制实现细节和 JVM 的版本、具体实现相关，不能依赖算法。</li><li>目前是处于随机的，不公平的状态。</li><li>synchronized 是非公平锁，ReentrantLock 可以设置是否是公平锁。</li></ul></li><li>synchronized 使得同时只有一个线程可以执行，性能较差，有什么方法可以提升性能？<ul><li>优化使用范围（临界区在符合要求的情况下尽可能得小）</li><li>使用其他类型的锁（如读写锁）</li><li>自己实现 Lock 接口，自由设定锁持有时间</li></ul></li><li>想灵活的控制锁的获取和释放怎么办（现在释放锁的时机都被规定死了）？<ul><li>自己实现一个锁</li></ul></li><li>什么是锁的升级和降级？什么是 JVM 里的偏斜锁、轻量级锁、重量级锁？</li></ol><p><img src="./1582467175893.png" alt="Alt text"></p><hr><h3 id="9-总结"><a href="#9-总结" class="headerlink" title="9.总结"></a>9.总结</h3><ul><li>一句话介绍 synchronized：JVM 会自动通过使用 monitor 来自动加锁和解锁，保证了同时只有一个线程可以执行指定代码，从而保证了线程安全，同时具有可重入和不可中断的性质。</li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#x6a;&#x79;&#x6d;&#101;&#x73;&#x73;&#105;&#64;&#x31;&#54;&#51;&#46;&#x63;&#x6f;&#x6d;" target="_blank" rel="noopener">&#x77;&#x6a;&#x79;&#x6d;&#101;&#x73;&#x73;&#105;&#64;&#x31;&#54;&#51;&#46;&#x63;&#x6f;&#x6d;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.简介&quot;&gt;&lt;/a&gt;1.简介&lt;/h3&gt;&lt;h4 id=&quot;①作用&quot;&gt;&lt;a href=&quot;#①作用&quot; class=&quot;headerlink&quot; title=&quot;①作用&quot;&gt;&lt;/a&gt;①作
      
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
    
      <category term="Java并发编程" scheme="http://messi1002.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb相关软件安装包分享</title>
    <link href="http://messi1002.top/2020/02/18/JavaWeb%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8C%85%E5%88%86%E4%BA%AB/"/>
    <id>http://messi1002.top/2020/02/18/JavaWeb相关软件安装包分享/</id>
    <published>2020-02-18T09:32:45.000Z</published>
    <updated>2020-02-23T13:58:11.245Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Linux-版本（JavaWeb-程序）"><a href="#1-Linux-版本（JavaWeb-程序）" class="headerlink" title="1.Linux 版本（JavaWeb 程序）"></a>1.Linux 版本（JavaWeb 程序）</h3><ul><li>链接：<a href="https://pan.baidu.com/s/1BHFbs0_sMzfBdQGIOCrQ-w" target="_blank" rel="noopener">https://pan.baidu.com/s/1BHFbs0_sMzfBdQGIOCrQ-w</a> </li><li>提取码：wvtt </li><li></li><li>jdk-8u201-linux-x64.tar.gz</li><li>apache-tomcat-8.5.39.tar.gz</li><li>apache-maven-3.6.0-bin.tar.gz</li><li>nginx-1.8.0.tar.gz</li><li>redis-5.0.4.tar.gz</li></ul><hr><h3 id="2-Windows-版本（JavaWeb-程序）"><a href="#2-Windows-版本（JavaWeb-程序）" class="headerlink" title="2.Windows 版本（JavaWeb 程序）"></a>2.Windows 版本（JavaWeb 程序）</h3><ul><li>链接：<a href="https://pan.baidu.com/s/1H4o8uCxwYVn_x0wn7aNvpg" target="_blank" rel="noopener">https://pan.baidu.com/s/1H4o8uCxwYVn_x0wn7aNvpg</a> </li><li>提取码：9h05</li><li></li><li>jdk-8u65-windows-x64.zip</li><li>mysql-5.7.24-winx64.zip</li><li>Redis-x64-3.0.504.msi</li><li>gradle-5.2.1-all.zip</li><li>elasticsearch-7.1.1-windows-x86_64.zip</li><li>elasticsearch-head-master.zip</li></ul><hr><h3 id="3-其他工具（Windows）"><a href="#3-其他工具（Windows）" class="headerlink" title="3.其他工具（Windows）"></a>3.其他工具（Windows）</h3><ul><li>链接：<a href="https://pan.baidu.com/s/1LnO1znY4nlDuu8QvC957bQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1LnO1znY4nlDuu8QvC957bQ</a> </li><li>提取码：ihaf</li><li></li><li>谷歌访问助手_v2.3.0.crx（翻墙）</li><li>Git-2.19.1-64-bit.exe</li><li>GitHubDesktopSetup.exe</li><li>redis-desktop-manager-0.8.8.384.exe</li><li>Xftp.6.0.0105.v2.7z（Xftp.exe）</li><li>Xshell.6.0.0111.v2.7z（Xshell.exe）</li><li>notepad++.exe</li><li>VMware-workstation-full-15.0.0-10134415.exe</li><li>CentOS-7-x86_64-Minimal-1908.iso（CentOS 镜像 在 VMware 中使用）</li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#x6a;&#x79;&#109;&#101;&#x73;&#x73;&#105;&#64;&#49;&#x36;&#51;&#46;&#x63;&#111;&#109;" target="_blank" rel="noopener">&#x77;&#x6a;&#x79;&#109;&#101;&#x73;&#x73;&#105;&#64;&#49;&#x36;&#51;&#46;&#x63;&#111;&#109;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Linux-版本（JavaWeb-程序）&quot;&gt;&lt;a href=&quot;#1-Linux-版本（JavaWeb-程序）&quot; class=&quot;headerlink&quot; title=&quot;1.Linux 版本（JavaWeb 程序）&quot;&gt;&lt;/a&gt;1.Linux 版本（JavaWeb 程
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://messi1002.top/categories/JavaWeb/"/>
    
    
      <category term="资源分享" scheme="http://messi1002.top/tags/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Java进制转换及位运算</title>
    <link href="http://messi1002.top/2019/12/20/Java%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%8F%8A%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://messi1002.top/2019/12/20/Java进制转换及位运算/</id>
    <published>2019-12-20T13:17:40.000Z</published>
    <updated>2019-12-24T08:37:49.764Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-进制"><a href="#1-进制" class="headerlink" title="1.进制"></a>1.进制</h3><h4 id="①进制相关"><a href="#①进制相关" class="headerlink" title="①进制相关"></a>①进制相关</h4><ul><li>在线进制转换工具：<a href="https://tool.lu/hexconvert/" target="_blank" rel="noopener">https://tool.lu/hexconvert/</a> </li><li>进位制是一种记数方式，亦称进位计数法或位值计数法。它是人们为计数和运算方便而约定的计数系统。</li><li>把一个数表示成 a 与 10 的 n 次幂相乘的形式（1 ≤ |a| &lt; 10，n 为整数），这种记数的方法叫做科学记数法。</li><li>使用的数字符号的数目称为这种进位制的基数或底数。</li><li>位权：一个数码在不同的位置上所代表的值不同、且不同的进位制，处于同一数位上的权也是不同的。<ul><li>例如：十进制第 2 位的位权为 10，第 3 位的位权为 100、而二进制第 2 位的位权为 2，第 3 位的位权为 4。</li></ul></li></ul><h4 id="②进制转换"><a href="#②进制转换" class="headerlink" title="②进制转换"></a>②进制转换</h4><table><thead><tr><th align="left">进位制</th><th align="left">基本数字</th><th align="left">进位规则</th><th align="left">应用</th><th align="left">标志的开头</th></tr></thead><tbody><tr><td align="left">二进制</td><td align="left">0 ~ 1</td><td align="left">二进一</td><td align="left">计算机内部采用二进制，其运算简单，简化了计算机结构</td><td align="left">0b / 0B</td></tr><tr><td align="left">八进制</td><td align="left">0 ~ 7</td><td align="left">八进一</td><td align="left">适用于12位和36位计算机系统</td><td align="left">0</td></tr><tr><td align="left">十进制</td><td align="left">0 ~ 9</td><td align="left">十进一</td><td align="left">日常生活中使用</td><td align="left">无</td></tr><tr><td align="left">十六进制</td><td align="left">0 ~ 9和A、B、C、D、E、F(15)</td><td align="left">十六进一</td><td align="left">长度短</td><td align="left">0x / 0X</td></tr></tbody></table><ul><li>进制表：</li></ul><p>​​​​<img src="./1576673576872.png" alt="Alt text"></p><ul><li>十进制转换为 二 / 八 / 十六 进制<ul><li>对于整数：采用重复相除权再倒看余数的方法</li><li>对于小数：采用重复相乘权再正看 “余数” 的方法</li></ul></li></ul><p><img src="./1576675506811.png" alt="Alt text"><br><img src="./1576676122913.png" alt="Alt text"><br><img src="./1577091709770.png" alt="Alt text"></p><ul><li>二 / 八 / 十六进制采用科学计数法按对应权展开可得十进制数：</li></ul><p><img src="./1577091995315.png" alt="Alt text"><br><img src="./1577092028399.png" alt="Alt text"></p><h4 id="③JDK-内置的进制转换"><a href="#③JDK-内置的进制转换" class="headerlink" title="③JDK 内置的进制转换"></a>③JDK 内置的进制转换</h4><p><img src="./1576672455340.png" alt="Alt text"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> object.base;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018/10/08</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: JDK内置的进制转换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">javaSystem</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 10进制转换为其他进制</span></span><br><span class="line">        <span class="comment">// 10进制转换为2进制：1100</span></span><br><span class="line">        System.out.println(Integer.toBinaryString(<span class="number">12</span>));</span><br><span class="line">        <span class="comment">// 10进制转换为8进制：14</span></span><br><span class="line">        System.out.println(Integer.toOctalString(<span class="number">12</span>));</span><br><span class="line">        <span class="comment">// 10进制转换为16进制：14</span></span><br><span class="line">        System.out.println(Integer.toHexString(<span class="number">20</span>));</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 其他进制转换为10进制</span></span><br><span class="line">        <span class="comment">// 2进制转换为10进制：1*2^2+1*2^0=5</span></span><br><span class="line">        System.out.println(Integer.parseInt(<span class="string">"0101"</span>,<span class="number">2</span>));</span><br><span class="line">        System.out.println(Integer.valueOf(<span class="string">"0101"</span>,<span class="number">2</span>).toString());</span><br><span class="line">        <span class="comment">// 8进制转换为10进制：1*8^2+2*8^1+3*8^0=83</span></span><br><span class="line">        System.out.println(Integer.parseInt(<span class="string">"0123"</span>,<span class="number">8</span>));</span><br><span class="line">        System.out.println(Integer.valueOf(<span class="string">"0123"</span>,<span class="number">8</span>).toString());</span><br><span class="line">        <span class="comment">// 16进制转换为10进制：15*16^3+15*16^2+15*16^1+15*16^0=65535</span></span><br><span class="line">        System.out.println(Integer.parseInt(<span class="string">"FFFF"</span>,<span class="number">16</span>));</span><br><span class="line">        System.out.println(Integer.valueOf(<span class="string">"FFFF"</span>,<span class="number">16</span>).toString());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 打印为十进制数字123</span></span><br><span class="line">        System.out.println(<span class="number">123</span>);</span><br><span class="line">        <span class="comment">// 打印为十进制数字5(其中0101是2进制数字，0b标识0101为2进制)</span></span><br><span class="line">        System.out.println(<span class="number">0b0101</span>);</span><br><span class="line">        <span class="comment">// 打印为十进制数字5(其中0101是2进制数字，0B标识0101为2进制)</span></span><br><span class="line">        System.out.println(<span class="number">0B0101</span>);</span><br><span class="line">        <span class="comment">// 打印为十进制数字83(其中123是8进制数字，0标识123为8进制)</span></span><br><span class="line">        System.out.println(<span class="number">0123</span>);</span><br><span class="line">        <span class="comment">// 打印为十进制数字291(其中123是16进制数字，0x标识123为16进制)</span></span><br><span class="line">        System.out.println(<span class="number">0x123</span>);</span><br><span class="line">        <span class="comment">// 打印为十进制数字291(其中123是16进制数字，0X标识123为16进制)</span></span><br><span class="line">        System.out.println(<span class="number">0X123</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-二进制数据的表示方法"><a href="#2-二进制数据的表示方法" class="headerlink" title="2.二进制数据的表示方法"></a>2.二进制数据的表示方法</h3><blockquote><p>ps：Java 中整型（int型）是 32 位的。</p></blockquote><h4 id="①原码"><a href="#①原码" class="headerlink" title="①原码"></a>①原码</h4><ul><li>原码表示法：最高位为符号位，其余位表示数值的大小。<ul><li>使用 0 表示正数、1 表示负数</li><li>[+1]原 = 0000 0001</li><li>[-1]原 = 1000 0001</li></ul></li><li>优点：表达简单明了、易于理解 </li><li>缺点：<ul><li>有歧义（0 既可以用 00 表示，也可以用 10 表示）</li><li>当两个操作数的符号不同时，运算十分复杂</li></ul></li></ul><p><img src="./1577096989867.png" alt="Alt text"></p><h4 id="②反码"><a href="#②反码" class="headerlink" title="②反码"></a>②反码</h4><ul><li>正数的反码是其本身 <ul><li>[+1] = [00000001]原 = [00000001]反</li></ul></li><li>负数的反码等于原码除符号位外按位取反 <ul><li>[-1] = [10000001]原 = [11111110]反</li></ul></li></ul><h4 id="③补码"><a href="#③补码" class="headerlink" title="③补码"></a>③补码</h4><ul><li>正数的补码是其本身<ul><li>[+1] = [00000001]原 = [00000001]反 = [00000001]补</li></ul></li><li>负数的补码等于反码加 1<ul><li>[-1] = [10000001]原 = [11111110]反 = [11111111]补</li></ul></li></ul><h4 id="④原码、补码和反码之间的关系"><a href="#④原码、补码和反码之间的关系" class="headerlink" title="④原码、补码和反码之间的关系"></a>④原码、补码和反码之间的关系</h4><ul><li>因为原码表示法对于零的表示有歧义且其减法运算复杂，所以引入了补码表示法。虽然补码表示法在一定程度上解决了这两个问题，但是其在计算补码的过程中引进了减法操作。<ul><li>解决方法：引进反码表示法。先由原码计算出反码，再由反码计算出补码，即可消除直接通过原码求补码时引入的减法操作。</li></ul></li><li>在计算机中，数据都是以补码的形式存储的。</li><li>0 的反码和补码都为零</li></ul><hr><h3 id="3-位运算"><a href="#3-位运算" class="headerlink" title="3.位运算"></a>3.位运算</h3><blockquote><p>ps：程序中所有的数在内存中都是以二进制的形式存储的，位运算是直接对二进制位进行的位操作。<br>二进制位运算的优点：计算方便，速度快，被支持面广。</p></blockquote><h4 id="①运算符"><a href="#①运算符" class="headerlink" title="①运算符"></a>①运算符</h4><table><thead><tr><th align="left">运算</th><th align="left">功能</th><th align="left">举例</th><th align="left">应用/规律</th></tr></thead><tbody><tr><td align="left">按位与(&amp;)</td><td align="left">两位全为1，结果才为1</td><td align="left">6(00000110) &amp; 3(00000011) = 2(00000010)</td><td align="left">a.清零(若要将一个单元清零，只要与一个各位都为0的数值相与即可) b.取一个数中的指定位(找一个数，对应x要取的位，该数的对应位为1，其余位为0，此数与x进行与运算即可得到x中的指定位)</td></tr><tr><td align="left">按位或(|)</td><td align="left">只要有一个为1，结果就为1</td><td align="left">6(00000110) | 3(00000011) = 7(00000111)</td><td align="left">用来对一个数据的某些位置1(找一个数，对应x要置1的位，该数的对应位为1，其余位为0，此数与x进行或运算即可使x中的某些位置1)</td></tr><tr><td align="left">异或运算(^)</td><td align="left">两个相应位为”异”，则该位结果为1，否则为0</td><td align="left">6(00000110) ^ 3(00000011) = 5(00000101)</td><td align="left">a.与0相异或，可保留原值 b.使特定位翻转(找一个数，对应x要翻转的位，该数的对应位为1，其余位为0，此数与x对应位异或即可)</td></tr><tr><td align="left">取反运算(~)</td><td align="left">对一个二进制数按位取反，0变1，1变0</td><td align="left">~6(00000110) = -7(11111001)</td><td align="left">补码(11111001)-1 -&gt; 得到反码(11111000)，除符号位外各位取反 -&gt; 得到原码-7(10000111)</td></tr><tr><td align="left">左移运算(&lt;&lt;)</td><td align="left">将一个数的各二进制位全部左移指定的位数，右边补0</td><td align="left">3(00000011) &lt;&lt; 2 = 12(00001100)</td><td align="left">若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2</td></tr><tr><td align="left">右移运算(&gt;&gt;)</td><td align="left">将一个数的各二进制位全部右移指定的位数，正数左补0，负数左补1</td><td align="left">3(00000011) &gt;&gt; 1 = 1(00000001)</td><td align="left">若操作数为正数，则每右移一位，相当于该数除以2</td></tr><tr><td align="left">无符号右移运算(&gt;&gt;&gt;)</td><td align="left">将一个数的各二进制位全部右移指定的位数，左边补0</td><td align="left">3(00000011) &gt;&gt;&gt; 1 = 1(00000001)</td><td align="left">若操作数为正数，则每右移一位，相当于该数除以2</td></tr></tbody></table><h4 id="②两个变量交换值的方法"><a href="#②两个变量交换值的方法" class="headerlink" title="②两个变量交换值的方法"></a>②两个变量交换值的方法</h4><ul><li>借助第三个变量来实现<ul><li>C = A、A = B、B = C</li></ul></li><li>利用加减法实现两个变量的交换<ul><li>A = A + B、B = A - B、A = A - B</li></ul></li><li>用位异或运算来实现（效率最高）<ul><li>原理：利用一个数异或本身等于 0 和异或运算符合交换律</li><li>举例：A = A ^ B、B = A ^ B、A = A ^ B</li></ul></li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#106;&#x79;&#x6d;&#101;&#115;&#x73;&#x69;&#x40;&#x31;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;" target="_blank" rel="noopener">&#x77;&#106;&#x79;&#x6d;&#101;&#115;&#x73;&#x69;&#x40;&#x31;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-进制&quot;&gt;&lt;a href=&quot;#1-进制&quot; class=&quot;headerlink&quot; title=&quot;1.进制&quot;&gt;&lt;/a&gt;1.进制&lt;/h3&gt;&lt;h4 id=&quot;①进制相关&quot;&gt;&lt;a href=&quot;#①进制相关&quot; class=&quot;headerlink&quot; title=&quot;①进制相关&quot;&gt;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://messi1002.top/categories/Java/"/>
    
    
      <category term="Java" scheme="http://messi1002.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>使用GoLand创建go工程</title>
    <link href="http://messi1002.top/2019/12/12/%E4%BD%BF%E7%94%A8GoLand%E5%88%9B%E5%BB%BAgo%E5%B7%A5%E7%A8%8B/"/>
    <id>http://messi1002.top/2019/12/12/使用GoLand创建go工程/</id>
    <published>2019-12-12T04:14:37.000Z</published>
    <updated>2019-12-23T13:24:31.509Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h3><ul><li>下载 JetBrains GoLand</li><li>配置 go 的开发环境</li></ul><hr><h3 id="2-hello-go-代码"><a href="#2-hello-go-代码" class="headerlink" title="2.hello go 代码"></a>2.hello go 代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"你好"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-创建-go-工程"><a href="#3-创建-go-工程" class="headerlink" title="3.创建 go 工程"></a>3.创建 go 工程</h3><ul><li>新建工程、选择 GOROOT 路径</li></ul><p><img src="./1562229247677.png" alt="Alt text"></p><ul><li>创建目录结构、创建 hello.go 文件<ul><li><strong>bin：包含生成的执行文件</strong></li><li><strong>pkg：包含编译的中间文件</strong></li><li><strong>src：包含程序的代码文件</strong> </li></ul></li></ul><p><img src="./1562229372284.png" alt="Alt text"></p><ul><li>配置全局路径和项目路径</li></ul><p><img src="./1562230835348.png" alt="Alt text"></p><ul><li>配置并运行 hello.go 文件</li></ul><p><img src="./1562231300913.png" alt="Alt text"><br><img src="./1562231159822.png" alt="Alt text"></p><hr><h3 id="4-命令行中运行-go-文件-windows"><a href="#4-命令行中运行-go-文件-windows" class="headerlink" title="4.命令行中运行 go 文件(windows)"></a>4.命令行中运行 go 文件(windows)</h3><p><img src="./1562228274537.png" alt="Alt text"></p><ul><li><strong>go run 文件名.go</strong>：编译一个或多个以 .go 结尾的源文件，链接库文件并运行最终生成的可执行文件</li><li><strong>go build 文件名.go</strong>：生成一个可执行的二进制文件</li><li><strong>文件名.exe</strong>：运行生成的文件</li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#119;&#x6a;&#x79;&#x6d;&#101;&#115;&#x73;&#x69;&#64;&#49;&#54;&#51;&#x2e;&#x63;&#111;&#x6d;" target="_blank" rel="noopener">&#119;&#x6a;&#x79;&#x6d;&#101;&#115;&#x73;&#x69;&#64;&#49;&#54;&#51;&#x2e;&#x63;&#111;&#x6d;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-准备工作&quot;&gt;&lt;a href=&quot;#1-准备工作&quot; class=&quot;headerlink&quot; title=&quot;1.准备工作&quot;&gt;&lt;/a&gt;1.准备工作&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;下载 JetBrains GoLand&lt;/li&gt;
&lt;li&gt;配置 go 的开发环境&lt;/li&gt;
&lt;/
      
    
    </summary>
    
    
      <category term="Go" scheme="http://messi1002.top/categories/Go/"/>
    
    
      <category term="Go" scheme="http://messi1002.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>华为春招面经2020届JavaWeb</title>
    <link href="http://messi1002.top/2019/10/13/%E5%8D%8E%E4%B8%BA%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F2020%E5%B1%8AJavaWeb/"/>
    <id>http://messi1002.top/2019/10/13/华为春招面经2020届JavaWeb/</id>
    <published>2019-10-13T11:56:10.000Z</published>
    <updated>2019-10-13T13:49:54.719Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-投递职位"><a href="#1-投递职位" class="headerlink" title="1.投递职位"></a>1.投递职位</h3><ul><li><strong>华为 2020 届勇敢星实习—通用软件开发工程师</strong></li><li>年龄：大二(非大三)</li><li>时间：2019 年</li><li>地点：华为西研所</li><li><a href="http://career.huawei.com/reccampportal/campus4_index.html#campus4/pages/joblist/jobList.html?jobFamClsCode=JFC1&type=0" target="_blank" rel="noopener">华为校招官网</a></li></ul><hr><h3 id="2-我的招聘流程"><a href="#2-我的招聘流程" class="headerlink" title="2.我的招聘流程"></a>2.我的招聘流程</h3><p><strong>3.29 投递简历 ——&gt; 4.2 性格测试 ——&gt; 4.3 线上笔试 ——&gt; 4.20 面试 ——&gt; 4.25 收到 offer ——&gt; 5.6 签约</strong></p><hr><h3 id="3-性格测试"><a href="#3-性格测试" class="headerlink" title="3.性格测试"></a>3.性格测试</h3><blockquote><p>华为比较重视这个，最好认真做完。<br>可以在网上查查技巧，反正我是挂了(⊙o⊙)…。</p></blockquote><hr><h3 id="4-笔试"><a href="#4-笔试" class="headerlink" title="4.笔试"></a>4.笔试</h3><h4 id="①题目分析"><a href="#①题目分析" class="headerlink" title="①题目分析"></a>①题目分析</h4><blockquote><p>华为的笔试题都是基础的编程题，比较简单。<br>总共有三道题，分值分别为 100、200、300，难度递增。<br>第一题重点考察输入与输出， 第二题重点考察对语言类库的运用，第三题重点考察数据结构与算法。<br><strong>注意：最好在笔试后仔细研究研究未 AC 的题，面试官可能会问。</strong></p></blockquote><h4 id="②练习网址"><a href="#②练习网址" class="headerlink" title="②练习网址"></a>②练习网址</h4><ul><li>牛客网：<a href="https://www.nowcoder.com/ta/huawei" target="_blank" rel="noopener">https://www.nowcoder.com/ta/huawei</a></li></ul><h4 id="③我的笔试"><a href="#③我的笔试" class="headerlink" title="③我的笔试"></a>③我的笔试</h4><blockquote><p>当时我 AC 了第一题和第二题(300 分)，由于第三题涉及到的算法还没有学习过，故放弃。<br>不过只要拿 100 分，就能得到面试机会。</p></blockquote><hr><h3 id="5-一面-35min"><a href="#5-一面-35min" class="headerlink" title="5.一面(35min)"></a>5.一面(35min)</h3><h4 id="①面试问题"><a href="#①面试问题" class="headerlink" title="①面试问题"></a>①面试问题</h4><ul><li>自我介绍</li><li>对华为的了解</li><li>为什么来华为实习</li><li>笔试中未做出的题</li><li>三道算法题</li><li>做项目遇到的困难</li><li>对软件工程的了解</li><li>对”好代码”的理解</li></ul><h4 id="②面试技巧"><a href="#②面试技巧" class="headerlink" title="②面试技巧"></a>②面试技巧</h4><ol><li>面试前最好了解一下企业文化及其业务方向。</li><li><strong>面试官很看重应聘者解决问题的能力，即面对一个完全陌生的问题，应聘者能将之快速理解并想出求解方法。</strong></li><li><strong>在解决算法题的时候，最好先从最基础的求解方法开始分析，逐步优化并且分析每种解法的复杂度和优缺点(系统原理、安全漏洞等)。</strong></li><li>如果实在想不出求解方法，也要尽可能地想出一个大概思路，最好别卡壳。如果面试时很紧张，会非常非常影响思路！所以一定要放松！！</li><li><strong>底层知识一定要重视！要将学过的知识点充分理解！</strong></li><li>注意：思考面试官问你的题目之间是否有关联，也许这是一个很好的解题突破点。</li></ol><hr><h3 id="6-二面-20min"><a href="#6-二面-20min" class="headerlink" title="6.二面(20min)"></a>6.二面(20min)</h3><h4 id="①面试问题-1"><a href="#①面试问题-1" class="headerlink" title="①面试问题"></a>①面试问题</h4><ul><li>自我介绍</li><li>对 996 的看法</li><li>为什么跨专业学习</li><li>职业规划</li><li>关于读研</li><li>想在华为学到什么</li><li>项目介绍</li><li>英语能力及课内成绩</li><li>瞎聊…</li></ul><h4 id="②面试体验"><a href="#②面试体验" class="headerlink" title="②面试体验"></a>②面试体验</h4><blockquote><p>一面结束后，排队等待二面，二面相对比较轻松。因为我是跨专业自学 CS，所以面试官一直逮着这点问，emmm。然后就会和你聊聊家庭情况、未来规划、学习情况等。</p></blockquote><hr><h3 id="7-等待结果"><a href="#7-等待结果" class="headerlink" title="7.等待结果"></a>7.等待结果</h3><ul><li>面试完成后官网会更新 <code>应聘进展</code></li><li>我的状态码：</li></ul><p><img src="./1556286277599.png" alt="Alt text"></p><ul><li>状态码：6、1 </li><li>性格测试貌似挂了 但没有被安排重测</li><li><code>面试考核</code> 下无小字：</li></ul><p><img src="./1556286450801.png" alt="Alt text"></p><ul><li>but 5 天后就收到 offer 啦</li></ul><hr><blockquote><p>ps：谢谢男票陪我去面试，肝就对了！<br>纪念收到的第一个 offer！</p></blockquote><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#119;&#106;&#121;&#x6d;&#x65;&#x73;&#115;&#105;&#x40;&#x31;&#x36;&#x33;&#x2e;&#99;&#111;&#109;" target="_blank" rel="noopener">&#119;&#106;&#121;&#x6d;&#x65;&#x73;&#115;&#105;&#x40;&#x31;&#x36;&#x33;&#x2e;&#99;&#111;&#109;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-投递职位&quot;&gt;&lt;a href=&quot;#1-投递职位&quot; class=&quot;headerlink&quot; title=&quot;1.投递职位&quot;&gt;&lt;/a&gt;1.投递职位&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;华为 2020 届勇敢星实习—通用软件开发工程师&lt;/strong&gt;&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
      <category term="面经" scheme="http://messi1002.top/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="面经" scheme="http://messi1002.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat+Nginx配置HTTPS</title>
    <link href="http://messi1002.top/2019/09/13/Tomcat-Nginx%E9%85%8D%E7%BD%AEHTTPS/"/>
    <id>http://messi1002.top/2019/09/13/Tomcat-Nginx配置HTTPS/</id>
    <published>2019-09-13T08:37:51.000Z</published>
    <updated>2019-10-13T08:43:15.492Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ps：每次修改配置后，需要重启 Nginx。<br>命令：<strong>systemctl restart nginx</strong>。<br>Nginx 的配置文件：<strong>/etc/nginx/nginx.conf</strong>。</p></blockquote><hr><h3 id="1-相关博客"><a href="#1-相关博客" class="headerlink" title="1.相关博客"></a>1.相关博客</h3><ul><li><a href="https://messi1002.top/2019/05/07/%E9%98%BF%E9%87%8C%E4%BA%91CentOS7%E5%AE%89%E8%A3%85Nginx/">阿里云CentOS7安装Nginx</a></li><li><a href="https://messi1002.top/2019/09/12/Nginx%E4%B9%8B%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/">Nginx之访问服务器静态资源</a></li><li><a href="https://messi1002.top/2019/09/12/Nginx%E4%B9%8Brewrite%E9%85%8D%E7%BD%AE%E5%9F%9F%E5%90%8D%E8%B7%B3%E8%BD%AC/#more">Nginx之rewrite配置域名跳转</a></li></ul><hr><h3 id="2-准备SSL证书"><a href="#2-准备SSL证书" class="headerlink" title="2.准备SSL证书"></a>2.准备SSL证书</h3><blockquote><p>在域名备案的前提下，我们需要购买 SSL 证书。<br>一般情况下，购买免费版即可。</p></blockquote><h4 id="①什么是SSL证书"><a href="#①什么是SSL证书" class="headerlink" title="①什么是SSL证书"></a>①什么是SSL证书</h4><p><img src="./1568361392033.png" alt="Alt text"><br><img src="./1568361434320.png" alt="Alt text"></p><h4 id="②准备过程"><a href="#②准备过程" class="headerlink" title="②准备过程"></a>②准备过程</h4><ul><li>进入阿里云控制台 购买免费版 SSL 证书 </li><li>然后在签发后下载 Nginx 服务器类型的证书并上传到服务器</li></ul><p><img src="./1568361492288.png" alt="Alt text"><br><img src="./1568361516967.png" alt="Alt text"><br><img src="./1568361531993.png" alt="Alt text"><br><img src="./1568361548330.png" alt="Alt text"><br><img src="./1568361629734.png" alt="Alt text"></p><hr><h3 id="3-具体配置"><a href="#3-具体配置" class="headerlink" title="3.具体配置"></a>3.具体配置</h3><h4 id="①强制HTTPS（可选）"><a href="#①强制HTTPS（可选）" class="headerlink" title="①强制HTTPS（可选）"></a>①强制HTTPS（可选）</h4><ul><li>把 HTTP 的域名请求转成 HTTPS</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  a.com;  # 使用证书绑定的域名替换localhost</span><br><span class="line">    return       301 https://$server_name$request_uri; </span><br><span class="line">    # 返回301状态码进行跳转被Google认为是将网站地址由HTTP迁移到HTTPS的最佳方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②开启HTTPS"><a href="#②开启HTTPS" class="headerlink" title="②开启HTTPS"></a>②开启HTTPS</h4><p><img src="./1568364999187.png" alt="Alt text"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl; # 监听433端口</span><br><span class="line">    server_name a.com; # 证书绑定的域名</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate /usr/local/javaweb/cert/2557101_a.com.pem; # 证书的文件名</span><br><span class="line">    ssl_certificate_key /usr/local/javaweb/cert/2557101_a.com.key; # 证书的密钥文件名</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:8080; # 对应tomcat的端口号</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto https;</span><br><span class="line">    proxy_redirect off;</span><br><span class="line">    proxy_connect_timeout 240;</span><br><span class="line">    proxy_send_timeout 240;</span><br><span class="line">    proxy_read_timeout 240;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置成功</li></ul><p><img src="./1568365113022.png" alt="Alt text"></p><hr><h3 id="4-工作原理"><a href="#4-工作原理" class="headerlink" title="4.工作原理"></a>4.工作原理</h3><blockquote><p>浏览器发送的请求是发送到 Nginx 的，Nginx 作为代理服务器再转发到 Tomcat，浏览器和 Nginx 之间以 HTTPS 协议传输数据，而 Nginx 和 Tomcat 之间通过 proxy_pass 以 HTTP 协议传输数据。<br>Nginx 是中间的代理服务器。</p></blockquote><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#x6a;&#x79;&#109;&#101;&#x73;&#x73;&#105;&#x40;&#x31;&#54;&#51;&#x2e;&#99;&#111;&#x6d;" target="_blank" rel="noopener">&#x77;&#x6a;&#x79;&#109;&#101;&#x73;&#x73;&#105;&#x40;&#x31;&#54;&#51;&#x2e;&#99;&#111;&#x6d;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;ps：每次修改配置后，需要重启 Nginx。&lt;br&gt;命令：&lt;strong&gt;systemctl restart nginx&lt;/strong&gt;。&lt;br&gt;Nginx 的配置文件：&lt;strong&gt;/etc/nginx/nginx.conf&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://messi1002.top/categories/Linux/"/>
    
      <category term="服务器" scheme="http://messi1002.top/categories/Linux/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Nginx" scheme="http://messi1002.top/tags/Nginx/"/>
    
      <category term="Tomcat" scheme="http://messi1002.top/tags/Tomcat/"/>
    
      <category term="HTTPS" scheme="http://messi1002.top/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb开发总结</title>
    <link href="http://messi1002.top/2019/09/12/JavaWeb%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    <id>http://messi1002.top/2019/09/12/JavaWeb开发总结/</id>
    <published>2019-09-12T07:00:40.000Z</published>
    <updated>2019-09-13T09:23:06.821Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-开发环境"><a href="#1-开发环境" class="headerlink" title="1.开发环境"></a>1.开发环境</h3><h4 id="①开发必备"><a href="#①开发必备" class="headerlink" title="①开发必备"></a>①开发必备</h4><ul><li>Java 版本：JDK8</li><li>Web 服务器：Tomcat9（运行后端）、Nginx（前端请求转发和搭建图片服务器）</li><li>工程框架：Spring Boot 2.0</li><li>操作数据库：Spring Boot Jpa（优先） / Mybatis</li><li>其他：Lombok 插件、JSON（fastjson / jackson）</li></ul><h4 id="②数据库"><a href="#②数据库" class="headerlink" title="②数据库"></a>②数据库</h4><ul><li>MySQL（主 db）</li><li>Redis（处理缓存）</li><li>MongoDB （特殊需求使用）</li></ul><h4 id="③编译器-amp-构建工具-amp-测试工具"><a href="#③编译器-amp-构建工具-amp-测试工具" class="headerlink" title="③编译器&amp;构建工具&amp;测试工具"></a>③编译器&amp;构建工具&amp;测试工具</h4><ul><li>IDEA</li><li>maven（优先） / gradle</li><li>Postman </li></ul><hr><h3 id="2-框架分层"><a href="#2-框架分层" class="headerlink" title="2.框架分层"></a>2.框架分层</h3><h4 id="①总览"><a href="#①总览" class="headerlink" title="①总览"></a>①总览</h4><ul><li>common（公共包）<ul><li>enums（枚举类）</li><li>exception（全局异常处理）</li><li>interceptor（拦截器）</li><li>jpa（jpa 配置）</li><li>log（AOP 方式的日志埋点）</li><li>utils（工具类）</li></ul></li><li>controller（控制层）</li><li>model（DAO 层）<ul><li>dto（数据传输对象）</li><li>entity（数据库实体类）</li></ul></li><li>repository / mapper（数据库操作层）</li><li>service（服务层)<ul><li>base（基础服务）</li><li>impl（业务服务实现类）</li></ul></li><li>resources（资源目录）<ul><li>application.yml（切换配置文件）</li><li>application-dev.yml（本地配置文件）</li><li>application-pro.yml （服务器配置文件）</li></ul></li></ul><h4 id="②common层"><a href="#②common层" class="headerlink" title="②common层"></a>②common层</h4><ul><li>ResultEnum 类：用于存放前端请求的响应 / 执行结果<ul><li>注意枚举类定义格式 私有变量名不能定义为 name</li></ul></li></ul><h4 id="③controller层"><a href="#③controller层" class="headerlink" title="③controller层"></a>③controller层</h4><ul><li>调用 service 层方法</li><li>提供对外暴露的接口</li></ul><h4 id="④model层"><a href="#④model层" class="headerlink" title="④model层"></a>④model层</h4><ul><li>ResultDTO 类：统一使用此类将数据封装好返回给前端</li><li>关于使用 DTO：从数据库中查出的是一个完整的对象，而大多数时候只会用到某些字段，这时候需要 DTO。</li></ul><hr><h3 id="3-代码规范"><a href="#3-代码规范" class="headerlink" title="3.代码规范"></a>3.代码规范</h3><h4 id="①注释"><a href="#①注释" class="headerlink" title="①注释"></a>①注释</h4><ul><li>类注释（配置模板）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @功能名称: HttpClient(举例)</span><br><span class="line"> * @文件名称: HttpUtil.java(举例)</span><br><span class="line"> * @Date: $date$ $time$</span><br><span class="line"> * @Author: 自定义</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><ul><li>方法注释（配置模板）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 功能描述: </span><br><span class="line"> *</span><br><span class="line"> * @param: $param$</span><br><span class="line"> * @return: $return$</span><br><span class="line"> * @auther: 自定义</span><br><span class="line"> * @date: $date$ $time$</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><ul><li>变量注释</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 文字</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><ul><li>方法内注释</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 文字</span><br></pre></td></tr></table></figure><h4 id="②注解"><a href="#②注解" class="headerlink" title="②注解"></a>②注解</h4><ul><li>自动装配用 @Autowired 注解 其 byType 注入 注解在字段上</li><li>@component：泛指组件 把普通 POJO 实例化到 spring 容器中</li><li>@Service：用于标注业务层组件</li><li>@RestController：用于标注控制层组件</li><li>@Repository：用于标注数据访问组件 即 DAO 组件</li><li>@RequestMapping(value = “/URI”)：标注控制层组件中的方法</li><li>@GetMapping(value = “/URI”)：标注控制层组件中的方法 </li><li>@PostMapping(value = “/URI”)：标注控制层组件中的方法</li><li>@RequestParam：用于标注控制层组件的方法的参数<ul><li>参数名与前端传来的必须吻合 若是不吻合 需要加 value = “…” 使参数名一一对应</li></ul></li></ul><h4 id="③配置文件"><a href="#③配置文件" class="headerlink" title="③配置文件"></a>③配置文件</h4><ul><li>application.yml：总控制文件 可随时切换为本地 / 服务器的配置文件 便于开发</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">dev/pro</span></span><br></pre></td></tr></table></figure><ul><li>application-dev.yml</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="string">本地访问端口号</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># MySQL数据库配置</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    driverClass:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://localhost:3306/数据库名?characterEncoding=utf-8&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">自定义</span></span><br><span class="line">  <span class="comment"># Redis配置</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    database:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">自定义</span></span><br><span class="line">  <span class="comment"># MongoDB配置</span></span><br><span class="line"><span class="attr">  data:</span></span><br><span class="line"><span class="attr">    mongodb:</span></span><br><span class="line"><span class="attr">      uri:</span> <span class="attr">mongodb://用户名:密码@localhost:27017/数据库名</span></span><br><span class="line">  <span class="comment"># jpa配置</span></span><br><span class="line"><span class="attr">  jpa:</span></span><br><span class="line"><span class="attr">    hibernate:</span></span><br><span class="line">      <span class="comment"># 在程序启动时更新实体类对应的表</span></span><br><span class="line"><span class="attr">      ddl-auto:</span> <span class="string">update</span></span><br><span class="line">    <span class="comment"># 在日志中打印出执行的SQL语句信息</span></span><br><span class="line"><span class="attr">    show-sql:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    naming:</span></span><br><span class="line"><span class="attr">      physical-strategy:</span> <span class="string">org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy</span></span><br><span class="line">  <span class="comment"># mybatis配置</span></span><br><span class="line"><span class="attr">  mybatis:</span></span><br><span class="line"><span class="attr">    type-aliases-package:</span> <span class="string">数据库实体类所在包</span></span><br><span class="line">    <span class="comment"># 下划线自动转驼峰</span></span><br><span class="line"><span class="attr">    configuration:</span></span><br><span class="line"><span class="attr">      map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      use-generated-keys:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># jackson配置</span></span><br><span class="line"><span class="attr">  jackson:</span></span><br><span class="line"><span class="attr">    serialization:</span></span><br><span class="line"><span class="attr">      indent-output:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>application-pro.yml</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="string">服务器端口号</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># MySQL数据库配置</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    driverClass:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://服务器公网ip:3306/数据库名?characterEncoding=utf-8&amp;serverTimezone=GMT%2B8&amp;useSSL=true</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">自定义</span></span><br><span class="line">  <span class="comment"># Redis配置</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    database:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">    host:</span> <span class="string">服务器公网ip</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">自定义</span></span><br><span class="line">  <span class="comment"># MongoDB配置</span></span><br><span class="line"><span class="attr">  data:</span></span><br><span class="line"><span class="attr">    mongodb:</span></span><br><span class="line"><span class="attr">      uri:</span> <span class="attr">mongodb://用户名:密码@服务器ip:27017/数据库名</span></span><br><span class="line">  <span class="string">...其他如上</span></span><br></pre></td></tr></table></figure><h4 id="④pom-xml（maven）"><a href="#④pom-xml（maven）" class="headerlink" title="④pom.xml（maven）"></a>④pom.xml（maven）</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- MySQL --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Redis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- MongoDB --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- jpa --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- lombok插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- httpclient --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- maven插件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 解决项目启动bug --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="⑤其他"><a href="#⑤其他" class="headerlink" title="⑤其他"></a>⑤其他</h4><ul><li>将私有常量值单独定义在类的开头 公有常量值定义在公有枚举类中</li><li>工具类一般不需要被注入或构造 只包含普通的类方法</li><li>所有需要注入的类，都应该放到 Service 目录下</li><li>除 db 对象外 尽量使用全参构造对象</li><li>尽量消除魔法值 可使用枚举类封装</li><li>遵循《阿里巴巴Java代码开发规范》进行开发</li></ul><hr><h3 id="4-安装插件"><a href="#4-安装插件" class="headerlink" title="4.安装插件"></a>4.安装插件</h3><ul><li>安装插件：<strong>Settings —&gt; Plugins —&gt; Marketplace —&gt; 查找所需插件 —&gt; Install</strong></li><li>查看安装的所有插件：</li></ul><p><img src="./1563267874950.png" alt="Alt text"></p><ul><li>安装后需要重启 IDEA</li></ul><h4 id="①Lombok"><a href="#①Lombok" class="headerlink" title="①Lombok"></a>①Lombok</h4><blockquote><p>以简单的注解形式来简化 Java 代码，提高开发人员的开发效率。</p></blockquote><ul><li>@Getter：注解在类上 为类提供 get 方法 </li><li>@Setter：注解在类上 为类提供 set 方法</li><li>@Data：注解在类上 为类提供读写属性 此外还提供了equals()、hashCode()、toString() 方法</li><li>@AllArgsConstructor：注解在类上 为类提供一个全参的构造方法</li><li>@NoArgsConstructor：注解在类上 为类提供一个无参的构造方法</li><li>@Slf4j：注解在类上 为类提供一个属性名为 log 的 log4j 日志对象</li><li><strong>@Slf4j 相当于 private static final Logger log = LoggerFactory.getLogger(CategoryServiceImpl.class);</strong></li></ul><h4 id="②Alibaba-Java-Coding-Guidelines"><a href="#②Alibaba-Java-Coding-Guidelines" class="headerlink" title="②Alibaba Java Coding Guidelines"></a>②Alibaba Java Coding Guidelines</h4><blockquote><p>阿里巴巴 Java 代码规约检测</p></blockquote><ul><li>使用插件：</li></ul><p><img src="./1563265527020.png" alt="Alt text"></p><h4 id="③Grep-Console"><a href="#③Grep-Console" class="headerlink" title="③Grep Console"></a>③Grep Console</h4><blockquote><p>可以将不同级别的日志通过颜色区分，便于查看。</p></blockquote><ul><li>配置各级日志的颜色：</li></ul><p><img src="./1563850702962.png" alt="Alt text"></p><hr><h3 id="5-前后端交互"><a href="#5-前后端交互" class="headerlink" title="5.前后端交互"></a>5.前后端交互</h3><h4 id="①交互流程"><a href="#①交互流程" class="headerlink" title="①交互流程"></a>①交互流程</h4><p>1.通过原型图确定产品功能（明确每个细节）<br>2.后端撰写 API 文档及建表<br>3.前后端按照 API 文档各自开发<br>4.测试</p><h4 id="②API文档"><a href="#②API文档" class="headerlink" title="②API文档"></a>②API文档</h4><ul><li><a href="https://www.showdoc.cc/" target="_blank" rel="noopener">ShowDoc</a></li><li>举例：</li></ul><p><img src="./1563442671800.png" alt="Alt text"></p><h4 id="③RESTful-API"><a href="#③RESTful-API" class="headerlink" title="③RESTful API"></a>③RESTful API</h4><ul><li>后端撰写请求 URL 时 必须遵守 <a href="https://github.com/godruoyi/restful-api-specification" target="_blank" rel="noopener">RESTful API 设计规范</a></li></ul><p><img src="./1562896136514.png" alt="Alt text"></p><ul><li>举例：</li></ul><p><img src="./1562896118142.png" alt="Alt text"></p><hr><h3 id="6-关于团队协作（git）"><a href="#6-关于团队协作（git）" class="headerlink" title="6.关于团队协作（git）"></a>6.关于团队协作（git）</h3><blockquote><p>GitHub 客户端每次只能 commit 一个文件，不利于版本回滚和团队协作，所以尽量使用 git 命令行。</p></blockquote><h4 id="①git同步流程"><a href="#①git同步流程" class="headerlink" title="①git同步流程"></a>①git同步流程</h4><ol><li>一般开发完成、但还没有测试的文件都会被提交到暂存区</li><li>将暂存区的文件（测试好的）提交到本地仓库</li><li>通过 git push 提交修改到远程仓库</li></ol><h4 id="②git常用命令"><a href="#②git常用命令" class="headerlink" title="②git常用命令"></a>②git常用命令</h4><ul><li>git add 文件名：将本地某个文件添加到暂存区</li><li>git add *：将本地所有文件添加到暂存区</li><li>git commit -m “本次提交说明（自定义）”：将暂存区文件提交到本地仓库</li><li>git push -u origin master：使用本地 master 分支来更新远程 master 分支（远程仓库）</li><li>git reset HEAD 文件名（将暂存区的内容还原为最后一次提交的内容）</li><li>git checkout – 文件名（将工作区的内容还原为最后一次提交的内容）</li><li>git tag -a name -m “comment”：新建标签并指定提交信息</li><li>git tag -d  name：删除标签</li><li>git branch：查看当前所有分支</li><li>git branch name：创建分支</li><li>git checkout name：进入分支</li><li>通过两种方式克隆仓库：<ul><li>Clone with SSH：git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:messi1002/leetcode.git</li><li>Clone with HTTPS：git clone <a href="https://github.com/messi1002/leetcode.git" target="_blank" rel="noopener">https://github.com/messi1002/leetcode.git</a></li></ul></li></ul><p><img src="./1563441995129.png" alt="Alt text"><br><img src="./1563442009700.png" alt="Alt text"></p><h4 id="③git高级操作"><a href="#③git高级操作" class="headerlink" title="③git高级操作"></a>③git高级操作</h4><ul><li>git stash save “注释”：将工作区和暂存区的新内容暂时保存在栈中</li><li>git stash list：显示缓存堆栈中的内容</li><li>git stash pop：将缓存堆栈中的第一个 stash 内容恢复到工作区后删除</li><li>git commit –amend：将缓存区的内容补充到上次 commit 并可以修改上次 commit 的描述（用来修复最近一次 commit）</li><li>git rebase -i  [startpoint]  [endpoint]：每一个功能开发完成后 对多个 commit 进行合并处理（变基）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[startpoint] 和 [endpoint] 指定了一个编辑区间，前开后闭。</span><br><span class="line">如果不指定 [endpoint]，则该区间的终点默认是当前分支 HEAD 所指向的 commit。</span><br><span class="line">进入编辑页面后，按照指令说明修改指令即可。</span><br></pre></td></tr></table></figure><hr><h3 id="7-入门博客汇总"><a href="#7-入门博客汇总" class="headerlink" title="7.入门博客汇总"></a>7.入门博客汇总</h3><ul><li><a href="https://blog.csdn.net/baidu_31071595/article/details/51320622" target="_blank" rel="noopener">StringUtils用法+StringUtils详细介绍</a></li><li><a href="https://blog.csdn.net/anhuoren/article/details/41313213" target="_blank" rel="noopener">Java 枚举类Enum的用法总结</a></li><li><a href="http://www.ityouknow.com/springboot/2016/03/06/spring-boot-redis.html" target="_blank" rel="noopener">Spring Boot 中 Redis 的使用</a></li><li><a href="https://www.jianshu.com/p/7bf5dc61ca06" target="_blank" rel="noopener">如何使用RedisTemplate访问Redis数据结构</a></li><li><a href="http://blog.didispace.com/springbootredis/" target="_blank" rel="noopener">Spring Boot中使用Redis数据库</a></li><li><a href="https://juejin.im/post/5afb9de8518825426c690307" target="_blank" rel="noopener">Spring Boot中快速操作Mongodb</a></li><li><a href="http://www.ityouknow.com/springboot/2017/05/08/spring-boot-mongodb.html" target="_blank" rel="noopener">Spring Boot 中 MongoDB 的使用</a></li><li><a href="https://www.cnblogs.com/ityouknow/p/5891443.html" target="_blank" rel="noopener">Spring Boot Jpa 的使用</a></li><li><a href="http://www.ityouknow.com/springboot/2016/11/06/spring-boot-mybatis.html" target="_blank" rel="noopener">如何优雅的使用 Mybatis</a></li><li><a href="https://w6513017.iteye.com/blog/1512761" target="_blank" rel="noopener">MyBatis中Like语句使用方式</a></li><li><a href="https://blog.csdn.net/lonelymanontheway/article/details/78221296" target="_blank" rel="noopener">Java 开发工具–Lombok 介绍</a></li><li><a href="https://blog.51cto.com/7308310/2310930" target="_blank" rel="noopener">Spring Boot中Jackson应用详解</a></li><li><a href="https://blog.csdn.net/xzp_12345/article/details/80272981" target="_blank" rel="noopener">JSON框架之阿里fastjson的介绍</a></li><li><a href="https://github.com/godruoyi/restful-api-specification" target="_blank" rel="noopener">RESTful API 设计规范</a></li><li><a href="https://blog.csdn.net/qq_41979043/article/details/89319160#3Git__74" target="_blank" rel="noopener">Git—版本控制工具</a></li><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">Git教程</a></li><li><a href="https://blog.csdn.net/Code_shadow/article/details/81454334" target="_blank" rel="noopener">上传图片到七牛云（前端和后端）</a></li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#119;&#106;&#121;&#x6d;&#x65;&#x73;&#115;&#x69;&#64;&#49;&#54;&#51;&#46;&#99;&#111;&#x6d;" target="_blank" rel="noopener">&#119;&#106;&#121;&#x6d;&#x65;&#x73;&#115;&#x69;&#64;&#49;&#54;&#51;&#46;&#99;&#111;&#x6d;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-开发环境&quot;&gt;&lt;a href=&quot;#1-开发环境&quot; class=&quot;headerlink&quot; title=&quot;1.开发环境&quot;&gt;&lt;/a&gt;1.开发环境&lt;/h3&gt;&lt;h4 id=&quot;①开发必备&quot;&gt;&lt;a href=&quot;#①开发必备&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://messi1002.top/categories/JavaWeb/"/>
    
    
  </entry>
  
  <entry>
    <title>Nginx之rewrite配置域名跳转</title>
    <link href="http://messi1002.top/2019/09/12/Nginx%E4%B9%8Brewrite%E9%85%8D%E7%BD%AE%E5%9F%9F%E5%90%8D%E8%B7%B3%E8%BD%AC/"/>
    <id>http://messi1002.top/2019/09/12/Nginx之rewrite配置域名跳转/</id>
    <published>2019-09-12T03:22:31.000Z</published>
    <updated>2019-10-13T08:43:06.909Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ps：每次修改配置后，需要重启 Nginx。<br>命令：<strong>systemctl restart nginx</strong>。<br>Nginx 的配置文件：<strong>/etc/nginx/nginx.conf</strong>。</p></blockquote><hr><h3 id="1-相关博客"><a href="#1-相关博客" class="headerlink" title="1.相关博客"></a>1.相关博客</h3><ul><li><a href="https://messi1002.top/2019/05/07/%E9%98%BF%E9%87%8C%E4%BA%91CentOS7%E5%AE%89%E8%A3%85Nginx/">阿里云CentOS7安装Nginx</a></li><li><a href="https://messi1002.top/2019/09/12/Nginx%E4%B9%8B%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/">Nginx之访问服务器静态资源</a></li><li><a href="https://messi1002.top/2019/09/13/Tomcat-Nginx%E9%85%8D%E7%BD%AEHTTPS/">Tomcat+Nginx配置HTTPS</a></li></ul><hr><h3 id="2-语法格式"><a href="#2-语法格式" class="headerlink" title="2.语法格式"></a>2.语法格式</h3><ul><li>rewrite 作用：将某个 URL 重写为特定的 URL</li><li>语法格式：<code>rewrite</code>（关键字） <code>&lt;regex&gt;</code>（正则表达式） <code>&lt;replacement&gt;</code>（替代内容）<ul><li>根据 <code>正则表达式</code> 重定向到 <code>replacement</code></li></ul></li></ul><hr><h3 id="3-对a域名的访问全部redirect到b域名"><a href="#3-对a域名的访问全部redirect到b域名" class="headerlink" title="3.对a域名的访问全部redirect到b域名"></a>3.对a域名的访问全部redirect到b域名</h3><ul><li>配置前 <code>server</code> 中不允许存在 <code>location / { ... }</code></li><li>配置示例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    rewrite ^/(.*) http://1000.xidian.edu.cn/$1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>跳转前：<a href="http://a.com/index.php/Request/" target="_blank" rel="noopener">http://a.com/index.php/Request/</a>…</li><li>跳转后：</li></ul><p><img src="./1568295962831.png" alt="Alt text"></p><ul><li>通过 <code>location /</code> 匹配所有以 <code>/</code> 开头的请求（即所有请求）</li><li><code>rewrite</code> 为固定关键字 </li><li><code>regex</code> 部分表示匹配完整的域名和之后的路径</li><li><code>replacement</code> 部分中的 <code>$1</code> 取自 <code>regex</code> 部分 <code>( )</code> 中的内容</li><li>即 nginx 将 <code>a.com/</code> 之后的路径拼接到了 <code>http://1000.xidian.edu.cn/</code> 后</li></ul><hr><h3 id="4-对a域名的不同访问redirect到不同域名"><a href="#4-对a域名的不同访问redirect到不同域名" class="headerlink" title="4.对a域名的不同访问redirect到不同域名"></a>4.对a域名的不同访问redirect到不同域名</h3><h4 id="①应用场景"><a href="#①应用场景" class="headerlink" title="①应用场景"></a>①应用场景</h4><ul><li>同一个域名下的不同 URL 需要跳转到不同的域名下</li></ul><h4 id="②示例一"><a href="#②示例一" class="headerlink" title="②示例一"></a>②示例一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /xiaoyuan/ &#123;</span><br><span class="line">    rewrite ^/xiaoyuan(.*) http://ehall.xidian.edu.cn$1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>跳转前：<code>http://a.com/xiaoyuan/jwapp/sys/cjcx</code></li><li>跳转后：</li></ul><p><img src="./1568261314056.png" alt="Alt text"></p><ul><li>通过 <code>location /xiaoyuan/</code> 匹配所有以 <code>/xiaoyuan/</code> 开头的请求</li><li><code>rewrite</code> 为固定关键字 </li><li><code>regex</code> 部分表示匹配完整的域名和之后的路径</li><li><code>replacement</code> 部分中的 <code>$1</code> 取自 <code>regex</code> 部分 <code>( )</code> 中的内容</li><li>即 nginx 将 <code>a.com/xiaoyuan</code> 之后的路径拼接到了 <code>http://ehall.xidian.edu.cn</code> 后</li></ul><h4 id="③示例二"><a href="#③示例二" class="headerlink" title="③示例二"></a>③示例二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /houqin/ &#123;</span><br><span class="line">    rewrite ^/houqin(.*) http://1000.xidian.edu.cn$1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>跳转前：<code>http://a.com/houqin/index.php/Request/...</code></li><li>跳转后：</li></ul><p><img src="./1568259929117.png" alt="Alt text"></p><ul><li>通过 <code>location /houqin/</code> 匹配所有以 <code>/houqin/</code> 开头的请求</li><li><code>rewrite</code> 为固定关键字 </li><li><code>regex</code> 部分表示匹配完整的域名和之后的路径</li><li><code>replacement</code> 部分中的 <code>$1</code> 取自 <code>regex</code> 部分 <code>( )</code> 中的内容</li><li>即 nginx 将 <code>a.com/houqin</code> 之后的路径拼接到了 <code>http://1000.xidian.edu.cn</code> 后</li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#119;&#106;&#x79;&#x6d;&#x65;&#115;&#115;&#x69;&#64;&#49;&#54;&#x33;&#x2e;&#99;&#x6f;&#109;" target="_blank" rel="noopener">&#119;&#106;&#x79;&#x6d;&#x65;&#115;&#115;&#x69;&#64;&#49;&#54;&#x33;&#x2e;&#99;&#x6f;&#109;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;ps：每次修改配置后，需要重启 Nginx。&lt;br&gt;命令：&lt;strong&gt;systemctl restart nginx&lt;/strong&gt;。&lt;br&gt;Nginx 的配置文件：&lt;strong&gt;/etc/nginx/nginx.conf&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://messi1002.top/categories/Linux/"/>
    
      <category term="服务器" scheme="http://messi1002.top/categories/Linux/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Nginx" scheme="http://messi1002.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx之访问服务器静态资源</title>
    <link href="http://messi1002.top/2019/09/12/Nginx%E4%B9%8B%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/"/>
    <id>http://messi1002.top/2019/09/12/Nginx之访问服务器静态资源/</id>
    <published>2019-09-12T03:19:49.000Z</published>
    <updated>2019-10-13T08:26:49.788Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ps：每次修改配置后，需要重启 Nginx。<br>命令：<strong>systemctl restart nginx</strong>。<br>Nginx 的配置文件：<strong>/etc/nginx/nginx.conf</strong>。</p></blockquote><hr><h3 id="1-相关博客"><a href="#1-相关博客" class="headerlink" title="1.相关博客"></a>1.相关博客</h3><ul><li><a href="https://messi1002.top/2019/05/07/%E9%98%BF%E9%87%8C%E4%BA%91CentOS7%E5%AE%89%E8%A3%85Nginx/">阿里云CentOS7安装Nginx</a></li><li><a href="https://messi1002.top/2019/09/13/Tomcat-Nginx%E9%85%8D%E7%BD%AEHTTPS/">Tomcat+Nginx配置HTTPS</a></li><li><a href="https://messi1002.top/2019/09/12/Nginx%E4%B9%8Brewrite%E9%85%8D%E7%BD%AE%E5%9F%9F%E5%90%8D%E8%B7%B3%E8%BD%AC/#more">Nginx之rewrite配置域名跳转</a></li></ul><hr><h3 id="2-通过域名-文件名-文件类型的URL格式访问"><a href="#2-通过域名-文件名-文件类型的URL格式访问" class="headerlink" title="2.通过域名/文件名.文件类型的URL格式访问"></a>2.通过<code>域名/文件名.文件类型</code>的URL格式访问</h3><blockquote><p>应用场景：小程序业务域名的验证。</p></blockquote><h4 id="①方法一"><a href="#①方法一" class="headerlink" title="①方法一"></a>①方法一</h4><ul><li>当 <code>server</code> 的配置中不存在 <code>location / { ... }</code> 时</li><li>配置示例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80 default_server; # 监听80端口</span><br><span class="line">    server_name  localhost; # 可自定义域名</span><br><span class="line">    root /usr; # 注意：/usr为文件所在目录,可任意设置</span><br><span class="line">    # root /; # 当文件在根目录时如此配置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②方法二"><a href="#②方法二" class="headerlink" title="②方法二"></a>②方法二</h4><ul><li>当 <code>server</code> 的配置中存在 <code>location / { ... }</code> 时</li><li>配置示例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在server中添加：</span><br><span class="line">location /文件名.文件类型 &#123;</span><br><span class="line">    root /usr; # 注意：/usr为文件所在目录,可任意设置</span><br><span class="line">    # root /; # 当文件在根目录时如此配置</span><br><span class="line">    expires 30d;</span><br><span class="line">    access_log off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 <code>/文件名.文件类型</code> 匹配以 <code>/文件名.文件类型</code> 开头的请求</li></ul><h4 id="③验证配置"><a href="#③验证配置" class="headerlink" title="③验证配置"></a>③验证配置</h4><p><img src="./1568213380744.png" alt="Alt text"><br><img src="./1568213790446.png" alt="Alt text"></p><hr><h3 id="3-通过域名-自定义-文件名-文件类型的URL格式访问"><a href="#3-通过域名-自定义-文件名-文件类型的URL格式访问" class="headerlink" title="3.通过域名/自定义/文件名.文件类型的URL格式访问"></a>3.通过<code>域名/自定义/文件名.文件类型</code>的URL格式访问</h3><blockquote><p>应用场景：搭建 Nginx 图片服务器。</p></blockquote><ul><li>配置示例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location /images/ &#123;</span><br><span class="line">    root  /usr/local/javaweb/xdxlb/; </span><br><span class="line">    # 将/images/映射到/usr/local/javaweb/xdxlb/images/</span><br><span class="line">    autoindex on; # 打开浏览功能</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 <code>location /images/</code> 匹配所有以 <code>/images/</code> 开头的请求</li><li>验证配置：</li></ul><p><img src="./1568252577331.png" alt="Alt text"><br><img src="./1568252491321.png" alt="Alt text"></p><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#119;&#106;&#121;&#109;&#101;&#x73;&#115;&#105;&#64;&#49;&#x36;&#51;&#x2e;&#99;&#111;&#109;" target="_blank" rel="noopener">&#119;&#106;&#121;&#109;&#101;&#x73;&#115;&#105;&#64;&#49;&#x36;&#51;&#x2e;&#99;&#111;&#109;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;ps：每次修改配置后，需要重启 Nginx。&lt;br&gt;命令：&lt;strong&gt;systemctl restart nginx&lt;/strong&gt;。&lt;br&gt;Nginx 的配置文件：&lt;strong&gt;/etc/nginx/nginx.conf&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://messi1002.top/categories/Linux/"/>
    
      <category term="服务器" scheme="http://messi1002.top/categories/Linux/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Nginx" scheme="http://messi1002.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Java发起HTTP请求的工具类</title>
    <link href="http://messi1002.top/2019/09/12/Java%E5%8F%91%E8%B5%B7HTTP%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://messi1002.top/2019/09/12/Java发起HTTP请求的工具类/</id>
    <published>2019-09-12T02:42:54.000Z</published>
    <updated>2019-09-18T14:09:40.430Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ps：CloseableHttpClient 是 HttpClient 接口的实现类</p></blockquote><h3 id="1-发起GET请求"><a href="#1-发起GET请求" class="headerlink" title="1.发起GET请求"></a>1.发起GET请求</h3><h4 id="①无参数的GET请求"><a href="#①无参数的GET请求" class="headerlink" title="①无参数的GET请求"></a>①无参数的GET请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能描述: 无参数的GET请求</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>: [url]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: java.lang.String</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/5/31 22:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doGet</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> doGet(url, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②有参数的GET请求"><a href="#②有参数的GET请求" class="headerlink" title="②有参数的GET请求"></a>②有参数的GET请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 功能描述: 有参数的GET请求</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>: [url, param]</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>: java.lang.String</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@date</span>: 2019/5/31 22:05</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doGet</span><span class="params">(String url, LinkedHashMap&lt;String, String&gt; param)</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 创建HttpClient对象</span></span><br><span class="line">     CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line">     CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">// GET请求的返回内容</span></span><br><span class="line">     String resultString = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         URIBuilder builder = <span class="keyword">new</span> URIBuilder(url);</span><br><span class="line">         <span class="comment">// 设置请求参数</span></span><br><span class="line">         <span class="keyword">if</span> (param != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">for</span> (String key : param.keySet()) &#123;</span><br><span class="line">                 builder.addParameter(key, param.get(key));</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 构建一个URI对象</span></span><br><span class="line">         URI uri = builder.build();</span><br><span class="line">         <span class="comment">// 创建GET请求</span></span><br><span class="line">         HttpGet httpGet = <span class="keyword">new</span> HttpGet(uri);</span><br><span class="line">         <span class="comment">// 执行GET请求</span></span><br><span class="line">         response = httpClient.execute(httpGet);</span><br><span class="line">         <span class="comment">// 获取响应状态码</span></span><br><span class="line">         <span class="keyword">if</span> (response.getStatusLine().getStatusCode() == <span class="number">200</span>) &#123;</span><br><span class="line">             resultString = EntityUtils.toString(response.getEntity(), <span class="string">"UTF-8"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         log.error(<span class="string">"GET Method Catch Unexception Hanlder:&#123;&#125;, message:&#123;&#125;"</span>, e, e.getMessage());</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ServiceException(e.getMessage());</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 response.close();</span><br><span class="line">             &#125;</span><br><span class="line">             httpClient.close();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> resultString;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-发起POST请求"><a href="#2-发起POST请求" class="headerlink" title="2.发起POST请求"></a>2.发起POST请求</h3><h4 id="①参数为Map对象的POST请求"><a href="#①参数为Map对象的POST请求" class="headerlink" title="①参数为Map对象的POST请求"></a>①参数为Map对象的POST请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 功能描述: 有参数(Map对象)的POST请求</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>: [url, param]</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>: java.lang.String</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@date</span>: 2019/5/31 22:06</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doPost</span><span class="params">(String url, Map&lt;String, String&gt; param)</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 创建HttpClient对象</span></span><br><span class="line">     CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line">     CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">// POST请求的返回内容</span></span><br><span class="line">     String resultString = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 创建POST请求</span></span><br><span class="line">         HttpPost httpPost = <span class="keyword">new</span> HttpPost(url);</span><br><span class="line">         <span class="comment">// 创建请求参数列表</span></span><br><span class="line">         <span class="keyword">if</span> (param != <span class="keyword">null</span>) &#123;</span><br><span class="line">             List&lt;NameValuePair&gt; paramList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">             <span class="keyword">for</span> (String key : param.keySet()) &#123;</span><br><span class="line">                 paramList.add(<span class="keyword">new</span> BasicNameValuePair(key, param.get(key)));</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 构造form表单式的实体</span></span><br><span class="line">             UrlEncodedFormEntity entity = <span class="keyword">new</span> UrlEncodedFormEntity(paramList);</span><br><span class="line">             httpPost.setEntity(entity);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 执行POST请求</span></span><br><span class="line">         response = httpClient.execute(httpPost);</span><br><span class="line">         <span class="comment">// 获取响应状态码</span></span><br><span class="line">         <span class="keyword">if</span> (response.getStatusLine().getStatusCode() == <span class="number">200</span>) &#123;</span><br><span class="line">             resultString = EntityUtils.toString(response.getEntity(), <span class="string">"UTF-8"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         log.error(<span class="string">"POST Method Catch Unexception Hanlder:&#123;&#125;, message:&#123;&#125;"</span>, e, e.getMessage());</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ServiceException(e.getMessage());</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 response.close();</span><br><span class="line">             &#125;</span><br><span class="line">             httpClient.close();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> resultString;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="②参数为JSON字符串的POST请求"><a href="#②参数为JSON字符串的POST请求" class="headerlink" title="②参数为JSON字符串的POST请求"></a>②参数为JSON字符串的POST请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能描述: 有参数(Json字符串)的POST请求</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>: [url, jsonData]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: java.lang.String</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/6/25 17:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doPost</span><span class="params">(String url, String jsonData)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建HttpClient对象</span></span><br><span class="line">    CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line">    CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// POST请求的返回内容</span></span><br><span class="line">    String resultString = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建POST请求</span></span><br><span class="line">        HttpPost httpPost = <span class="keyword">new</span> HttpPost(url);</span><br><span class="line">        <span class="comment">// 解析Json数据并构造实体</span></span><br><span class="line">        StringEntity stringEntity = <span class="keyword">new</span> StringEntity(jsonData, ContentType.APPLICATION_JSON);</span><br><span class="line">        httpPost.setEntity(stringEntity);</span><br><span class="line">        <span class="comment">// 执行POST请求</span></span><br><span class="line">        response = httpClient.execute(httpPost);</span><br><span class="line">        <span class="comment">// 获取响应状态码</span></span><br><span class="line">        <span class="keyword">if</span> (response.getStatusLine().getStatusCode() == <span class="number">200</span>) &#123;</span><br><span class="line">            resultString = EntityUtils.toString(response.getEntity(), <span class="string">"UTF-8"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">"POST Method Catch Exception Handler:&#123;&#125;, message:&#123;&#125;"</span>, e, e.getMessage());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                response.close();</span><br><span class="line">            &#125;</span><br><span class="line">            httpClient.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resultString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#119;&#x6a;&#121;&#x6d;&#x65;&#x73;&#115;&#105;&#64;&#x31;&#54;&#51;&#x2e;&#x63;&#111;&#x6d;" target="_blank" rel="noopener">&#119;&#x6a;&#121;&#x6d;&#x65;&#x73;&#115;&#105;&#64;&#x31;&#54;&#51;&#x2e;&#x63;&#111;&#x6d;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;ps：CloseableHttpClient 是 HttpClient 接口的实现类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-发起GET请求&quot;&gt;&lt;a href=&quot;#1-发起GET请求&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://messi1002.top/categories/JavaWeb/"/>
    
    
      <category term="HTTP" scheme="http://messi1002.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>八种排序算法的总结及性能分析</title>
    <link href="http://messi1002.top/2019/07/22/%E5%85%AB%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <id>http://messi1002.top/2019/07/22/八种排序算法的总结及性能分析/</id>
    <published>2019-07-22T13:12:59.000Z</published>
    <updated>2020-02-22T13:13:38.806Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://messi1002.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://messi1002.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>树的遍历(递归+迭代)</title>
    <link href="http://messi1002.top/2019/06/11/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E9%80%92%E5%BD%92-%E8%BF%AD%E4%BB%A3/"/>
    <id>http://messi1002.top/2019/06/11/树的遍历-递归-迭代/</id>
    <published>2019-06-11T06:39:59.000Z</published>
    <updated>2020-02-24T05:44:28.325Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-相关博客"><a href="#1-相关博客" class="headerlink" title="1.相关博客"></a>1.相关博客</h3><p><strong>因为二叉树这种数据结构本身天然的就具有递归的结构，所以面对二叉树问题，使用递归方法解决通常比较简单。</strong></p><p><a href="https://messi1002.top/2019/06/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%80%A7%E8%B4%A8/">二叉树的定义及性质</a></p><blockquote><p>注意：示例代码中的 <code>TreeNode</code> 对象和 <code>Node</code> 对象定义如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; children;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val, List&lt;Node&gt; _children)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="2-树的前序遍历"><a href="#2-树的前序遍历" class="headerlink" title="2.树的前序遍历"></a>2.树的前序遍历</h3><ul><li>前序遍历也称为先序遍历</li><li>遍历过程为：<ul><li>①访问根结点</li><li>②先序遍历其左子树</li><li>③先序遍历其右子树 </li></ul></li><li>举例：<ul><li>下图的先序遍历结果为：1、2、3、4、5、6、7、8、9</li></ul></li></ul><p><img src="./1582471231193.png" alt="Alt text"></p><h4 id="①二叉树-递归"><a href="#①二叉树-递归" class="headerlink" title="①二叉树-递归"></a>①二叉树-递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归函数定义: 前序遍历以root节点为根节点的二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode root, List list)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归过程</span></span><br><span class="line">        <span class="comment">// 处理当前节点</span></span><br><span class="line">        list.add(root.val); </span><br><span class="line">        <span class="comment">// 前序遍历root节点的左子树</span></span><br><span class="line">        traversal(root.left, list);</span><br><span class="line">        <span class="comment">// 前序遍历root节点的右子树</span></span><br><span class="line">        traversal(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        traversal(root, list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归函数，returnSize、arr是指针，动态修改。</span></span><br><span class="line"><span class="comment">// 递归函数定义: 前序遍历以root节点为根节点的二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">orderTraversal</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span>* returnSize, <span class="keyword">int</span>* arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归过程</span></span><br><span class="line">    <span class="comment">// 处理当前节点</span></span><br><span class="line">    arr[(*returnSize)++] = root-&gt;val;</span><br><span class="line">    <span class="comment">// 前序遍历root节点的左子树</span></span><br><span class="line">    orderTraversal(root-&gt;left, returnSize, arr);</span><br><span class="line">    <span class="comment">// 前序遍历root节点的右子树</span></span><br><span class="line">    orderTraversal(root-&gt;right, returnSize, arr);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计结点数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">makeSize</span><span class="params">(struct TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> makeSize(root-&gt;left) + makeSize(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">preorderTraversal</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = makeSize(root);</span><br><span class="line">    <span class="keyword">int</span>* arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * size);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    orderTraversal(root, returnSize, arr);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②二叉树-迭代"><a href="#②二叉树-迭代" class="headerlink" title="②二叉树-迭代"></a>②二叉树-迭代</h4><ul><li>遇到一个节点就访问它，然后把它压入栈中，并去遍历它的左子树</li><li>当左子树遍历结束后，弹出栈顶元素</li><li>再去先序遍历该节点的右子树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 遇到一个节点就访问它，然后把它压入栈中，并去遍历它的左子树。</span></span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                list.add(root.val);</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当左子树遍历结束后，弹出栈顶元素。</span></span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                <span class="comment">// 再去先序遍历该节点的右子树</span></span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计结点数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">makeSize</span><span class="params">(struct TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> makeSize(root-&gt;left) + makeSize(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>** <span class="title">array</span>;</span></span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">preorderTraversal</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = makeSize(root);</span><br><span class="line">    <span class="keyword">int</span>* arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * size);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    Stack* s = (Stack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    s-&gt;<span class="built_in">array</span> = (struct TreeNode**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode*) * size);</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (s-&gt;top != <span class="number">-1</span> || root) &#123;</span><br><span class="line">        <span class="comment">// 遇到一个节点就访问它，然后把它压入栈中，并去遍历它的左子树。</span></span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            arr[(*returnSize)++] = root-&gt;val;</span><br><span class="line">            s-&gt;<span class="built_in">array</span>[++s-&gt;top] = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当左子树遍历结束后，弹出栈顶元素。</span></span><br><span class="line">        <span class="keyword">if</span> (s-&gt;top != <span class="number">-1</span>) &#123;</span><br><span class="line">            root = s-&gt;<span class="built_in">array</span>[s-&gt;top--];</span><br><span class="line">            <span class="comment">// 再去先序遍历该节点的右子树</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③N叉树-递归"><a href="#③N叉树-递归" class="headerlink" title="③N叉树-递归"></a>③N叉树-递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归函数定义: 前序遍历以root节点为根节点的N叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(Node root, List list)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归过程</span></span><br><span class="line">        <span class="comment">// 处理当前节点</span></span><br><span class="line">        list.add(root.val);</span><br><span class="line">        <span class="comment">// 前序遍历root节点的每个子树</span></span><br><span class="line">        <span class="keyword">for</span> (Node node: root.children) &#123;</span><br><span class="line">            traversal(node, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        traversal(root, list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="④N叉树-迭代"><a href="#④N叉树-迭代" class="headerlink" title="④N叉树-迭代"></a>④N叉树-迭代</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            <span class="comment">// 将N叉树的子树从右向左推入栈中，这样子树出栈的顺序是从左到右。</span></span><br><span class="line">            Collections.reverse(root.children);</span><br><span class="line">            <span class="keyword">for</span> (Node n: root.children) &#123;</span><br><span class="line">                stack.push(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-树的中序遍历"><a href="#3-树的中序遍历" class="headerlink" title="3.树的中序遍历"></a>3.树的中序遍历</h3><ul><li>遍历过程为：<ul><li>①中序遍历其左子树</li><li>②访问根结点</li><li>③中序遍历其右子树 </li></ul></li><li>对于二分搜索树来说，中序遍历使得元素从小到大排序</li><li>举例：<ul><li>下图的中序遍历结果为：1、2、3、4、5、6、7、8、9</li></ul></li></ul><p><img src="./1582470579020.png" alt="Alt text"></p><h4 id="①二叉树-递归-1"><a href="#①二叉树-递归-1" class="headerlink" title="①二叉树-递归"></a>①二叉树-递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归函数定义: 中序遍历以root节点为根节点的二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode root, List list)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归过程</span></span><br><span class="line">        <span class="comment">// 中序遍历root节点的左子树</span></span><br><span class="line">        traversal(root.left, list);</span><br><span class="line">        <span class="comment">// 处理当前节点</span></span><br><span class="line">        list.add(root.val); </span><br><span class="line">        <span class="comment">// 中序遍历root节点的右子树</span></span><br><span class="line">        traversal(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        traversal(root, list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归函数，returnSize、arr是指针，动态修改。</span></span><br><span class="line"><span class="comment">// 递归函数定义: 中序遍历以root节点为根节点的二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">orderTraversal</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span>* returnSize, <span class="keyword">int</span>* arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归过程</span></span><br><span class="line">    <span class="comment">// 中序遍历root节点的左子树</span></span><br><span class="line">    orderTraversal(root-&gt;left, returnSize, arr);</span><br><span class="line">    <span class="comment">// 处理当前节点</span></span><br><span class="line">    arr[(*returnSize)++] = root-&gt;val;</span><br><span class="line">    <span class="comment">// 中序遍历root节点的右子树</span></span><br><span class="line">    orderTraversal(root-&gt;right, returnSize, arr);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计结点数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">makeSize</span><span class="params">(struct TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> makeSize(root-&gt;left) + makeSize(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">inorderTraversal</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = makeSize(root);</span><br><span class="line">    <span class="keyword">int</span>* arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * size);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    orderTraversal(root, returnSize, arr);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②二叉树-迭代-1"><a href="#②二叉树-迭代-1" class="headerlink" title="②二叉树-迭代"></a>②二叉树-迭代</h4><ul><li>遇到一个节点，就把它压入栈中，并去遍历它的左子树</li><li>当左子树遍历结束后，弹出栈顶元素并访问它</li><li>再去中序遍历该节点的右子树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 遇到一个节点，就把它压入栈中，并去遍历它的左子树。</span></span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当左子树遍历结束后，弹出栈顶元素并访问它。</span></span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                list.add(root.val);</span><br><span class="line">                <span class="comment">// 再去中序遍历该节点的右子树</span></span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计结点数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">makeSize</span><span class="params">(struct TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> makeSize(root-&gt;left) + makeSize(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>** <span class="title">array</span>;</span></span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">inorderTraversal</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = makeSize(root);</span><br><span class="line">    <span class="keyword">int</span>* arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * size);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    Stack* s = (Stack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    s-&gt;<span class="built_in">array</span> = (struct TreeNode**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode*) * size);</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (s-&gt;top != <span class="number">-1</span> || root) &#123;</span><br><span class="line">        <span class="comment">// 遇到一个节点，就把它压入栈中，并去遍历它的左子树。</span></span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            s-&gt;<span class="built_in">array</span>[++s-&gt;top] = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当左子树遍历结束后，弹出栈顶元素并访问它。</span></span><br><span class="line">        <span class="keyword">if</span> (s-&gt;top != <span class="number">-1</span>) &#123;</span><br><span class="line">            root = s-&gt;<span class="built_in">array</span>[s-&gt;top--];</span><br><span class="line">            arr[(*returnSize)++] = root-&gt;val;</span><br><span class="line">            <span class="comment">// 再去中序遍历该节点的右子树</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-树的后序遍历"><a href="#4-树的后序遍历" class="headerlink" title="4.树的后序遍历"></a>4.树的后序遍历</h3><ul><li>遍历过程为：<ul><li>①后序遍历其左子树</li><li>②后序遍历其右子树</li><li>③访问根结点</li></ul></li><li>举例：<ul><li>下图的后序遍历结果为：1、2、3、4、5、6、7、8、9</li></ul></li></ul><p><img src="./1582470913495.png" alt="Alt text"></p><h4 id="①二叉树-递归-2"><a href="#①二叉树-递归-2" class="headerlink" title="①二叉树-递归"></a>①二叉树-递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归函数定义: 后序遍历以root节点为根节点的二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode root, List list)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归过程</span></span><br><span class="line">        <span class="comment">// 后序遍历root节点的左子树</span></span><br><span class="line">        traversal(root.left, list);</span><br><span class="line">        <span class="comment">// 后序遍历root节点的右子树</span></span><br><span class="line">        traversal(root.right, list);</span><br><span class="line">        <span class="comment">// 处理当前节点</span></span><br><span class="line">        list.add(root.val); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        traversal(root, list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归函数，returnSize、arr是指针，动态修改。</span></span><br><span class="line"><span class="comment">// 递归函数定义: 后序遍历以root节点为根节点的二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">orderTraversal</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span>* returnSize, <span class="keyword">int</span>* arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归过程</span></span><br><span class="line">    <span class="comment">// 后序遍历root节点的左子树</span></span><br><span class="line">    orderTraversal(root-&gt;left, returnSize, arr);</span><br><span class="line">    <span class="comment">// 后序遍历root节点的右子树</span></span><br><span class="line">    orderTraversal(root-&gt;right, returnSize, arr);    </span><br><span class="line">    <span class="comment">// 处理当前节点</span></span><br><span class="line">    arr[(*returnSize)++] = root-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计结点数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">makeSize</span><span class="params">(struct TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> makeSize(root-&gt;left) + makeSize(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">postorderTraversal</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = makeSize(root);</span><br><span class="line">    <span class="keyword">int</span>* arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * size);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    orderTraversal(root, returnSize, arr);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②二叉树-迭代-2"><a href="#②二叉树-迭代-2" class="headerlink" title="②二叉树-迭代"></a>②二叉树-迭代</h4><ul><li>后序遍历的顺序是：左右中</li><li>先序遍历的顺序是：中左右</li><li>所以我们可以先将先序遍历修改为：中右左，再将其遍历结果翻转存放，即可得到后序遍历的结果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先将先序遍历的中左右改为中右左，再将遍历结果翻转，即可得到后序遍历的左右中。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 遇到一个节点就访问它，然后把它压入栈中，并去遍历它的右子树。</span></span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                list.add(root.val);</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当右子树遍历结束后，弹出栈顶元素。</span></span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                <span class="comment">// 再去"改写的先序"遍历该节点的左子树</span></span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将遍历结果翻转</span></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先将先序遍历的中左右改为中右左，再将遍历结果翻转，即可得到后序遍历的左右中。</span></span><br><span class="line"><span class="comment">// 统计结点数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">makeSize</span><span class="params">(struct TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> makeSize(root-&gt;left) + makeSize(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>** <span class="title">array</span>;</span></span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">postorderTraversal</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = makeSize(root);</span><br><span class="line">    <span class="keyword">int</span>* arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * size);</span><br><span class="line">    Stack* s = (Stack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    s-&gt;<span class="built_in">array</span> = (struct TreeNode**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode*) * size);</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    *returnSize = size;</span><br><span class="line">    <span class="keyword">int</span> row = *returnSize<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (root || s-&gt;top != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 遇到一个节点就访问它，然后把它压入栈中，并去遍历它的右子树。</span></span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            <span class="comment">// 反向存储遍历结果</span></span><br><span class="line">            arr[row--] = root-&gt;val;</span><br><span class="line">            s-&gt;<span class="built_in">array</span>[++s-&gt;top] = root;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当右子树遍历结束后，弹出栈顶元素。</span></span><br><span class="line">        <span class="keyword">if</span> (s-&gt;top != <span class="number">-1</span>) &#123;</span><br><span class="line">            root = s-&gt;<span class="built_in">array</span>[s-&gt;top--];</span><br><span class="line">            <span class="comment">// 再去"改写的先序"遍历该节点的左子树</span></span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③N叉树-递归-1"><a href="#③N叉树-递归-1" class="headerlink" title="③N叉树-递归"></a>③N叉树-递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归函数定义: 后序遍历以root节点为根节点的N叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(Node root, List list)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归过程</span></span><br><span class="line">        <span class="comment">// 后序遍历root节点的每个子树</span></span><br><span class="line">        <span class="keyword">for</span> (Node node: root.children) &#123;</span><br><span class="line">            traversal(node, list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理当前节点</span></span><br><span class="line">        list.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        traversal(root, list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="④N叉树-迭代-1"><a href="#④N叉树-迭代-1" class="headerlink" title="④N叉树-迭代"></a>④N叉树-迭代</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 与二叉树的后序遍历——迭代法同理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            <span class="comment">// 将N叉树的子树从左向右推入栈中，这样子树出栈的顺序是从右到左。</span></span><br><span class="line">            <span class="keyword">for</span> (Node n: root.children) &#123;</span><br><span class="line">                stack.push(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将遍历结果翻转</span></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-树的层序遍历"><a href="#5-树的层序遍历" class="headerlink" title="5.树的层序遍历"></a>5.树的层序遍历</h3><ul><li>从根节点开始，首先将根节点入队，然后开始执行循环：节点出队、访问该节点、其左右孩子入队</li><li>举例：<ul><li>下图的层序遍历结果为：5、2、8、1、4、6、9、3、7</li></ul></li></ul><p><img src="./1582470604901.png" alt="Alt text"></p><blockquote><p>注意：层序遍历的示例代码输出格式为下图所示格式。</p></blockquote><p><img src="./1582517961898.png" alt="Alt text"></p><h4 id="①二叉树-迭代"><a href="#①二叉树-迭代" class="headerlink" title="①二叉树-迭代"></a>①二叉树-迭代</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root)   &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 将根节点入队</span></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 使用count分层</span></span><br><span class="line">            <span class="keyword">int</span> count = queue.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();            </span><br><span class="line">            <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 节点出队</span></span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="comment">// 访问该节点</span></span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="comment">// 其左右孩子入队</span></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②N叉树-迭代"><a href="#②N叉树-迭代" class="headerlink" title="②N叉树-迭代"></a>②N叉树-迭代</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 将根节点入队</span></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 使用count分层</span></span><br><span class="line">            <span class="keyword">int</span> count = queue.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();            </span><br><span class="line">            <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 节点出队</span></span><br><span class="line">                Node node = queue.poll();</span><br><span class="line">                <span class="comment">// 访问该节点</span></span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="comment">// 其所有孩子从左到右依次入队</span></span><br><span class="line">                <span class="keyword">for</span> (Node n: node.children) &#123;</span><br><span class="line">                    queue.add(n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h3><ul><li>前、中、后序遍历都属于 <strong>深度优先遍历</strong><ul><li>即首先尝试走到最深，走不通之后再返回用回溯的方式将整棵树遍历结束</li><li>三种遍历实际访问节点的顺序相同，只是执行打印的位置不同</li><li>实现深度优先遍历：需要堆栈</li></ul></li><li>层序遍历属于 <strong>广度优先遍历</strong><ul><li>一层一层地遍历，关注广度，将每层的所有结点遍历完再去下一层</li><li>实现广度优先遍历：需要队列</li></ul></li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#106;&#x79;&#x6d;&#x65;&#115;&#115;&#105;&#x40;&#x31;&#54;&#51;&#x2e;&#99;&#x6f;&#x6d;" target="_blank" rel="noopener">&#x77;&#106;&#x79;&#x6d;&#x65;&#115;&#115;&#105;&#x40;&#x31;&#54;&#51;&#x2e;&#99;&#x6f;&#x6d;</a></li><li>关于 <strong>数据结构与算法</strong> 的更多代码 请查看我的 <a href="https://github.com/messi1002/DataStructure" target="_blank" rel="noopener">GitHub仓库</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-相关博客&quot;&gt;&lt;a href=&quot;#1-相关博客&quot; class=&quot;headerlink&quot; title=&quot;1.相关博客&quot;&gt;&lt;/a&gt;1.相关博客&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;因为二叉树这种数据结构本身天然的就具有递归的结构，所以面对二叉树问题，使用递归方法解决通常比
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://messi1002.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树" scheme="http://messi1002.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的定义及性质</title>
    <link href="http://messi1002.top/2019/06/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%80%A7%E8%B4%A8/"/>
    <id>http://messi1002.top/2019/06/08/二叉树的定义及性质/</id>
    <published>2019-06-08T07:44:04.000Z</published>
    <updated>2020-02-21T09:42:06.230Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://messi1002.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树" scheme="http://messi1002.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二分查找法代码实现</title>
    <link href="http://messi1002.top/2019/06/05/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>http://messi1002.top/2019/06/05/二分查找法代码实现/</id>
    <published>2019-06-05T08:08:43.000Z</published>
    <updated>2020-02-21T14:59:56.693Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p><img src="./1582294410014.png" alt="Alt text"></p><ul><li>对于有序数列，才能使用<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">二分查找法</a>。</li><li>二分查找又称折半查找。<ul><li>优点：比较次数少、查找速度快、平均性能好</li><li>缺点：要求待查表为有序表、插入和删除困难</li><li>因此二分查找适用于不经常变动且查找频繁的有序列表</li></ul></li></ul><hr><h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><ul><li>二分查找法：在有序数组 arr 中查找 target。<ul><li>如果找到 target，返回相应的索引 index。</li><li>如果没有找到 target，返回 -1。</li></ul></li><li>时间复杂度：O(log n)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 二分查找法: 在有序数组arr中查找target。</span></span><br><span class="line"><span class="comment"> * 如果找到target，返回相应的索引index。如果没有找到target，返回-1。</span></span><br><span class="line"><span class="comment"> * 时间复杂度: O(log n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 使用迭代的方法实现二分查找法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [arr, target]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: int</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/21 21:10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在arr[l...r]之中查找target</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="comment">// int mid = (l + r) / 2;</span></span><br><span class="line">            <span class="comment">// 防止极端情况下的整形溢出，用以下方法求mid。</span></span><br><span class="line">            <span class="comment">// int mid = l + (r - l) / 2;</span></span><br><span class="line">            <span class="comment">// 模仿jdk源码中的写法，无符号右移一位。</span></span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; arr[mid]) &#123;</span><br><span class="line">                <span class="comment">// 在arr[l...mid-1]之中查找target</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 在arr[mid+1...r]之中查找target</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 使用递归的方法实现二分查找法(性能上略差，但差异是常数级的)。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [arr, l, r, target]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: int</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/21 20:58</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearchByRecursion</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在arr[l...r]之中查找target</span></span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// int mid = (l + r) / 2;</span></span><br><span class="line">        <span class="comment">// 防止极端情况下的整形溢出，用以下方法求mid。</span></span><br><span class="line">        <span class="comment">// int mid = l + (r - l) / 2, index = -1;</span></span><br><span class="line">        <span class="comment">// 模仿jdk源码中的写法，无符号右移一位。</span></span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt;&gt; <span class="number">1</span>, index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">            index = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; arr[mid]) &#123;</span><br><span class="line">            <span class="comment">// 在arr[l...mid-1]之中查找target</span></span><br><span class="line">            index = binarySearchByRecursion(arr, l, mid - <span class="number">1</span>, target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在arr[mid+1...r]之中查找target</span></span><br><span class="line">            index = binarySearchByRecursion(arr, mid + <span class="number">1</span>, r, target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 测试迭代方法和递归方法的正确性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [args]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/21 20:39</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成一个有序数组</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> random = (<span class="keyword">int</span>) (Math.random() * n);</span><br><span class="line">        System.out.println(<span class="string">"随机数: "</span> + random + <span class="string">" 迭代方法执行结果: "</span> + binarySearch(arr, random));</span><br><span class="line">        System.out.println(<span class="string">"随机数: "</span> + random + <span class="string">" 递归方法执行结果: "</span> + binarySearchByRecursion(arr, <span class="number">0</span>, n - <span class="number">1</span>, random));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582288073738.png" alt="Alt text"></p><hr><h3 id="3-Leetcode-题解举例"><a href="#3-Leetcode-题解举例" class="headerlink" title="3.Leetcode 题解举例"></a>3.Leetcode 题解举例</h3><ul><li><a href="https://messi1002.top/2019/06/04/LeetCode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%EF%BC%88Easy%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/#more">[LeetCode] 35.搜索插入位置（Easy）Java语言题解</a></li><li><a href="https://messi1002.top/2019/06/04/LeetCode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%EF%BC%88Easy%EF%BC%89C%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/">[LeetCode] 35.搜索插入位置（Easy）C语言题解</a></li><li>优秀题解分享：<a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">用“排除法”（减治思想）写二分查找问题</a></li></ul><hr><h3 id="4-扩展问题"><a href="#4-扩展问题" class="headerlink" title="4.扩展问题"></a>4.扩展问题</h3><ul><li>如果有序数列中存在多个 target 值，我们应该返回什么呢？</li><li>使用上述代码，并不能确定我们找到的索引具体对应哪一个 target。</li><li>为了解决这个问题，我们额外定义两个函数：<ul><li>①floor() 函数: 返回 target 在数组中第一次出现的位置，若是元素不存在，返回数组中小于 target 的最大元素。</li><li>②ceil() 函数: 返回 target 在数组中最后一次出现的位置，若是元素不存在，返回数组中大于 target 的最小元素。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 二分查找法的扩展问题: 当数组中存在多个target值时，应该返回什么？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchExtend</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">floor</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所有元素都小于target</span></span><br><span class="line">        <span class="keyword">if</span> (l == arr.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> l - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[l] == target? l: l - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ceil</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所有元素都大于target</span></span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所有元素都小于target</span></span><br><span class="line">        <span class="keyword">if</span> (l == arr.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> l - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[r] == target? r: r + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: 测试floor()函数和ceil()函数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: [args]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@auther</span>: wjy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2020/2/21 20:39</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> random = (<span class="keyword">int</span>) (Math.random() * arr.length);</span><br><span class="line">        System.out.println(<span class="string">"floor(arr, "</span> + random  + <span class="string">") = "</span> + floor(arr, random));</span><br><span class="line">        System.out.println(<span class="string">"ceil(arr, "</span> + random  + <span class="string">") = "</span> + ceil(arr, random));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./1582294232081.png" alt="Alt text"></p><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#x6a;&#x79;&#109;&#101;&#x73;&#115;&#x69;&#x40;&#x31;&#x36;&#51;&#46;&#x63;&#111;&#x6d;" target="_blank" rel="noopener">&#x77;&#x6a;&#x79;&#109;&#101;&#x73;&#115;&#x69;&#x40;&#x31;&#x36;&#51;&#46;&#x63;&#111;&#x6d;</a></li><li>关于 <strong>数据结构与算法</strong> 的更多代码 请查看我的 <a href="https://github.com/messi1002/DataStructure" target="_blank" rel="noopener">GitHub仓库</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1.概念&quot;&gt;&lt;/a&gt;1.概念&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;./1582294410014.png&quot; alt=&quot;Alt text&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://messi1002.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分查找法" scheme="http://messi1002.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 35.搜索插入位置（Easy）Java语言题解</title>
    <link href="http://messi1002.top/2019/06/04/LeetCode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%EF%BC%88Easy%EF%BC%89Java%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/"/>
    <id>http://messi1002.top/2019/06/04/LeetCode-35-搜索插入位置（Easy）Java语言题解/</id>
    <published>2019-06-04T09:35:43.000Z</published>
    <updated>2020-02-21T17:52:37.212Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目相关"><a href="#1-题目相关" class="headerlink" title="1.题目相关"></a>1.题目相关</h3><h4 id="①题目及示例"><a href="#①题目及示例" class="headerlink" title="①题目及示例"></a>①题目及示例</h4><p><img src="./1582280358807.png" alt="Alt text"></p><h4 id="②相关标签"><a href="#②相关标签" class="headerlink" title="②相关标签"></a>②相关标签</h4><ul><li>数组</li><li>二分查找 </li></ul><h4 id="③题目地址"><a href="#③题目地址" class="headerlink" title="③题目地址"></a>③题目地址</h4><ul><li><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置 — 力扣网</a></li></ul><hr><h3 id="2-解题方法"><a href="#2-解题方法" class="headerlink" title="2.解题方法"></a>2.解题方法</h3><h4 id="①顺序查找"><a href="#①顺序查找" class="headerlink" title="①顺序查找"></a>①顺序查找</h4><ul><li>根据题意可以看出，数组中第一个大于或等于 target 的元素对应的下标就是 target 将要插入的位置，若是数组中的元素都比 target 小，则返回数组长度。</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h4 id="②二分查找"><a href="#②二分查找" class="headerlink" title="②二分查找"></a>②二分查找</h4><ul><li>结论：<ul><li>每次判断 nums[mid] 和 target 之间的大小：</li><li>若 nums[mid] = target，则直接返回下标。</li><li>若 nums[mid] &lt; target，则 left = mid + 1。</li><li>若 nums[mid] &gt; target，则 right = mid - 1。</li><li>查找结束后返回 left，该值为插入位置。</li></ul></li><li>这道题的难点是如果数组中不包含值和 target 相等的元素，那么我们要返回什么呢？上文的结论是返回 left，那么我们是如何得到的呢？</li><li>此时我们可以想象程序在最后一次循环中会做什么：<ul><li>已知程序结束循环的条件是 <code>left &gt; right</code>，所以我们可以确定在最后一次循环中有：<code>right == left</code> -&gt; <code>mid == (right + left) / 2 == right == left</code>，此时存在两种情况：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">    <span class="comment">// left &gt; right，之后退出循环。</span></span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 退出循环后，nums[left] = nums[right + 1] &gt; target。</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">    <span class="comment">// right &lt; left，之后退出循环。</span></span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 退出循环后，nums[left] = nums[mid] &gt; target。</span></span><br></pre></td></tr></table></figure><ul><li>根据上述证明可知，返回 left 是正确的。</li><li>时间复杂度：O(log n)</li><li>空间复杂度：O(1)</li></ul><hr><h3 id="3-代码详解"><a href="#3-代码详解" class="headerlink" title="3.代码详解"></a>3.代码详解</h3><h4 id="①暴力解法"><a href="#①暴力解法" class="headerlink" title="①暴力解法"></a>①暴力解法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt;= target) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②二分查找-1"><a href="#②二分查找-1" class="headerlink" title="②二分查找"></a>②二分查找</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// int mid = (left + right) / 2;</span></span><br><span class="line">        <span class="comment">// int mid = left + (right - left) / 2;</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#x6a;&#121;&#x6d;&#101;&#115;&#x73;&#x69;&#x40;&#49;&#x36;&#x33;&#46;&#x63;&#111;&#x6d;" target="_blank" rel="noopener">&#x77;&#x6a;&#121;&#x6d;&#101;&#115;&#x73;&#x69;&#x40;&#49;&#x36;&#x33;&#46;&#x63;&#111;&#x6d;</a></li><li>关于 <strong>数据结构与算法</strong> 的更多代码 请查看我的 <a href="https://github.com/messi1002/leetcode" target="_blank" rel="noopener">GitHub仓库</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目相关&quot;&gt;&lt;a href=&quot;#1-题目相关&quot; class=&quot;headerlink&quot; title=&quot;1.题目相关&quot;&gt;&lt;/a&gt;1.题目相关&lt;/h3&gt;&lt;h4 id=&quot;①题目及示例&quot;&gt;&lt;a href=&quot;#①题目及示例&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://messi1002.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode-Java" scheme="http://messi1002.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode-Java/"/>
    
    
      <category term="二分查找法" scheme="http://messi1002.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 35.搜索插入位置（Easy）C语言题解</title>
    <link href="http://messi1002.top/2019/06/04/LeetCode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%EF%BC%88Easy%EF%BC%89C%E8%AF%AD%E8%A8%80%E9%A2%98%E8%A7%A3/"/>
    <id>http://messi1002.top/2019/06/04/LeetCode-35-搜索插入位置（Easy）C语言题解/</id>
    <published>2019-06-04T09:35:34.000Z</published>
    <updated>2020-02-21T17:51:45.085Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目相关"><a href="#1-题目相关" class="headerlink" title="1.题目相关"></a>1.题目相关</h3><h4 id="①题目及示例"><a href="#①题目及示例" class="headerlink" title="①题目及示例"></a>①题目及示例</h4><p><img src="./1582280358807.png" alt="Alt text"></p><h4 id="②相关标签"><a href="#②相关标签" class="headerlink" title="②相关标签"></a>②相关标签</h4><ul><li>数组</li><li>二分查找 </li></ul><h4 id="③题目地址"><a href="#③题目地址" class="headerlink" title="③题目地址"></a>③题目地址</h4><ul><li><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置 — 力扣网</a></li></ul><hr><h3 id="2-解题方法"><a href="#2-解题方法" class="headerlink" title="2.解题方法"></a>2.解题方法</h3><h4 id="①顺序查找"><a href="#①顺序查找" class="headerlink" title="①顺序查找"></a>①顺序查找</h4><ul><li>根据题意可以看出，数组中第一个大于或等于 target 的元素对应的下标就是 target 将要插入的位置，若是数组中的元素都比 target 小，则返回数组长度。</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h4 id="②二分查找"><a href="#②二分查找" class="headerlink" title="②二分查找"></a>②二分查找</h4><ul><li>结论：<ul><li>每次判断 nums[mid] 和 target 之间的大小：</li><li>若 nums[mid] = target，则直接返回下标。</li><li>若 nums[mid] &lt; target，则 left = mid + 1。</li><li>若 nums[mid] &gt; target，则 right = mid - 1。</li><li>查找结束后返回 left，该值为插入位置。</li></ul></li><li>这道题的难点是如果数组中不包含值和 target 相等的元素，那么我们要返回什么呢？上文的结论是返回 left，那么我们是如何得到的呢？</li><li>此时我们可以想象程序在最后一次循环中会做什么：<ul><li>已知程序结束循环的条件是 <code>left &gt; right</code>，所以我们可以确定在最后一次循环中有：<code>right == left</code> -&gt; <code>mid == (right + left) / 2 == right == left</code>，此时存在两种情况：</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">    <span class="comment">// left &gt; right，之后退出循环。</span></span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 退出循环后，nums[left] = nums[right + 1] &gt; target。</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">    <span class="comment">// right &lt; left，之后退出循环。</span></span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 退出循环后，nums[left] = nums[mid] &gt; target。</span></span><br></pre></td></tr></table></figure><ul><li>根据上述证明可知，返回 left 是正确的。</li><li>时间复杂度：O(log n)</li><li>空间复杂度：O(1)</li></ul><hr><h3 id="3-代码详解"><a href="#3-代码详解" class="headerlink" title="3.代码详解"></a>3.代码详解</h3><h4 id="①暴力解法"><a href="#①暴力解法" class="headerlink" title="①暴力解法"></a>①暴力解法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt;= target) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numsSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②二分查找-1"><a href="#②二分查找-1" class="headerlink" title="②二分查找"></a>②二分查找</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// int mid = (left + right) / 2;</span></span><br><span class="line">        <span class="comment">// int mid = left + (right - left) / 2;</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#x6a;&#121;&#x6d;&#x65;&#x73;&#x73;&#105;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#x6d;" target="_blank" rel="noopener">&#x77;&#x6a;&#121;&#x6d;&#x65;&#x73;&#x73;&#105;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#x6d;</a></li><li>关于 <strong>数据结构与算法</strong> 的更多代码 请查看我的 <a href="https://github.com/messi1002/leetcode" target="_blank" rel="noopener">GitHub仓库</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目相关&quot;&gt;&lt;a href=&quot;#1-题目相关&quot; class=&quot;headerlink&quot; title=&quot;1.题目相关&quot;&gt;&lt;/a&gt;1.题目相关&lt;/h3&gt;&lt;h4 id=&quot;①题目及示例&quot;&gt;&lt;a href=&quot;#①题目及示例&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://messi1002.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode-C" scheme="http://messi1002.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode-C/"/>
    
    
      <category term="二分查找法" scheme="http://messi1002.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>在命令行中使用SSH免密登录服务器</title>
    <link href="http://messi1002.top/2019/05/25/%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E4%BD%BF%E7%94%A8SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://messi1002.top/2019/05/25/在命令行中使用SSH免密登录服务器/</id>
    <published>2019-05-25T07:44:31.000Z</published>
    <updated>2019-11-07T13:57:24.123Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-生成公钥和私钥"><a href="#1-生成公钥和私钥" class="headerlink" title="1.生成公钥和私钥"></a>1.生成公钥和私钥</h3><ul><li>打开命令行 输入 <strong>ssh-keygen -t rsa</strong></li><li>然后连续按三个回车(第一个回车表示不重命名文件 第二、三个回车表示不设置密码)</li></ul><p><img src="./1558759109193.png" alt="Alt text"></p><ul><li>最后在 C 盘找到生成的公钥和私钥</li></ul><p><img src="./1558759476823.png" alt="Alt text"></p><hr><h3 id="2-将公钥写入服务器"><a href="#2-将公钥写入服务器" class="headerlink" title="2.将公钥写入服务器"></a>2.将公钥写入服务器</h3><blockquote><p><strong>ps：需要服务器的防火墙放行 22 端口。</strong></p></blockquote><ul><li>在命令行使用密码登录服务器</li></ul><p><img src="./1558757036170.png" alt="Alt text"></p><ul><li>将生成的公匙内容粘贴到 <strong>authorized_keys</strong> 文件中</li></ul><p><img src="./1558768523032.png" alt="Alt text"><br><img src="./1573133642836.png" alt="Alt text"></p><ul><li>退出服务器</li><li>重新连接时 不用输入密码即可登录！</li></ul><p><img src="./1558758414242.png" alt="Alt text"></p><hr><h3 id="3-解决WARNING-REMOTE-HOST-IDENTIFICATION-HAS-CHANGED"><a href="#3-解决WARNING-REMOTE-HOST-IDENTIFICATION-HAS-CHANGED" class="headerlink" title="3.解决WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!"></a>3.解决WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!</h3><ul><li>重置服务器之后再配置 SSH 连接时 会报这个错误：远程主机标识已更改！</li></ul><p><img src="./1572876290523.png" alt="Alt text"></p><ul><li>这时需要将电脑上的旧连接信息删除（根据服务器IP）</li></ul><p><img src="./1572876599187.png" alt="Alt text"><br><img src="./1572872409055.png" alt="Alt text"></p><ul><li>删除后重新连接即可</li></ul><p><img src="./1572876039692.png" alt="Alt text"></p><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#x77;&#x6a;&#x79;&#109;&#x65;&#x73;&#x73;&#x69;&#x40;&#49;&#x36;&#x33;&#x2e;&#99;&#x6f;&#x6d;" target="_blank" rel="noopener">&#x77;&#x6a;&#x79;&#109;&#x65;&#x73;&#x73;&#x69;&#x40;&#49;&#x36;&#x33;&#x2e;&#99;&#x6f;&#x6d;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-生成公钥和私钥&quot;&gt;&lt;a href=&quot;#1-生成公钥和私钥&quot; class=&quot;headerlink&quot; title=&quot;1.生成公钥和私钥&quot;&gt;&lt;/a&gt;1.生成公钥和私钥&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;打开命令行 输入 &lt;strong&gt;ssh-keygen -t rsa&lt;/
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://messi1002.top/categories/Linux/"/>
    
      <category term="服务器" scheme="http://messi1002.top/categories/Linux/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="CentOS7" scheme="http://messi1002.top/tags/CentOS7/"/>
    
      <category term="SSH" scheme="http://messi1002.top/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>项目管理利器-maven</title>
    <link href="http://messi1002.top/2019/05/16/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%88%A9%E5%99%A8-maven/"/>
    <id>http://messi1002.top/2019/05/16/项目管理利器-maven/</id>
    <published>2019-05-15T17:02:53.000Z</published>
    <updated>2019-09-07T03:36:50.136Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>maven 是 Apache 下的一个纯 Java 开发的开源项目。</strong><br>基于项目对象模型(POM)的概念，它可以从一个中心资料片管理项目构建、报告和文件。<br>它也是一套强大的自动化构建工具，覆盖了编译、测试、运行、清理、打包和部署等整个项目构建的周期。<br>并且它提供了一个仓库的概念，可以统一地管理项目所依赖的第三方 jar 包。</p></blockquote><hr><h3 id="1-安装-maven"><a href="#1-安装-maven" class="headerlink" title="1.安装 maven"></a>1.安装 maven</h3><h4 id="①下载-maven"><a href="#①下载-maven" class="headerlink" title="①下载 maven"></a>①下载 maven</h4><ul><li>下载地址：<a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener">https://maven.apache.org/download.cgi</a></li></ul><p><img src="./1555411972602.png" alt="Alt text"></p><ul><li>然后解压压缩包</li></ul><h4 id="②安装目录介绍"><a href="#②安装目录介绍" class="headerlink" title="②安装目录介绍"></a>②安装目录介绍</h4><p><img src="./1555412239139.png" alt="Alt text"></p><h4 id="③配置环境变量"><a href="#③配置环境变量" class="headerlink" title="③配置环境变量"></a>③配置环境变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">M2_HOME: D:\apache-maven-3.5.4(安装目录)</span><br><span class="line">path: %M2_HOME%\bin</span><br></pre></td></tr></table></figure><p><img src="./1555412766079.png" alt="Alt text"><br><img src="./1555412915871.png" alt="Alt text"></p><blockquote><p><strong>注意：<code>%环境变量%</code> 相当于引用这个环境变量的路径。</strong><br> <strong>配置完 path 环境变量后，需要重启命令行(重新加载环境变量)。</strong></p></blockquote><h4 id="④验证配置"><a href="#④验证配置" class="headerlink" title="④验证配置"></a>④验证配置</h4><ul><li><strong>mvn -v</strong> 命令：查看 maven 版本</li></ul><p><img src="./1555412597017.png" alt="Alt text"></p><ul><li>如果出现上图文字 说明安装成功</li></ul><hr><h3 id="2-第一个-maven-项目"><a href="#2-第一个-maven-项目" class="headerlink" title="2.第一个 maven 项目"></a>2.第一个 maven 项目</h3><h4 id="①目录结构"><a href="#①目录结构" class="headerlink" title="①目录结构"></a>①目录结构</h4><ul><li>使用 maven 管理的 Java 项目都有着相同的项目结构(强制)</li></ul><p><img src="./1556028747733.png" alt="Alt text"></p><h4 id="②编写代码"><a href="#②编写代码" class="headerlink" title="②编写代码"></a>②编写代码</h4><ul><li>编写 “Hello Maven!” 类：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloMaven</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello Maven!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编写测试类：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Assert.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloMavenTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表明该方法为测试方法。</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检验new HelloMaven().say()的返回值是否为"Hello Maven!"。</span></span><br><span class="line">        Assert.assertEquals(<span class="string">"Hello Maven!"</span>, <span class="keyword">new</span> HelloMaven().say());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>目录结构如下：</li></ul><p><img src="./1556028804253.png" alt="Alt text"><br><img src="./1556028856246.png" alt="Alt text"></p><h4 id="③新建-pom-xml-文件"><a href="#③新建-pom-xml-文件" class="headerlink" title="③新建 pom.xml 文件"></a>③新建 pom.xml 文件</h4><blockquote><p><strong>pom.xml：用于管理项目依赖和构建过程(维护当前项目的 jar 包)。</strong></p></blockquote><ul><li>写完代码后 还需要 pom.xml 文件管理项目的依赖</li><li>新建 pom.xml 文件 并将之移至项目根目录</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 以下文字:</span></span><br><span class="line"><span class="comment">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line"><span class="comment">  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</span></span><br><span class="line"><span class="comment">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    &lt;!-- 组织名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>wjy-maven1<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!-- 模块名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven1-model<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 导入junit依赖(测试框架) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 增加jdk的设置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span>    </span><br><span class="line"> !--&gt;</span><br></pre></td></tr></table></figure><h4 id="④编译运行-进入项目根目录"><a href="#④编译运行-进入项目根目录" class="headerlink" title="④编译运行(进入项目根目录)"></a>④编译运行(进入项目根目录)</h4><ul><li><strong>mvn compile</strong>：编译项目</li><li><strong>mvn test</strong>：测试运行项目</li></ul><p><img src="./1555421650119.png" alt="Alt text"><br><img src="./1555421666849.png" alt="Alt text"></p><blockquote><p>编译运行后，项目根目录会自动生成一个 target 目录，里面存放着测试报告、编译生成的 class 文件等。</p></blockquote><hr><h3 id="3-核心知识"><a href="#3-核心知识" class="headerlink" title="3.核心知识"></a>3.核心知识</h3><h4 id="①常用构建命令"><a href="#①常用构建命令" class="headerlink" title="①常用构建命令"></a>①常用构建命令</h4><ul><li><strong>mvn -v</strong>：查看 maven 版本</li><li><strong>mvn clean</strong>：清理上一次构建生成的所有文件</li><li><strong>mvn compile</strong>：编译</li><li><strong>mvn test</strong>：测试运行</li><li><strong>mvn package</strong>：将项目打包</li><li><strong>mvn install</strong>：安装 jar 包到本地仓库</li></ul><blockquote><p><strong>若要在 a 包的类中导入 b 包类，一般需要把包含 b 包类的 jar 包加入到 classpath 路径中。而 maven 为我们提供了更方便的方法：在 b 包的根目录下，我们使用 mvn install 命令将包含其所有类的 jar 文件发布到本地仓库中，然后在 a 包的 pom.xml 文件中添加 b 包的坐标，之后 maven 会自动帮我们进行依赖管理操作。</strong><br><strong>原理：在编译源代码时，若程序用到了其他的包，maven 会在 pom.xml 文件中查找程序是否引入了该包的坐标。若是已经引入，maven 会在本地仓库中查找其对应的 jar 包并添加到 classpath 路径中，若是没有找到 jar 包，maven 会上网在中央仓库中下载 jar 包并放入本地仓库。若是没有引入，则返回异常信息。</strong></p></blockquote><h4 id="②自动创建目录结构"><a href="#②自动创建目录结构" class="headerlink" title="②自动创建目录结构"></a>②自动创建目录结构</h4><ul><li><strong>archetype 插件：用于自动创建符合 maven 规定的目录结构</strong><br>| 目录结构详情见 2-①</li><li>创建目录结构的两种方式：</li><li>1.输入 <strong>mvn archetype:generate -DarchetypeCatalog=internal</strong> 后按照命令行提示进行创建：</li></ul><p><img src="./1556026650584.png" alt="Alt text"><br><img src="./1556031831727.png" alt="Alt text"><br><img src="./1556027003507.png" alt="Alt text"></p><ul><li>2.一次性写入以下代码：        </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DarchetypeCatalog=internal -DgroupId=wjy-maven02 -DartifactId=maven02-model -Dversion=1.0-SNAPSHOT -Dpackage=maven02.model</span><br><span class="line"># groupId: 组织名，一般为公司网址的反写-项目名。</span><br><span class="line"># artifactId: 一般为项目名-模块名，它是maven项目在组织中的唯一标识。</span><br><span class="line"># package: 代码所存在的包名，应该和groupId名、artifactId名相吻合。</span><br></pre></td></tr></table></figure><p><img src="./1556031963727.png" alt="Alt text"><br><img src="./1556027200877.png" alt="Alt text"></p><h4 id="③坐标"><a href="#③坐标" class="headerlink" title="③坐标"></a>③坐标</h4><blockquote><p>在 maven 中，任何一个依赖、插件、项目构件的输出都可被称为构件。<br>所有构件都通过坐标作为其唯一标识。<br><strong><code>&lt;groupId&gt;</code>、<code>&lt;artifactId&gt;</code>、<code>&lt;version&gt;</code> 组成了 maven 的基本坐标。</strong></p></blockquote><h4 id="④仓库"><a href="#④仓库" class="headerlink" title="④仓库"></a>④仓库</h4><blockquote><p>仓库：用来管理<strong>项目的依赖</strong>。</p></blockquote><h5 id="a-本地仓库"><a href="#a-本地仓库" class="headerlink" title="a.本地仓库"></a>a.本地仓库</h5><ul><li>在本地仓库中找不到项目所需要的构件时 会自动到远程仓库中查找并下载</li></ul><h5 id="b-远程仓库"><a href="#b-远程仓库" class="headerlink" title="b.远程仓库"></a>b.远程仓库</h5><ul><li>远程仓库：即全球中央仓库 地址为 <a href="https://repo.maven.apache.org/maven2" target="_blank" rel="noopener">https://repo.maven.apache.org/maven2</a></li><li>远程仓库中包含了绝大多数开源的 Java 项目</li><li>但访问速度较慢(访问量大、且在国外)</li></ul><h5 id="c-镜像仓库"><a href="#c-镜像仓库" class="headerlink" title="c.镜像仓库"></a>c.镜像仓库</h5><ul><li>镜像仓库：与全球中央仓库的功能相同</li><li>可以将默认的远程仓库改为国内的镜像仓库(访问速度更快、更稳定)</li><li>修改方法(将下列内容添加到 settings.xml 文件中)：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置镜像仓库为阿里云--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 为中央仓库配置镜像。 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="./1556085425566.png" alt="Alt text"><br><img src="./1556090137995.png" alt="Alt text"></p><ul><li>修改后 访问远程仓库的操作会转为访问镜像仓库</li></ul><h5 id="d-更改仓库默认位置"><a href="#d-更改仓库默认位置" class="headerlink" title="d.更改仓库默认位置"></a>d.更改仓库默认位置</h5><ul><li>maven 的本地仓库默认存放在 C 盘中(占用 C 盘内存！)</li></ul><p><img src="./1556090215718.png" alt="Alt text"></p><ul><li>修改上文的 settings.xml 文件 可以更改本地仓库的位置</li></ul><p><img src="./1556089304067.png" alt="Alt text"></p><ul><li>然后在 maven 项目下执行 <strong>mvn clean compile</strong> 命令 会更新本地仓库的位置                </li></ul><p><img src="./1556090478122.png" alt="Alt text"></p><ul><li>最后将 setting.xml 文件放入新仓库中 防止 maven 升级后需要重新配置此文件 </li></ul><p><img src="./1556089242908.png" alt="Alt text"></p><hr><h3 id="4-项目构建过程"><a href="#4-项目构建过程" class="headerlink" title="4.项目构建过程"></a>4.项目构建过程</h3><h4 id="①项目构建与插件"><a href="#①项目构建与插件" class="headerlink" title="①项目构建与插件"></a>①项目构建与插件</h4><blockquote><p>完整的项目构建过程包括：<strong>清理(clean)、编译(compile)、测试(test)、打包(package)、集成测试、验证、部署(deploy)等。</strong><br><strong>maven 和插件是密不可分的，maven 抽象出一套项目构建的生命周期，而插件是对 maven 抽象的具体实现，即 maven 中的所有命令都是调用插件实现的。</strong><br>在 maven 官网中，提供了很多插件。<br>插件地址：<a href="https://mvnrepository.com/open-source/maven-plugins" target="_blank" rel="noopener">https://mvnrepository.com/open-source/maven-plugins</a></p></blockquote><h4 id="②生命周期"><a href="#②生命周期" class="headerlink" title="②生命周期"></a>②生命周期</h4><blockquote><p>maven 定义了三套相互独立的生命周期(<strong>clean、default、site</strong>)，每套生命周期包含一些有顺序的阶段，后面的阶段依赖于前面的阶段。<br><strong>即执行某个阶段时，其之前同一周期的阶段会顺序执行，如执行 package 命令时，complie、test 命令会自动顺序执行。</strong></p></blockquote><ul><li>在 IDEA 中 pom.xml 文件会自动导入与生命周期有关的插件</li></ul><p><img src="./1556587573175.png" alt="Alt text"></p><h5 id="a-clean—清理项目"><a href="#a-clean—清理项目" class="headerlink" title="a.clean—清理项目"></a>a.clean—清理项目</h5><ul><li>pre-clean：执行清理前的工作</li><li>clean：清理上一次构建生成的所有文件</li><li>post-clean：执行清理后的工作</li></ul><h5 id="b-default-最核心-—构建项目"><a href="#b-default-最核心-—构建项目" class="headerlink" title="b.default(最核心)—构建项目"></a>b.default(最核心)—构建项目</h5><ul><li>compile：编译</li><li>test：测试</li><li>package：打包</li><li>install：安装 jar 包到本地仓库</li></ul><h5 id="c-site—生成项目站点"><a href="#c-site—生成项目站点" class="headerlink" title="c.site—生成项目站点"></a>c.site—生成项目站点</h5><ul><li>pre-site：在生成项目站点之前要完成的工作</li><li>site：生成项目的站点文档</li><li>post-site：在生成项目站点之后要完成的工作</li><li>site-deploy：将生成的站点发布到服务器上</li></ul><hr><h3 id="5-pom-xml-详解"><a href="#5-pom-xml-详解" class="headerlink" title="5.pom.xml 详解"></a>5.pom.xml 详解</h3><h4 id="①pom"><a href="#①pom" class="headerlink" title="①pom"></a>①pom</h4><blockquote><p><strong>pom 是 maven 项目的核心管理文件，用于项目描述、组织管理、依赖管理和构建信息的管理。</strong><br>方便的第三方框架的管理和便捷的项目构建过程，大大提高了工作效率。</p></blockquote><h4 id="②pom-常用元素"><a href="#②pom-常用元素" class="headerlink" title="②pom 常用元素"></a>②pom 常用元素</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- project是pom.xml文件的根元素，包含了一些约束信息。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- modelVersion为必须元素，指定了当前文件的版本。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span><span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 坐标信息: --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- maven项目与实际项目不同，maven项目体现了模块化的概念，一个实际项目往往被划分为多个模块。 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- groupId为主项目标识，一般为反写的公司网址+项目名。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- artifactId为实际项目中的一个模块，一般为项目名+模块名。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        version为当前项目的版本号。</span></span><br><span class="line"><span class="comment">        第一个0是大版本号，第二个0是分支版本号，第三个0是小版本号，如0.0.1。      </span></span><br><span class="line"><span class="comment">        napshot: 快照版、alpha: 内测版、beta: 公测版、Release: 稳定版、GA: 正式版。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- package为maven项目的打包方式，默认打包为war，也可以是jar、zip、pom等。 --&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span><span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- name为项目的描述名，产生项目文档时才会使用。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span><span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- url为项目地址。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span><span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- description为项目描述。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- developers为开发人员列表。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">developers</span>&gt;</span><span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- licenses为许可证信息。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">licenses</span>&gt;</span><span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- organization为组织信息。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">organization</span>&gt;</span><span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- dependencies为依赖列表，其下包含多个依赖项(dependency)，一个坐标唯一标识一个依赖项。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span><span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- optional设置该依赖是否可选，默认为false。若为true，项目必须显式引入该依赖，若为false，项目默认继承该依赖。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span><span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖范围。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span><span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- exclusions是排除依赖传递的列表。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- dependencyManagement为依赖的管理，主要定义在父模块中，供子模块继承。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 对构建行为提供一个支持。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 插件列表: --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 一个坐标唯一标识一个插件。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 用于子模块中，是对父模块的一个继承。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 用来聚合多个maven项目，使多个maven模块可以一起编译并运行。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="6-依赖"><a href="#6-依赖" class="headerlink" title="6.依赖"></a>6.依赖</h3><h4 id="①依赖范围"><a href="#①依赖范围" class="headerlink" title="①依赖范围"></a>①依赖范围</h4><ul><li>关于 <code>&lt;scope&gt;&lt;/scope&gt;</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">    平时开发时，若使用某一框架，就要将该框架的jar包引入到项目的classpath路径中，这样项目就可以使用该框架为我们封装好的一些方法。而maven为我们提供了三种classpath，分别为编译、测试、运行(时有效)，依赖的范围就是用来控制依赖与三种classpath的关系的。</span><br><span class="line">    scope标签的值有六种，分别为: </span><br><span class="line">        compile(测试、编译和运行时都有效，默认选项)、</span><br><span class="line">        provided(测试、编译时有效，适用于一些web容器中已经包含的jar(运行时不需要再引入)，如servlet)、</span><br><span class="line">        runtime(测试、运行时有效，适用于JDBC驱动，项目主代码的编译只需要jdk提供的JDBC的API，只有测试或运行时才需要具体驱动的API)、</span><br><span class="line">        test(测试时有效，如junit测试框架)、</span><br><span class="line">        system(测试、编译时有效，但具有不可移植性，需要与本地系统相关联)、</span><br><span class="line">        import(导入，它只使用在dependencyManagement标签中，表示从其它的pom中继承过来的依赖)。</span><br><span class="line"> --&gt;</span><br></pre></td></tr></table></figure><ul><li>将 A 中的依赖导入到 B 中</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>WJY-Test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Test-B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>B<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>WJY-Test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Test-A<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="②排除依赖传递"><a href="#②排除依赖传递" class="headerlink" title="②排除依赖传递"></a>②排除依赖传递</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    exclusions是排除依赖传递的列表。</span></span><br><span class="line"><span class="comment">    若模块C依赖模块B的jar，模块B依赖模块A的jar，模块A对模块C来说就是传递依赖，默认模块C也会依赖模块A的jar。</span></span><br><span class="line"><span class="comment">    若模块C不想依赖模块A的jar，可以使用这个标签，在模块C的pom.xml文件中添加以下内容便可排除模块A的依赖。</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 此时模块C只依赖模块B的jar。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>WJY-Maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Mavan-B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 排除依赖。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>WJY-Maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Maven-A<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">&lt;!-- 注意: 先要将模块A的jar发布到本地仓库中，模块B才能通过坐标在本地仓库中找到模块A的jar，再将模块B的jar发布到本地仓库中，模块C才能通过坐标在本地仓库中找到模块B的jar。 --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="③依赖冲突"><a href="#③依赖冲突" class="headerlink" title="③依赖冲突"></a>③依赖冲突</h4><blockquote><p><strong>如果 A 和 B 分别有不同版本的相同构件，而 C 同时依赖于 A 和 B，此时会发生依赖冲突。</strong></p></blockquote><ul><li>解决依赖冲突的两个原则：</li><li>1.短路优先—优先解析路径短(依赖级数少)的版本</li><li>2.如果路径相同 则看依赖的先后(先声明依赖哪个 就选择哪个依赖的版本)</li></ul><h4 id="④聚合"><a href="#④聚合" class="headerlink" title="④聚合"></a>④聚合</h4><blockquote><p><strong>聚合：在 maven 中，将多个项目(模块)放在一起运行。</strong><br>聚合时，需要新建一个 maven 项目(父模块)，新建项目的 pom 将作为其他 pom 的容器。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 作为其他pom的容器。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>WJY-Maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Maven-0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 此pom项目里不执行任何代码，只是为了聚合或传递依赖。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 用来聚合多个maven项目，使多个maven模块可以一起编译并运行。 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 聚合后，还需要引入这些maven项目的依赖！ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../Maven-1<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../Maven-2<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../Maven-3<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="⑤继承"><a href="#⑤继承" class="headerlink" title="⑤继承"></a>⑤继承</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">    dependencyManagement为依赖的管理，可以声明依赖列表，但不会被引入到实际依赖中。主要定义在父模块中，供子模块继承(继承版本号等信息)。</span><br><span class="line">    即若多个模块都包括同一个依赖，可以抽象出来一个父模块，在父模块中对其进行一个定义，其他子模块只需要继承即可。</span><br><span class="line">    注意: 子模块还是需要显式地声明依赖。</span><br><span class="line">    优点: 如果有多个子模块都需要引用同样的依赖，则此标签可以避免在每个子模块中重复声明版本号等信息，便于整体修改。如果某个子模块需要其他版本，只需要单独声明version。</span><br><span class="line"> --&gt;</span><br></pre></td></tr></table></figure><ul><li>父 pom.xml 中：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>WJY-Maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Maven-1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">peoperties</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 要被继承的依赖:  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>子 pom.xml 中：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 父坐标: --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>WJY-Maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Maven-1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="7-IDEA-中使用-maven-构建-web-项目"><a href="#7-IDEA-中使用-maven-构建-web-项目" class="headerlink" title="7.IDEA 中使用 maven 构建 web 项目"></a>7.IDEA 中使用 maven 构建 web 项目</h3><h4 id="①新建工程"><a href="#①新建工程" class="headerlink" title="①新建工程"></a>①新建工程</h4><p><img src="./1556469580356.png" alt="Alt text"><br><img src="./1556469690745.png" alt="Alt text"><br><img src="./1556469799697.png" alt="Alt text"><br><img src="./1556501717314.png" alt="Alt text"><br><img src="./1556501467363.png" alt="Alt text"></p><blockquote><p>注意：模板 <strong>maven-archetype-quickstart</strong> 的目录结构如下图所示，应该根据需要选择合适的模板。</p></blockquote><p><img src="./1556501671702.png" alt="Alt text"></p><h4 id="②创建目录结构"><a href="#②创建目录结构" class="headerlink" title="②创建目录结构"></a>②创建目录结构</h4><ul><li>在 <strong>src/main</strong> 目录下新建 <strong>java</strong> 目录</li><li>将 <strong>java</strong> 目录作为 <strong>Sources Root</strong></li></ul><p><img src="./1556502571969.png" alt="Alt text"></p><ul><li>在 <strong>src/main</strong> 目录下新建 <strong>resources</strong> 目录 </li><li>将 <strong>resources</strong> 目录作为 <strong>Resources Root</strong></li></ul><p><img src="./1556549788899.png" alt="Alt text"></p><ul><li>在 <strong>src/test</strong> 目录下新建 <strong>java</strong> 目录</li><li>将 <strong>java</strong> 目录作为 <strong>Test Sources Root</strong></li></ul><p><img src="./1556549658404.png" alt="Alt text"></p><ul><li>在 <strong>src/test</strong> 目录下新建 <strong>resources</strong> 目录 </li><li>将 <strong>resources</strong> 目录作为 <strong>Test Resources Root</strong></li></ul><p><img src="./1556549714155.png" alt="Alt text"></p><ul><li>目录结构如下：</li></ul><p><img src="./1556549497797.png" alt="Alt text"></p><h4 id="③配置-tomcat"><a href="#③配置-tomcat" class="headerlink" title="③配置 tomcat"></a>③配置 tomcat</h4><ul><li>新建 tomcat：</li></ul><p><img src="./1556504833034.png" alt="Alt text"><br><img src="./1556513581604.png" alt="Alt text"></p><ul><li>tomcat 热部署：</li></ul><p><img src="./1556504958610.png" alt="Alt text"><br><img src="./1556513711235.png" alt="Alt text"><br><img src="./1556513755173.png" alt="Alt text"><br><img src="./1556513797728.png" alt="Alt text"></p><h4 id="④运行-tomcat"><a href="#④运行-tomcat" class="headerlink" title="④运行 tomcat"></a>④运行 tomcat</h4><p><img src="./1556513361205.png" alt="Alt text"><br><img src="./1556513330189.png" alt="Alt text"></p><ul><li>如果出现上图内容 说明配置成功</li></ul><h4 id="⑤IDEA-中管理-maven-的生命周期"><a href="#⑤IDEA-中管理-maven-的生命周期" class="headerlink" title="⑤IDEA 中管理 maven 的生命周期"></a>⑤IDEA 中管理 maven 的生命周期</h4><p><img src="./1556513258780.png" alt="Alt text"></p><ul><li>修改以下部分 并新增工程入口类</li></ul><p><img src="./1556551889365.png" alt="Alt text"><br><img src="./1556553539090.png" alt="Alt text"></p><ul><li>使用 <strong>package</strong> 命令 可以将工程打包</li></ul><p><img src="./1556550160208.png" alt="Alt text"><br><img src="./1556553215349.png" alt="Alt text"></p><h4 id="⑥运行-jar-包"><a href="#⑥运行-jar-包" class="headerlink" title="⑥运行 jar 包"></a>⑥运行 jar 包</h4><ul><li>用 <code>360压缩</code> 打开 jar 包</li><li>编辑 <strong>MANIFEST.MF</strong> 文件</li></ul><p><img src="./1556553116224.png" alt="Alt text"></p><ul><li>添加划线部分</li></ul><p><img src="./1556553384959.png" alt="Alt text"></p><ul><li>保存并退出</li><li>在命令行运行 jar 包</li></ul><p><img src="./1556553442250.png" alt="Alt text"></p><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#119;&#x6a;&#x79;&#x6d;&#x65;&#115;&#115;&#105;&#64;&#49;&#54;&#x33;&#46;&#99;&#111;&#x6d;" target="_blank" rel="noopener">&#119;&#x6a;&#x79;&#x6d;&#x65;&#115;&#115;&#105;&#64;&#49;&#54;&#x33;&#46;&#99;&#111;&#x6d;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;maven 是 Apache 下的一个纯 Java 开发的开源项目。&lt;/strong&gt;&lt;br&gt;基于项目对象模型(POM)的概念，它可以从一个中心资料片管理项目构建、报告和文件。&lt;br&gt;它也是一套强大的自动化构建工具，覆盖了编译、测试
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://messi1002.top/categories/JavaWeb/"/>
    
    
      <category term="maven" scheme="http://messi1002.top/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>域名解析到服务器</title>
    <link href="http://messi1002.top/2019/05/14/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://messi1002.top/2019/05/14/域名解析到服务器/</id>
    <published>2019-05-14T13:51:08.000Z</published>
    <updated>2019-09-12T03:35:03.305Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-域名与服务器"><a href="#1-域名与服务器" class="headerlink" title="1.域名与服务器"></a>1.域名与服务器</h3><blockquote><p><strong>域名是网站的入口，是 IP 的别名，便于记忆而存在，域名最终会通过 DNS 解析成 IP 地址。</strong><br><strong>所以将域名解析到服务器后，域名 == 服务器 IP(一样的作用)！</strong></p></blockquote><hr><h3 id="2-域名解析到服务器"><a href="#2-域名解析到服务器" class="headerlink" title="2.域名解析到服务器"></a>2.域名解析到服务器</h3><h4 id="①域名解析"><a href="#①域名解析" class="headerlink" title="①域名解析"></a>①域名解析</h4><ul><li>登录阿里云 打开 <code>控制台-域名</code></li><li>选择域名 点击 <code>解析</code></li></ul><p><img src="./1557549623861.png" alt="Alt text"></p><ul><li>点击 <code>添加记录</code></li><li>解析类型为 <strong>A-将域名解析到服务器</strong></li></ul><p><img src="./1557549924064.png" alt="Alt text"><br><img src="./1557840235962.png" alt="Alt text"></p><h4 id="②验证解析"><a href="#②验证解析" class="headerlink" title="②验证解析"></a>②验证解析</h4><ul><li>验证网址：<a href="http://www.17ce.com/site/http/?spm=a2c4g.11186623.2.32.68664c35MlZcKe" target="_blank" rel="noopener">17CE</a></li><li>选择 <code>Dns</code> 并输入域名</li></ul><p><img src="./1557549204166.png" alt="Alt text"></p><ul><li>如果画圈处的 IP 地址正确 说明解析成功</li></ul><blockquote><p>ps：解析成功后，使用 <strong>www.域名/域名</strong> 均可代替服务器 IP。</p></blockquote><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>我的个人博客：<a href="http:messi1002.top" target="_blank" rel="noopener">messi1002.top</a></li><li>如有错误或疑惑之处 请联系 <a href="mailto:&#119;&#106;&#x79;&#x6d;&#x65;&#x73;&#x73;&#x69;&#x40;&#49;&#54;&#51;&#x2e;&#99;&#111;&#109;" target="_blank" rel="noopener">&#119;&#106;&#x79;&#x6d;&#x65;&#x73;&#x73;&#x69;&#x40;&#49;&#54;&#51;&#x2e;&#99;&#111;&#109;</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-域名与服务器&quot;&gt;&lt;a href=&quot;#1-域名与服务器&quot; class=&quot;headerlink&quot; title=&quot;1.域名与服务器&quot;&gt;&lt;/a&gt;1.域名与服务器&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;域名是网站的入口，是 IP 的别名，便于记忆而存在
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://messi1002.top/categories/Linux/"/>
    
      <category term="服务器" scheme="http://messi1002.top/categories/Linux/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="CentOS7" scheme="http://messi1002.top/tags/CentOS7/"/>
    
      <category term="域名" scheme="http://messi1002.top/tags/%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
</feed>
